{
  "theorems": [
    {
      "split": "train-sft",
      "index": 0,
      "prefix": "(** Programs and Proofs Ilya Sergey *)\n(* http://ilyasergey.net/pnp/ *)\n\n(**\n\u300c\u6570\u5b66\u69cb\u9020\u306e\u30b3\u30fc\u30c9\u5316\u300dDepRecords.v \u304b\u3089\u629c\u7c8b\u3057\u305f\u3002\n *)\n\n(**\n7 Encoding Mathematical Structures\n *)\nModule DepRecords.\n  From mathcomp Require Import ssreflect ssrbool ssrnat ssrfun.\n  \n  Set Implicit Arguments.\n  Unset Strict Implicit.\n  Unset Printing Implicit Defensive.\n\n(**\n7.1 Encoding partial commutative monoids\n\n\u3072\u3068\u3064\u3081\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u53ef\u63db\u30e2\u30ce\u30a4\u30c9\u3002\n(mathcomp\u306e\u547d\u540d\u6cd5\u3067\u306f\u3001pcmType)\n *)\n  Module PCMDef. \n\n(**\nMixin\u306e\u5b9a\u7fa9\n*)\n    Record mixin_of (T : Type) :=\n      Mixin\n        {\n          valid_op : T -> bool;\n          join_op : T -> T -> T;\n          unit_op : T;\n          _ : commutative join_op;\n          _ : associative join_op;\n          _ : left_id unit_op join_op;\n          _ : forall x y, valid_op (join_op x y) -> valid_op x; \n          _ : valid_op unit_op \n        }.\n\n    Lemma r_unit T (pcm: mixin_of T) (t: T) :\n      (join_op pcm t (unit_op pcm)) = t.\n    Proof.\n      case: pcm => _ join unit Hc _ Hlu _ _ /=.\n                  by rewrite Hc Hlu.\n    Qed.\n    \n(**\n7.1.3 Packaging the structure from mixins\n *)\n(**\nPack\u306e\u5b9a\u7fa9\n*)\n    Section Packing.\n      Structure pack_type : Type :=\n        Pack {\n            type : Type;\n            _ : mixin_of type\n          }.\n      Local Coercion type : pack_type >-> Sortclass.\n(**\npack\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306f\u4efb\u610f\u306esort\u306e\u8981\u7d20\n\uff08type\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u7d4c\u7531\u3057\u3066\u53c2\u7167\u3055\u308c\u308b\u3001\u578bType\u306e\u3053\u3068\uff09\n\u306b\u30b3\u30a2\u30fc\u30b7\u30e7\u30f3\u3055\u308c\u308b\u3002\u30b3\u30a2\u30fc\u30b7\u30e7\u30f3\u306e\u305f\u3081\u306b\n\n``type :  pack_type -> Type``\n\n\u304c\u633f\u5165\u3055\u308c\u308b\u3002\u539f\u6587\uff1a\n\nan instance of pack type should be coerced into an element of an arbitrary sort,\nit should be done via referring to is type field.\n\n``Coercion F : A >-> B.``\n\nA\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306f\u4efb\u610f\u306eB\u8981\u7d20\uff08F\u30d5\u30a3\u30fc\u30eb\u30c9\u3092\u7d4c\u7531\u3057\u3066\u53c2\u7167\u3055\u308c\u308b\uff09\n\u306b\u30b3\u30a2\u30fc\u30b7\u30e7\u30f3\u3055\u308c\u308b\u3002\u6b21\u3068\u6bd4\u8f03\u305b\u3088\u3002\n\u30b3\u30a2\u30fc\u30b7\u30e7\u30f3\u306e\u305f\u3081\u306b ``is_true`` \u304c\u633f\u5165\u3055\u308c\u308b\u3002\n\n``Coercion is_true : bool >-> Sortclass. (* Prop *)``\n *)\n      Check type.\n      \n      Variable cT: pack_type.\n      Definition pcm_struct : mixin_of cT := (* Coercion cT *)\n        let: Pack _ c := cT return mixin_of cT in c.\n      Definition valid := valid_op pcm_struct.\n      Definition join := join_op pcm_struct.\n      Definition unit := unit_op pcm_struct.\n    End Packing.\n\n(**\nExports \u306e\u5ba3\u8a00\n*)    \n    Module Exports.\n      Notation pcm := pack_type.\n      Notation PCMMixin := Mixin.\n      Notation PCM T m := (@Pack T m).\n      Notation \"x \\+ y\" := (join x y) (at level 43, left associativity). (* join_op\u3067\u306f\u306a\u3044\u3002 *)\n      Notation valid := valid.\n      Notation Unit := unit.\n      Coercion type : pack_type >-> Sortclass.\n\n(**\n7.2 Properties of partial commutative monoids\n\n\u53ef\u63db\u5247\u3084\u7d50\u5408\u5247\u3092\u8a3c\u660e\u3057\u3066\u304a\u304f\u3002\u3053\u308c\u3089\u306fexport\u3055\u308c\u308b\u3002\n*)      \n      Section PCMLemmas.\n        Variable U : pcm.\n\n        Lemma joinC (x y : U) : x \\+ y = y \\+ x. (* Coercion U *)\n        Proof.\n            by case: U x y => tp [v j z Cj *]; apply Cj.\n        Qed.\n\n        Lemma joinA (x y z : U) : x \\+ (y \\+ z) = x \\+ y \\+ z.\n        Proof. \n            by case: U x y z => tp [v j z Cj Aj *]; apply: Aj. \n        Qed.\n(**\nExercices 7.1\n*)\n        Lemma joinAC (x y z : U) : x \\+ y \\+ z = x \\+ z \\+ y.\n        Proof.\n          rewrite -[x \\+ z \\+ y]joinA.\n          rewrite [z \\+ y]joinC.\n          rewrite [x \\+ (y \\+ z)]joinA.\n          by [].\n        Qed.\n        \n        Lemma joinCA (x y z : U) : x \\+ (y \\+ z) = y \\+ (x \\+ z).\n        Proof.\n          rewrite [y \\+ (x \\+ z)]joinA.\n          rewrite [y \\+ x]joinC.\n          rewrite -[x \\+ y \\+ z]joinA.\n          by [].\n        Qed.\n        \n        Lemma validL (x y : U) : valid (x \\+ y) -> valid x.\n        Proof.\n          case: U x y => tp [v j z Cj Aj H1 H2 H3 x y] => H.\n          by apply: (H2 x y).\n        Qed.\n\n        Lemma validR (x y : U) : valid (x \\+ y) -> valid y.\n        Proof.\n          case: U x y => tp [v j z Cj Aj H1 H2 H3 x y].\n          rewrite [x \\+ y]Cj.\n          by apply: (H2 y x).\n        Qed.\n        \n        Lemma unitL (x : U) : (@Unit U) \\+ x = x.\n        Proof.\n          case: U x => tp [v j z Cj Aj H1 H2 H3 x].\n          by apply H1.\n        Qed.\n        \n        Lemma unitR (x : U) : x \\+ (@Unit U) = x.\n        Proof.\n          case: U x => tp [v j z Cj Aj H1 H2 H3 x].\n          rewrite [x \\+ _]Cj.\n          by apply H1.\n        Qed.\n        \n        Lemma valid_unit : valid (@Unit U).\n        Proof.\n          case: U => tp [v j z Cj Aj H1 H2 H3].\n          by apply H3.\n        Qed.\n(**\nEnd of Exercices 7.1\n *)\n      End PCMLemmas.\n    End Exports.\n  End PCMDef.\n  Export PCMDef.Exports.                    (* Exports\u3092export\u3059\u308b\u3002 *)\n(**\n\u3072\u3068\u3064\u3081\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u53ef\u63db\u30e2\u30ce\u30a4\u30c9\u306e\u7d42\u4e86\u3002\n *)\n\n(**\n7.3 Implementing inheritance hierarchies\n\n\u3075\u305f\u3064\u3081\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u7c21\u7d04\u53ef\u63db\u30e2\u30ce\u30a4\u30c9\u3002\n(mathcomp\u306e\u547d\u540d\u6cd5\u3067\u306f\u3001cancelPcmType)\n *)\n  Module CancelPCM.\n(**\nMixin -- PCM\u306b\u7c21\u7d04\u6cd5\u5247\u3092\u8ffd\u52a0\u3059\u308b\u3002\n *)\n    Record mixin_of (U : pcm) :=\n      Mixin\n        {\n          _ : forall a b c : U, valid (a \\+ b) -> a \\+ b = a \\+ c -> b = c\n        }.\n\n(**\nPacking -- Struture pack_type ... \u306e\u5b9a\u7fa9\u306f\u524d\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u540c\u3058\u3002\n\nSection Packing. \u3068 End Packing. \u306e\u6709\u7121\u306f\u95a2\u4fc2\u306a\u304f\u3001\nVariable\u306a\u3069\u306e\u5ba3\u8a00\u306e\u5fc5\u8981\u306b\u5fdc\u3058\u3066\u3001Section \u306b\u3059\u308c\u3070\u3088\u3044\u3002\n *)\n    Structure pack_type : Type :=\n      Pack {\n          pcmT : pcm;\n          _ : mixin_of pcmT\n        }.\n    \n(**\nExports \u306e\u5ba3\u8a00\n*)    \n    Module Exports.\n      Notation cancel_pcm := pack_type.\n      Notation CancelPCMMixin := Mixin.\n      Notation CancelPCM T m:= (@Pack T m).\n      Coercion pcmT : pack_type >-> pcm.\n(**\n\u53ef\u63db\u5247\u3092\u8a3c\u660e\u3057\u3066\u304a\u304f\u3002\n *)\n      Lemma cancel (U: cancel_pcm) (x y z: U): (* Coecion U *)\n        valid (x \\+ y) -> x \\+ y = x \\+ z -> y = z.",
      "suffix": "\n    End Exports.\n  End CancelPCM. \n  Export CancelPCM.Exports.                 (* Exports\u3092export\u3059\u308b\u3002 *)\n(**\n\u3075\u305f\u3064\u3081\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3001\u7c21\u7d04\u53ef\u63db\u30e2\u30ce\u30a4\u30c9\u306e\u7d42\u4e86\u3002\n *)\n  \n  Lemma cancelC (U: cancel_pcm) (x y z : U) :\n    valid (y \\+ x \\+ z) -> y \\+ x = x \\+ z -> y = z.\n  Proof.\n      by move/validL; rewrite ![y \\+ _]joinC; apply: cancel.\n  Qed.\n\n(**\n7.4 Instantiation and canonical structures\n\n\u7c21\u7d04\u30e2\u30ce\u30a4\u30c9\u3092\u6574\u6570\u306b\u3064\u3044\u3066\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u308b\u3002\n(mathcomp\u306e\u547d\u540d\u6cd5\u3067\u306f\u3001nat_pcmType)\n *)\n  Definition natPCMMixin := \n    PCMMixin\n      addnC                                 (* commutative *)\n      addnA                                 (* associative *)\n      add0n                                 (* left_id *)\n      (fun x y => @id true)                 (* valid_op join_op *)\n      (erefl _).                            (* valid_op unit_op *)\n  \n  Definition NatPCM := PCM nat natPCMMixin.\n  Canonical natPCM := NatPCM.               (* \u539f\u6587\u3067\u306f\u3001PCM nat natPCMMixin. *)\n  Print Canonical Projections.\n(**\nnat <- PCMDef.type ( natPCM )\n\u304c\u8ffd\u52a0\u3055\u308c\u308b\u3002type\u306fCoercion\u3067\u3042\u308b\u3053\u3068\u306b\u6ce8\u610f\uff01\n *)\n\n(**\nnatPCM \u304c Canonical \u3067\u306a\u3044\u3068\u3001add_perm \u306e\u5b9a\u7fa9\u304c\u30a8\u30e9\u30fc\u306b\u306a\u308b\u3002\nnatPCM \u3092 Canonical \u306b\u3059\u308b\u3068\u3001add_perm \u306e nat \u3092 natPCM \u3068\u3057\u3066\u6271\u3048\u308b\u3002\n *)\n  Lemma add_perm (a b c : nat) : a \\+ (b \\+ c) = a \\+ (c \\+ b).\n  Proof.\n      by rewrite [c \\+ b]joinC.\n  Qed.\n  \n(** \u53ef\u63db\u7c21\u7d04\u30e2\u30ce\u30a4\u30c9\u3092\u6574\u6570\u306b\u3064\u3044\u3066\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u4f5c\u308b\u3002\n(mathcomp\u306e\u547d\u540d\u6cd5\u3067\u306f\u3001nat_cancelPcmType) *)\n(**\n\u7c21\u7d04\u898f\u5247\u3092\u8a3c\u660e\u3057\u3066\u304a\u304f\u3002\n *)\n  Lemma cancelNat : forall a b c : nat, true -> a + b = a + c -> b = c.\n  Proof.\n    move=> a b c; elim: a => // n /(_ is_true_true) Hn _ H.\n      by apply: Hn; rewrite !addSn in H; move/eq_add_S: H.\n  Qed.\n  \n  (**\nnatPCM \u304c Canonical\u3067\u306a\u3044\u3068\u3001cancelNat \u304c\u4f7f\u7528\u3067\u304d\u306a\u3044\u3002\nnatPCM \u3092 Canonical \u306b\u3059\u308b\u3068\u3001cancelNat \u306e nat \u3092 natPCM \u3068\u3057\u3066\u6271\u3048\u308b\u3002\n *)\n  Definition cancelNatPCMMixin :=\n    CancelPCMMixin\n      cancelNat.                            (* \u7c21\u7d04\u898f\u5247 *)\n\n  Definition CancelNatPCM := CancelPCM natPCM cancelNatPCMMixin.\n  Canonical cancelNatPCM := CancelNatPCM.\n  (* \u539f\u6587\u3067\u306f\u3001\u76f4\u63a5\u3001CancelPCM natPCM cancelNatPCMMixin \u3092\u4f7f\u3063\u3066\u5b9a\u7fa9\u3055\u308c\u308b\u3002 *)\n  Print Canonical Projections.\n(**\nnatPCM <- CancelPCM.pcmT ( cancelNatPCM )\n\u304c\u8ffd\u52a0\u3055\u308c\u308b\u3002pcmT\u306fCoercion\u3067\u3042\u308b\u3053\u3068\u306b\u6ce8\u610f\uff01\n *)\n  \n  Section PCMExamples.\n    Variables a b c: nat.\n\n    Check PCMDef.join_op : forall T : Type, PCMDef.mixin_of T -> T -> T -> T.\n    Check PCMDef.join : forall cT : pcm, cT -> cT -> cT.\n    About \"_ \\+ _\".                         (* PCMDef.join  *)\n    \n    Goal a \\+ (b \\+ c) =  c \\+ (b \\+ a).\n      by rewrite joinA [c \\+ _]joinC [b \\+ _]joinC.\n    Qed.\n    \n    Goal c \\+ a = a \\+ b -> c = b.\n      by rewrite [c \\+ _]joinC; apply: cancel.\n    Qed.\n    \n    Lemma addn_join (x y: nat): x + y = x \\+ y. \n    Proof.\n        by [].\n    Qed.\n  End PCMExamples.\n\n(** \nExercise 7.2 Partially-ordered sets\n(see. ssr_pnp_poset.v)\n*)\n  \n(**\nExercise 7.3 Canonical instances of partially ordered sets\n*)\n\n(**\n7.4.2 Types with decidable equalities\n *)\n  Module Equality.\n    Definition axiom T (e : rel T) := forall x y, reflect (x = y) (e x y).\n    \n(**\nMixin\u306e\u5b9a\u7fa9\n*)\n    Structure mixin_of T :=\n      Mixin {\n          op : rel T;\n          _ : axiom op\n        }.\n    \n(**\nPack\u306e\u5b9a\u7fa9\n*)\n    Structure type :=\n      Pack\n        {\n          sort;\n         _ : mixin_of sort\n        }.\n    \n(**\nExports \u306e\u5ba3\u8a00\n*)    \n    Module Exports.\n      Notation EqMixin := Mixin.\n      Notation EqType T m := (@Pack T m).     (* \"@\"\u304c\u5fc5\u8981\u3002 *)\n    End Exports.\n  End Equality.\n  Export Equality.Exports.       (* \u4ed6\u306b\u7fd2\u3063\u3066\u3001Exports\u3092export\u3059\u308b\u3002 *)\n  \nEnd DepRecords.\n\n(* END *)\n",
      "theorem": "Lemma cancel (U: cancel_pcm) (x y z: U): (* Coecion U *)\n        valid (x \\+ y) -> x \\+ y = x \\+ z -> y = z.",
      "ground_truth": "Proof.\n          by case: U x y z => Up [Hc] x y z; apply: Hc.\n      Qed."
    },
    {
      "split": "train-sft",
      "index": 1,
      "prefix": "(* Notation *)\nNotation \"\u2200 x .. y , P\" := (forall x, .. (forall y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' \u2200 x .. y ']' , '/' P ']'\") : type_scope.\n\nNotation \"\u2203 x .. y , P\" := (exists x, .. (exists y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' \u2203 x .. y ']' , '/' P ']'\") : type_scope.\n\nNotation \"x \u2228 y\" :=\n  (x \\/ y) (at level 85, right associativity) : type_scope.\n\nNotation \"x \u2227 y\" :=\n  (x /\\ y) (at level 80, right associativity) : type_scope.\n\nNotation \"\u00ac x\" := (~x) (at level 75, right associativity) : type_scope.\n\nNotation \"x \u2192 y\" := (x -> y)\n  (at level 99, y at level 200, right associativity): type_scope.\n\nNotation \"x \u2194 y\" :=\n  (x <-> y) (at level 95, no associativity): type_scope.\n\nNotation \"x \u2260 y\" := (x <> y) (at level 70) : type_scope.\n\nNotation \"'\u03bb' x .. y , t\" := (fun x => .. (fun y => t) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' '\u03bb' x .. y ']' , '/' t ']'\").\n\n(* Logic *)\nAxiom classic : \u2200 P : Prop, P \u2228 \u00acP.\n\nProposition NNPP : \u2200 P, (\u00ac (\u00ac P) \u2194 P).\nProof. intros; destruct (classic P); tauto. Qed.\n\nProposition inp : \u2200 P Q : Prop, (P \u2194 Q) \u2192 (\u00ac P \u2192 \u00ac Q).\nProof. intros; intro. elim H0. apply H; auto. Qed.\n\nParameter Class : Type.\n\nParameter In : Class \u2192 Class \u2192 Prop.\nNotation \"a \u2208 A\" := (In a A)(at level 70).\nNotation \"a \u2209 A\" := (\u00ac (a \u2208 A))(at level 70).\n\nParameter Classifier : \u2200 P : Class \u2192 Prop, Class.\nNotation \"\\{ P \\}\" := (Classifier P)(at level 0).\n\n(* Axiom and Ensemble *)\nAxiom ExtAx : \u2200 A B : Class, A = B \u2194 (\u2200 x, x \u2208 A \u2194 x \u2208 B).\nLtac AppE := apply ExtAx; split; intros.\n\nDefinition Ensemble x : Prop := \u2203 y, x \u2208 y.\nLtac Ens := unfold Ensemble; eauto.\n\nAxiom ClaAx : \u2200 x P, x \u2208 \\{ P \\} \u2194 Ensemble x \u2227 (P x).\n\nFact ClaI : \u2200 x (P : Class \u2192 Prop), Ensemble x \u2192 P x \u2192 x \u2208 \\{ P \\}.\nProof. intros * Hx HP. apply ClaAx; auto. Qed.\n\nFact ClaE : \u2200 x (P : Class \u2192 Prop), x \u2208 \\{ P \\} \u2192 Ensemble x \u2227 P x.\nProof. intros * Hx. apply ClaAx; auto. Qed.\n\nDefinition NoEmpty A := \u2203 x, x \u2208 A.\nNotation \"\u29bf A\" := (NoEmpty A) (at level 45).\n\nDefinition Empty := \\{ \u03bb x, x \u2260 x \\}.\nNotation \" \u2205 \" := Empty.\n\nFact EmptyNI : \u2200 x, x \u2209 \u2205.\nProof. intros x H. apply ClaE in H. apply H; auto. Qed.\nLtac exfalso0 := exfalso; eapply EmptyNI; eauto.\n\nFact EmptyEq : \u2200 x, x = \u2205 \u2194 \u00ac (\u29bf x).\nProof.\n  split; intros. subst x. intro. destruct H. exfalso0.\n  AppE. elim H. exists x0; auto. exfalso0.\nQed.\n\nFact EmptyNE : \u2200 x, x \u2260 \u2205 \u2194 \u29bf x.\nProof.\n  intros. pose proof EmptyEq. split; intros.\n  - apply inp with (Q := \u00ac (\u29bf x)) in H0; auto.\n    apply -> NNPP in H0; auto.\n  - intro. apply H in H1; auto.\nQed.\n\nDefinition \u03bc := \\{ \u03bb x, x = x \\}.\n\nFact \u03bc_En : \u2200 x, x \u2208 \u03bc \u2194 Ensemble x.\nProof. split; intros. Ens. apply ClaI; auto. Qed.\n\nDefinition Singleton x := \\{ \u03bb z, x \u2208 \u03bc \u2192 z = x \\}.\nNotation \"[ x ]\" := (Singleton x) (at level 0, right associativity).\n\nFact SingI : \u2200 x, Ensemble x \u2192 x \u2208 [x].\nProof. intros. apply ClaI; auto. Qed.\n\nFact SingE : \u2200 x y, Ensemble x \u2192 y \u2208 [x] \u2192 y = x.\nProof.\n  intros. apply ClaE in H0 as []. apply H1. apply \u03bc_En; auto.\nQed.\n\nDefinition Included A B := \u2200 x, x \u2208 A \u2192 x \u2208 B.\nNotation \"A \u2282 B\" := (Included A B)(at level 70).\n\nFact ReSyTrP : \u2200 A B C,\n  (A \u2282 A) \u2227 (A \u2282 B \u2192 B \u2282 A \u2192 A = B) \u2227 (A \u2282 B \u2192 B \u2282 C \u2192 A \u2282 C).\nProof.\n  intros. split. intros x; auto. split; intros.\n  - AppE; auto. - intros x Hx. apply H in Hx. auto.\nQed.\n\nAxiom SubAx : \u2200 x, Ensemble x \u2192\n  \u2203 y, Ensemble y \u2227 (\u2200 z, z \u2282 x \u2192 z \u2208 y).\n\nFact SubAxI : \u2200 x z, Ensemble x \u2192 z \u2282 x \u2192 Ensemble z.\nProof. intros. apply SubAx in H as [y []]. Ens. Qed.\n\nDefinition PowerSet X := \\{ \u03bb A, A \u2282 X \\}.\nNotation \" cP( X )\" := (PowerSet X)(at level 9, right associativity).\n\nFact PowerIE : \u2200 X Y, Ensemble X \u2192 Y \u2208 cP(X) \u2194 Y \u2282 X.\nProof.\n  intros. split; intros. apply ClaE in H0; tauto.\n  apply ClaI; auto. eapply SubAxI; eauto.\nQed.\n\nFact PowerP : \u2200 X, Ensemble X \u2192 Ensemble cP(X) \u2227\n  (\u2200 Y, Y \u2282 X \u2194 Y \u2208 cP(X)).\nProof.\n  intros. split.\n  - pose proof H as H'. apply SubAx in H as [B [Hbe Hb]].\n    assert (cP(X) \u2282 B). { intros z Hz. apply PowerIE in Hz; auto. }\n    clear H'. eapply SubAxI; eauto.\n  - split; intros. apply PowerIE; auto. apply PowerIE in H0; auto.\nQed.\n\nFact SingEn : \u2200 x, Ensemble x \u2192 Ensemble [x].\nProof.\n  intros. assert ([x] \u2282 cP(x)).\n  { intros z Hz. apply SingE in Hz; auto. subst.\n    apply PowerIE; auto. intros z; auto. }\n  apply PowerP in H as []; auto. eapply SubAxI; eauto.\nQed.\n\nDefinition Union A B := \\{ \u03bb x, x \u2208 A \u2228 x \u2208 B \\}.\nNotation \"A \u22c3 B\" := (Union A B)(at level 65, right associativity).\n\nFact UnionIE : \u2200 x A B, x \u2208 A \u2228 x \u2208 B \u2194 x \u2208 (A \u22c3 B).\nProof.\n  intros. split; intros. destruct H as []; apply ClaI; Ens.\n  apply ClaE in H. tauto.\nQed.\n\nFact UnionNE : \u2200 x A B, x \u2209 A \u22c3 B \u2192 x \u2209 A /\\ x \u2209 B.\nProof. intros. split; intro; elim H; apply UnionIE; auto. Qed.\n\nFact Idem : \u2200 A, A \u22c3 A = A.\nProof.\n  intros. AppE. apply UnionIE in H. tauto. apply UnionIE; auto.\nQed.\n\nFact Commu : \u2200 A B, A \u22c3 B = B \u22c3 A.\nProof. intros. AppE; apply UnionIE in H; apply UnionIE; tauto. Qed.\n\nFact EmUnion : \u2200 A, A \u22c3 \u2205 = A.",
      "suffix": "\n\nAxiom UnionAx : \u2200 X Y, Ensemble X \u2192 Ensemble Y \u2192 Ensemble (X \u22c3 Y).\n\nDefinition Inter A B := \\{ \u03bb x, x \u2208 A \u2227 x \u2208 B \\}.\nNotation \"A \u2229 B\" := (Inter A B)(at level 60, right associativity).\n\nFact InterIE : \u2200 x A B, x \u2208 A \u2227 x \u2208 B \u2194 x \u2208 (A \u2229 B).\nProof.\n  intros. split; intros. apply ClaI; auto. destruct H; Ens.\n  apply ClaE in H. tauto.\nQed.\n\nFact Idem' : \u2200 A, A \u2229 A = A.\nProof.\n  intros. AppE. apply InterIE in H; tauto. apply InterIE; auto.\nQed.\n\nFact Commu' : \u2200 A B, A \u2229 B = B \u2229 A.\nProof. intros. AppE; apply ClaE in H; apply ClaI; tauto. Qed.\n\nFact EmInter : \u2200 A, A \u2229 \u2205 = \u2205.\nProof. intros. AppE. apply InterIE in H; tauto. exfalso0. Qed.\n\nFact Distribu : \u2200 A B C, (A \u22c3 B) \u2229 C = (A \u2229 C) \u22c3 (B \u2229 C).\nProof.\n  intros. AppE; apply ClaI; Ens.\n  - apply InterIE in H as []. apply UnionIE in H as [H|H].\n    left; apply InterIE; tauto. right; apply InterIE; tauto.\n  - apply UnionIE in H as []; apply InterIE in H as [];\n    split; auto; apply ClaI; auto; Ens.\nQed.\n\nFact DistribuLI : \u2200 A B C, A \u2229 (B \u22c3 C) = A \u2229 B \u22c3 A \u2229 C.\nProof.\n  intros. rewrite Commu', Distribu, Commu', (Commu' A C); auto.\nQed.\n\nFact InterEn : \u2200 X Y, Ensemble X \u2192 Ensemble Y \u2192 Ensemble (X \u2229 Y).\nProof.\n   intros. assert (X \u2229 Y \u2282 X).\n   { intros z Hz. apply ClaE in Hz; tauto. }\n   clear H0. eapply SubAxI; eauto.\nQed.\n\nDefinition Setmin A B := \\{ \u03bb x, x \u2208 A \u2227 x \u2209 B \\}.\nNotation \"A - B\" := (Setmin A B).\n\nFact SetminIE : \u2200 x A B, x \u2208 A \u2227 x \u2209 B \u2194 x \u2208 (A - B).\nProof.\n  intros. split; intros. apply ClaI; auto. destruct H; Ens.\n  apply ClaE in H. tauto.\nQed.\n\nFact SetminId : \u2200 X, X - X = \u2205.\nProof. intro. AppE. apply SetminIE in H; tauto. exfalso0. Qed.\n\nFact SetminEm : \u2200 X, X - \u2205 = X.\nProof.\n  intro. AppE. apply SetminIE in H; tauto.\n  apply SetminIE. split; auto. intro. exfalso0.\nQed.\n\nFact IncludP : \u2200 A B X, A \u2282 X \u2192 A - B \u2282 X.\nProof. intros * Ha z Hz. apply SetminIE in Hz as []; auto. Qed.\n\nFact IncludP1 : \u2200 A B C, A \u2282 B \u2192 A - C \u2282 B - C.\nProof.\n  intros * Hab z Hz. apply SetminIE in Hz as []. apply SetminIE; auto.\nQed.\n\nFact IncludP2 : \u2200 A X, X - A \u2282 X.\nProof. intros * x Hx. apply ClaE in Hx. tauto. Qed.\n\nFact TwSetmin : \u2200 A X, A \u2282 X \u2192 X - (X - A) = A.\nProof.\n  intros. AppE. apply SetminIE in H0 as [Hx H0].\n  destruct (classic (x \u2208 A)); eauto. elim H0. apply SetminIE. tauto.\n  apply SetminIE. split; auto. intro. apply SetminIE in H1 as []; tauto.\nQed.\n\nFact TwDeMorgan : \u2200 A B C, A - (B \u2229 C) = (A - B) \u22c3 (A - C).\nProof.\n  intros. AppE; apply ClaE in H as [_ H].\n  - destruct H, (classic (x \u2208 C)); apply UnionIE.\n    + left; apply SetminIE. split; auto.\n      intro; elim H0. apply InterIE. auto.\n    + right; apply SetminIE. auto.\n  - destruct H; apply SetminIE in H as []; apply SetminIE;\n    split; auto; intro; apply InterIE in H1 as []; tauto.\nQed.\n\nFact InterEqEmI : \u2200 x U A,\n  Ensemble x \u2192 U \u2229 A - [x] = \u2205 \u2192 x \u2209 A \u2192 U \u2229 A = \u2205.\nProof with eauto.\n  intros. rewrite <- H0. AppE; apply InterIE in H2 as [Hu Ha];\n  apply InterIE; split... apply SetminIE. split... intro.\n  apply SingE in H2... subst... apply ClaE in Ha. tauto.\nQed.\n\nDefinition EleU cA := \\{ \u03bb z, \u2203 y, z \u2208 y \u2227 y \u2208 cA \\}.\nNotation \"\u222a cA\" := (EleU cA)(at level 66).\n\nFact EleUIE : \u2200 x cA, (\u2203 A, x \u2208 A \u2227 A \u2208 cA) \u2194 x \u2208 \u222acA.\nProof.\n  split; intros. destruct H as [A []]. apply ClaI; Ens.\n  apply ClaE in H as [Hx [y []]]. eauto.\nQed.\n\nFact EleUSin : \u2200 X, Ensemble X \u2192 \u222a[X] = X.\nProof with eauto.\n  intros * Hxe. AppE. apply EleUIE in H as [y [Hx Hy]].\n  apply SingE in Hy... subst... apply EleUIE.\n  exists X. split... apply SingI...\nQed.\n\nAxiom EleUAx : \u2200 A, Ensemble A \u2192 Ensemble (\u222aA).\n\nDefinition EleI cA := \\{ \u03bb z, \u2200 y, y \u2208 cA \u2192 z \u2208 y \\}.\nNotation \"\u22c2 cA\" := (EleI cA)(at level 66).\n\n(* De Morgan Law *)\nDefinition AAr A cA := \\{\u03bb z, \u2203 Ar, Ar \u2208 cA \u2227 z = A - Ar\\}.\n\nFact AArI : \u2200 A B cA, Ensemble A \u2192\n  (\u2203 Ar, Ar \u2208 cA \u2227 B = A - Ar) \u2192 B \u2208 AAr A cA.\nProof.\n  intros. destruct H0 as [Ar []]. apply ClaI. eapply SubAxI; eauto.\n  subst. apply IncludP2. eauto.\nQed.\n\nFact AArE : \u2200 A B cA, B \u2208 AAr A cA \u2192 (\u2203 Ar, Ar \u2208 cA \u2227 B = A - Ar).\nProof. intros. apply ClaE in H. tauto. Qed.\n\nFact AArP : \u2200 A cA, Ensemble A \u2192 cA \u2260 \u2205 \u2192 AAr A cA \u2260 \u2205.\nProof.\n  intros. apply EmptyNE in H0 as [Ar H0]. apply EmptyNE.\n  exists (A - Ar). apply AArI; eauto.\nQed.\n\nFact DeMorganUI : \u2200 A cA, Ensemble A \u2192 cA \u2260 \u2205 \u2192 (A - \u222acA) = \u22c2(AAr A cA).\nProof with eauto.\n  intros. AppE.\n  - apply SetminIE in H1 as [Hx HcA]. apply ClaI; Ens. intros.\n    apply AArE in H1 as [B [Hb Heq]]. subst. apply SetminIE.\n    split... intro. elim HcA. apply EleUIE...\n  - apply EmptyNE in H0 as [Ar H0]. apply ClaE in H1 as []. apply ClaI...\n    assert (A - Ar \u2208 AAr A cA). apply AArI...\n    apply H2 in H3. apply SetminIE in H3 as [Hx H3]. split...\n    intro. apply EleUIE in H4 as [B [Hb H4]].\n    assert (A - B \u2208 AAr A cA). apply AArI...\n    apply H2 in H5. apply ClaE in H5; tauto.\nQed.\n\nDefinition Unordered x y := [x] \u22c3 [y].\nNotation \"[ x | y ] \" := (Unordered x y) (at level 0).\n\nDefinition Ordered x y := [ [x] | [x | y] ].\nNotation \"[ x , y ]\" := (Ordered x y) (at level 0).\n\nDefinition Relation r := \u2200 z, z \u2208 r \u2192 \u2203 x y, z = [x,y].\n\nDefinition Function f :=\n  Relation f \u2227 \u2200 x y z, [x,y] \u2208 f \u2227 [x,z] \u2208 f \u2192 y = z.\n\nDefinition Value f x := \u22c2 \\{ \u03bb y, [x,y] \u2208 f \\}.\nNotation \"f [ x ]\" := (Value f x)(at level 5).\n\nDefinition Domain f := \\{ \u03bb x, \u2203 y, [x,y] \u2208 f \\}.\nNotation \"dom( f )\" := (Domain f)(at level 5).\n\nDefinition Range f := \\{ \u03bb y, \u2203 x, [x,y] \u2208 f \\}.\nNotation \"ran( f )\" := (Range f)(at level 5).\n\nAxiom RepAx : \u2200 f, Function f \u2192 Ensemble dom( f ) \u2192 Ensemble ran( f ).\n\nAxiom RegAx : \u2200 x, x \u2260 \u2205 -> \u2203 y, y \u2208 x \u2227 x \u2229 y = \u2205.\n\nAxiom InfAx : \u2203 y, Ensemble y \u2227 \u2205 \u2208 y \u2227 (\u2200 x, x \u2208 y \u2192 (x \u22c3 [x]) \u2208 y).\n\nDefinition ChoiceFunction c :=\n  Function c /\\ \u2200 x, x \u2208 dom(c) -> c [x] \u2208 x.\n\nAxiom ChoAx : \u2203 c, ChoiceFunction c /\\ dom(c) = \u03bc - [\u2205].\n\nFact EmptySet : Ensemble \u2205.\nProof. destruct InfAx as [x [_ [He _]]]. Ens. Qed.\nLtac Empt := apply EmptySet.\n\nFact IntSinEm : \u2200 A B C, Ensemble C \u2192\n  A \u2208 [C] \u22c3 [\u2205] \u2192 B \u2208 [C] \u22c3 [\u2205] \u2192 A \u2229 B \u2208 [C] \u22c3 [\u2205].\nProof with eauto.\n  intros * Hc Ha Hb. apply UnionIE in Ha as [];\n  apply UnionIE in Hb as []; apply SingE in H;\n  apply SingE in H0; try Empt; subst...\n  - rewrite Idem'. apply UnionIE. left; apply ClaI...\n  - rewrite EmInter. apply UnionIE. right; apply SingI. Empt.\n  - rewrite Commu', EmInter. apply UnionIE.\n    right; apply SingI. Empt.\n  - rewrite EmInter. apply UnionIE. right. apply SingI. Empt.\nQed.\n\nFact EleUSinEm : \u2200 a cT, Ensemble a \u2192 cT \u2282 [a] \u22c3 [\u2205] \u2192 \u222acT \u2208 [a] \u22c3 [\u2205].\nProof with eauto.\n  intros * Hae Ht. assert (Hte : Ensemble cT).\n  { eapply SubAxI; [| apply Ht]. apply UnionAx; apply SingEn... Empt. }\n  assert (cT \u2208 cP([a] \u22c3 [\u2205])). apply ClaI...\n  assert (\u2200 c d, Ensemble c \u2192 Ensemble d \u2192 cP([c] \u22c3 [d]) =\n    \\{ \u03bb Z, Z = \u2205 \u2228 Z = [c] \u2228 Z = [d] \u2228 Z = [c] \u22c3 [d] \\}).\n  { intros. AppE.\n    - apply ClaI. Ens. apply ClaE in H2 as [_ H2].\n      destruct (classic (c \u2208 x)), (classic (d \u2208 x)).\n      + right; right; right. apply ReSyTrP... intros z Hz.\n        apply UnionIE in Hz as []; apply SingE in H5; auto; subst...\n      + right; left. AppE; [| apply SingE in H5; subst; auto].\n        apply ClaI. Ens. intro. pose proof H5 as H5'.\n        apply H2, UnionIE in H5 as []; apply SingE in H5...\n        subst; tauto.\n      + right; right; left. AppE; [| apply SingE in H5; subst; auto].\n        apply ClaI. Ens. intro. pose proof H5 as H5'.\n        apply H2, UnionIE in H5 as []; apply SingE in H5...\n        subst; tauto.\n      + left. AppE; [|exfalso0]. pose proof H5 as H5'.\n        apply H2, UnionIE in H5 as []; apply SingE in H5; subst; tauto.\n    - apply ClaI. Ens. intros z Hz.\n      apply ClaE in H2 as [_ [| [| [| ]]]];\n      subst... exfalso0. apply ClaI; Ens. apply ClaI; Ens. }\n  rewrite H0 in H; try apply EmptySet... clear H0.\n  apply ClaE in H as [_ [| [| [| ]]]]; subst.\n  + assert (\u222a\u2205 = \u2205).\n    { AppE; [| exfalso0]. apply EleUIE in H as [y [_ Hy]]. exfalso0. }\n    rewrite H. apply UnionIE. right. apply ClaI...\n  + rewrite EleUSin... apply UnionIE. left. apply ClaI...\n  + pose proof EmptySet. rewrite EleUSin...\n    apply UnionIE. right. apply SingI...\n  + assert (\u222a [a] \u22c3 [\u2205] = a).\n    { AppE. apply EleUIE in H as [y [Hx Hy]].\n      apply UnionIE in Hy as []; apply SingE in H; subst... exfalso0.\n      apply EmptySet. apply EleUIE. exists a. split...\n      apply UnionIE. left. apply ClaI... }\n    rewrite H. apply UnionIE. left; apply ClaI...\nQed.\n",
      "theorem": "Fact EmUnion : \u2200 A, A \u22c3 \u2205 = A.",
      "ground_truth": "Proof.\n  intros. AppE. apply UnionIE in H as []; auto.\n  exfalso0. apply UnionIE; Ens.\nQed."
    },
    {
      "split": "train-sft",
      "index": 2,
      "prefix": "Require Import Permutation List Lia.\n\nInductive value := x0 | x1 | x2 | x3 | x4 | x5 | x6 | x7.\nInductive variable := aux | num: value -> variable.\nDefinition variable_eq_dec (x y: variable): {x=y} + {x<>y}.\nProof.\n  destruct x, y.\n  + left; auto.\n  + right; abstract congruence.\n  + right; abstract congruence.\n  + destruct v, v0; try (left; abstract congruence); (right; abstract congruence).\nDefined.\n\nInductive assignment := assign: variable -> variable -> assignment.\nInductive comparison := GT: forall (more less: value), comparison.\n\nInductive step :=\n| assignments: forall (L: list assignment), step\n| conditional: forall (c: comparison) (positive negative: step), step.\n\nDefinition algorithm := list step.\n\nDefinition instantation := variable -> nat.\n\nDefinition is_increasing (i: instantation) :=\n  i (num x0) <= i (num x1) /\\\n  i (num x1) <= i (num x2) /\\\n  i (num x2) <= i (num x3) /\\\n  i (num x3) <= i (num x4) /\\\n  i (num x4) <= i (num x5) /\\\n  i (num x5) <= i (num x6) /\\\n  i (num x6) <= i (num x7).\nDefinition list_of_values (i: instantation) :=\n  i (num x0) :: i (num x1) :: i (num x2) :: i (num x3) :: i (num x4) :: i (num x5) :: i (num x6) :: i (num x7) :: nil.\nDefinition is_permutation (i1 i2: instantation) := Permutation (list_of_values i1) (list_of_values i2).\n\nDefinition is_sorted (start result: instantation) := is_increasing result /\\ is_permutation start result.\n\nDefinition run_assignment (values: instantation) (a: assignment): instantation.\nProof.\n  destruct a as [v1 v2].\n  exact (fun i => if variable_eq_dec i v1 then values v2 else values i).\nDefined.\n\nDefinition run_step (values: instantation) (s: step): instantation.\nProof.\n  induction s.\n  + induction L.\n    - exact values.\n    - exact (run_assignment IHL a).\n  + destruct c.\n    exact (if Compare_dec.gt_dec (values (num more)) (values (num less)) then IHs1 else IHs2).\nDefined.\n\nDefinition run_algorithm (values: instantation) (algo: algorithm): instantation.\nProof.\n  induction algo.\n  + exact values.\n  + exact (run_step IHalgo a).\nDefined.\n\nDefinition run_algorithm_tail (values: instantation) (s: step) (algo: algorithm):\n  run_algorithm values (algo ++ s :: nil) = run_algorithm (run_step values s) algo.\nProof.\n  induction algo.\n  + simpl. auto.\n  + simpl. rewrite IHalgo. auto.\nQed.\n\nDefinition count_comparisons_in_step (s: step): nat.\nProof.\n  induction s.\n  + exact 0.\n  + exact (1 + PeanoNat.Nat.max IHs1 IHs2).\nDefined.\nDefinition count_comparisons_in_algorithm (a: algorithm): nat.\nProof.\n  induction a as [| s L].\n  + exact 0.\n  + exact (IHL + count_comparisons_in_step s).\nDefined.\n\nDefinition do_nothing := assignments nil.\nDefinition swap (x y: value) :=\n  assign (num y) aux ::\n  assign (num x) (num y) ::\n  assign aux (num x) ::\n  nil.\n\nDefinition property (L: list comparison) (i: instantation): Prop.\nProof.\n  induction L.\n  + exact True.\n  + destruct a. exact (IHL /\\ i (num less) <= i (num more)).\nDefined.\n\nDefinition step1 := conditional (GT x0 x1) (assignments (swap x0 x1)) do_nothing.\nDefinition prop1 := GT x1 x0 :: nil.\nDefinition step2 := conditional (GT x2 x3) (assignments (swap x2 x3)) do_nothing.\nDefinition prop2 := GT x3 x2 :: prop1.\nDefinition step3 := conditional (GT x4 x5) (assignments (swap x4 x5)) do_nothing.\nDefinition prop3 := GT x5 x4 :: prop2.\nDefinition step4 := conditional (GT x6 x7) (assignments (swap x6 x7)) do_nothing.\nDefinition prop4 := GT x7 x6 :: prop3.\nDefinition step5 := conditional (GT x1 x3) (assignments (swap x1 x3 ++ swap x0 x2)) do_nothing.\nDefinition prop5 := GT x3 x1 :: prop4.\nDefinition step6 := conditional (GT x5 x7) (assignments (swap x5 x7 ++ swap x4 x6)) do_nothing.\nDefinition prop6 := GT x7 x5 :: prop5.\nDefinition step7 := conditional (GT x3 x7) (assignments (swap x0 x4 ++ swap x1 x5 ++ swap x2 x6 ++ swap x3 x7)) do_nothing.\nDefinition prop7 := GT x7 x3 :: prop6.\nDefinition step8_9 := conditional (GT x5 x3)\n                       do_nothing\n                       (conditional (GT x5 x1)\n                        (assignments (swap x3 x5 ++ swap x2 x4))\n                        (assignments ( \n                         assign (num x2) aux :: assign (num x4) (num x2) :: assign (num x0) (num x4) :: assign aux (num x0) ::\n                         assign (num x3) aux :: assign (num x5) (num x3) :: assign (num x1) (num x5) :: assign aux (num x1) :: nil))).\nDefinition prop9 := GT x5 x3 :: prop6.\nDefinition step10_11 := conditional (GT x1 x4)\n                         (conditional (GT x0 x4)\n                          (assignments (assign (num x1) aux :: assign (num x2) (num x1) :: assign (num x3) (num x2) ::\n                                        assign (num x4) (num x3) :: assign (num x0) (num x4) :: assign aux (num x0) :: nil))\n                          (assignments (assign (num x2) aux :: assign (num x3) (num x2) :: assign (num x4) (num x3) ::\n                                        assign (num x1) (num x4) :: assign aux (num x1) :: nil)))\n                         (conditional (GT x3 x4)\n                          (assignments (assign (num x3) aux :: assign (num x4) (num x3) :: assign (num x2) (num x4) ::\n                                        assign aux (num x2) :: nil))\n                          (assignments (swap x2 x3))).\nDefinition prop11 := GT x1 x0 :: GT x2 x1 :: GT x4 x2 :: GT x4 x3 :: GT x5 x4 :: GT x7 x5 :: GT x7 x6 :: nil.\nDefinition step12_13 := conditional (GT x1 x3)\n                         (conditional (GT x0 x3)\n                          (assignments (assign (num x1) aux :: assign (num x2) (num x1) :: assign (num x3) (num x2) ::\n                                        assign (num x0) (num x3) :: assign aux (num x0) :: nil))\n                          (assignments (assign (num x2) aux :: assign (num x3) (num x2) :: assign (num x1) (num x3) ::\n                                        assign aux (num x1) :: nil)))\n                         (conditional (GT x2 x3)\n                          (assignments (swap x2 x3)) do_nothing).\nDefinition prop13 := GT x1 x0 :: GT x2 x1 :: GT x3 x2 :: GT x4 x3 :: GT x5 x4 :: GT x7 x5 :: GT x7 x6 :: nil.\nDefinition step14_15_16 :=\n  conditional (GT x3 x6)\n   (conditional (GT x1 x6)\n     (conditional (GT x0 x6)\n      (assignments (assign (num x1) aux :: assign (num x2) (num x1) :: assign (num x3) (num x2) :: assign (num x4) (num x3) ::\n                    assign (num x5) (num x4) :: assign (num x6) (num x5) :: assign (num x0) (num x6) :: assign aux (num x0) :: nil))\n      (assignments (assign (num x2) aux :: assign (num x3) (num x2) :: assign (num x4) (num x3) :: assign (num x5) (num x4) ::\n                    assign (num x6) (num x5) :: assign (num x1) (num x6) :: assign aux (num x1) :: nil)))\n     (conditional (GT x2 x6)\n      (assignments (assign (num x3) aux :: assign (num x4) (num x3) :: assign (num x5) (num x4) :: assign (num x6) (num x5) ::\n                    assign (num x2) (num x6) :: assign aux (num x2) :: nil))\n      (assignments (assign (num x4) aux :: assign (num x5) (num x4) :: assign (num x6) (num x5) :: assign (num x3) (num x6) ::\n                    assign aux (num x3) :: nil))))\n   (conditional (GT x5 x6)\n     (conditional (GT x4 x6)\n      (assignments (assign (num x5) aux :: assign (num x6) (num x5) :: assign (num x4) (num x6) :: assign aux (num x4) :: nil))\n      (assignments (swap x5 x6)))\n     do_nothing).\nDefinition prop16 := GT x1 x0 :: GT x2 x1 :: GT x3 x2 :: GT x4 x3 :: GT x5 x4 :: GT x6 x5 :: GT x7 x6 :: nil.\n\nDefinition sort8: algorithm := step14_15_16 :: step12_13 :: step10_11 :: step8_9 :: step7 ::\n                               step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil.\n\nEval compute in count_comparisons_in_algorithm sort8.\n\nLtac T1 after := intros; repeat split; simpl in *; unfold after; clear after;\n     repeat destruct Compare_dec.gt_dec; repeat (destruct variable_eq_dec; try congruence); lia.\n\nDefinition step1_condition (before: instantation):\n  let after := run_algorithm before (step1 :: nil) in\n  property prop1 after.\nProof.\n  T1 after.\nQed.\nDefinition step2_after_step1_condition (before: instantation)\n  (H: property prop1 before):\n  let after := run_algorithm before (step2 :: nil) in\n  property prop2 after.\nProof.\n  T1 after.\nQed.\nDefinition step3_after_step2_condition (before: instantation)\n  (H: property prop2 before):\n  let after := run_algorithm before (step3 :: nil) in\n  property prop3 after.\nProof.\n  T1 after.\nQed.\nDefinition step4_after_step3_condition (before: instantation)\n  (H: property prop3 before):\n  let after := run_algorithm before (step4 :: nil) in\n  property prop4 after.\nProof.\n  T1 after.\nQed.\nDefinition step5_after_step4_condition (before: instantation)\n  (H: property prop4 before):\n  let after := run_algorithm before (step5 :: nil) in\n  property prop5 after.\nProof.\n  T1 after.\nQed.\nDefinition step6_after_step5_condition (before: instantation)\n  (H: property prop5 before):\n  let after := run_algorithm before (step6 :: nil) in\n  property prop6 after.\nProof.\n  T1 after.\nQed.\nDefinition step7_after_step6_condition (before: instantation)\n  (H: property prop6 before):\n  let after := run_algorithm before (step7 :: nil) in\n  property prop7 after.\nProof.\n  T1 after.\nQed.\nDefinition step9_after_step7_condition (before: instantation)\n  (H: property prop7 before):\n  let after := run_algorithm before (step8_9 :: nil) in\n  property prop9 after.\nProof.\n  T1 after.\nQed.\nDefinition step11_after_step9_condition (before: instantation)\n  (H: property prop9 before):\n  let after := run_algorithm before (step10_11 :: nil) in\n  property prop11 after.\nProof.\n  T1 after.\nQed.\nDefinition step13_after_step11_condition (before: instantation)\n  (H: property prop11 before):\n  let after := run_algorithm before (step12_13 :: nil) in\n  property prop13 after.\nProof.\n  T1 after.\nQed.\nDefinition step16_after_step13_condition (before: instantation)\n  (H: property prop13 before):\n  let after := run_algorithm before (step14_15_16 :: nil) in\n  property prop16 after.\nProof.\n  T1 after.\nQed.\n\n\nLemma Permutation_Add_cons A :\n  forall (a : A) l1 l2 l2', Add a l2 l2' -> Permutation l1 l2 -> Permutation (a :: l1) l2'.\nProof.\n  intros a l1 l2 l2' Hadd HP.\n  now etransitivity; [ apply Permutation_cons | apply Permutation_Add, Hadd ].\nQed.\n\nLtac permutation_solve :=\n  intros; now repeat (eapply Permutation_Add_cons; [ repeat econstructor | ]).\n\nLtac T2 after list_of_values := intros; unfold after, list_of_values; simpl; repeat destruct Compare_dec.gt_dec;\n                                repeat (destruct variable_eq_dec; try congruence); permutation_solve.\n\nDefinition step1_permutation (before: instantation):\n  let after := run_algorithm before (step1 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step2_permutation (before: instantation):\n  let after := run_algorithm before (step2 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step3_permutation (before: instantation):\n  let after := run_algorithm before (step3 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step4_permutation (before: instantation):\n  let after := run_algorithm before (step4 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step5_permutation (before: instantation):\n  let after := run_algorithm before (step5 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step6_permutation (before: instantation):\n  let after := run_algorithm before (step6 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step7_permutation (before: instantation):\n  let after := run_algorithm before (step7 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step9_permutation (before: instantation):\n  let after := run_algorithm before (step8_9 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step11_permutation (before: instantation):\n  let after := run_algorithm before (step10_11 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step13_permutation (before: instantation):\n  let after := run_algorithm before (step12_13 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\nDefinition step16_permutation (before: instantation):\n  let after := run_algorithm before (step14_15_16 :: nil) in\n  Permutation (list_of_values before) (list_of_values after).\nProof.\n  T2 after list_of_values.\nQed.\n\nTheorem algorithm_cons (s: step) (a: algorithm) (before: instantation):\n  run_algorithm before (s :: a) = run_algorithm (run_algorithm before a) (s :: nil).\nProof.\n  simpl. reflexivity.\nQed.\n\nTheorem algorithm_permutation (before: instantation):\n  let after := run_algorithm before sort8 in\n  Permutation (list_of_values before) (list_of_values after).",
      "suffix": "\n\n\nDefinition equivalent (i1 i2: instantation) :=\n  forall x y, i1 x <= i1 y <-> i2 x <= i2 y.\n\nFixpoint distinct (L: list instantation) :=\n  match L with\n  | x :: (y :: t) as t0 => ~ equivalent x y /\\ distinct t0\n  | _ => True\n  end.\n\nFixpoint factorial n :=\n  match n with\n  | O => 1\n  | S m => S m * factorial m\n  end.\n\nTheorem run_algorithm_nil (i: instantation) : forall x, run_algorithm i nil x = i x.\nProof.\n  intros. simpl. auto.\nQed.\n\nTheorem run_step_cons (i: instantation) (a: assignment) (L: list assignment):\n  run_step i (assignments (a :: L)) = run_assignment (run_step i (assignments L)) a.\nProof.\n  simpl. auto.\nQed.\n\nTheorem equivalent_after_assignment (i1 i2: instantation) (H: equivalent i1 i2) (a: assignment):\n  equivalent (run_assignment i1 a) (run_assignment i2 a).\nProof.\n  unfold equivalent in *. intros. destruct a.\n  destruct v, v0; simpl; repeat (destruct variable_eq_dec); apply H.\nQed.\n\nTheorem equivalent_after_step (i1 i2: instantation) (H: equivalent i1 i2) (s: step):\n  equivalent (run_step i1 s) (run_step i2 s).\nProof.\n  induction s.\n  + induction L.\n    - simpl. auto.\n    - intros. repeat rewrite run_step_cons. apply equivalent_after_assignment; auto.\n  + intros. simpl. destruct c. unfold equivalent in *. intros. repeat (destruct Compare_dec.gt_dec); eauto.\n    - pose (H (num more) (num less)). lia.\n    - pose (H (num more) (num less)). lia.\nQed.\n\nTheorem equivalent_after_algorithm (i1 i2: instantation) (H: equivalent i1 i2) (a: algorithm):\n  equivalent (run_algorithm i1 a) (run_algorithm i2 a).\nProof.\n  unfold equivalent in *.\n  + induction a; intros; simpl in *.\n    - apply H.\n    - apply equivalent_after_step; eauto.\nQed.\n\n\n(* ?? Something about distinct instantations being factorial 8 ?? *)\nTheorem max_number_of_distinct_instantations (L: list instantation):\n  distinct L -> length L <= factorial 8.\nProof.\nAdmitted.\n\n\n\n\n(* Extraction to graphviz as flowchart *)\nRequire Import String.\nOpen Scope string.\n\nDefinition value_to_string (n: value): string :=\n  match n with\n  | x0 => \"x0\"\n  | x1 => \"x1\"\n  | x2 => \"x2\"\n  | x3 => \"x3\"\n  | x4 => \"x4\"\n  | x5 => \"x5\"\n  | x6 => \"x6\"\n  | x7 => \"x7\"\n  end.\nDefinition variable_to_string (v: variable): string :=\n  match v with\n  | aux => \"t\"\n  | num x => value_to_string x\n  end.\nDefinition comparison_to_string (c: comparison) :=\n  match c with\n  | GT x y => \"[label=\"\"\" ++ value_to_string x ++ \" > \" ++ value_to_string y ++ \"\"\", shape=\"\"diamond\"\"]; \" end.\nDefinition assignment_to_string (a: assignment) :=\n  match a with assign x y => variable_to_string x ++ \"=\" ++ variable_to_string y end.\nFixpoint assignment_list_to_string_aux (L: list assignment): string :=\n  match L with\n  | nil => \"\"\n  | x :: nil => assignment_to_string x\n  | x :: t => assignment_to_string x ++ \"; \" ++ assignment_list_to_string_aux t\n  end.\nDefinition assignment_list_to_string L := \"[label=\"\"\" ++ assignment_list_to_string_aux (rev L) ++ \"\"\"];\".\n\nEval compute in assignment_list_to_string (swap x0 x1).\nEval compute in comparison_to_string (GT x0 x1).\n\nDefinition count_assignment_blocks_in_step (s: step): nat.\nProof.\n  induction s.\n  + exact 1.\n  + exact (IHs1 + IHs2).\nDefined.\nEval compute in count_assignment_blocks_in_step step14_15_16.\n\nDefinition count_comparison_blocks_in_step (s: step): nat.\nProof.\n  induction s.\n  + exact 0.\n  + exact (1 + IHs1 + IHs2).\nDefined.\nEval compute in count_comparison_blocks_in_step step14_15_16.\n\n(* http://poleiro.info/posts/2013-03-31-reading-and-writing-numbers-in-coq.html *)\nDefinition natToDigit (n : nat) :=\n  match n with\n    | 0 => \"0\"\n    | 1 => \"1\"\n    | 2 => \"2\"\n    | 3 => \"3\"\n    | 4 => \"4\"\n    | 5 => \"5\"\n    | 6 => \"6\"\n    | 7 => \"7\"\n    | 8 => \"8\"\n    | _ => \"9\"\n  end.\nFixpoint writeNatAux (time n : nat) (acc : string) : string :=\n  let acc' := (natToDigit (Nat.modulo n 10)) ++ acc in\n  match time with\n    | 0 => acc'\n    | S time' =>\n      match Nat.div n 10 with\n        | 0 => acc'\n        | n' => writeNatAux time' n' acc'\n      end\n  end.\nDefinition writeNat (n : nat) : string :=\n  writeNatAux n n \"\".\n",
      "theorem": "Theorem algorithm_permutation (before: instantation):\n  let after := run_algorithm before sort8 in\n  Permutation (list_of_values before) (list_of_values after).",
      "ground_truth": "Proof.\n  unfold sort8.\n  assert (Permutation\n    (list_of_values (run_algorithm before (step12_13 :: step10_11 :: step8_9 :: step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step14_15_16 :: step12_13 :: step10_11 :: step8_9 :: step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step14_15_16). apply step16_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step10_11 :: step8_9 :: step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step12_13 :: step10_11 :: step8_9 :: step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step12_13). apply step13_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step8_9 :: step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step10_11 :: step8_9 :: step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step10_11). apply step11_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step8_9 :: step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step8_9). apply step9_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step7 :: step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step7). apply step7_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step5 :: step4 :: step3 :: step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step6 :: step5 :: step4 :: step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step6). apply step6_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step4 :: step3 :: step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step5 :: step4 :: step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step5). apply step5_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step3 :: step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step4 :: step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step4). apply step4_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step2 :: step1 :: nil)))\n    (list_of_values (run_algorithm before (step3 :: step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step3). apply step3_permutation. }\n  assert (Permutation\n    (list_of_values (run_algorithm before (step1 :: nil)))\n    (list_of_values (run_algorithm before (step2 :: step1 :: nil)))).\n  { rewrite (algorithm_cons step2). apply step2_permutation. }\n  assert (Permutation\n    (list_of_values before)\n    (list_of_values (run_algorithm before (step1 :: nil)))).\n  { apply step1_permutation. }\n  repeat (eapply perm_trans; eauto).\nQed."
    },
    {
      "split": "train-sft",
      "index": 3,
      "prefix": "Require Import Bool List String.\nRequire Import Lib.CommonTactics Lib.Struct.\nRequire Import Lib.ilist Lib.Word Lib.FMap Lib.StringEq.\nRequire Import Kami.Syntax Kami.Semantics Kami.SemFacts.\nRequire Import Kami.Wf Kami.Inline.\nRequire Import Kami.RefinementFacts.\n\nRequire Import FunctionalExtensionality.\n\nRequire Import (hints) btauto.Algebra.\n\nSet Implicit Arguments.\nSet Asymmetric Patterns.\n\nLocal Ltac Tauto.intuition_solver ::= auto with datatypes exfalso.\n\nLemma inlineDm_SemAction_intact:\n  forall {retK} or a nr calls (retV: type retK),\n    SemAction or a nr calls retV ->\n    forall dmn dmb,\n      None = M.find dmn calls ->\n      SemAction or (inlineDm a (dmn :: dmb)%struct) nr calls retV.\nProof.\n  induction 1; intros.\n\n  - simpl.\n    remember (getBody meth (dmn :: dmb)%struct s) as omb;\n      destruct omb.\n    + exfalso; subst.\n      unfold getBody in Heqomb.\n      remember (string_eq _ _) as seq; destruct seq; [|discriminate].\n      apply string_eq_dec_eq in Heqseq.\n      subst; rewrite M.find_add_1 in H0; inv H0.\n    + subst.\n      unfold getBody in Heqomb.\n      remember (string_eq _ _) as seq; destruct seq.\n      * apply string_eq_dec_eq in Heqseq.\n        subst; rewrite M.find_add_1 in H0; inv H0.\n      * apply string_eq_dec_neq in Heqseq.\n        rewrite M.find_add_2 in H0 by intuition auto.\n        econstructor; eauto.\n\n  - simpl; constructor; auto.\n  - simpl; econstructor; eauto.\n  - simpl; econstructor; eauto.\n  - simpl; econstructor; eauto.\n\n  - subst; eapply SemIfElseTrue; eauto.\n    + apply IHSemAction1.\n      rewrite M.find_union in H1.\n      destruct (M.find dmn calls1); auto.\n    + apply IHSemAction2.\n      rewrite M.find_union in H1.\n      destruct (M.find dmn calls1); auto; inv H1.\n\n  - subst; eapply SemIfElseFalse; eauto.\n    + apply IHSemAction1.\n      rewrite M.find_union in H1.\n      destruct (M.find dmn calls1); auto.\n    + apply IHSemAction2.\n      rewrite M.find_union in H1.\n      destruct (M.find dmn calls1); auto; inv H1.\n\n  - simpl; constructor; auto.\n  - simpl; constructor; auto.\n  - simpl; constructor; auto.\nQed.\n\nLemma inlineDm_correct_SemAction:\n  forall (meth: DefMethT) or u1 cm1 argV retV1,\n    SemAction or (projT2 (attrType meth) type argV) u1 cm1 retV1 ->\n    forall {retK2} a\n           u2 cm2 (retV2: type retK2),\n      M.Disj u1 u2 -> M.Disj cm1 cm2 ->\n      Some (existT _ (projT1 (attrType meth))\n                   (argV, retV1)) =\n      M.find (attrName meth) cm2 ->\n      SemAction or a u2 cm2 retV2 ->\n      SemAction or (inlineDm a meth) (M.union u1 u2)\n                (M.union cm1 (M.remove (attrName meth) cm2))\n                retV2.\nProof.\n  induction a; intros; simpl in *.\n\n  - inv H4; destruct_existT.\n    remember (getBody meth0 meth s) as ob; destruct ob.\n    + unfold getBody in Heqob.\n      remember (string_eq _ _) as seq; destruct seq; [|inv Heqob].\n      apply string_eq_dec_eq in Heqseq; subst.\n      destruct (SignatureT_dec _ _); [|inv Heqob].\n      generalize dependent HSemAction; inv Heqob; intros.\n      rewrite M.find_add_1 in H3.\n      inv H3; destruct_existT.\n      simpl; constructor.\n\n      eapply appendAction_SemAction; eauto.\n      \n      rewrite M.remove_add.\n      rewrite M.remove_find_None by assumption.\n\n      destruct meth; apply inlineDm_SemAction_intact; auto.\n\n    + unfold getBody in Heqob.\n      remember (string_eq _ _) as seq; destruct seq.\n\n      * apply string_eq_dec_eq in Heqseq; subst.\n        destruct (SignatureT_dec _ _); [inv Heqob|].\n\n        { constructor 1 with\n          (mret := mret)\n            (calls := M.union cm1 (M.remove (attrName meth) calls)).\n          - apply M.F.P.F.not_find_in_iff.\n            unfold not; intros.\n            apply M.F.P.F.not_find_in_iff in HDisjCalls.\n            apply M.union_In in H4.\n            dest_disj.\n            destruct H4; auto.\n            rewrite M.F.P.F.remove_in_iff in H4; intuition.\n          - meq; clear - n H3; inv H3; destruct_existT; intuition auto.\n          - apply H0; auto.\n            elim n.\n            rewrite M.find_add_1 in H3.\n            clear -H3; inv H3; destruct_existT; auto.\n        }\n\n      * apply string_eq_dec_neq in Heqseq; subst.\n        { constructor 1 with\n          (mret := mret)\n            (calls := M.union cm1 (M.remove (attrName meth) calls)).\n          - apply M.F.P.F.not_find_in_iff.\n            unfold not; intros.\n            apply M.F.P.F.not_find_in_iff in HDisjCalls.\n            apply M.union_In in H4.\n            dest_disj.\n            destruct H4; auto.\n            rewrite M.F.P.F.remove_in_iff in H4; intuition.\n          - meq; clear - n H3; inv H3; destruct_existT; intuition auto.\n          - apply H0; auto.\n            rewrite M.find_add_2 in H3; auto.\n        } \n        \n  - inv H4; destruct_existT.\n    constructor; auto.\n  - inv H4; destruct_existT.\n    econstructor; eauto.\n  - inv H4; destruct_existT.\n    econstructor; eauto.\n  - inv H3; destruct_existT.\n    constructor 5 with (newRegs := M.union u1 newRegs).\n    + apply M.F.P.F.not_find_in_iff.\n      apply M.F.P.F.not_find_in_iff in HDisjRegs.\n      unfold not; intros.\n      apply M.union_In in H3.\n      dest_disj.\n      intuition.\n    + meq.\n    + apply IHa; auto.\n\n  - inv H4; destruct_existT.\n    + rewrite M.find_union in H3.\n      remember (M.find (attrName meth) calls1) as omv1; destruct omv1.\n      * remember (M.find (attrName meth) calls2) as omv2; destruct omv2.\n        { exfalso.\n          specialize (HDisjCalls (attrName meth)); destruct HDisjCalls; elim H4.\n          { apply M.F.P.F.in_find_iff; rewrite <-Heqomv1; discriminate. }\n          { apply M.F.P.F.in_find_iff; rewrite <-Heqomv2; discriminate. }\n        }\n        { inv H3.\n          rewrite M.union_assoc, M.remove_union, M.union_assoc.\n          eapply SemIfElseTrue with\n          (newRegs1 := M.union u1 newRegs1)\n            (calls1 := M.union cm1 (M.Map.remove (attrName meth) calls1)); eauto.\n          { dest_disj; solve_disj. }\n          { dest_disj.\n            apply M.Disj_remove_2.\n            solve_disj.\n          }\n          { rewrite M.remove_find_None by auto.\n            destruct meth; apply inlineDm_SemAction_intact; auto.\n          }\n        }\n      * assert (M.union u1 (M.union newRegs1 newRegs2) =\n                M.union newRegs1 (M.union u1 newRegs2)).\n        { rewrite M.union_assoc.\n          rewrite M.union_comm with (m1:= u1); [|eapply M.Disj_union_1; eauto].\n          rewrite <-M.union_assoc; auto.\n        }\n        rewrite H4; clear H4.\n\n        assert (M.union cm1 (M.remove (attrName meth) (M.union calls1 calls2)) =\n                M.union (M.remove (attrName meth) calls1)\n                        (M.union cm1 (M.remove (attrName meth) calls2))).\n        { rewrite M.remove_union, M.union_assoc.\n          rewrite M.union_comm with (m1:= cm1);\n            [|apply M.Disj_remove_2; eapply M.Disj_union_1; eauto].\n          rewrite <-M.union_assoc; auto.\n        }\n        rewrite H4; clear H4.\n        eapply SemIfElseTrue with\n        (newRegs1 := newRegs1)\n          (newRegs2 := M.union u1 newRegs2)\n          (calls1 := M.remove (attrName meth) calls1)\n          (calls2 := M.union cm1 (M.remove (attrName meth) calls2)); eauto.\n        rewrite M.remove_find_None by auto.\n        destruct meth; eapply inlineDm_SemAction_intact; eauto.\n\n    + rewrite M.find_union in H3.\n      remember (M.find (attrName meth) calls1) as omv1; destruct omv1.\n      * remember (M.find (attrName meth) calls2) as omv2; destruct omv2.\n        { exfalso.\n          specialize (HDisjCalls (attrName meth)); destruct HDisjCalls; elim H4.\n          { apply M.F.P.F.in_find_iff; rewrite <-Heqomv1; discriminate. }\n          { apply M.F.P.F.in_find_iff; rewrite <-Heqomv2; discriminate. }\n        }\n        { inv H3.\n          rewrite M.union_assoc, M.remove_union, M.union_assoc.\n          eapply SemIfElseFalse with\n          (newRegs1 := M.union u1 newRegs1)\n            (calls1 := M.union cm1 (M.Map.remove (attrName meth) calls1)); eauto.\n          { dest_disj; solve_disj. }\n          { dest_disj.\n            apply M.Disj_remove_2.\n            solve_disj.\n          }\n          { rewrite M.remove_find_None by auto.\n            destruct meth; apply inlineDm_SemAction_intact; auto.\n          }\n        }\n      * assert (M.union u1 (M.union newRegs1 newRegs2) =\n                M.union newRegs1 (M.union u1 newRegs2)).\n        { rewrite M.union_assoc.\n          rewrite M.union_comm with (m1:= u1); [|eapply M.Disj_union_1; eauto].\n          rewrite <-M.union_assoc; auto.\n        }\n        rewrite H4; clear H4.\n\n        assert (M.union cm1 (M.remove (attrName meth) (M.union calls1 calls2)) =\n                M.union (M.remove (attrName meth) calls1)\n                        (M.union cm1 (M.remove (attrName meth) calls2))).\n        { rewrite M.remove_union, M.union_assoc.\n          rewrite M.union_comm with (m1:= cm1);\n            [|apply M.Disj_remove_2; eapply M.Disj_union_1; eauto].\n          rewrite <-M.union_assoc; auto.\n        }\n        rewrite H4; clear H4.\n        eapply SemIfElseFalse with\n        (newRegs1 := newRegs1)\n          (newRegs2 := M.union u1 newRegs2)\n          (calls1 := M.remove (attrName meth) calls1)\n          (calls2 := M.union cm1 (M.remove (attrName meth) calls2)); eauto.\n        rewrite M.remove_find_None by auto.\n        destruct meth; eapply inlineDm_SemAction_intact; eauto.\n\n  - inv H3; destruct_existT.\n    constructor; auto.\n\n  - inv H3; destruct_existT.\n    constructor; auto.\n\n  - inv H3; destruct_existT.\n    rewrite M.find_empty in H2; inv H2.\nQed.\n\nLemma isLeaf_SemAction_calls:\n  forall {retK} aU aT,\n    ActionEquiv (k:= retK) aT aU ->\n    forall lcalls or nr calls retV,\n      isLeaf aU lcalls = true ->\n      SemAction or aT nr calls retV ->\n      forall lc,\n        In lc lcalls ->\n        M.find lc calls = None.\nProof.\n  induction 1; intros.\n\n  - inv H2; destruct_existT.\n    destruct (string_dec lc n).\n    + subst; simpl in H1.\n      apply andb_true_iff in H1; dest.\n      remember (string_in _ _) as sin; destruct sin; [inv H1|].\n      apply string_in_dec_not_in in Heqsin; elim Heqsin; auto.\n    + simpl in H1.\n      apply andb_true_iff in H1; dest.\n      remember (string_in _ _) as sin; destruct sin; [inv H1|].\n      apply string_in_dec_not_in in Heqsin.\n      rewrite M.find_add_2 by assumption.\n      eapply H0; eauto.\n\n  - inv H2; destruct_existT.\n    simpl in H1.\n    eapply H0; eauto.\n  - inv H2; destruct_existT.\n    simpl in H1.\n    eapply H0; eauto.\n  - inv H2; destruct_existT.\n    simpl in H1.\n    eapply H0; eauto.\n  - inv H1; destruct_existT.\n    simpl in H0.\n    eapply IHActionEquiv; eauto.\n  - inv H3.\n    apply andb_true_iff in H7; dest.\n    apply andb_true_iff in H3; dest.\n    inv H4; destruct_existT; rewrite M.find_union.\n    + erewrite IHActionEquiv1; eauto.\n    + erewrite IHActionEquiv2; eauto.\n  - inv H1; destruct_existT.\n    simpl in H0.\n    eapply IHActionEquiv; eauto.\n  - inv H0; destruct_existT.\n    rewrite M.find_empty; auto.\nQed.\n\nLemma noCallDm_SemAction_calls:\n  forall mn (mb: sigT MethodT) or nr calls argV retV\n         (Hmb: ActionEquiv (projT2 mb type argV) (projT2 mb typeUT tt)),\n    noCallDm (mn :: mb)%struct (mn :: mb)%struct = true ->\n    SemAction or (projT2 mb type argV) nr calls retV ->\n    M.find (elt:=sigT SignT) mn calls = None.\nProof.\n  intros; unfold noCallDm in H; simpl in H.\n  eapply isLeaf_SemAction_calls; eauto.\n  intuition.\nQed.\n\nSection HideExts.\n  Definition hideMeth (l: LabelT) (dmn: string): LabelT :=\n    match M.find dmn (defs l), M.find dmn (calls l) with\n      | Some v1, Some v2 =>\n        match signIsEq v1 v2 with\n          | left _ => {| annot := annot l;\n                         defs := M.remove dmn (defs l);\n                         calls := M.remove dmn (calls l) |}\n          | _ => l\n        end\n      | _, _ => l\n    end.\n\n  Fixpoint hideMeths (l: LabelT) (dms: list string): LabelT :=\n    match dms with\n      | nil => l\n      | dm :: dms' => hideMeths (hideMeth l dm) dms'\n    end.\n\n  Lemma hideMeth_preserves_hide:\n    forall (l: LabelT ) dm,\n      hide (hideMeth l dm) = hide l.\n  Proof.\n    intros; destruct l as [rm dms cms].\n    unfold hide, hideMeth; simpl.\n    remember (M.find dm dms) as odm; destruct odm; [|reflexivity].\n    remember (M.find dm cms) as ocm; destruct ocm; [|reflexivity].\n    destruct (signIsEq s s0); [|reflexivity].\n    subst; f_equal; auto; apply M.subtractKV_remove; rewrite <-Heqodm, <-Heqocm; auto.\n  Qed.\n\nEnd HideExts.\n\nSection SubstepFacts.\n  Variable m: Modules.\n  Hypotheses (Hequiv: ModEquiv type typeUT m)\n             (Hdefs: NoDup (namesOf (getDefsBodies m))).\n  Variable dm: DefMethT.\n  \n  Lemma inlineDmToMod_correct_Substep:\n    forall or u1 u2 cs1 cs2 argV retV ul2,\n      Substep m or u2 ul2 cs2 ->\n      SemAction or (projT2 (attrType dm) type argV) u1 cs1 retV ->\n      M.Disj u1 u2 -> M.Disj cs1 cs2 ->\n      Some (existT _ (projT1 (attrType dm)) (argV, retV)) = M.find (attrName dm) cs2 ->\n      Substep (Mod (getRegInits m) (inlineDmToRules (getRules m) dm)\n                   (inlineDmToDms (getDefsBodies m) dm))\n              or (M.union u1 u2) ul2 (M.union cs1 (M.remove (attrName dm) cs2)).\n  Proof.\n    induction 1; intros; simpl in *; try (inv H2).\n\n    - eapply SingleRule with (a:= attrType (inlineDmToRule (k :: a)%struct dm)); eauto.\n      + apply in_map with (f:= fun r => inlineDmToRule r dm) in HInRules; auto.\n      + simpl; eapply inlineDm_correct_SemAction; eauto.\n\n    - eapply SingleMeth with (f:= inlineDmToDm f dm); eauto.\n      + apply in_map with (f:= fun d => inlineDmToDm d dm) in HIn; auto.\n      + simpl; eapply inlineDm_correct_SemAction; eauto.\n  Qed.  \n\n  Lemma inlineDmToMod_Substep_intact:\n    forall or u ul cs (dmn: string),\n      Substep m or u ul cs ->\n      None = M.find (attrName dm) cs ->\n      dmn = attrName dm ->\n      Substep (Mod (getRegInits m) (inlineDmToRules (getRules m) dm)\n                   (inlineDmToDms (getDefsBodies m) dm))\n              or u ul cs.\n  Proof.\n    induction 1; intros; simpl in *; try (constructor; auto; fail).\n\n    - apply SingleRule with (a:= attrType (inlineDmToRule (k :: a)%struct dm)); auto.\n      + apply in_map with (f:= fun r => inlineDmToRule r dm) in HInRules; auto.\n      + simpl; destruct dm; apply inlineDm_SemAction_intact; auto.\n\n    - eapply SingleMeth with (f:= inlineDmToDm f dm); eauto.\n      + apply in_map with (f:= fun d => inlineDmToDm d dm) in HIn; auto.\n      + simpl; destruct dm; apply inlineDm_SemAction_intact; auto.\n  Qed.\n\nEnd SubstepFacts.\n\nLemma hideMeths_subtractKVD:\n  forall dmsAll (l: LabelT),\n    hideMeths l dmsAll = {| annot := annot l;\n                            defs := M.subtractKVD signIsEq (defs l) (calls l) dmsAll;\n                            calls := M.subtractKVD signIsEq (calls l) (defs l) dmsAll |}.\nProof.\n  induction dmsAll; intros; destruct l as [ann ds cs]; simpl in *;\n    [do 2 rewrite M.subtractKVD_nil; auto|].\n\n  unfold hideMeth; simpl in *.\n  do 2 rewrite M.subtractKVD_cons.\n  remember (M.find a ds) as odv; destruct odv.\n  - remember (M.find a cs) as ocv; destruct ocv; [|apply IHdmsAll].\n    destruct (signIsEq s s0); [|destruct (signIsEq _ _); intuition; apply IHdmsAll].\n    subst; destruct (signIsEq s0 s0); intuition idtac.\n    rewrite IHdmsAll; simpl in *.\n    clear; f_equal.\n  - destruct (M.find a cs); apply IHdmsAll.\nQed.\n\nLemma hideMeths_hide:\n  forall dmsAll (l: LabelT),\n    M.KeysSubset (defs l) dmsAll ->\n    hideMeths l dmsAll = hide l.\nProof.\n  intros; rewrite hideMeths_subtractKVD.\n  unfold hide; f_equal.\n  - rewrite <-M.subtractKV_subtractKVD_1; auto.\n  - rewrite <-M.subtractKV_subtractKVD_2; auto.\nQed.\n\nLemma inlineDmToMod_getDmsMod:\n  forall m a,\n    getDefs (fst (inlineDmToMod m a)) = getDefs m.\nProof.\n  intros; unfold inlineDmToMod; simpl.\n  destruct (getAttribute _ _); [|auto].\n  simpl.\n\n  clear; induction m; unfold getDefs in *; simpl in *.\n  - clear; induction (pm_methods prim); [auto|].\n    simpl; f_equal; auto.\n  - clear; induction dms; [auto|].\n    simpl; f_equal; auto.\n  - apply inlineDmToDms_names.\nQed.\n\nLemma inlineDm_calls:\n  forall {retK} dm dms,\n    In dm dms ->\n    forall (a: ActionT typeUT retK),\n      SubList (getCallsA (inlineDm a dm))\n              (getCallsA a ++ getCallsM dms).\nProof.\n  induction a; simpl; intros; eauto.\n\n  - unfold getBody.\n    destruct (string_eq _ _).\n    + subst; destruct (SignatureT_dec _ _).\n      * subst; simpl.\n        rewrite getCallsA_appendAction.\n        apply SubList_app_3.\n        { apply SubList_cons_right, SubList_app_2.\n          clear H0; induction dms; [inv H|].\n          simpl; inv H.\n          { apply SubList_app_1, SubList_refl. }\n          { apply SubList_app_2; auto. }\n        }\n        { apply SubList_cons_right; auto. }\n      * simpl; apply SubList_cons; intuition.\n        apply SubList_cons_right; eauto.\n    + simpl; apply SubList_cons; intuition.\n      apply SubList_cons_right; eauto.\n  - apply SubList_app_3.\n    + apply SubList_app_comm.\n      rewrite app_assoc.\n      apply SubList_app_1, SubList_app_comm; eauto.\n    + apply SubList_app_3.\n      * rewrite <-app_assoc.\n        apply SubList_app_comm, SubList_app_1.\n        apply SubList_app_comm.\n        rewrite app_assoc.\n        apply SubList_app_1, SubList_app_comm; eauto.\n      * rewrite <-app_assoc.\n        apply SubList_app_comm, SubList_app_1.\n        rewrite <-app_assoc.\n        apply SubList_app_2; eauto.\n  - apply SubList_nil.\nQed.\n\nLemma inlineDmToRule_calls:\n  forall rules dms dm,\n    In dm dms ->\n    SubList (getCallsR (inlineDmToRules rules dm))\n            (getCallsR rules ++ getCallsM dms).\nProof.\n  induction rules; simpl; intros; [apply SubList_nil|].\n  apply SubList_app_3.\n  - apply SubList_app_comm.\n    rewrite app_assoc.\n    apply SubList_app_1, SubList_app_comm.\n    eapply inlineDm_calls; eauto.\n  - rewrite <-app_assoc.\n    apply SubList_app_2.\n    eapply IHrules; eauto.\nQed.\n\nLemma inlineDmToDms_calls':\n  forall dm dms2 dms1,\n    In dm dms2 ->\n    (forall d : DefMethT,\n       In d dms1 ->\n       SubList (getCallsA (projT2 (attrType (inlineDmToDm d dm))\n                                  typeUT tt))\n               (getCallsA (projT2 (attrType d) typeUT tt)\n                          ++ getCallsM dms2)) ->\n    SubList (getCallsM (inlineDmToDms dms1 dm))\n            (getCallsM dms1 ++ getCallsM dms2).\nProof.\n  induction dms1; simpl; intros; [apply SubList_nil|].\n  apply SubList_app_3.\n  - rewrite <-app_assoc.\n    apply SubList_app_comm.\n    rewrite <-app_assoc.\n    apply SubList_app_2, SubList_app_comm; auto.\n  - rewrite <-app_assoc.\n    apply SubList_app_2.\n    simpl in *; auto.\nQed.\n\nLemma inlineDmToDms_calls:\n  forall dms dm,\n    In dm dms ->\n    SubList (getCallsM (inlineDmToDms dms dm))\n            (getCallsM dms).\nProof.\n  intros.\n  assert (SubList (getCallsM (inlineDmToDms dms dm))\n                  (getCallsM dms ++ getCallsM dms)).\n  { intros; apply inlineDmToDms_calls'; auto; intros.\n    simpl; apply inlineDm_calls; auto.\n  }\n  apply SubList_app_idempotent; auto.\nQed.\n\nLemma inlineDmToMod_calls:\n  forall m a,\n    SubList (getCalls (fst (inlineDmToMod m a)))\n            (getCalls m).\nProof.\n  intros; unfold inlineDmToMod; simpl.\n  remember (getAttribute _ _) as odm; destruct odm;\n  [|apply SubList_refl]; simpl.\n  unfold getCalls; simpl.\n  apply SubList_app_3.\n  - eapply inlineDmToRule_calls; eauto.\n    eapply getAttribute_Some_body; eauto.\n  - apply SubList_app_2.\n    eapply inlineDmToDms_calls; eauto.\n    eapply getAttribute_Some_body; eauto.\nQed.\n\nLemma inlineDmToMod_wellHidden:\n  forall m (l: LabelT) a,\n    wellHidden m l ->\n    wellHidden (fst (inlineDmToMod m a)) l.\nProof.\n  unfold wellHidden; intros.\n  rewrite inlineDmToMod_getDmsMod.\n  dest; split; auto.\n  apply M.KeysDisj_SubList with (d1:= getCalls m); auto.\n  apply inlineDmToMod_calls.\nQed.\n\nLemma inlineDms_wellHidden:\n  forall m (l: LabelT),\n    wellHidden m l ->\n    wellHidden (fst (inlineDms m)) l.\nProof.\n  intros; unfold inlineDms.\n  remember (namesOf (getDefsBodies m)) as dms; clear Heqdms.\n  generalize dependent m; induction dms; intros; [assumption|]; simpl.\n  pose proof (inlineDmToMod_wellHidden a H) as iwh.\n  simpl; remember (inlineDmToMod m a) as imb; destruct imb; simpl in *.\n  pose proof (IHdms _ iwh) as sth.\n  remember (inlineDms' m0 dms) as imb'; destruct imb'; simpl in *.\n  intuition.\nQed.\n\nLemma hideMeths_Substeps_hide:\n  forall m or nr l,\n    SubstepsInd m or nr l ->\n    hideMeths l (namesOf (getDefsBodies m)) = hide l.\nProof.\n  intros; apply hideMeths_hide.\n\n  (* NOTE: better to extract a lemma *)\n  induction H; [apply M.KeysSubset_empty|].\n  subst; destruct l as [ann ds cs].\n  inv H1; dest; simpl in *.\n  destruct ann; destruct sul as [|[|]]; auto; destruct a as [an ab].\n  - apply M.KeysSubset_union; auto.\n    apply M.KeysSubset_add.\n    + apply M.KeysSubset_empty.\n    + pose proof (getDefs_substep H0); auto.\n  - apply M.KeysSubset_union; auto.\n    apply M.KeysSubset_add.\n    + apply M.KeysSubset_empty.\n    + pose proof (getDefs_substep H0); auto.\nQed.\n\nLemma inlineDm_ActionEquiv:\n  forall type1 type2 {retT}\n         (aU: ActionT type1 retT) (aT: ActionT type2 retT) (dm: DefMethT),\n    (forall (argV1: ft1 type1 (SyntaxKind _))\n            (argV2: ft2 type2 (SyntaxKind _)),\n       ActionEquiv (projT2 (attrType dm) type1 argV1) (projT2 (attrType dm) type2 argV2)) ->\n    ActionEquiv aU aT ->\n    ActionEquiv (inlineDm aU dm) (inlineDm aT dm).\nProof.\n  induction 2; intros; try (constructor; auto).\n\n  simpl; remember (getBody n dm s) as dmb; destruct dmb; [|constructor; auto].\n\n  unfold getBody in Heqdmb.\n  remember (string_eq _ _) as seq; destruct seq; [|discriminate].\n  apply string_eq_dec_eq in Heqseq; subst.\n  destruct (SignatureT_dec _ _); [subst|discriminate].\n  inv Heqdmb; simpl.\n\n  constructor; intros.\n  apply actionEquiv_appendAction.\n  + apply H; auto.\n  + intros.\n    apply H1; auto.\nQed.\n\nLemma inlineDmToRules_RulesEquiv:\n  forall {type1 type2} rules (dm: DefMethT),\n    (forall (argV1: ft1 type1 (SyntaxKind _))\n            (argV2: ft2 type2 (SyntaxKind _)),\n       ActionEquiv (projT2 (attrType dm) type1 argV1) (projT2 (attrType dm) type2 argV2)) ->\n    RulesEquiv type1 type2 rules ->\n    RulesEquiv type1 type2 (inlineDmToRules rules dm).\nProof.\n  induction 2; intros; simpl in *; constructor; auto.\n  intros; simpl; apply inlineDm_ActionEquiv; auto.\nQed.\n\nLemma inlineDmToDms_MethsEquiv:\n  forall {type1 type2} dms (dm: DefMethT),\n    (forall (argV1: ft1 type1 (SyntaxKind _))\n            (argV2: ft2 type2 (SyntaxKind _)),\n       ActionEquiv (projT2 (attrType dm) type1 argV1) (projT2 (attrType dm) type2 argV2)) ->\n    MethsEquiv type1 type2 dms ->\n    MethsEquiv type1 type2 (inlineDmToDms dms dm).\nProof.\n  induction 2; intros; unfold MethEquiv in *; simpl in *; constructor; auto.\n  unfold MethEquiv in *.\n  intros; simpl in *; apply inlineDm_ActionEquiv; auto.\nQed.\n\nLemma inlineDmToMod_ModEquiv:\n  forall m dm,\n    ModEquiv type typeUT m ->\n    ModEquiv type typeUT (fst (inlineDmToMod m dm)).\nProof.\n  intros.\n  unfold inlineDmToMod.\n  remember (getAttribute _ _) as oattr; destruct oattr; [|auto].\n  simpl in Heqoattr.\n  apply getAttribute_Some_body in Heqoattr.\n  simpl; inv H.\n  pose proof (proj1 (MethsEquiv_in type typeUT (getDefsBodies m)) H1 _ Heqoattr).\n  constructor.\n  - apply inlineDmToRules_RulesEquiv; auto.\n  - apply inlineDmToDms_MethsEquiv; auto.\nQed.\n\nLemma inlineDms'_ModEquiv:\n  forall dms m,\n    ModEquiv type typeUT m ->\n    ModEquiv type typeUT (fst (inlineDms' m dms)).\nProof.\n  induction dms; simpl; intros; auto.\n  case_eq (inlineDmToMod m a); intros.\n  case_eq (inlineDms' m0 dms); intros; simpl.\n  replace m1 with (fst (inlineDms' m0 dms)) by (rewrite H1; auto).\n  apply IHdms.\n  replace m0 with (fst (inlineDmToMod m a)) by (rewrite H0; auto).\n  apply inlineDmToMod_ModEquiv; auto.\nQed.\n\nLemma inlineDms_ModEquiv:\n  forall m,\n    ModEquiv type typeUT m ->\n    ModEquiv type typeUT (fst (inlineDms m)).\nProof. intros; apply inlineDms'_ModEquiv; auto. Qed.\n\nLemma inline_ModEquiv:\n  forall m,\n    ModEquiv type typeUT m ->\n    ModEquiv type typeUT (fst (inline m)).\nProof. intros; apply inlineDms_ModEquiv; auto. Qed.\n\nLemma inlineDmToMod_dms_names:\n  forall m a,\n    namesOf (getDefsBodies (fst (inlineDmToMod m a))) =\n    namesOf (getDefsBodies m).\nProof.\n  destruct m; intros; simpl in *.\n  - unfold inlineDmToMod.\n    try destruct (getAttribute _ _);\n    try (reflexivity; fail).\n    simpl; clear.\n    induction (pm_methods prim); auto.\n    simpl; f_equal; auto.\n\n  - unfold inlineDmToMod.\n    try destruct (getAttribute _ _);\n    try (reflexivity; fail).\n    simpl; clear.\n    induction dms; auto.\n    simpl; f_equal; auto.\n\n  - unfold inlineDmToMod.\n    try destruct (getAttribute _ _);\n    try reflexivity.\n    apply inlineDmToDms_names.\nQed.\n\nSection SubstepsFacts.\n  Variable m: Modules.\n  Hypotheses (Hequiv: ModEquiv type typeUT m)\n             (Hdefs: NoDup (namesOf (getDefsBodies m))).\n  Variable dm: DefMethT.\n  Hypotheses (Hdm: In dm (getDefsBodies m)).\n\n  Lemma inlineDmToMod_Substeps_intact:\n    forall or u l,\n      SubstepsInd m or u l ->\n      forall ann ds cs,\n        l = {| annot := ann; defs := ds; calls := cs |} ->\n        None = M.find (attrName dm) cs ->\n        SubstepsInd\n          (Mod (getRegInits m) (inlineDmToRules (getRules m) dm)\n               (inlineDmToDms (getDefsBodies m) dm)) or u l.\n  Proof.\n    induction 1; simpl; intros; [constructor|].\n\n    subst; destruct l as [pann pds pcs].\n    eapply SubstepsCons; eauto.\n    - eapply IHSubstepsInd.\n      + reflexivity.\n      + inv H4.\n        rewrite M.find_union in H5.\n        destruct (M.find (attrName dm) pcs); auto.\n        destruct (M.find (attrName dm) scs); inv H5.\n    - eapply inlineDmToMod_Substep_intact; eauto.\n      inv H4.\n      rewrite M.find_union in H5.\n      destruct (M.find (attrName dm) scs); auto.\n  Qed.\n\n  Lemma inlineDmToMod_correct_Substeps_called_rule:\n    forall or su sr scs u l s,\n      Substep m or su (Rle sr) scs ->\n      SubstepsInd m or u l ->\n      forall ds cs,\n        l = {| annot := None; defs := ds; calls := cs |} ->\n        Some s = M.find (attrName dm) scs ->\n        Some s = M.find (attrName dm) ds ->\n        M.Disj su u ->\n        M.Disj scs cs ->\n        SubstepsInd\n          (Mod (getRegInits m) (inlineDmToRules (getRules m) dm)\n               (inlineDmToDms (getDefsBodies m) dm)) or (M.union u su)\n          {| annot := Some sr;\n             defs := M.remove (attrName dm) (M.union (M.empty (sigT SignT)) ds);\n             calls := M.remove (attrName dm) (M.union scs cs) |}.\n  Proof.\n    induction 2; simpl; intros; [inv H0; mcontra|].\n    destruct l as [pann pds pcs]; simpl in *; subst.\n    assert (pann = None); subst.\n    { destruct pann; [destruct sul; discriminate|reflexivity]. }\n\n    destruct sul as [psr|[[pdmn pdmv]|]]; inv H5.\n\n    - M.cmp (attrName dm) pdmn; mred.\n      + inv H2; dest; simpl in *.\n        eapply SubstepsCons.\n        * eapply inlineDmToMod_Substeps_intact; eauto; findeq.\n        * inv H1; inv Hsig.\n          assert (f = dm) by (eapply in_NoDup_attr; eauto); subst.\n          eapply inlineDmToMod_correct_Substep; eauto.\n        * repeat split; simpl; auto.\n        * auto.\n        * simpl; f_equal; auto.\n      + eapply SubstepsCons.\n        * eapply IHSubstepsInd; eauto.\n        * eapply inlineDmToMod_Substep_intact; eauto; findeq.\n        * inv H2; dest; simpl in *.\n          repeat split; simpl; auto.\n          findeq.\n        * auto.\n        * simpl; f_equal; auto.\n      \n    - eapply SubstepsCons.\n      + apply IHSubstepsInd; eauto.\n      + eapply inlineDmToMod_Substep_intact; eauto; findeq.\n      + inv H2; dest; simpl in *.\n        repeat split; simpl; auto.\n      + auto.\n      + simpl; f_equal; auto.\n  Qed.\n\n  Lemma inlineDmToMod_correct_Substeps_called_meth:\n    forall or su smn smv scs u l,\n      Substep m or su (Meth (Some (smn :: smv)%struct)) scs ->\n      SubstepsInd m or u l ->\n      forall ann ds cs s,\n        l = {| annot := ann; defs := ds; calls := cs |} ->\n        Some s = M.find (attrName dm) scs ->\n        Some s = M.find (attrName dm) ds ->\n        M.Disj su u ->\n        M.Disj scs cs ->\n        ~ M.In smn ds ->\n        SubstepsInd\n          (Mod (getRegInits m) (inlineDmToRules (getRules m) dm)\n               (inlineDmToDms (getDefsBodies m) dm)) or (M.union u su)\n          {|\n            annot := ann;\n            defs := M.remove (attrName dm) (M.union (M.add smn smv (M.empty (sigT SignT))) ds);\n            calls := M.remove (attrName dm) (M.union scs cs) |}.",
      "suffix": "\n\n  Lemma inlineDmToMod_correct_Substeps_calling:\n    forall or su scs u l sdmv,\n      Substep m or su (Meth (Some ((attrName dm) :: sdmv)%struct)) scs ->\n      SubstepsInd m or u l ->\n      forall ann ds cs,\n        l = {| annot := ann; defs := ds; calls := cs |} ->\n        M.Disj su u ->\n        M.Disj scs cs ->\n        Some sdmv = M.Map.find (elt:=sigT SignT) (attrName dm) cs ->\n        ~ M.In (attrName dm) ds ->\n        SubstepsInd\n          (Mod (getRegInits m) (inlineDmToRules (getRules m) dm)\n               (inlineDmToDms (getDefsBodies m) dm)) or (M.union u su)\n          {| annot := ann;\n             defs := M.remove (elt:=sigT SignT) (attrName dm)\n                              (M.union (M.add (attrName dm) sdmv (M.empty (sigT SignT))) ds);\n             calls := M.remove (elt:=sigT SignT) (attrName dm) (M.union scs cs) |}.\n  Proof.\n    induction 2; simpl; intros; [inv H0; mcontra|].\n    subst; destruct l as [pann pds pcs].\n    inv H5; mred.\n    remember (M.find (attrName dm) scs0) as osdm; destruct osdm.\n\n    - inv H8; inv H2; dest; simpl in *.\n      eapply SubstepsCons.\n      + eapply inlineDmToMod_Substeps_intact; eauto; findeq.\n      + inv H; inv Hsig.\n        assert (f = dm) by (eapply in_NoDup_attr; eauto); subst.\n        eapply inlineDmToMod_correct_Substep; eauto.\n      + repeat split; simpl; auto.\n      + auto.\n      + simpl; f_equal; auto.\n        destruct sul as [|[[? ?]|]]; auto.\n\n    - inv H2; dest; simpl in *.\n      eapply SubstepsCons.\n      + apply IHSubstepsInd; auto.\n        destruct sul as [|[[pdmn pdmv]|]]; findeq.\n      + eapply inlineDmToMod_Substep_intact; eauto.\n      + repeat split; simpl; auto.\n        destruct pann; destruct sul as [|[[pdmn pdmv]|]]; auto;\n          findeq; auto.\n      + auto.\n      + simpl; f_equal; auto.\n        destruct sul as [|[[pdmn pdmv]|]]; auto.\n  Qed.\n\nEnd SubstepsFacts.\n\nLemma inlineDmToMod_correct_Substeps:\n  forall m (Hequiv: ModEquiv type typeUT m)\n         or nr l dm,\n    NoDup (namesOf (getDefsBodies m)) ->\n    SubstepsInd m or nr l ->\n    M.find dm (calls l) = None \\/ M.find dm (defs l) = M.find dm (calls l) ->\n    snd (inlineDmToMod m dm) = true ->\n    SubstepsInd (fst (inlineDmToMod m dm)) or nr (hideMeth l dm).\nProof.\n  induction 3; intros; [constructor|].\n\n  subst; unfold inlineDmToMod in *.\n  remember (getAttribute _ _) as odm; destruct odm; [|inv H6].\n  remember (noCallDm _ _) as onc; destruct onc; [|inv H6].\n  destruct l as [ann ds cs]; simpl in *.\n\n  pose proof (getAttribute_Some_name _ _ Heqodm); subst.\n  apply getAttribute_Some_body in Heqodm.\n  inv H2; dest; simpl in *.\n\n  unfold hideMeth in *; simpl in *.\n\n  (* inline target called? *)\n  remember (M.find (attrName a) (M.union scs cs)) as ocmv; destruct ocmv.\n\n  - destruct H5; [discriminate|].\n    rewrite H5 in *; mred.\n\n    (* by Substep? *)\n    remember (M.find (attrName a) scs) as oscmv; destruct oscmv.\n    + inv Heqocmv.\n      assert (None = M.find (attrName a) cs) by findeq.\n      rewrite <-H7 in IHSubstepsInd.\n      destruct (signIsEq s0 s0); [clear e|elim n; auto].\n      specialize (IHSubstepsInd (or_introl eq_refl) eq_refl).\n\n      destruct sul as [sr|[[sdmn sdmv]|]].\n\n      * mred.\n        rewrite H5 in IHSubstepsInd.\n        destruct ann; [intuition idtac|].\n        eapply inlineDmToMod_correct_Substeps_called_rule; eauto.\n      * M.cmp (attrName a) sdmn.\n        { (* Substep(head)-inlined: impossible *)\n          mred; exfalso.\n          inv H1; inv Hsig.\n          assert (f = a) by (apply in_NoDup_attr with (attrs:= getDefsBodies m); auto);\n            subst.\n          assert (M.find (attrName a) scs = None).\n          { eapply noCallDm_SemAction_calls; eauto.\n            eapply MethsEquiv_in; eauto.\n            inv Hequiv; auto.\n          }\n          rewrite H1 in Heqoscmv; discriminate.\n        }\n        { mred.\n          rewrite H5 in IHSubstepsInd.\n          assert (~ M.In sdmn ds)\n            by (destruct ann; auto).\n          eapply inlineDmToMod_correct_Substeps_called_meth; eauto.\n        }\n      * exfalso; inv H1; mred.\n\n    + rewrite <-Heqocmv in IHSubstepsInd.\n      match goal with\n        | [H: match (M.find ?a ?lm) with | Some _ => _ | None => _ end = Some _ |- _] =>\n          remember (M.find a lm) as odmv; destruct odmv\n      end.\n\n      * inv H5; destruct (signIsEq s s); [clear e|elim n; auto].\n        destruct sul as [sr|[[sdmn sdmv]|]].\n        { mred; mcontra. }\n        { M.cmp (attrName a) sdmn; [|mred; mcontra].\n          mred.\n          assert (~ M.In (attrName a) ds)\n            by (destruct ann; auto).\n          eapply inlineDmToMod_correct_Substeps_calling; eauto.\n        }\n        { mred; mcontra. }\n\n      * rewrite H5 in IHSubstepsInd.\n        destruct (signIsEq s s); [clear e|elim n; auto].\n\n        eapply SubstepsCons; eauto.\n        { eapply inlineDmToMod_Substep_intact; eauto. }\n        { repeat split; simpl; auto.\n          destruct ann; destruct sul as [|[|]]; auto;\n          intro Hx; elim H4; eapply M.F.P.F.remove_in_iff; eauto.\n        }\n        { simpl; f_equal; auto. }\n\n  - rewrite M.find_union in Heqocmv.\n    remember (M.find (attrName a) scs) as oscmv; destruct oscmv; [inv Heqocmv|].\n    rewrite <-Heqocmv in IHSubstepsInd.\n    match goal with\n      | [ |- SubstepsInd _ _ _ ?ll] =>\n        match ll with\n          | (match ?c with Some _ => ?l | None => ?l end) =>\n            replace ll with l by (destruct c; reflexivity)\n        end\n    end.\n\n    eapply SubstepsCons; eauto.\n    + eapply inlineDmToMod_Substep_intact; eauto.\n    + destruct (M.find (attrName a) ds); repeat split; simpl; auto.\n    + destruct (M.find (attrName a) ds); reflexivity.\nQed.\n\nLemma inlineDms'_correct_Substeps:\n  forall cdms m (Hequiv: ModEquiv type typeUT m)\n         (Hdms: NoDup (namesOf (getDefsBodies m)))\n         (Hcdms: SubList cdms (namesOf (getDefsBodies m)))\n         or nr l,\n    SubstepsInd m or nr l ->\n    wellHidden m (hide l) ->\n    snd (inlineDms' m cdms) = true ->\n    SubstepsInd (fst (inlineDms' m cdms)) or nr (hideMeths l cdms).\nProof.\n  induction cdms; intros; simpl; [apply flatten_preserves_substepsInd; auto|].\n  apply SubList_cons_inv in Hcdms; dest.\n  remember (inlineDmToMod m a) as imb; destruct imb as [im ib]; simpl.\n  remember (inlineDms' im cdms) as imc; destruct imc as [im' ib']; simpl.\n  destruct ib; simpl in *.\n  - assert (im' = fst (inlineDms' im cdms)) by (rewrite <- Heqimc; reflexivity); subst; simpl in *.\n    assert (im = fst (inlineDmToMod m a)) by (rewrite <-Heqimb; reflexivity); subst; simpl in *.\n    apply IHcdms; auto.\n    + apply inlineDmToMod_ModEquiv; auto.\n    + rewrite inlineDmToMod_dms_names; auto.\n    + rewrite inlineDmToMod_dms_names; auto.\n    + apply inlineDmToMod_correct_Substeps; auto.\n      * eapply wellHidden_find_1; eauto.\n      * simpl in H0; destruct (inlineDmToMod m a); simpl in *.\n        destruct b; [auto|inv Heqimb].\n    + apply inlineDmToMod_wellHidden.\n      rewrite hideMeth_preserves_hide; auto.\n    + simpl in H1; destruct (inlineDmToMod m a); simpl in *.\n      destruct (inlineDms' m0 cdms); simpl in *.\n      destruct b; [auto|inv Heqimb].\n  - destruct (inlineDmToMod m a).\n    destruct (inlineDms' m0 cdms); simpl in *.\n    inversion Heqimb; subst.\n    simpl in *.\n    discriminate.\nQed.\n\nLemma inlineDms_correct_SubstepsInd:\n  forall m (Hequiv: ModEquiv type typeUT m)\n         (Hdms: NoDup (namesOf (getDefsBodies m))) or u l,\n    SubstepsInd m or u l ->\n    snd (inlineDms m) = true ->\n    wellHidden m (hide l) ->\n    SubstepsInd (fst (inlineDms m)) or u (hide l).\nProof.\n  intros.\n  erewrite <-hideMeths_Substeps_hide; eauto.\n  apply inlineDms'_correct_Substeps; auto.\n  apply SubList_refl.\nQed.\n\nLemma inlineDms_correct:\n  forall m (Hequiv: ModEquiv type typeUT m)\n         (Hdms: NoDup (namesOf (getDefsBodies m)))\n         (Hin: snd (inlineDms m) = true)\n         or nr l,\n    StepInd m or nr l ->\n    StepInd (fst (inlineDms m)) or nr l.\nProof.\n  intros; inv H.\n  rewrite hide_idempotent.\n  constructor.\n  - apply inlineDms_correct_SubstepsInd; auto.\n  - rewrite <-hide_idempotent.\n    apply inlineDms_wellHidden; auto.\nQed.\n\nLemma step_dms_hidden:\n  forall m or nr l,\n    Step m or nr l ->\n    M.KeysDisj (defs l) (getCalls m).\nProof.\n  intros; inv H.\n  unfold wellHidden in HWellHidden.\n  destruct (hide _); simpl in *; intuition.\nQed.\n\nLemma inline_correct_Step:\n  forall m (Hequiv: ModEquiv type typeUT m)\n         (Hdms: NoDup (namesOf (getDefsBodies m)))\n         (Hin: snd (inline m) = true)\n         or nr l,\n    Step m or nr l ->\n    Step (fst (inline m)) or nr l.\nProof.\n  intros; unfold inline.\n  apply step_consistent; apply step_consistent in H.\n  apply inlineDms_correct; auto.\nQed.\n\nLemma inlineF_correct_Step:\n  forall m (Hequiv: ModEquiv type typeUT m)\n         (Hdms: NoDup (namesOf (getDefsBodies m)))\n         (Hin: snd (inlineF m) = true)\n         or nr l,\n    Step m or nr l ->\n    Step (fst (inlineF m)) or nr l.\nProof.\n  unfold inlineF; intros.\n  remember (inline m) as imb; destruct imb as [im ib]; subst.\n  simpl; remember (noInternalCalls im) as imc.\n  destruct imc; [|inv Hin].\n  assert (Hit: snd (inline m) = true)\n    by (rewrite <-Heqimb; inv Hin; auto).\n  pose proof (inline_correct_Step Hequiv Hdms Hit H).\n  rewrite <-Heqimb in H0; simpl in H0.\n  pose proof (step_dms_hidden H).\n  apply step_dms_weakening; auto.\n  - replace im with (fst (inline m)) by (rewrite <-Heqimb; auto).\n    apply inline_ModEquiv; auto.\n  - apply noInternalCalls_implies_disj; auto.\n  - apply flatten_preserves_step; auto.\nQed.\n  \nLemma inlineDms'_preserves_regInits:\n  forall dms m, getRegInits m = getRegInits (fst (inlineDms' m dms)).\nProof.\n  induction dms; [reflexivity|].\n  intros; simpl; remember (inlineDmToMod m a) as ima; destruct ima.\n  remember (inlineDms' m0 dms) as imb; destruct imb; simpl in *.\n  specialize (IHdms m0).\n  destruct (inlineDms' m0 dms).\n  simpl in *.\n  inv Heqimb.\n  unfold inlineDmToMod in *.\n  destruct (getAttribute _ _);\n  inv Heqima; simpl in *; intuition.\nQed.\n\nLemma inline_preserves_regInits:\n  forall m, getRegInits m = getRegInits (fst (inline m)).\nProof. intros; apply inlineDms'_preserves_regInits. Qed.\n\nLemma inlineF_preserves_regInits:\n  forall m, getRegInits m = getRegInits (fst (inlineF m)).\nProof.\n  intros; unfold inlineF.\n  remember (inline m) as imb; destruct imb as [im ib]; simpl.\n  replace im with (fst (inline m)) by (rewrite <-Heqimb; auto).\n  apply inlineDms'_preserves_regInits.\nQed.\n\nTheorem inline_refines:\n  forall m (Hequiv: ModEquiv type typeUT m)\n         (Hdms: NoDup (namesOf (getDefsBodies m)))\n         (Hin: snd (inline m) = true),\n    traceRefines id m (fst (inline m)).\nProof.\n  intros.\n  apply stepRefinement with (ruleMap:= fun o r => Some r) (theta:= id).\n  - erewrite inlineDms'_preserves_regInits; reflexivity.\n  - intros.\n    apply inline_correct_Step in H0; unfold id in *; auto.\n    exists u; split; auto.\n    destruct l as [ann ds cs]; simpl in *.\n    destruct ann as [[|]|]; auto.\nQed.\n\nTheorem inlineF_refines:\n  forall m (Hequiv: ModEquiv type typeUT m)\n         (Hdms: NoDup (namesOf (getDefsBodies m))),\n    let im := inlineF m in\n    snd im = true -> traceRefines id m (fst im).\nProof.\n  intros.\n  apply stepRefinement with (ruleMap:= fun o r => Some r) (theta:= id).\n  - rewrite inlineF_preserves_regInits; reflexivity.\n  - intros; eapply inlineF_correct_Step in H; unfold id in *; eauto.\n    destruct l as [ann ds cs]; simpl in *.\n    destruct ann as [[|]|]; auto.\nQed.\n\n(** Interface lemmas and ltacs *)\nLemma traceRefines_inlining_left:\n  forall ma\n         (Hequiv: ModEquiv type typeUT ma)\n         (Hdup: NoDup (namesOf (getDefsBodies ma)))\n         mb p,\n    traceRefines p (fst (inlineF ma)) mb /\\ snd (inlineF ma) = true ->\n    traceRefines p ma mb.\nProof.\n  intros; dest; apply traceRefines_trans with (mb:= fst (inlineF ma)).\n  - apply inlineF_refines; auto.\n  - auto.\nQed.\n\n\n(** Now for fine-grained partial inlining *)\nSection NoCallDmSig.\n  Fixpoint noCallDmSigA {retT} (a: ActionT typeUT retT) (dmn: string) (dsig: SignatureT) :=\n    match a with\n    | MCall name sig _ cont =>\n      ((negb (string_eq name dmn))\n       || (if SignatureT_dec sig dsig then false else true))\n        && (noCallDmSigA (cont tt) dmn dsig)\n    | Let_ _ ar cont => noCallDmSigA (cont (getUT _)) dmn dsig\n    | ReadNondet k cont => noCallDmSigA (cont (getUT _)) dmn dsig\n    | ReadReg reg k cont => noCallDmSigA (cont (getUT _)) dmn dsig\n    | WriteReg reg _ e cont => noCallDmSigA cont dmn dsig\n    | IfElse ce _ ta fa cont =>\n      (noCallDmSigA ta dmn dsig) && (noCallDmSigA fa dmn dsig) && (noCallDmSigA (cont tt) dmn dsig)\n    | Assert_ ae cont => noCallDmSigA cont dmn dsig\n    | Displ ls cont => noCallDmSigA cont dmn dsig\n    | Return e => true\n    end.\n\n  Definition noCallDmSigDms (dms: list DefMethT) (ndm: DefMethT) :=\n    Forall (fun dm: DefMethT =>\n              noCallDmSigA (projT2 (attrType dm) typeUT tt) (attrName ndm)\n                           (projT1 (attrType ndm)) = true) dms.\n\n  Definition noCallDmSigRules (rules: list (Attribute (Action Void))) (ndm: DefMethT) :=\n    Forall (fun r: Attribute (Action Void) =>\n              noCallDmSigA (attrType r typeUT) (attrName ndm)\n                           (projT1 (attrType ndm)) = true) rules.\n\n  Definition noCallDmSig (m: Modules) (ndm: DefMethT) :=\n    (noCallDmSigRules (getRules m) ndm) /\\ (noCallDmSigDms (getDefsBodies m) ndm).\n\nEnd NoCallDmSig.\n\nLemma noCallDmSigA_semAction_calls:\n  forall {retK} (aty: ActionT type retK) aut (Hequiv: ActionEquiv aty aut)\n         (dm: DefMethT),\n    noCallDmSigA aut (attrName dm) (projT1 (attrType dm)) = true ->\n    forall s o u cs retv,\n      SemAction o aty u cs retv ->\n      Some s = M.find (attrName dm) cs ->\n      projT1 s = projT1 (attrType dm) ->\n      False.\nProof.\n  induction 1; simpl; intros; auto.\n\n  - inv H2; destruct_existT.\n    apply andb_true_iff in H1; dest.\n    remember (string_eq n (attrName dm)) as ndeq; destruct ndeq.\n    + apply string_eq_dec_eq in Heqndeq; subst; mred.\n    + apply string_eq_dec_neq in Heqndeq.\n      rewrite M.find_add_2 in H3 by intuition.\n      eapply H0; eauto.\n\n  - inv H2; destruct_existT; eapply H0; eauto.\n  - inv H2; destruct_existT; eapply H0; eauto.\n  - inv H2; destruct_existT; eapply H0; eauto.\n  - inv H0; destruct_existT; eapply IHHequiv; eauto.\n  - apply andb_true_iff in H1; dest.\n    apply andb_true_iff in H1; dest.\n    inv H2; destruct_existT.\n    + rewrite M.find_union in H3.\n      remember (M.find (attrName dm) calls1) as odc1; destruct odc1.\n      * inv H3; eapply IHHequiv1; eauto.\n      * eapply H0; eauto.\n    + rewrite M.find_union in H3.\n      remember (M.find (attrName dm) calls1) as odc1; destruct odc1.\n      * inv H3; eapply IHHequiv2; eauto.\n      * eapply H0; eauto.\n  - inv H0; destruct_existT; eapply IHHequiv; eauto.\n  - inv H0; destruct_existT; mred.\nQed.\n\nLemma appendAction_noCallDmSigA:\n  forall {retK1 retK2} (a1: ActionT typeUT retK1)\n         (a2: typeUT retK1 -> ActionT typeUT retK2) dmn dsig,\n    noCallDmSigA (appendAction a1 a2) dmn dsig =\n    noCallDmSigA a1 dmn dsig && noCallDmSigA (a2 tt) dmn dsig.\nProof.\n  induction a1; simpl; intros; auto.\n  - rewrite <-andb_assoc; f_equal; auto.\n  - do 3 rewrite <-andb_assoc; repeat f_equal; auto.\nQed.\n\nLemma noCallDm_noCallDmSigA:\n  forall tdm dm,\n    noCallDm tdm dm = true ->\n    noCallDmSigA (projT2 (attrType tdm) typeUT tt)\n                 (attrName dm) (projT1 (attrType dm)) = true.\nProof.\n  unfold noCallDm; intros.\n  generalize dependent (projT2 (attrType tdm) typeUT tt).\n  clear; intros.\n  induction a; simpl; intros; auto; simpl in *.\n  - apply andb_true_iff in H; dest.\n    apply andb_true_iff; split; auto.\n    remember (string_eq meth (attrName dm)) as md; destruct md.\n    + apply string_eq_dec_eq in Heqmd; subst.\n      exfalso; rewrite string_eq_true in H.\n      inv H.\n    + auto.\n  - apply andb_true_iff in H; dest.\n    apply andb_true_iff in H; dest.\n    auto 9 using andb_true_iff.\nQed.\n\nLemma noCalls_noCallDmSigATrue:\n  forall k (a: ActionT typeUT k) dmName dmBody,\n    ~ In dmName (getCallsA a) -> noCallDmSigA a dmName dmBody = true.\nProof.\n  induction a; simpl in *; auto; intros.\n  - assert (sth1: meth <> dmName) by intuition auto.\n    assert (sth2: ~ In dmName (getCallsA (a tt))) by intuition auto.\n    unfold negb, orb, andb.\n    case_eq (string_eq meth dmName); intros.\n    + apply eq_sym in H1; apply string_eq_dec_eq in H1; subst; intuition.\n    + apply H; auto.\n  - rewrite IHa1, IHa2, H; auto; unfold not; intros.\n    + assert (In dmName (getCallsA a1 ++ getCallsA a2 ++ getCallsA (a3 tt)))\n        by (apply in_or_app; right; apply in_or_app; right; intuition auto).\n      auto.\n    + assert (In dmName (getCallsA a1 ++ getCallsA a2 ++ getCallsA (a3 tt)))\n        by (apply in_or_app; right; apply in_or_app; left; intuition auto).\n      auto.\n    + assert (In dmName (getCallsA a1 ++ getCallsA a2 ++ getCallsA (a3 tt)))\n        by (apply in_or_app; left; intuition auto).\n      auto.\nQed.\n\nLemma inlineDm_noCallDmSigA:\n  forall (dm: DefMethT)\n         (Hdm: noCallDmSigA (projT2 (attrType dm) typeUT tt)\n                            (attrName dm) (projT1 (attrType dm)) = true)\n         {retK} (a: ActionT typeUT retK),\n    noCallDmSigA (inlineDm a dm) (attrName dm) (projT1 (attrType dm)) = true.\nProof.\n  induction a; simpl; intros; auto;\n    (try solve [do 2 (apply andb_true_iff; split; auto)]); [ ].\n\n  unfold getBody.\n  remember (string_eq meth (attrName dm)) as md; destruct md;\n    [|simpl; rewrite <-Heqmd; simpl; auto].\n  destruct (SignatureT_dec _ _).\n  - simpl; rewrite appendAction_noCallDmSigA.\n    apply andb_true_iff; split; auto.\n    subst; simpl.\n    assumption.\n  - simpl; rewrite <-Heqmd; simpl.\n    destruct (SignatureT_dec _ _); [elim n; auto|].\n    simpl; auto.\nQed.\n\nLemma inlineDmToRule_noCallDmSigA:\n  forall (dm: DefMethT)\n         (Hdm: noCallDmSigA (projT2 (attrType dm) typeUT tt)\n                            (attrName dm) (projT1 (attrType dm)) = true) r,\n    noCallDmSigA (attrType (inlineDmToRule r dm) typeUT)\n                 (attrName dm) (projT1 (attrType dm)) = true.\nProof.\n  intros; apply inlineDm_noCallDmSigA; auto.\nQed.\n\nLemma noCallDmSig_substep_calls:\n  forall m o u ul cs,\n    ModEquiv type typeUT m ->\n    Substep m o u ul cs ->\n    forall dm s,\n      noCallDmSig m dm ->\n      Some s = M.find (elt:=sigT SignT) (attrName dm) cs ->\n      projT1 s = projT1 (attrType dm) ->\n      False.\nProof.\n  intros; inv H0; try (mred; fail).\n\n  - inv H; rewrite RulesEquiv_in in H0.\n    specialize (H0 _ HInRules); unfold RuleEquiv in H0; simpl in H0.\n    unfold noCallDmSig in H1; dest.\n    unfold noCallDmSigRules in H; rewrite Forall_forall in H.\n    specialize (H _ HInRules); simpl in H.\n    eapply noCallDmSigA_semAction_calls; eauto.\n\n  - inv H; rewrite MethsEquiv_in in H4.\n    specialize (H4 _ HIn); unfold MethEquiv in H4; simpl in H4.\n    unfold noCallDmSig in H1; dest.\n    unfold noCallDmSigDms in H1; rewrite Forall_forall in H1.\n    specialize (H1 _ HIn); simpl in H1.\n    eapply noCallDmSigA_semAction_calls; eauto.\nQed.\n\nLemma noCallDmSig_substepsInd_calls:\n  forall m o u l,\n    ModEquiv type typeUT m ->\n    SubstepsInd m o u l ->\n    forall dm s,\n      noCallDmSig m dm ->\n      Some s = M.find (elt:=sigT SignT) (attrName dm) (calls l) ->\n      projT1 s = projT1 (attrType dm) ->\n      False.\nProof.\n  induction 2; simpl; intros; [mred|].\n  subst; destruct l as [ann ds cs]; simpl in *.\n  rewrite M.find_union in H6.\n  remember (M.find (attrName dm) scs) as odsc; destruct odsc.\n  - inv H6; apply noCallDmSig_substep_calls with (dm:= dm) (s:= s0) in H1; auto.\n  - eapply IHSubstepsInd; eauto.\nQed.\n\nLemma stepInd_filterDm:\n  forall regs rules dms o u l,\n    ModEquiv type typeUT (Mod regs rules dms) ->\n    NoDup (getDefs (Mod regs rules dms)) ->\n    StepInd (Mod regs rules dms) o u l ->\n    forall (dm: DefMethT),\n      In dm dms ->\n      M.find (attrName dm) (defs l) = None ->\n      noCallDmSig (Mod regs rules dms) dm ->\n      StepInd (Mod regs rules (filterDm dms (attrName dm))) o u l.\nProof.\n  intros; inv H1; constructor; [|apply filterDm_wellHidden; auto].\n\n  remember (M.find (attrName dm) (defs l0)) as odl; destruct odl.\n\n  - pose proof (substepsInd_defs_sig _ H0 H2 HSubSteps Heqodl).\n    remember (M.find (attrName dm) (calls l0)) as ocl; destruct ocl.\n\n    + assert (s = s0); subst.\n      { clear -H3 Heqodl Heqocl.\n        destruct l0 as [ann ds cs]; simpl in *.\n        findeq.\n      }\n      exfalso; eapply noCallDmSig_substepsInd_calls; eauto.\n\n    + exfalso; clear -H3 Heqodl Heqocl.\n      destruct l0 as [ann ds cs]; simpl in *.\n      findeq.\n\n  - assert (None = M.find (attrName dm) (calls l0)).\n    { apply wellHidden_find_1 with (a:= attrName dm) in HWellHidden.\n      { destruct HWellHidden; auto.\n        rewrite Heqodl; auto.\n      }\n      { simpl; apply in_map; auto. }\n    }\n    apply substepsInd_dm_weakening; auto.\nQed.\n\n(* Partial inlining interfaces *)\nSection Partial.\n  Variable m: Modules.\n\n  Variable dm: DefMethT. (* a method to be inlined *)\n  Hypotheses (Hdm: In dm (getDefsBodies m))\n             (HnoDupMeths: NoDup (namesOf (getDefsBodies m))).\n  Variable r: Attribute (Action Void). (* a rule calling dm *)\n  Hypothesis Hrule: In r (getRules m).\n\n  Lemma inlineDmToRule_substepsInd_intact_1:\n    forall o u l,\n      SubstepsInd m o u l ->\n      ~ (annot l = Some (Some (attrName r)) /\\ M.find (attrName dm) (calls l) <> None) ->\n      SubstepsInd\n        (Mod (getRegInits m)\n             (map\n                (fun newr =>\n                   if string_dec (attrName r) (attrName newr)\n                   then inlineDmToRule newr dm\n                   else newr) (getRules m)) (getDefsBodies m)) o u l.\n  Proof.\n    induction 1; intros; [constructor|].\n    subst; econstructor.\n\n    - apply IHSubstepsInd.\n      intro Hx; elim H4; clear H4; dest; split.\n      + clear -H1 H2.\n        inv H1; dest.\n        destruct l as [ann ds cs], sul as [|];\n          simpl in *; subst; intuition idtac.\n      + intro Hx; elim H3; clear H3.\n        destruct l as [ann ds cs]; simpl in *; findeq.\n\n    - instantiate (1:= scs); instantiate (1:= sul); instantiate (1:= su).\n      clear -H0 H4.\n      inv H0; try constructor.\n\n      + destruct (string_dec (attrName r) k); subst.\n        * remember (M.find (attrName dm) scs) as ods; destruct ods.\n          { elim H4; clear H4; split.\n            { destruct l as [ann ds cs]; simpl; destruct ann; reflexivity. }\n            { destruct l as [ann ds cs]; simpl.\n              rewrite M.find_union, <-Heqods; discriminate.\n            }\n          }\n          { econstructor.\n            { simpl.\n              apply in_map with (f:= fun newr =>\n                                       if string_dec (attrName r) (attrName newr)\n                                       then inlineDmToRule newr dm\n                                       else newr) in HInRules.\n              simpl in HInRules.\n              destruct (string_dec (attrName r) (attrName r)); [clear e|elim n; reflexivity].\n              eauto.\n            }\n            { simpl; destruct dm as [dmn dmb].\n              apply inlineDm_SemAction_intact; auto.\n            }\n          }\n        * econstructor.\n          { simpl.\n            apply in_map with (f:= fun newr =>\n                                     if string_dec (attrName r) (attrName newr)\n                                     then inlineDmToRule newr dm\n                                     else newr) in HInRules.\n            simpl in HInRules.\n            destruct (string_dec (attrName r) k); [elim n; auto|].\n            eauto.\n          }\n          { auto. }\n\n      + econstructor; eauto.\n\n    - auto.\n    - auto.\n    - auto.\n\n  Qed.\n\n  Lemma inlineDmToRule_substepsInd_intact_2:\n    forall o pu pds pcs,\n      SubstepsInd m o pu {| annot := None; defs := pds; calls := pcs |} ->\n      forall ru rcs,\n        Substep m o ru (Rle (Some (attrName r))) rcs ->\n        None = M.find (elt:=sigT SignT) (attrName dm) rcs ->\n        (* Some s = M.find (elt:=sigT SignT) (attrName dm) pcs -> *)\n        M.Disj ru pu -> M.Disj rcs pcs ->\n        SubstepsInd\n          (Mod (getRegInits m)\n               (map\n                  (fun newr =>\n                     if string_dec (attrName r) (attrName newr)\n                     then inlineDmToRule newr dm else newr)\n                  (getRules m)) (getDefsBodies m)) o (M.union pu ru)\n          {| annot := Some (Some (attrName r)); defs := pds; calls := M.union rcs pcs |}.\n  Proof.\n    intros; econstructor.\n\n    - apply inlineDmToRule_substepsInd_intact_1.\n      + eassumption.\n      + simpl; intro Hx; dest; discriminate.\n\n    - instantiate (1:= rcs).\n      instantiate (1:= Rle (Some (attrName r))).\n      instantiate (1:= ru).\n      inv H0.\n\n      econstructor.\n      + simpl.\n        apply in_map with (f:= fun newr =>\n                                 if string_dec (attrName r) (attrName newr)\n                                 then inlineDmToRule newr dm\n                                 else newr) in HInRules.\n        simpl in HInRules.\n        destruct (string_dec (attrName r) (attrName r)); [clear e|elim n; reflexivity].\n        eauto.\n      + simpl; destruct dm as [dmn dmb].\n        apply inlineDm_SemAction_intact; auto.\n\n    - repeat split; auto.\n    - reflexivity.\n    - reflexivity.\n\n  Qed.\n\n  Lemma inlineDmToRule_substepsInd_sub:\n    forall o u su scs s l,\n      Substep m o su (Rle (Some (attrName r))) scs ->\n      M.find (elt:=sigT SignT) (attrName dm) scs = Some s ->\n      SubstepsInd m o u l ->\n      forall ds cs,\n        l = {| annot := None; defs:= ds; calls := cs |} ->\n        M.Disj su u -> M.Disj scs cs ->\n        M.find (elt:=sigT SignT) (attrName dm) ds = Some s ->\n        SubstepsInd\n          (Mod (getRegInits m)\n               (map\n                  (fun newr =>\n                     if string_dec (attrName r) (attrName newr)\n                     then inlineDmToRule newr dm else newr)\n                  (getRules m)) (getDefsBodies m)) o (M.union u su)\n          (hideMeth \n             {| annot := Some (Some (attrName r));\n                defs := ds;\n                calls := M.union scs cs |} (attrName dm)).\n  Proof.\n    induction 3; simpl; intros; [exfalso; inv H1; mred|].\n\n    subst; destruct l as [pann pds pcs].\n    destruct pann as [|]; [exfalso; destruct sul; inv H6|].\n    specialize (IHSubstepsInd _ _ eq_refl).\n\n    remember (M.find (attrName dm) pds) as odp; destruct odp.\n\n    - assert (s = s0); subst.\n      { clear -Heqodp H3 H6 H9.\n        inv H3; dest; simpl in *.\n        inv H6.\n        destruct sul as [|[[dmn dmb]|]]; simpl in *; findeq.\n        destruct (string_dec (attrName dm) dmn).\n        { subst; exfalso; mcontra. }\n        { mred. }\n      }\n\n      econstructor.\n      + apply IHSubstepsInd; auto.\n        inv H6; auto.\n      + instantiate (1:= scs0); instantiate (1:= sul); instantiate (1:= su0).\n        destruct sul as [|]; [exfalso; inv H6|].\n        clear -H2.\n        inv H2; [constructor|].\n        econstructor; eauto.\n      + inv H6; inv H3; dest; simpl in *.\n        unfold hideMeth; simpl.\n        rewrite <-Heqodp.\n        rewrite M.find_union, H0.\n        destruct (signIsEq _ _); [|elim n; reflexivity].\n        repeat split; simpl; auto.\n        destruct sul as [|[|]]; auto.\n        * inv H5.\n        * findeq; auto.\n      + meq.\n      + unfold hideMeth at 1; simpl.\n        rewrite H9.\n        rewrite M.find_union, H0.\n        destruct (signIsEq _ _); [clear e|elim n; reflexivity].\n        unfold hideMeth; simpl.\n        rewrite <-Heqodp.\n        rewrite M.find_union, H0.\n        destruct (signIsEq _ _); [clear e|elim n; reflexivity].\n        f_equal.\n        * inv H6; destruct sul as [|[|]]; auto; inv H5.\n        * inv H6; inv H3; dest; simpl in *.\n          destruct sul as [|[[dmn dmb]|]]; auto.\n          destruct (string_dec (attrName dm) dmn); auto.\n          subst; meq.\n          simpl in H6; mcontra.\n        * inv H6; inv H3; dest; simpl in *.\n          apply eq_sym in H0; meq.\n          \n    - clear IHSubstepsInd.\n      assert (sul = Meth (Some (attrName dm :: s)%struct)); subst.\n      { destruct sul as [|]; inv H6.\n        destruct o0 as [[dmn dmb]|]; [|mred].\n        destruct (string_dec (attrName dm) dmn); subst; mred.\n      }\n      inv H3; inv H6; dest; simpl in *; clear H5 H9.\n\n      econstructor.\n      + apply inlineDmToRule_substepsInd_intact_1.\n        * eassumption.\n        * simpl; intro Hx; dest; discriminate.\n      + instantiate (1:= M.remove (attrName dm) (M.union scs scs0)).\n        instantiate (1:= Rle (Some (attrName r))).\n        instantiate (1:= M.union su su0).\n\n        inv H; inv H2.\n        econstructor.\n        * simpl.\n          apply in_map with (f:= fun newr =>\n                                   if string_dec (attrName r) (attrName newr)\n                                   then inlineDmToRule newr dm\n                                   else newr) in HInRules.\n          simpl in HInRules.\n          destruct (string_dec _ _); [|elim n; reflexivity].\n          eauto.\n        * simpl; inv Hsig.\n          assert (dm = f) by (eapply in_NoDup_attr; eauto); subst.\n          rewrite M.union_comm with (m1:= su) by auto.\n          replace (M.remove (attrName f) (M.union scs scs0)) with\n          (M.union scs0 (M.remove (attrName f) scs))\n            by (meq; apply eq_sym in H0; mcontra).\n          eapply inlineDm_correct_SemAction; eauto.\n\n      + repeat split; auto.\n      + meq.\n      + unfold hideMeth; simpl; mred.\n        simpl; f_equal; meq.\n\n  Qed.\n\n  Lemma inlineDmToRule_wellHidden:\n    forall l,\n      wellHidden m l ->\n      wellHidden\n        (Mod (getRegInits m)\n             (map\n                (fun newr =>\n                   if string_dec (attrName r) (attrName newr)\n                   then inlineDmToRule newr dm else newr)\n                (getRules m)) (getDefsBodies m)) l.\n  Proof.\n    intros; apply wellHidden_weakening with (m2:= m); auto.\n    - unfold getCalls; simpl.\n      apply SubList_app_3; [|apply SubList_app_2, SubList_refl].\n      clear -Hdm.\n      induction (getRules m); [apply SubList_nil|].\n      apply SubList_app_3.\n      + destruct (string_dec _ _).\n        * simpl.\n          pose proof (inlineDm_calls _ _ Hdm (attrType a typeUT)).\n          apply SubList_trans with (l2:= getCallsA (attrType a typeUT)\n                                                   ++ getCallsM (getDefsBodies m)); auto.\n          apply SubList_app_3.\n          { apply SubList_app_1, SubList_app_1, SubList_refl. }\n          { apply SubList_app_2, SubList_refl. }\n        * simpl.\n          apply SubList_app_1, SubList_app_1, SubList_refl.\n      + fold getCallsR.\n        apply SubList_trans with (l2:= getCallsR l ++ getCallsM (getDefsBodies m)); auto.\n        apply SubList_app_3.\n        * apply SubList_app_1, SubList_app_2, SubList_refl.\n        * apply SubList_app_2, SubList_refl.\n    - apply SubList_refl.\n  Qed.\n\n  Lemma inlineDmToRule_stepInd:\n    forall o u l,\n      StepInd m o u l ->\n      StepInd\n        (Mod (getRegInits m)\n             (map\n                (fun newr =>\n                   if string_dec (attrName r) (attrName newr)\n                   then inlineDmToRule newr dm else newr)\n                (getRules m)) (getDefsBodies m)) o u l.\n  Proof.\n    intros; inv H.\n\n    destruct l0 as [ann ds cs].\n    assert (ann = Some (Some (attrName r)) \\/ ~ ann = Some (Some (attrName r))).\n    { destruct ann; [|right; discriminate].\n      destruct o0; [|right; discriminate].\n      destruct (string_dec s (attrName r)).\n      { subst; left; reflexivity. }\n      { right; intro Hx; inv Hx; elim n; reflexivity. }\n    }\n\n    destruct H.\n\n    - subst.\n      pose proof (substepsInd_rule_split HSubSteps) as Hsp.\n      clear HSubSteps.\n      specialize (Hsp _ eq_refl).\n      destruct Hsp as [ru [rcs [pu [pl ?]]]]; dest; subst.\n\n      remember (M.find (attrName dm) rcs) as odr; destruct odr.\n\n      + rewrite <-hideMeth_preserves_hide with (dm:= attrName dm).\n        constructor.\n        * destruct pl as [pann pds pcs]; inv H3.\n          inv H1; dest; simpl in *; mred.\n          destruct pann; [inv H3|].\n          eapply inlineDmToRule_substepsInd_sub; eauto.\n\n          clear -Hdm Heqodr HWellHidden.\n          apply wellHidden_find_1 with (a:= attrName dm) in HWellHidden.\n          { simpl in *; destruct HWellHidden; mred. }\n          { apply in_map; auto. }\n          \n        * rewrite hideMeth_preserves_hide.\n          apply inlineDmToRule_wellHidden; auto.\n\n      + destruct pl as [pann pds pcs]; simpl in *.\n        remember (M.find (attrName dm) pcs) as odp; destruct odp.\n\n        * econstructor.\n          { mred; inv H3; clear H4.\n            inv H1; dest; simpl in *.\n            destruct pann; [inv H3|].\n            apply inlineDmToRule_substepsInd_intact_2; auto.\n          }\n          { apply inlineDmToRule_wellHidden; auto. }\n\n        * econstructor.\n          { apply inlineDmToRule_substepsInd_intact_1; auto.\n            { econstructor; eauto. }\n            { simpl; intro Hx; dest.\n              elim H4; clear H4.\n              inv H3; findeq.\n            }\n          }\n          { apply inlineDmToRule_wellHidden; auto. }\n\n    - econstructor.\n      + apply inlineDmToRule_substepsInd_intact_1; auto.\n        simpl; intro Hx; dest; elim H; auto.\n      + apply inlineDmToRule_wellHidden; auto.\n\n  Qed.\n\n  Lemma inlineDmToRule_traceRefines_1:\n    m <<== (Mod (getRegInits m)\n                (map (fun newr =>\n                        if string_dec (attrName r) (attrName newr)\n                        then inlineDmToRule newr dm\n                        else newr) (getRules m))\n                (getDefsBodies m)).\n  Proof.\n    apply stepRefinement with (ruleMap:= fun _ s => Some s) (theta:= id); auto.\n    intros; exists u; split; auto.\n\n    rewrite idElementwiseId.\n    replace (liftPLabel _ _ _ _) with l; [|destruct l as [[[|]|] ? ?]; simpl; f_equal].\n    unfold id.\n\n    clear H.\n    apply step_consistent; apply step_consistent in H0.\n    apply inlineDmToRule_stepInd; auto.\n  Qed.\n\n  Hypotheses (Hequiv: ModEquiv type typeUT m)\n             (HrCalls: In (attrName dm) (getCallsA (attrType r typeUT)))\n             (HnoRuleCalls: forall rule,\n                 In rule (getRules m) ->\n                 attrName rule <> attrName r ->\n                 noCallDmSigA (attrType rule typeUT)\n                              (attrName dm) (projT1 (attrType dm)) = true)\n             (HnoMethCalls: forall meth,\n                 In meth (getDefsBodies m) ->\n                 noCallDmSigA (projT2 (attrType meth) typeUT tt)\n                              (attrName dm) (projT1 (attrType dm)) = true).\n\n  Lemma getCallsA_getCalls_In:\n    In (attrName dm) (getCalls m).\n  Proof.\n    unfold getCalls.\n    apply in_or_app; left.\n    clear -Hrule HrCalls.\n    induction (getRules m); auto.\n    destruct Hrule; [subst|].\n    - simpl; apply in_or_app; left; auto.\n    - simpl; apply in_or_app; right; auto.\n  Qed.\n\n  Lemma inlineDmToRule_noDup:\n    NoDup (namesOf (getDefsBodies (Mod (getRegInits m)\n                                       (map\n                                          (fun newr =>\n                                             if string_dec (attrName r) (attrName newr)\n                                             then inlineDmToRule newr dm else newr)\n                                          (getRules m))\n                                       (getDefsBodies m)))).\n  Proof. simpl; auto. Qed.\n\n  Lemma inlineDmToRule_In:\n    In dm (getDefsBodies (Mod (getRegInits m)\n                              (map\n                                 (fun newr =>\n                                    if string_dec (attrName r) (attrName newr)\n                                    then inlineDmToRule newr dm else newr)\n                                 (getRules m))\n                              (getDefsBodies m))).\n  Proof. simpl; auto. Qed.\n\n  Lemma inlineDmToRule_ModEquiv:\n    ModEquiv type typeUT (Mod (getRegInits m)\n                              (map (fun newr =>\n                                      if string_dec (attrName r) (attrName newr)\n                                      then inlineDmToRule newr dm\n                                      else newr) (getRules m))\n                              (getDefsBodies m)).\n  Proof.\n    clear -Hequiv Hdm.\n    assert (MethEquiv type typeUT dm).\n    { inv Hequiv.\n      rewrite MethsEquiv_in in H0.\n      apply H0; auto.\n    }\n    inv Hequiv.\n    constructor; simpl; auto; clear H1.\n    induction H0; simpl; [constructor|].\n    constructor; auto.\n    destruct (string_dec _ _); auto.\n    apply inlineDm_ActionEquiv; auto.\n  Qed.\n\n  Lemma inlineDmToRule_traceRefines_2:\n    m <<== (Mod (getRegInits m)\n                (map (fun newr =>\n                        if string_dec (attrName r) (attrName newr)\n                        then inlineDmToRule newr dm\n                        else newr) (getRules m))\n                (filterDm (getDefsBodies m) (attrName dm))).\n  Proof.\n    apply stepRefinement with (ruleMap:= fun _ s => Some s) (theta:= id); auto.\n    intros; exists u; split; auto.\n\n    rewrite idElementwiseId.\n    replace (liftPLabel _ _ _ _) with l; [|destruct l as [[[|]|] ? ?]; simpl; f_equal].\n    unfold id.\n\n    clear H.\n    apply step_consistent; apply step_consistent in H0.\n\n    pose proof (inlineDmToRule_stepInd H0).\n    \n    apply stepInd_filterDm; auto.\n\n    - apply inlineDmToRule_ModEquiv.\n    - inv H0; pose proof getCallsA_getCalls_In.\n      clear -HWellHidden H0.\n      destruct (hide l0) as [ann ds cs].\n      unfold wellHidden in HWellHidden; dest; simpl in *.\n      specialize (H (attrName dm) H0).\n      findeq.\n    - constructor; simpl.\n      + apply Forall_forall; intros.\n        destruct (string_dec (attrName r) (attrName x)).\n        * apply in_map_iff in H1; dest.\n          destruct (string_dec _ _); subst; auto.\n          apply inlineDmToRule_noCallDmSigA; auto.\n        * apply HnoRuleCalls; auto.\n          apply in_map_iff in H1; dest.\n          destruct (string_dec _ _); subst; auto.\n          elim n; auto.\n      + apply Forall_forall; intros.\n        apply HnoMethCalls; auto.\n  Qed.\n\nEnd Partial.\n\n",
      "theorem": "Lemma inlineDmToMod_correct_Substeps_called_meth:\n    forall or su smn smv scs u l,\n      Substep m or su (Meth (Some (smn :: smv)%struct)) scs ->\n      SubstepsInd m or u l ->\n      forall ann ds cs s,\n        l = {| annot := ann; defs := ds; calls := cs |} ->\n        Some s = M.find (attrName dm) scs ->\n        Some s = M.find (attrName dm) ds ->\n        M.Disj su u ->\n        M.Disj scs cs ->\n        ~ M.In smn ds ->\n        SubstepsInd\n          (Mod (getRegInits m) (inlineDmToRules (getRules m) dm)\n               (inlineDmToDms (getDefsBodies m) dm)) or (M.union u su)\n          {|\n            annot := ann;\n            defs := M.remove (attrName dm) (M.union (M.add smn smv (M.empty (sigT SignT))) ds);\n            calls := M.remove (attrName dm) (M.union scs cs) |}.",
      "ground_truth": "Proof.\n    induction 2; simpl; intros; [inv H0; mcontra|].\n    destruct l as [pann pds pcs]; simpl in *; subst.\n\n    destruct sul as [psr|[[pdmn pdmv]|]]; inv H5.\n\n    - mred; eapply SubstepsCons.\n      + eapply IHSubstepsInd; eauto.\n      + eapply inlineDmToMod_Substep_intact; eauto; findeq.\n      + inv H2; dest; simpl in *.\n        repeat split; simpl; auto.\n      + auto.\n      + simpl; f_equal; auto.\n\n    - M.cmp (attrName dm) pdmn; mred.\n      + inv H2; dest; simpl in *.\n        eapply SubstepsCons.\n        * eapply inlineDmToMod_Substeps_intact; eauto; findeq.\n        * inv H1; inv Hsig.\n          assert (f = dm) by (eapply in_NoDup_attr; eauto); subst.\n          eapply inlineDmToMod_correct_Substep; eauto.\n        * repeat split; simpl; auto.\n          destruct ann; M.cmp smn (attrName dm); findeq.\n        * auto.\n        * simpl; f_equal; auto.\n          destruct ann; meq.\n      + eapply SubstepsCons.\n        * eapply IHSubstepsInd; eauto.\n          M.cmp smn pdmn; findeq.\n        * eapply inlineDmToMod_Substep_intact; eauto; findeq.\n        * inv H2; dest; simpl in *.\n          repeat split; simpl; auto.\n          destruct ann; M.cmp pdmn smn; findeq.\n        * auto.\n        * simpl; f_equal; auto.\n\n    - mred; eapply SubstepsCons.\n      + eapply IHSubstepsInd; eauto.\n      + eapply inlineDmToMod_Substep_intact; eauto; findeq.\n      + inv H2; dest; simpl in *.\n        repeat split; simpl; auto.\n      + auto.\n      + simpl; f_equal; auto.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 4,
      "prefix": "(* Quick Coq *)\n\n(* Use check to view the types and structures of values *)\n\n(* Use definition to define constants: *)\nDefinition example1 := fun x : nat => x * x + 2 * x + 1.\n\n(* We can force coq to evaluate an expression,\n* and actually do work, to do so, coq must do some symbolic execution.\n* multiple strategies are available to do this,\n* we will use compute.*)\n\nDefinition sum5 := fun (x y z a b : nat) => x + y + z + a + b.\n\n\nRequire Import Bool.\n\n(* while bools are defined as part of the language, much of the functionality of boolean\n* values are achieved by drawing from a library Bool. \n* this includes facilities such as if else, \n* conjunctions etc.\n*)\nEval compute in if true then 3 else 4.\n\nRequire Import Arith.\nRequire Import Nat.\nRequire Import List.\n\nLemma example2 : forall a b : Prop, a /\\ b -> b /\\ a.",
      "suffix": "\n\nLemma example3 : forall A B, A \\/ B -> B \\/ A.\nProof.\n    intros.\n    destruct H.\n    right.\n    exact H.\n    left.\n    exact H.\nQed.\n\nLemma example : 3 <= 5.\nProof.\n    apply le_S.\n    apply le_S.\n    apply le_n.\nQed.\n\n\nLemma example5: forall x y, x <= 10 -> 10 <= y -> x <= y.\n    intros.\n    apply le_trans with (m := 10).\n    assumption.\n    assumption.\nQed.\n\n(* Lemma example6: forall x y, (x + y) * (x + y) = x * x + 2 * x * y + y * y.\nProof.\n    intros.\n    rewrite Nat.mul_add_distr_l.\n    rewrite Nat.mul_add_distr_r.\n    rewrite <- plus_assoc with (n := x * x).\n    rewrite mult_comm with (n := y) (m := x).\n    pattern (x * y) at 1; rewrite <- mult_1_l.\nExercise for reader.\n*)\n\n\nFixpoint count n l :=\n    match l with\n    | nil => 0\n    | a ::t1 => \n            let r := count n t1 in\n            if beq_nat n a then\n                1 + r\n            else\n                r\n    end.\n\n\nLemma insert_incr : forall n l, count n (n::l) = 1 + count n l.\nProof.\n    intros.\n    induction l.\n    simpl.\n    rewrite <- beq_nat_refl.\n    reflexivity.\n    simpl.\n    rewrite <- beq_nat_refl.\n    reflexivity.\nQed.\n\n\n\nInductive bin : Type :=\n    | L : bin\n    | N : bin -> bin -> bin.\n\n\nExample example7 (t : bin) : bool := \n    match t with N L L => false\n    | _ => true\n    end.\n\nFixpoint flatten_aux (t1 t2:bin) : bin :=\n    match t1 with\n    | L => N L t2\n    | N t'1 t'2 => flatten_aux t'1 (flatten_aux t'2 t2)\n    end.\n\nFixpoint flatten (t : bin) : bin :=\n    match t with\n    | L => L\n    | N t1 t2 => flatten_aux t1 (flatten t2)\n    end.\n\nFixpoint size (t : bin) : nat :=\n    match t with\n    | L => 1\n    | N t1 t2 => 1 + (size t1) + (size t2) \n    end.\n\nLemma example7_size : \n    forall t : bin, example7 t = false -> size t = 3.\n    intro t.\n    destruct t.\n    simpl.\n    intros H.\n    discriminate H.\n    destruct t1.\n    destruct t2.\n    simpl.\n    auto.\n    intros H; discriminate H.\n    intros H; discriminate H.\nQed.\n\n\nLemma flatten_aux_size :\n    forall t1 t2, size (flatten_aux t1 t2) = size t1 + size t2 + 1.\n    induction t1.\n    intros t2.\n    simpl.\n    ring.\n    intros t2.\n    simpl.\n    rewrite IHt1_1.\n    rewrite IHt1_2.\n    ring.\nQed.\n\n\nLemma flatten_size : forall t, size (flatten t) = size t.\nProof.\n    intros.\n    induction t.\n    simpl.\n    ring.\n    simpl.\n    rewrite  flatten_aux_size.\n    rewrite IHt2.\n    ring.\nQed.\n\n\nLemma not_subterm_self_1 : forall x y, ~ x = N x y.\nProof.\n    induction x.\n    intros y.\n    discriminate.\n    intros y.\n    intros abs.\n    injection abs.\n    intros h2 h1.\n    assert (IHx1' : x1 <> N x1 x2).\n        apply IHx1.\n    case  IHx1'.\n    exact h1.\nQed.\n\n\nInductive even : nat -> Prop :=\n    | even0 : even 0\n    | evenS : forall x:nat, even x -> even (S (S x)).\n\nLemma even_mult : forall x, even x -> exists y, x = 2 * y.\nProof.\n    intros x.\n    intros H.\n    elim H.\n    exists 0.\n    ring.\n    intros x0 Hevenx0 IHx.\n    destruct IHx as [y Heq].\n    exists (y + 1).\n    rewrite Nat.mul_add_distr_l.\n    rewrite <- Heq.\n    ring.\nQed.\n\n\n\nLemma not_even_1 : ~even 1.\nProof.\n    intros even1.\n    inversion even1.\nQed.\n\n\nLemma even_inv : forall x, even (S (S x)) -> even x.\n    induction x.\n    intros even2.\n    exact even0.\n    intros even_3.\n    inversion even_3.\n    exact H0.\nQed.\n",
      "theorem": "Lemma example2 : forall a b : Prop, a /\\ b -> b /\\ a.",
      "ground_truth": "Proof.\n    intros.\n    destruct H.\n    split.\n    exact H0.\n    exact H.\nQed."
    },
    {
      "split": "train-sft",
      "index": 5,
      "prefix": "\n(** * Extra lemmas for seq *)\n\nFrom Coq Require Import List Relations Morphisms.\nFrom mathcomp Require Import ssreflect ssrbool ssrnat seq eqtype ssrfun.\nFrom ssrlib Require Import Compatibility Lists.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(** Lemmas for sequences of Type *)\n\nSection SeqLemmas.\n\n  Variable A : Type.\n\n  Variable B : Type.\n\n  Variable default : A.\n\n  Lemma in_cat (x : A) (s1 s2 : seq A) :\n    In x (s1 ++ s2) -> In x s1 \\/ In x s2.\n  Proof.\n    elim: s1 s2 => [| y s1 IH] s2 /=.\n    - move=> H; right; assumption.\n    - case => H.\n      + left; left; assumption.\n      + case: (IH _ H) => {}H.\n        * left; right; assumption.\n        * right; assumption.\n  Qed.\n\n  Lemma in_cat_l (x : A) (s1 s2 : seq A) :\n    In x s1 -> In x (s1 ++ s2).\n  Proof.\n    elim: s1 s2 => [| y s1 IH] s2 //=. case => H.\n    + left; assumption.\n    + right; exact: (IH _ H).\n  Qed.\n\n  Lemma in_cat_r (x : A) (s1 s2 : seq A) :\n    In x s2 -> In x (s1 ++ s2).\n  Proof.\n    elim: s1 s2 => [| y s1 IH] s2 //=. move=> H; right; exact: (IH _ H).\n  Qed.\n\n  Lemma in_singleton (x y : A) :\n    In x [:: y] -> x = y.\n  Proof. by case => //=. Qed.\n\n  Lemma singleton_seq (l : seq A) :\n    size l = 1%N -> exists x : A, l = x :: nil.\n  Proof.\n    elim: l => //=.\n    move=> hd tl; elim tl => //=.\n    move=> _ _; exists hd.\n    reflexivity.\n  Qed.\n\n  Lemma last_decomp (l : seq A) (n : nat) :\n    size l = (n + 1)%N -> exists s x, l = rcons s x.\n  Proof.\n    move: l n. apply: last_ind => /=.\n    - by case.\n    - move=> l x IH n H. exists l; exists x; reflexivity.\n  Qed.\n\n  Lemma last_default_irrelevant (l : seq A) (n : nat) b1 b2 :\n    size l = (n + 1)%N -> last b1 l = last b2 l.\n  Proof.\n    move: l n b1 b2. apply: last_ind => /=.\n    - move=> n b1 b2; by case n.\n    - move=> l lst IH n b1 b2 H. rewrite !last_rcons. reflexivity.\n  Qed.\n\n  Lemma nth_cons (x : A) (l : list A) (n : nat) :\n    0 < n -> nth default (x::l) n = nth default l (n - 1).\n  Proof. case: n => //=. move=> n _. by rewrite subn1 -pred_Sn. Qed.\n\n  Lemma nth_tl (l : list A) (n : nat) : nth default (tl l) n = nth default l (n + 1).\n  Proof.\n    case: l => [| x l] //=.\n    - by rewrite 2!nth_nil.\n    - rewrite nth_cons; last by rewrite addn_gt0 orbT. by rewrite addn1 subn1 -pred_Sn.\n  Qed.\n\n  Lemma drop_take (s : seq A) n m :\n    n <= m -> m < size s -> drop (m - n) (take m s) = take n (drop (m - n) s).\n  Proof.\n    elim: s n m => [| x s IH] n m Hnm Hms //. rewrite /= in Hms.\n    case: m Hnm Hms.\n    - rewrite leqn0 => /eqP ->. rewrite subnn drop0 take0. reflexivity.\n    - move=> m Hnm Hms. rewrite -(addn1 m) -(addn1 (size s)) ltn_add2r in Hms.\n      rewrite leq_eqVlt in Hnm. case/orP: Hnm => Hnm.\n      + rewrite (eqP Hnm) subnn !drop0. reflexivity.\n      + rewrite ltnS in Hnm. rewrite take_cons. rewrite !(subSn Hnm) !drop_cons.\n        exact: (IH _ _ Hnm Hms).\n  Qed.\n\n  Lemma take_take (s : seq A) (n m : nat) : take n (take m s) = take (minn n m) s.\n  Proof.\n    elim: s n m => [| x s IH] n m //.\n    case: m => [| m] //. case: n => [| n] //. rewrite minnSS.\n    rewrite !take_cons. rewrite IH. reflexivity.\n  Qed.\n\n  Lemma nseq_addn (x : A) n m : nseq (n + m) x = nseq n x ++ nseq m x.\n  Proof.\n    elim: n m => [| n IHn] m //=. rewrite IHn. reflexivity.\n  Qed.\n\n  Lemma drop_nseq (x : A) n m : drop n (nseq m x) = nseq (m - n) x.\n  Proof.\n    case Hnm: (m <= n).\n    - rewrite -{1}(subnK Hnm). rewrite -drop_drop.\n      have Hm: m = size (nseq m x) by rewrite size_nseq.\n      rewrite {2}Hm. rewrite drop_size /=. rewrite -subn_eq0 in Hnm.\n      rewrite (eqP Hnm) /=. reflexivity.\n    - move/idP/negP: Hnm. rewrite -ltnNge => Hnm. move: (subnK (ltnW Hnm)) => H.\n      rewrite -{1}H. rewrite addnC nseq_addn.\n      rewrite drop_size_cat; last by rewrite size_nseq. reflexivity.\n  Qed.\n\n  Lemma take_nseq (x : A) n m : take n (nseq m x) = nseq (minn n m) x.\n  Proof.\n    case Hnm: (n <= m).\n    - move/minn_idPl: (Hnm) => ->. move: (subnK Hnm) => <-.\n      rewrite addnC nseq_addn. rewrite take_size_cat; last by rewrite size_nseq.\n      reflexivity.\n    - move/idP/negP: Hnm. rewrite -ltnNge => Hnm.\n      move/minn_idPr: (ltnW Hnm) => ->. rewrite take_oversize; first by reflexivity.\n      rewrite size_nseq. exact: (ltnW Hnm).\n  Qed.\n\n  Lemma drop_nseq_more (s : seq A) (x : A) n m :\n    n <= m -> drop n s = nseq (size s - n) x -> drop m s = nseq (size s - m) x.\n  Proof.\n    move=> Hmn Hdn. move: (subnK Hmn) => H. rewrite -{1}H.\n    rewrite -drop_drop. rewrite Hdn. rewrite drop_nseq. rewrite -subnDA.\n    rewrite addnC H. reflexivity.\n  Qed.\n\n  Lemma take_nseq_less_minn (s : seq A) (x : A) n m :\n    m <= n -> take n s = nseq (minn n (size s)) x ->\n    take m s = nseq (minn m (size s)) x.\n  Proof.\n    move=> Hmn. case Hns: (n <= size s).\n    - move/minn_idPl: (Hns) => ->. move/minn_idPl: (leq_trans Hmn Hns) => ->.\n      elim: s n m Hmn Hns => [| e s IH] n m Hmn Hns.\n      + rewrite leqn0 in Hns. rewrite (eqP Hns) in Hmn.\n        rewrite leqn0 in Hmn. rewrite (eqP Hmn). reflexivity.\n      + case: n Hmn Hns => [| n] Hmn Hns.\n        * rewrite leqn0 in Hmn. rewrite (eqP Hmn). reflexivity.\n        * case: m Hmn => [| m] Hmn.\n          -- reflexivity.\n          -- rewrite /= !ltnS in Hmn Hns. rewrite !take_cons.\n             rewrite -(addn1 n) -(addn1 m). rewrite (addnC n) (addnC m).\n             rewrite !nseq_addn /=. case => -> H.\n             rewrite (IH _ _ Hmn Hns H). reflexivity.\n    - move/idP/negP: Hns. rewrite -ltnNge => Hsn. move/minn_idPr: (ltnW Hsn) => ->.\n      rewrite (take_oversize (ltnW Hsn)). move=> ->. rewrite size_nseq.\n      case Hms: (m <= size s).\n      + rewrite take_nseq. move/minn_idPl: (Hms) => ->. reflexivity.\n      + move/idP/negP: Hms. rewrite -ltnNge => Hsm. move/minn_idPr: (ltnW Hsm) => ->.\n        rewrite take_oversize; first reflexivity.\n        rewrite size_nseq. exact: (ltnW Hsm).\n  Qed.\n\n  Lemma take_nseq_less (s : seq A) (x : A) n m :\n    m <= n -> n <= size s -> take n s = nseq n x -> take m s = nseq m x.\n  Proof.\n    move=> Hmn Hns. move/minn_idPl: (leq_trans Hmn Hns) => {2}<-.\n    move/minn_idPl: (Hns) => {2}<-. exact: (take_nseq_less_minn Hmn).\n  Qed.\n\n  Lemma catsl_inj (s1 s2 s3 : seq A) : s1 ++ s2 = s1 ++ s3 -> s2 = s3.\n  Proof. elim: s1 s2 s3 => [| hd tl IH] s2 s3 //=. case. exact: IH. Qed.\n\n  Lemma catsr_inj (s1 s2 s3 : seq A) : s2 ++ s1 = s3 ++ s1 -> s2 = s3.\n  Proof.\n    elim: s1 s2 s3 => [| hd tl IH] s2 s3 /=.\n    - rewrite !cats0. by apply.\n    - rewrite -!cat_rcons. move=> H. move: (IH _ _ H) => {} H.\n      move: (rcons_inj H). case. by apply.\n  Qed.\n\n  Lemma In_rcons x (s : seq A) l :\n    List.In x (rcons s l) <-> List.In x s \\/ x = l.\n  Proof.\n    elim: s => [| hd tl IH] /=.\n    - split; case=> H //=.\n      + right. symmetry. assumption.\n      + left; symmetry. assumption.\n    - move: IH=> [IH1 IH2]. split; case => H /=.\n      + left; left. assumption.\n      + case: (IH1 H) => {} H.\n        * left; right; assumption.\n        * right; assumption.\n      + case: H => H.\n        * left; assumption.\n        * right. exact: (IH2 (or_introl H)).\n      + right. exact: (IH2 (or_intror H)).\n  Qed.\n\n  Lemma incl_consl (a : A) (l m : seq A) :\n    incl (a :: l) m -> In a m /\\ incl l m.\n  Proof.\n    move=> H. split.\n    - apply: (H a). exact: in_eq.\n    - move=> x Hinx. apply: (H x). apply: List.in_cons. assumption.\n  Qed.\n\n  Lemma incl_empty (s : seq A) :\n    incl s [::] -> s = [::].\n  Proof.\n    elim: s => [| x s IH] //=. move=> H. move: (incl_consl H) => [H1 H2].\n    apply: False_ind. exact: (List.in_nil H1).\n  Qed.\n\n  Lemma split_cons (x : A * B) (s : seq (A * B)) :\n    split (x::s) = (x.1::(split s).1, x.2::(split s).2).\n  Proof.\n    rewrite /=. case Hs: (split s) => [sa sb] /=. case: x => [xa xb] /=.\n    reflexivity.\n  Qed.\n\n  Lemma split_cat (s1 s2 : seq (A * B)) :\n    split (s1 ++ s2) = ((split s1).1 ++ (split s2).1, (split s1).2 ++ (split s2).2).\n  Proof.\n    elim: s1 => [| [hd1a hd1b] tl1 IH] //=.\n    - by case: (split s2).\n    - move: IH. case: (split (tl1 ++ s2)) => [cs1 cs2].\n      case: (split tl1) => [tl11 tl12]. case: (split s2) => [tl21 tl22] /=.\n      case=> ? ?; subst. reflexivity.\n  Qed.\n\n  Lemma split_rcons (s : seq (A * B)) (x : A * B) :\n    split (rcons s x) = (rcons (split s).1 x.1, rcons (split s).2 x.2).\n  Proof.\n    move: s x. apply: last_ind.\n    - move=> [xa xb] /=. reflexivity.\n    - move=> s [ya yb] IH [xa xb] /=. rewrite IH /=.\n      rewrite -(cats1 s) rcons_cat. rewrite split_cat /=.\n      rewrite -cats1 cat_rcons. rewrite -cats1 cat_rcons. reflexivity.\n  Qed.\n\n  Lemma split_rev (s : seq (A * B)) :\n    split (rev s) = (rev (split s).1, rev (split s).2).\n  Proof.\n    elim: s => [| [hda hdb] tl IH] //=. rewrite rev_cons.\n    rewrite split_rcons. rewrite IH /=. case: (split tl) => [s1 s2] /=.\n    rewrite !rev_cons. reflexivity.\n  Qed.\n\n  Lemma catrevs0 (s : seq A) : catrev s [::] = rev s.\n  Proof. by rewrite catrevE cats0. Qed.\n\n  Lemma catrev0s (s : seq A) : catrev [::] s = s.\n  Proof. reflexivity. Qed.\n\n  Lemma in_map_exists (s : seq A) (f : A -> B) (x : B) :\n    In x (map f s) -> exists y, In y s /\\ x = f y.\n  Proof.\n    elim: s => [| hd tl IH] //=. case=> Hin.\n    - subst. exists hd. tauto.\n    - move: (IH Hin) => [y [Hiny Hxy]]. exists y. tauto.\n  Qed.\n\n  Lemma In_rev x (s : seq A) :\n    In x (rev s) <-> In x s.\n  Proof.\n    elim: s => [| e s IH] //=. move: IH => [IH1 IH2].\n    rewrite rev_cons. split => H.\n    - case/In_rcons: H => H.\n      + right; exact: (IH1 H).\n      + left; rewrite H; reflexivity.\n    - apply/In_rcons. case: H => H.\n      + right; rewrite H; reflexivity.\n      + left; exact: (IH2 H).\n  Qed.\n\n  Lemma catrev_rev (s1 s2 : seq A) :\n    catrev (rev s1) s2 = s1 ++ s2.\n  Proof.\n    move: s1 s2. apply: last_ind => [| s1 x1 IH1] s2 //=.\n    rewrite rev_rcons /= IH1. rewrite cat_rcons. reflexivity.\n  Qed.\n\n  (* all, has, Forall, and Exists *)\n\n  Lemma all_Forall (P : pred A) (s : seq A) :\n    all P s <-> Forall P s.\n  Proof.\n    split.\n    - elim: s => [| e s IH] //=. move/andP=> [H1 H2]. move: (IH H2) => {}H2.\n      by apply: Forall_cons.\n    - elim: s => [| e s IH] //=. move=> /Forall_cons_iff [H1 H2].\n      by rewrite H1 (IH H2).\n  Qed.\n\n  Lemma all_forall (P : pred A) (s : seq A) :\n    all P s <-> (forall e, In e s -> P e).\n  Proof.\n    split => H.\n    - apply/Forall_forall. apply/all_Forall. assumption.\n    - apply/all_Forall. apply/Forall_forall. assumption.\n  Qed.\n\n  Lemma has_Exists (P : pred A) (s : seq A) :\n    has P s <-> Exists P s.\n  Proof.\n    split.\n    - elim: s => [| e s IH] //=. case/orP=> H.\n      + apply: Exists_cons_hd. assumption.\n      + apply: Exists_cons_tl. exact: (IH H).\n    - elim: s => [| e s IH] //=.\n      + move/Exists_nil. by elim.\n      + case/Exists_cons => H.\n        * by rewrite H.\n        * by rewrite (IH H) orbT.\n  Qed.\n\n  Lemma has_exists (P : pred A) (s : seq A) :\n    has P s <-> exists e, In e s /\\ P e.\n  Proof.\n    split.\n    - move/has_Exists. move/Exists_exists. by apply.\n    - move/Exists_exists. move/has_Exists. by apply.\n  Qed.\n\n  Lemma all_flatten (P : pred A) (ss : seq (seq A)) :\n    all P (flatten ss) = all (all P) ss.\n  Proof.\n    elim: ss => [| s ss IH] //=. rewrite all_cat IH. reflexivity.\n  Qed.\n\n  Lemma has_flatten (P : pred A) (ss : seq (seq A)) :\n    has P (flatten ss) = has (has P) ss.\n  Proof.\n    elim: ss => [| s ss IH] //=. rewrite has_cat IH. reflexivity.\n  Qed.\n\n  Lemma all_in (P : pred A) (s : seq A) (x : A) :\n    all P s -> In x s -> P x.\n  Proof. move/all_forall. by apply. Qed.\n\nEnd SeqLemmas.\n\n\n(** Lemmas for foldl and folr *)\n\nSection Fold.\n\n  Context {A : Type} {B : Type} {R : relation B} {E : Equivalence R}.\n\n  Context {f : B -> A -> B}.\n\n  Context {g : A -> B -> B}.\n\n  Context {Rf_swap : forall (a1 a2 : A) (b : B),\n              R (f (f b a1) a2) (f (f b a2) a1)}.\n\n  Context {R_foldl : forall (b1 b2 : B) (ls : seq A),\n              R b1 b2 -> R (foldl f b1 ls) (foldl f b2 ls)}.\n\n  Lemma foldl_fold_left a s : foldl f a s = fold_left f s a.\n  Proof. by elim: s a => [| x s IH] a //=. Qed.\n\n  Lemma foldr_fold_right a s : foldr g a s = fold_right g a s.\n  Proof. reflexivity. Qed.\n\n  Lemma foldl_map {C : Type} (h : C -> A) r s :\n    foldl f r (map h s) = foldl (fun x y => f x (h y)) r s.\n  Proof. by elim: s r => [| x s IH] r //=. Qed.\n\n  Lemma foldl_cons (hd : A) (tl : seq A) (r : B) :\n    R (foldl f r (hd::tl)) (f (foldl f r tl) hd).\n  Proof.\n    elim: tl hd r => /=.\n    - move=> hd r. reflexivity.\n    - move=> tl_hd tl_tl IH hd r. rewrite -(IH hd (f r tl_hd)).\n      move: (Rf_swap tl_hd hd r) => H. rewrite (R_foldl _ H). reflexivity.\n  Qed.\n\n  Lemma flodr_cons r x s : foldr g r (x::s) = g x (foldr g r s).\n  Proof. reflexivity. Qed.\n\n  Lemma foldr_rev r s : foldr g r (rev s) = foldl (fun r x => g x r) r s.\n  Proof.\n    elim: s r => [| x s IH] r //=. rewrite rev_cons foldr_rcons. rewrite IH.\n    reflexivity.\n  Qed.\n\nEnd Fold.\n\n\n(** Tail-recursive flatten, the result is the reverse of flatten *)\n\nSection TailRecursiveFlatten.\n\n  Context {A : Type}.\n\n  Definition tflatten (ss : seq (seq A)) := foldl (fun r s => catrev s r) [::] ss.\n\n  Lemma tflatten_flatten ss : tflatten ss = rev (flatten ss).\n  Proof.\n    rewrite /tflatten. rewrite -(cats0 (rev (flatten ss))).\n    move: [::]. move: ss. apply: last_ind => [| ss x IH] l //=.\n    rewrite flatten_rcons. rewrite rev_cat -catA. rewrite -IH.\n    rewrite foldl_rcons. rewrite catrevE. reflexivity.\n  Qed.\n\n  Lemma tflatten_cons s ss : tflatten (s::ss) = (tflatten ss) ++ (rev s).\n  Proof. rewrite !tflatten_flatten /=. rewrite rev_cat. reflexivity. Qed.\n\n  Lemma tflatten_rcons ss s :\n    tflatten (rcons ss s) = rev s ++ tflatten ss.\n  Proof. rewrite !tflatten_flatten. rewrite flatten_rcons rev_cat. reflexivity. Qed.\n\n  Lemma tflattens_cat ss1 ss2 :\n    tflatten (ss1 ++ ss2) = tflatten ss2 ++ tflatten ss1.\n  Proof. rewrite !tflatten_flatten. rewrite flatten_cat rev_cat. reflexivity. Qed.\n\n  Lemma filter_tflatten ss (p : pred A) :\n    filter p (tflatten ss) = tflatten [seq filter p i | i <- ss].\n  Proof.\n    rewrite (tflatten_flatten [seq filter p i | i <- ss]).\n    rewrite -filter_flatten. rewrite -filter_rev. rewrite -tflatten_flatten.\n    reflexivity.\n  Qed.\n\n  Lemma all_tflatten (p : pred A) ss :\n    all p (tflatten ss) = all (all p) ss.\n  Proof. rewrite tflatten_flatten. rewrite all_rev. exact: all_flatten. Qed.\n\n  Lemma has_tflatten (p : pred A) ss :\n    has p (tflatten ss) = has (has p) ss.\n  Proof. rewrite tflatten_flatten. rewrite has_rev. exact: has_flatten. Qed.\n\nEnd TailRecursiveFlatten.\n\nLemma map_tflatten {A B : Type} (f : A -> B) ss :\n  map f (tflatten ss) = tflatten (map (map f) ss).\nProof.\n  rewrite (tflatten_flatten (map (map f) ss)). rewrite -map_flatten.\n  rewrite -map_rev. rewrite -tflatten_flatten. reflexivity.\nQed.\n\n\n(* Tail-recursive maps.\n   mapr: the result is the reverse of map\n   tmap: the result is the same as map *)\n\nSection MapRev.\n\n  Context {A : Type} {B : Type}.\n\n  Variable f : A -> B.\n\n  Fixpoint mapr_rec res es :=\n    match es with\n    | [::] => res\n    | hd::tl => mapr_rec (f hd::res) tl\n    end.\n\n  Definition mapr es := mapr_rec [::] es.\n\n  Lemma mapr_rec_rev_map res es : mapr_rec res es = rev (map f es) ++ res.\n  Proof.\n    elim: es res => [| e es IH] res //=. rewrite IH. rewrite rev_cons.\n    rewrite cat_rcons. reflexivity.\n  Qed.\n\n  Lemma mapr_rev_map es : mapr es = rev (map f es).\n  Proof. rewrite /mapr. rewrite mapr_rec_rev_map. by rewrite cats0. Qed.\n\n  Lemma mapr_map es : mapr es = map f (rev es).\n  Proof. rewrite map_rev. exact: mapr_rev_map. Qed.\n\n  Lemma mapr_rec_cons res e es : mapr_rec res (e::es) = mapr_rec (f e::res) es.\n  Proof. reflexivity. Qed.\n\n  Lemma mapr_rec_split res es : mapr_rec res es = mapr_rec [::] es ++ res.\n  Proof.\n    elim: es res => [| e es IH] //= res. rewrite (IH (f e::res)).\n    rewrite (IH [:: f e]). rewrite -cat_rcons. rewrite -cats1. reflexivity.\n  Qed.\n\n  Lemma mapr_cons e es : mapr (e::es) = rcons (mapr es) (f e).\n  Proof.\n    rewrite !mapr_map. rewrite rev_cons map_rcons. reflexivity.\n  Qed.\n\n  Lemma mapr_rec_rcons res es e :\n    mapr_rec res (rcons es e) = f e :: mapr_rec res es.\n  Proof. by elim: es res e => [| e1 es IH] //=. Qed.\n\n  Lemma mapr_rcons es e : mapr (rcons es e) = f e :: mapr es.\n  Proof. exact: mapr_rec_rcons. Qed.\n\n  Lemma mapr_rec_cat res es1 es2 :\n    mapr_rec res (es1 ++ es2) = mapr_rec (mapr_rec res es1) es2.\n  Proof. by elim: es1 res es2 => [| e1 es1 IH] res es2 //=. Qed.\n\n  Lemma mapr_cat es1 es2 : mapr (es1 ++ es2) = mapr es2 ++ mapr es1.\n  Proof.\n    rewrite !mapr_map. rewrite rev_cat map_cat. reflexivity.\n  Qed.\n\n  Lemma size_mapr es : size (mapr es) = size es.\n  Proof.\n    rewrite mapr_map. rewrite size_map size_rev. reflexivity.\n  Qed.\n\n  Lemma mapr_rev es : mapr (rev es) = map f es.\n  Proof.\n    elim: es => [| e es IH] //=. rewrite rev_cons. rewrite mapr_rcons.\n    rewrite IH. reflexivity.\n  Qed.\n\n\n  Definition tmap es := mapr (rev es).\n\n  Lemma tmap_map es : tmap es = map f es.\n  Proof. rewrite /tmap mapr_rev. reflexivity. Qed.\n\n  Lemma in_tmap e es : In e es -> In (f e) (tmap es).\n  Proof.\n    rewrite tmap_map. exact: in_map.\n  Qed.\n\nEnd MapRev.\n\nSection FlattenMap.\n\n  Lemma in_flatten {A : Type} x (ss : seq (seq A)) :\n    In x (flatten ss) <-> exists s, In s ss /\\ In x s.\n  Proof.\n    elim: ss => [| s ss IH] //=.\n    - split => //=. move=> [s H]. tauto.\n    - move: IH => [IH1 IH2]. split => H.\n      + case: (in_cat H) => {}H.\n        * exists s. split; [ by left | assumption ].\n        * move: (IH1 H) => [t [Hint Hinx]]. exists t; tauto.\n      + move: H => [t [Hint Hinx]]. case: Hint => Hint.\n        * subst. apply: in_cat_l. assumption.\n        * apply: in_cat_r. apply: IH2. exists t. tauto.\n  Qed.\n\n  Lemma in_tflatten {A : Type} x (ss : seq (seq A)) :\n    In x (tflatten ss) <-> exists s, In s ss /\\ In x s.\n  Proof.\n    rewrite tflatten_flatten. move: (in_flatten x ss) => Hin. split => H.\n    - move/In_rev: H. tauto.\n    - apply/In_rev. tauto.\n  Qed.\n\n  Lemma in_flatten_map {A B : Type} (f : B -> seq A) x e (s : seq B) :\n    In e s ->\n    In x (f e) ->\n    In x (flatten (map f s)).\n  Proof.\n    move=> Hine Hinx. apply/in_flatten. exists (f e). split; [| assumption ].\n    apply: in_map. assumption.\n  Qed.\n\n  Lemma in_tflatten_tmap {A B : Type} (f : B -> seq A) x e (s : seq B) :\n    In e s ->\n    In x (f e) ->\n    In x (tflatten (tmap f s)).\n  Proof.\n    move=> H1 H2. rewrite tflatten_flatten tmap_map.\n    apply/In_rev. exact: (in_flatten_map H1 H2).\n  Qed.\n\nEnd FlattenMap.\n\n\n(** Tail-recursive append. *)\n\nSection TailRecursiveAppend.\n\n  Context {A : Type}.\n\n  Definition tappend (es1 es2 : seq A) := rev_append (rev es1) es2.\n\n  Lemma tappend_cat es1 es2 : tappend es1 es2 = es1 ++ es2.\n  Proof.\n    rewrite /tappend. move: es1 es2. apply: last_ind => [| es1 e1 IH1] es2 //=.\n    rewrite rev_rcons /=. rewrite IH1. rewrite cat_rcons. reflexivity.\n  Qed.\n\nEnd TailRecursiveAppend.\n\n\n\n(** Lemmas for sequences of eqType *)\n\nSection EqSeqLemmas.\n\n  Variable A : eqType.\n\n  Variable B : eqType.\n\n  Lemma singleton_eq (x y : A) : ([::x] == [::y]) = (x == y).\n  Proof.\n    case H: (x == y).\n    - by rewrite (eqP H) eqxx.\n    - apply/negP => /eqP [] Heq. by rewrite Heq eqxx in H.\n  Qed.\n\n  Lemma in_In (x : A) (s : seq A) : x \\in s <-> In x s.\n  Proof.\n    elim: s => [| y ys IH] //=. rewrite in_cons. case H: (x == y) => /=.\n    - split.\n      + move=> _. left. rewrite (eqP H). reflexivity.\n      + done.\n    - split.\n      + move=> Hin. right. apply/IH. exact: Hin.\n      + case.\n        * move=> Hyx; rewrite Hyx eqxx in H; discriminate.\n        * move/IH. by apply.\n  Qed.\n\n  Lemma map_l_nil (f : A -> B) (l : seq A) :\n    (map f l == [::]) = (l == [::]).\n  Proof. by case: l. Qed.\n\n  Lemma seq_neq_split (x y : A) (xs ys : seq A) :\n    (x::xs != y::ys) = ((x != y) || (xs != ys)).\n  Proof.\n    rewrite negb_and -/eqseq. case Hxy: (x == y) => /=; by trivial.\n  Qed.\n\n  Lemma has_catrev p (l1 l2 : seq A) : has p (catrev l1 l2) = has p l1 || has p l2.\n  Proof.\n    elim: l1 l2 => [| hd tl IH] l2 //=. rewrite -cat1s catrev_catr has_cat IH /=.\n    rewrite orbF (Bool.orb_comm (has p tl)). reflexivity.\n  Qed.\n\n  Lemma all_catrev p (l1 l2 : seq A) : all p (catrev l1 l2) = all p l1 && all p l2.\n  Proof.\n    elim: l1 l2 => [| hd tl IH] l2 //=. rewrite -cat1s catrev_catr all_cat IH /=.\n    rewrite andbT (Bool.andb_comm (all p tl)). reflexivity.\n  Qed.\n\n  Lemma cat_nseql (x : A) s1 s2 n :\n    s1 ++ s2 = nseq n x -> s1 = nseq (size s1) x.\n  Proof.\n    move=> H. have: size (s1 ++ s2) = size (nseq n x) by rewrite H.\n    rewrite size_cat size_nseq => Hn. rewrite -Hn in H.\n    rewrite nseq_addn in H. move/eqP: H. rewrite eqseq_cat; last by rewrite size_nseq.\n    move/andP=> [/eqP <- _]. reflexivity.\n  Qed.\n\n  Lemma cat_nseqr (x : A) s1 s2 n :\n    s1 ++ s2 = nseq n x -> s2 = nseq (size s2) x.\n  Proof.\n    move=> H. have: size (s1 ++ s2) = size (nseq n x) by rewrite H.\n    rewrite size_cat size_nseq => Hn. rewrite -Hn in H.\n    rewrite nseq_addn in H. move/eqP: H. rewrite eqseq_cat; last by rewrite size_nseq.\n    move/andP=> [_ /eqP <-]. reflexivity.\n  Qed.\n\n  Lemma in_rcons (x : A) s (y : A) :\n    x \\in rcons s y = (x \\in s) || (x == y).\n  Proof. rewrite mem_rcons in_cons orbC. reflexivity. Qed.\n\n  Lemma in_rev (x : A) s :\n    (x \\in rev s) = (x \\in s).\n  Proof.\n    elim: s => [| y s IH] //=. rewrite rev_cons in_rcons IH in_cons orbC.\n    reflexivity.\n  Qed.\n\n  Lemma in_split_rev_l {C : Type} (x : A) (s : seq (A * C)) :\n    (x \\in (split (rev s)).1) = (x \\in (split s).1).\n  Proof.\n    rewrite split_rev /=. rewrite mem_rev. reflexivity.\n  Qed.\n\n  Lemma in_split_rev_r {C : Type} (x : B) (s : seq (C * B)) :\n    (x \\in (split (rev s)).2) = (x \\in (split s).2).\n  Proof.\n    rewrite split_rev /=. rewrite mem_rev. reflexivity.\n  Qed.\n\n\n  (* Tail-recursive filter function, the result is the reverse of filter *)\n\n  Variable p : pred A.\n\n  Definition tfilter es := foldl (fun r x => if p x then x::r else r) [::] es.\n\n  Lemma tfilter_filter es : tfilter es = filter p (rev es).\n  Proof.\n    rewrite -(cats0 (filter p (rev es))). rewrite /tfilter. rewrite filter_rev.\n    move: [::]. elim: es => [| e es IH] r //=. case: (p e).\n    - rewrite rev_cons. rewrite cat_rcons. rewrite -IH. reflexivity.\n    - exact: IH.\n  Qed.\n\n  Lemma tfilter_cat es1 es2 : tfilter (es1 ++ es2) = tfilter es2 ++ tfilter es1.\n  Proof.\n    rewrite !tfilter_filter. rewrite rev_cat filter_cat. reflexivity.\n  Qed.\n\n  Lemma tfilter_rcons es e :\n    tfilter (rcons es e) = if p e\n                           then e::(tfilter es)\n                           else tfilter es.\n  Proof.\n    rewrite !tfilter_filter. rewrite rev_rcons /=. reflexivity.\n  Qed.\n\n  Lemma tfilter_cons e es :\n    tfilter (e::es) = if p e\n                      then rcons (tfilter es) e\n                      else tfilter es.\n  Proof.\n    rewrite !tfilter_filter. rewrite rev_cons filter_rcons. reflexivity.\n  Qed.\n\n  Lemma tfilter_nil : tfilter [::] = [::].\n  Proof. reflexivity. Qed.\n\nEnd EqSeqLemmas.\n\n\n(* Tail-recursive zip *)\n\nSection TailRecursiveZip.\n\n  Context {A : Type} {B : Type}.\n\n  Fixpoint zipr_rec res_rev (xs : seq A) (ys : seq B) : seq (A * B) :=\n    match xs, ys with\n    | _, [::]\n    | [::], _ => res_rev\n    | x::xs, y::ys => zipr_rec ((x, y)::res_rev) xs ys\n    end.\n\n  Definition zipr (xs : seq A) (ys : seq B) : seq (A * B) := zipr_rec [::] xs ys.\n\n  Definition unzip1r := mapr (@fst A B).\n\n  Definition unzip2r := mapr (@snd A B).\n\n  Lemma zipr_rec_cons r x xs y ys : zipr_rec r (x::xs) (y::ys) = zipr_rec ((x, y)::r) xs ys.\n  Proof. reflexivity. Qed.\n\n  Lemma zipr_zip xs ys : zipr xs ys = rev (zip xs ys).\n  Proof.\n    rewrite /zipr. rewrite -(cats0 (rev (zip xs ys))). move: [::].\n    elim: xs ys => [| x xs IHx] [| y ys] r //=. rewrite IHx. rewrite rev_cons.\n    rewrite cat_rcons. reflexivity.\n  Qed.\n\n  Lemma unzip1r_unzip1 s : unzip1r s = rev (unzip1 s).\n  Proof. rewrite /unzip1r. rewrite mapr_map map_rev. reflexivity. Qed.\n\n  Lemma unzip2r_unzip2 s : unzip2r s = rev (unzip2 s).\n  Proof. rewrite /unzip2r. rewrite mapr_map map_rev. reflexivity. Qed.\n\n  Lemma zipr_cons x xs y ys : zipr (x::xs) (y::ys) = rcons (zipr xs ys) (x, y).\n  Proof. rewrite !zipr_zip /=. rewrite rev_cons. reflexivity. Qed.\n\n  Lemma zipr_rcons xs x ys y :\n    size xs = size ys -> zipr (rcons xs x) (rcons ys y) = (x, y)::(zipr xs ys).\n  Proof.\n    move=> Hs. rewrite !zipr_zip. rewrite (zip_rcons _ _ Hs).\n    rewrite rev_rcons. reflexivity.\n  Qed.\n\n  Lemma zipr_cat xs1 xs2 ys1 ys2 :\n    size xs1 = size ys1 -> zipr (xs1 ++ xs2) (ys1 ++ ys2) = zipr xs2 ys2 ++ zipr xs1 ys1.\n  Proof.\n    move=> Hs. rewrite !zipr_zip. rewrite (zip_cat _ _ Hs). rewrite rev_cat.\n    reflexivity.\n  Qed.\n\n  Lemma rev_zipr xs ys : size xs = size ys -> rev (zipr xs ys) = zipr (rev xs) (rev ys).\n  Proof.\n    move=> Hs. rewrite !zipr_zip. rewrite (rev_zip Hs). reflexivity.\n  Qed.\n\n  Lemma unzip1_zipr s t : size s <= size t -> unzip1 (zipr s t) = rev s.\n  Proof.\n    rewrite zipr_zip => Hs. move: (unzip1_zip Hs). rewrite /unzip1.\n    rewrite map_rev. move=> ->. reflexivity.\n  Qed.\n\n  Lemma unzip2_zipr s t : size t <= size s -> unzip2 (zipr s t) = rev t.\n  Proof.\n    rewrite zipr_zip => Hs. move: (unzip2_zip Hs). rewrite /unzip2.\n    rewrite map_rev. move=> ->. reflexivity.\n  Qed.\n\n  Lemma unzip1r_zipr s t : size s <= size t -> unzip1r (zipr s t) = s.\n  Proof.\n    rewrite unzip1r_unzip1 => Hs. rewrite (unzip1_zipr Hs). by rewrite revK.\n  Qed.\n\n  Lemma unzip2r_zipr s t : size t <= size s -> unzip2r (zipr s t) = t.\n  Proof.\n    rewrite unzip2r_unzip2 => Hs. rewrite (unzip2_zipr Hs). by rewrite revK.\n  Qed.\n\n  Lemma size1_zipr s t : size s <= size t -> size (zipr s t) = size s.\n  Proof.\n    rewrite zipr_zip => Hs. rewrite size_rev. rewrite (size1_zip Hs). reflexivity.\n  Qed.\n\n  Lemma size2_zipr s t : size t <= size s -> size (zipr s t) = size t.\n  Proof.\n    rewrite zipr_zip => Hs. rewrite size_rev. rewrite (size2_zip Hs). reflexivity.\n  Qed.\n\n  Lemma size_zipr xs ys : size (zipr xs ys) = minn (size xs) (size ys).\n  Proof. rewrite zipr_zip size_rev size_zip. reflexivity. Qed.\n\n  Lemma nth_zipr x y s t i :\n    size s = size t -> nth (x, y) (zipr s t) i = (nth x (rev s) i, nth y (rev t) i).\n  Proof.\n    move=> Hs. rewrite zipr_zip. rewrite (rev_zip Hs). rewrite nth_zip; first reflexivity.\n    rewrite !size_rev; assumption.\n  Qed.\n\n  Lemma zipr_map {C : eqType} (f : C -> A) (g : C -> B) (s : seq C) :\n    zipr (map f s) (map g s) = mapr (fun x => (f x, g x)) s.\n  Proof. rewrite zipr_zip. rewrite zip_map mapr_map map_rev. reflexivity. Qed.\n\n  Lemma zipr_mapr {C : eqType} (f : C -> A) (g : C -> B) (s : seq C) :\n    zipr (mapr f s) (mapr g s) = map (fun x => (f x, g x)) s.\n  Proof.\n    rewrite zipr_zip. rewrite !mapr_map !map_rev.\n    rewrite rev_zip; last by rewrite !size_rev !size_map. rewrite !revK.\n    rewrite zip_map. reflexivity.\n  Qed.\n\nEnd TailRecursiveZip.\n\nSection ZipLemmas.\n\n  Context {A : eqType} {B : eqType}.\n\n  Lemma unzip1_l_nil (pairs : seq (A * B)) :\n    (unzip1 pairs == [::]) = (pairs == [::]).\n  Proof. by rewrite /unzip1 map_l_nil. Qed.\n\n  Lemma unzip2_l_nil (pairs : seq (A * B)) :\n    (unzip2 pairs == [::]) = (pairs == [::]).\n  Proof. by rewrite /unzip2 map_l_nil. Qed.\n\nEnd ZipLemmas.\n\n\nSection Map2.\n\n  Context {S T U : Type}.\n\n  Context (f : S -> T -> U).\n\n  (* This function is tail-recursive. *)\n  Definition map2 (s : seq S) (t : seq T) : seq U :=\n    mapr (fun '(a, b) => f a b) (zipr s t).\n\n  Lemma map2s0 s : map2 s [::] = [::].\n  Proof. by case: s. Qed.\n\n  Lemma map20s t : map2 [::] t = [::].\n  Proof. by case: t. Qed.\n\n  Lemma map2_cons s ss t tt : map2 (s::ss) (t::tt) = (f s t)::(map2 ss tt).\n  Proof. rewrite /map2. rewrite zipr_cons mapr_rcons. reflexivity. Qed.\n\n  Lemma map2_rcons ss s tt t :\n    size ss = size tt ->\n    map2 (rcons ss s) (rcons tt t) = rcons (map2 ss tt) (f s t).\n  Proof.\n    move=> Hs. rewrite /map2 (zipr_rcons _ _ Hs). rewrite mapr_cons. reflexivity.\n  Qed.\n\n  Lemma map2_cat ss1 ss2 tt1 tt2 :\n    size ss1 = size tt1 ->\n    map2 (ss1 ++ ss2) (tt1 ++ tt2) = (map2 ss1 tt1) ++ (map2 ss2 tt2).\n  Proof.\n    move=> Hs. rewrite /map2. rewrite (zipr_cat _ _ Hs). rewrite mapr_cat. reflexivity.\n  Qed.\n\n  Lemma map2_equal_size ss tt :\n    map2 ss tt = map2 (take (minn (size ss) (size tt)) ss)\n                      (take (minn (size ss) (size tt)) tt).\n  Proof.\n    elim: ss tt => [| s ss IH] [| t tt] //=. rewrite map2_cons. rewrite !minnSS.\n    rewrite !take_cons map2_cons. rewrite -IH. reflexivity.\n  Qed.\n\n  Lemma map2_size_gt_l ss tt :\n    size tt < size ss -> map2 ss tt = map2 (take (size tt) ss) tt.\n  Proof.\n    move=> Hs. rewrite map2_equal_size /minn. move: (ltn_geF Hs).\n    rewrite leq_eqVlt. move/Bool.orb_false_elim => [_ {}Hs]. rewrite Hs take_size.\n    reflexivity.\n  Qed.\n\n  Lemma map2_size_gt_r ss tt :\n    size ss < size tt -> map2 ss tt = map2 ss (take (size ss) tt).\n  Proof.\n    move=> Hs. rewrite map2_equal_size /minn. rewrite Hs take_size.\n    reflexivity.\n  Qed.\n\nEnd Map2.\n\nSection Map2SSS.\n\n  Context {S : Type}.\n  Context (f : S -> S -> S).\n  Context {f_commutative : commutative f}.\n  Context {f_associative : associative f}.\n  Context {f_idempotent : idempotent f}.\n\n  Lemma map2_comm xs ys : map2 f xs ys = map2 f ys xs.",
      "suffix": "\n\n  Lemma map2_assoc xs ys zs : map2 f xs (map2 f ys zs) = map2 f (map2 f xs ys) zs.\n  Proof.\n    elim: xs ys zs => [| x xs IH] //=.\n    - move=> ys zs. rewrite !map20s. reflexivity.\n    - case=> [| y ys] //=.\n      + move=> zs. rewrite map20s map2s0. reflexivity.\n      + case=> [| z zs] //=.\n        * rewrite !map2s0. reflexivity.\n        * rewrite !map2_cons. rewrite f_associative IH. reflexivity.\n  Qed.\n\n  Lemma map2_idem xs : map2 f xs xs = xs.\n  Proof.\n    elim: xs => [| x xs IH] //=. rewrite map2_cons f_idempotent IH. reflexivity.\n  Qed.\n\nEnd Map2SSS.\n\n\nSection PrefixOf.\n\n  Variable A : eqType.\n\n  Implicit Type s : seq A.\n\n  Fixpoint prefix_of (s1 s2 : seq A) : bool :=\n    match s1 with\n    | [::] => true\n    | x1::s1 => match s2 with\n                | [::] => false\n                | x2::s2 => (x1 == x2) && (prefix_of s1 s2)\n                end\n    end.\n\n  Lemma prefix_of_nil s : prefix_of nil s.\n  Proof. done. Qed.\n\n  Lemma prefix_of_is_nil s : prefix_of s nil = (s == nil).\n  Proof. by case: s. Qed.\n\n  Lemma prefix_of_take s1 s2 :\n    prefix_of s1 s2 = (s1 == take (size s1) s2).\n  Proof.\n    elim: s1 s2 => [|x1 s1 IH1] /=.\n    - by move=> ?; rewrite take0 eqxx.\n    - case => //=. move=> x2 s2. rewrite eqseq_cons IH1. reflexivity.\n  Qed.\n\n  Lemma prefix_of_size s1 s2 : prefix_of s1 s2 -> size s1 <= size s2.\n  Proof.\n    rewrite prefix_of_take. move=> /eqP ->. rewrite size_take.\n    case H: (size s1 < size s2) => //=. by apply: ltnW.\n  Qed.\n\n  Lemma prefix_of_cons x1 s1 x2 s2 :\n    prefix_of (x1::s1) (x2::s2) = ((x1 == x2) && prefix_of s1 s2).\n  Proof. reflexivity. Qed.\n\n  Lemma prefix_of_rcons s1 s2 x :\n    prefix_of s1 s2 -> prefix_of s1 (rcons s2 x).\n  Proof.\n    elim: s1 s2 x => [| hd1 tl1 IH1] [| hd2 tl2] x //=.\n    move=> /andP [/eqP -> Htl]. by rewrite eqxx (IH1 _ _ Htl).\n  Qed.\n\n  Lemma prefix_of_cat s1 s2 s3 :\n    prefix_of s1 s2 -> prefix_of s1 (s2 ++ s3).\n  Proof.\n    move: s3 s2. apply: last_ind => [| s3 x IH] s2 Hpre12 //=.\n    - rewrite cats0. assumption.\n    - rewrite -rcons_cat. apply: prefix_of_rcons. exact: (IH _ Hpre12).\n  Qed.\n\n  Lemma prefix_of_belast x s1 s2 :\n    prefix_of (x::s1) s2 -> prefix_of (belast x s1) s2.\n  Proof.\n    elim: s1 s2 x => [| hd1 tl1 IH1] [| hd2 [| tl2_hd tl2_tl]] x //=.\n    - by rewrite andbF.\n    - move=> /andP [/eqP -> /andP [/eqP -> H]]. rewrite eqxx andTb. apply: IH1.\n      by rewrite prefix_of_cons eqxx H.\n  Qed.\n\n  Lemma prefix_of_refl s : prefix_of s s.\n  Proof. elim: s => //=. move=> ? ? ->; by rewrite eqxx. Qed.\n\n  Lemma prefix_of_antisym s1 s2 : (prefix_of s1 s2 && prefix_of s2 s1) = (s1 == s2).\n  Proof.\n    elim: s1 s2 => [| hd1 tl1 IH1] /=.\n    - move=> s2. rewrite prefix_of_is_nil eq_sym. reflexivity.\n    - case=> [|hd2 tl2] => //=. rewrite (andbA ((hd1 == hd2) && prefix_of tl1 tl2)).\n      rewrite -(andbA (hd1 == hd2)). rewrite (andbC (prefix_of tl1 tl2)).\n      rewrite andbA. rewrite (eq_sym hd2). rewrite Bool.andb_diag. rewrite -andbA.\n      rewrite IH1. reflexivity.\n  Qed.\n\n  Lemma prefix_of_trans s1 s2 s3 :\n    prefix_of s1 s2 -> prefix_of s2 s3 -> prefix_of s1 s3.\n  Proof.\n    elim: s1 s2 s3 => [| hd1 tl1 IH1] [| hd2 tl2] [| hd3 tl3] //=.\n    move=> /andP [/eqP -> H12] /andP [/eqP -> H23].\n      by rewrite eqxx (IH1 _ _ H12 H23).\n  Qed.\n\n  Lemma prefix_of_cons_ident x s1 s2 :\n    prefix_of (x::s1) s2 -> prefix_of s1 s2 -> constant (x::s1).\n  Proof.\n    elim: s1 s2 x => [| hd1 tl1 IH1] [| hd2 [| tl2_hd tl2_tl]] x //=.\n    - by rewrite andbF.\n    - move=> /andP [/eqP <- /andP [/eqP <- H1]]. move=> /andP [/eqP -> H2].\n      rewrite eqxx andTb. apply: (IH1 _ _ _ H2).\n      by rewrite prefix_of_cons eqxx andTb H1.\n  Qed.\n\n  Variable default : A.\n\n  Lemma prefix_of_nth s1 s2 i :\n    prefix_of s1 s2 -> i < size s1 -> nth default s1 i = nth default s2 i.\n  Proof.\n    rewrite prefix_of_take. move=> /eqP Hs Hi. rewrite Hs (nth_take _ Hi).\n    reflexivity.\n  Qed.\n\nEnd PrefixOf.\n\n\nSection ExtSeq.\n\n  Context {A : Type} (a : A).\n  (* Extend a sequence *)\n  Fixpoint extseq (xs ys : seq A) :=\n    match xs, ys with\n    | _, [::] => [::]\n    | [::], _::ys => a::(extseq xs ys)\n    | x::xs, y::ys => x::(extseq xs ys)\n    end.\n\n  Lemma extseq_cons x xs y ys :\n    extseq (x::xs) (y::ys) = x::(extseq xs ys).\n  Proof. reflexivity. Qed.\n\n  Lemma extseqs0 xs : extseq xs [::] = [::].\n  Proof. by elim: xs => [| x xs IH] //=. Qed.\n\n  Lemma extseq0s ys : extseq [::] ys = nseq (size ys) a.\n  Proof.\n    elim: ys => [| y ys IH] //=. rewrite IH. reflexivity.\n  Qed.\n\n  Lemma extseq_eqsize xs ys : size xs = size ys -> extseq xs ys = xs.\n  Proof.\n    elim: xs ys => [| x xs IH] [| y ys] //= Hs. move: (eq_add_S _ _ Hs) => {}Hs.\n    rewrite (IH _ Hs). reflexivity.\n  Qed.\n\n  Lemma extseq_lesize xs ys :\n    size xs <= size ys -> extseq xs ys = xs ++ nseq (size ys - size xs) a.\n  Proof.\n    elim: xs ys => [| x xs IH] [| y ys] //=.\n    - move=> _. rewrite extseq0s. reflexivity.\n    - move=> Hs. move: (ltnSE Hs) => {}Hs. rewrite subSS. rewrite (IH _ Hs).\n      reflexivity.\n  Qed.\n\n  Lemma extseq_gesize xs ys : size ys <= size xs -> extseq xs ys = take (size ys) xs.\n  Proof.\n    elim: xs ys => [| x xs IH] [| y ys] //=. move=> Hs. move: (ltnSE Hs) => {}Hs.\n    rewrite (IH _ Hs). reflexivity.\n  Qed.\n\n  Lemma size_extseq xs ys : size (extseq xs ys) = size ys.\n  Proof.\n    case Hseq: (size xs == size ys).\n    - rewrite (extseq_eqsize (eqP Hseq)). exact: (eqP Hseq).\n    - case/orP: (leq_total (size xs) (size ys)) => Hs.\n      + rewrite (extseq_lesize Hs). rewrite seq.size_cat size_nseq.\n        rewrite (subnKC Hs). reflexivity.\n      + rewrite (extseq_gesize Hs). rewrite size_take. rewrite leq_eqVlt in Hs.\n        rewrite eq_sym in Hseq. rewrite Hseq /= in Hs. rewrite Hs. reflexivity.\n  Qed.\n\nEnd ExtSeq.\n",
      "theorem": "Lemma map2_comm xs ys : map2 f xs ys = map2 f ys xs.",
      "ground_truth": "Proof.\n    elim: xs ys => [| x xs IH] [| y ys] //=.\n    rewrite !map2_cons. rewrite f_commutative IH. reflexivity.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 6,
      "prefix": "From Coq Require Import Arith Lia.\nNotation \"'Sigma' x .. y , p\" :=\n  (sigT (fun x => .. (sigT (fun y => p)) ..))\n    (at level 200, x binder, right associativity,\n     format \"'[' 'Sigma'  '/  ' x  ..  y ,  '/  ' p ']'\")\n  : type_scope.\nNotation pi1 := projT1.\nNotation pi2 := projT2.\n\nDefinition size_rec {X: Type} (sigma: X -> nat) {p: X -> Type} :\n  (forall x, (forall y, sigma y < sigma x -> p y) -> p x) ->\n  (forall x, p x).\nProof.\n  intros F.\n  enough (forall n x, sigma x < n -> p x) as H.\n  { intros x. apply (H (S (sigma x))). lia. }\n  induction n as [|n IH]; intros x H.\n  - exfalso. lia.\n  - apply F. intros y H1. apply IH. lia.\nDefined.\n\nDefinition size_rec2 {X Y: Type} (sigma: X -> Y -> nat) {p: X -> Y -> Type} :\n  (forall x y, (forall x' y', sigma x' y' < sigma x y -> p x' y') -> p x y) ->\n  (forall x y, p x y).\nProof.\n  intros F.\n  enough (forall '(x,y), p x y) as H.\n  { intros x y. apply (H (x,y)). } \n  refine (size_rec (fun '(x,y) => sigma x y) (fun '(x,y) IH => _)). cbn in IH.\n  apply F. intros x' y' H. apply (IH (x',y')), H.\nDefined.\n\nNotation agree f g := (forall x y, f x y = g x y).\nNotation respects f p := (forall x y, p x y (f x y)).\nNotation functional p := (forall x y z z', p x y z -> p x y z' -> z = z').\n\n\n(*** Euclidean Division *)\n\nDefinition delta x y k := k * S y <= x < S k * S y.\n\nDefinition Delta f x y :=\n  if le_lt_dec x y then 0 else S (f (x - S y) y).\n\nFact Delta_unique f g :\n  agree f (Delta f) -> agree g (Delta g) -> agree f g.\nProof.\n  intros H1 H2 x y. revert x.\n  apply (size_rec (fun x => x)).\n  intros x IH. rewrite H1, H2. unfold Delta.\n  destruct le_lt_dec as [H|H]. reflexivity.\n  f_equal. apply IH. lia.\nQed.\n\nFact delta_fun :\n  functional delta. \nProof.\n  unfold delta. nia.\nQed.\n\nFact delta1 x y :\n  x <= y -> delta x y 0.",
      "suffix": "\n\nFact delta2 x y z :\n  x > y -> delta (x - S y) y z -> delta x y (S z).\nProof.\n  unfold delta. lia.\nQed.\n\nDefinition div_rec (y: nat) {p: nat -> Type} :\n  (forall x, x <= y -> p x) ->\n  (forall x, x > y -> p (x - S y) -> p x) ->\n  forall x, p x.\nProof.\n  intros e1 e2.\n  apply (size_rec (fun x => x)).\n  intros x IH.\n  destruct (le_lt_dec x y) as [H|H].\n  - apply e1. exact H.\n  - apply e2. exact H. apply IH. lia.\nDefined.\n\nDefinition Div :\n  forall x y, Sigma z, delta x y z.\nProof.\n  intros x y. revert x. apply (div_rec y).\n  - intros x H. exists 0. apply delta1, H.\n  - intros x H [z IH]. exists (S z). apply delta2. exact H. exact IH.\nDefined.\n\nDefinition div (x y: nat) : nat :=\n  match y with\n  | 0 => 0\n  | S y' => pi1 (Div x y')\n  end.\n\nCompute div 7 3.\nCompute div 48 8.\n\nFact Delta_delta f :\n  agree f (Delta f) -> respects f delta.\nProof.\n  intros H x y. \n  revert x.\n  apply (size_rec (fun x => x)).\n  intros x IH. rewrite H. unfold Delta.\n  destruct le_lt_dec as [H1|H1].\n  - apply delta1, H1.\n  - apply delta2. exact H1. apply IH. lia.\nQed.\n\nFact delta_Delta f :\n  respects f delta -> agree f (Delta f).\nProof.\n  intros H x y.\n  apply (delta_fun x y).\n  - apply H.\n  - unfold Delta.\n    destruct le_lt_dec as [H1|H1].\n    + apply delta1. exact H1.\n    + apply delta2. exact H1. apply H.\nQed.\n\nDefinition div' : nat -> nat -> nat.\nProof.\n  intros x [|y]. exact 0.\n  revert x. apply (div_rec y).\n  - exact (fun _ _ => 0).\n  - exact (fun _ _ => S).\nDefined.\n\nCompute div' 7 3.\n\n(*** Greatest Common Divisors *)\n\nDefinition Gamma f x y :=\n  match x, y with\n  | 0, y => y\n  | S x, 0 => S x\n  | (S x), (S y) => if le_lt_dec x y then f (S x) (y - x) else f (x - y) (S y)\n  end.\n\n(** NB: Uniqueness of Gamma follows best with binary size recursion. *)\nFact Gamma_unique f g :\n  agree f (Gamma f) -> agree g (Gamma g) -> agree f g.\nProof.\n  intros F G.\n  refine (size_rec2 (fun x y => x + y) _).\n  intros x y IH. rewrite F, G.\n  destruct x as [|x]. reflexivity.\n  destruct y as [|y]. reflexivity.\n  cbn. destruct le_lt_dec as [H|H]; apply IH; lia.\nQed.\n\n(** Totality of gcd relation follows best with gcd recursion. *)\nDefinition gcd_rec (p: nat -> nat -> Type) :\n  (forall y, p 0 y) ->\n  (forall x y, p y x -> p x y) ->\n  (forall x y, x <= y -> p x (y - x) -> p x y) ->\n  forall x y, p x y.\nProof.\n  intros e1 e2 e3.\n  apply (size_rec2 (fun x y => x + y)).\n  intros x y IH.\n  destruct x.\n  - apply e1.\n  - destruct y.\n    + apply e2,e1.\n    + destruct (le_lt_dec x y) as [H|H].\n      * apply e3. lia. apply IH. lia.\n      * apply e2,e3. lia. apply IH. lia.\nDefined.\n\nDefinition gcd' : nat -> nat -> nat.\nProof.\n  apply (gcd_rec (fun _ _ => nat)).\n  - exact (fun x => x).\n  - exact (fun _ _ x => x).\n  - exact (fun _ _ _ x => x).\nDefined.\n\nCompute gcd' 49 63.\n\nSection Gcd_relation.\n  Variable gamma: nat -> nat -> nat -> Prop.\n  Variable gamma1: forall y, gamma 0 y y.\n  Variable gamma2: forall x y z, gamma x y z -> gamma y x z.\n  Variable gamma3: forall x y z, x <= y -> gamma x (y - x) z -> gamma x y z.\n\n  Definition GCD :\n    forall x y, Sigma z, gamma x y z.\n  Proof.\n      apply gcd_rec.\n      - intros y. exists y. apply gamma1.\n      - intros x y [z IH]. exists z. apply gamma2, IH.\n      - intros x y H [z IH]. exists z. apply gamma3. exact H. exact IH.\n  Defined.\n\n  Definition gcd (x y: nat) : nat :=\n    pi1 (GCD x y).\n    \n  Compute gcd 49 63.\n\n  Fact Gamma_gamma f :\n    agree f (Gamma f) -> respects f gamma.\n  Proof.\n    intros H. hnf.\n    apply (size_rec2 (fun x y => x + y)).\n    intros x y IH. rewrite H.\n    destruct x.\n    - apply gamma1.\n    - destruct y.\n      + apply gamma2, gamma1.\n      + cbn. destruct le_lt_dec as [H1|H1].\n        * apply gamma3. lia. apply IH. lia.\n        * apply gamma2,gamma3. lia. apply gamma2, IH. lia.\n  Qed.\n    \n  Fact gamma_Gamma f :\n    functional gamma -> respects f gamma -> agree f (Gamma f).\n  Proof.\n    intros H1 H2 x y. apply (H1 x y).\n    - apply H2.\n    - destruct x.\n      + apply gamma1.\n      + destruct y.\n        * apply gamma2, gamma1.\n        * cbn. destruct le_lt_dec as [H|H].\n          -- apply gamma3. lia. apply H2.\n          -- apply gamma2, gamma3. lia. apply gamma2, H2.\n  Qed.\nEnd Gcd_relation.\n\nDefinition gcd_rel (gamma: nat -> nat -> nat -> Prop) :=\n  (forall y, gamma 0 y y) /\\\n  (forall x y z, gamma x y z -> gamma y x z) /\\\n  (forall x y z, x <= y -> gamma x (y - x) z -> gamma x y z).\n\nFact fun_gcd_rel_agree G G' :\n  gcd_rel G -> functional G ->\n  gcd_rel G' -> \n  forall x y z, G x y z -> G' x y z.\nProof.\n  intros (H1&H2&H3) Hfun (H1'&H2'&H3').\n  assert (Sigma g, respects g G) as [g Hg].\n  { exists (fun x y => pi1 (GCD G H1 H2 H3 x y)).\n    intros x y. exact (pi2 (GCD G H1 H2 H3 x y)). }\n  assert (respects g G') as Hg'.\n  { apply (Gamma_gamma G' H1' H2' H3').\n    eapply (gamma_Gamma G H1 H2 H3).\n    exact Hfun. exact Hg. }\n  intros x y z H.\n  assert (z = g x y) as ->.\n  { eapply Hfun. exact H. apply Hg. }\n  apply Hg'.\nQed.\n\nFact Gamma_fun_gcd_rel f :\n  agree f (Gamma f) -> gcd_rel (fun x y z => f x y = z).\nProof.\n  intros H. repeat split.\n  - intros y. rewrite H. reflexivity.\n  - refine (size_rec2 (fun x y => x + y) _).\n    intros x y IH z. rewrite H, H.\n    destruct x as [|x], y as [|y]; cbn. 1-3:easy.\n    destruct le_lt_dec as [H1|H1]; destruct le_lt_dec as [H2|H2].\n    + assert (x = y) as <- by lia. easy.\n    + apply IH. lia.\n    + apply IH. lia. \n    + exfalso. lia.\n  - destruct x as [|x], y as [|y]; cbn. 1-3:easy.\n    intros z H1 H2. rewrite H. cbn.\n    destruct le_lt_dec as [H3|H3].\n    + exact H2.\n    + exfalso. lia.\nQed.\n\n\n(*** Concrete GCD Relation *)\n\nDefinition divides n x : Prop := exists k, x = k * n.\nNotation \"( n | x )\" := (divides n x) (at level 0) : nat_scope.\n\nDefinition gamma x y z : Prop :=\n  forall n, (n | z) <-> (n | x) /\\ (n | y).\n\nFact divides_zero n :\n  (n | 0).\nProof.\n  exists 0. reflexivity.\nQed.\n\nFact divides_self x :\n  (x | x).\nProof.\n  exists 1. lia.\nQed.\n\nFact divides_minus x y n :\n  x <= y -> (n | x) -> (n | y) <->  (n | y - x).\nProof.\n  intros H [k ->]. split.\n  - intros [l ->]. exists (l-k). nia.\n  - intros [l H1]. exists (k + l). nia.\nQed.\n\nFact divides_bnd n x :\n  x > 0 -> (n | x) -> n <= x.\nProof.\n  intros H [k ->]. destruct k; lia.\nQed.\n\nFact divides_bnd' n x :\n  n > x -> (n | x) -> x = 0.\nProof.\n  intros H [k ->]. destruct k; lia.\nQed.\n \nFact divides_le x y :\n  (forall n, (n | x) <-> (n | y)) -> x <= y.\nProof.\n  intros H.\n  destruct y.\n  - enough (x = 0) by lia.\n    apply divides_bnd' with (n:= S x). lia.\n    apply H, divides_zero.\n  - apply divides_bnd. lia.\n    apply H, divides_self.\nQed.\n\nFact gamma1 y :\n  gamma 0 y y.\nProof.\n  intros n. generalize (divides_zero n). tauto.\nQed.\n\nFact gamma2 x y z :\n  gamma x y z -> gamma y x z.\nProof.\n  unfold gamma. firstorder.\nQed.\n\nFact gamma3 x y z :\n  x <= y -> gamma x (y - x) z -> gamma x y z.\nProof.\n  intros H H1 n.\n  specialize (H1 n).\n  generalize (divides_minus _ _ n H).\n  tauto.\nQed.\n\nFact gamma_agree x y z z' n :\n  gamma x y z -> gamma x y z' -> (n | z) <-> (n | z').\nProof.\n  intros H H'. specialize (H n). specialize (H' n). tauto.\nQed.\n\nFact gamma_fun :\n  functional gamma.\nProof.\n  hnf. intros * H H'.\n  enough (z <= z' /\\ z' <= z) by lia.\n  split;\n    apply divides_le; intros n;\n    eapply gamma_agree; eassumption.\nQed.\n\nFact Gamma_concrete_gamma g :\n  agree g (Gamma g) <-> forall x y n, (n | g x y) <-> (n | x) /\\ (n | y).\nProof.\n  split; intros H.\n  - apply (Gamma_gamma gamma gamma1 gamma2 gamma3), H.\n  - apply (gamma_Gamma gamma gamma1 gamma2 gamma3).\n    + apply gamma_fun.\n    + exact H.\nQed.\n\n(*** GCDs with modulo *)\n\nModule GCD_mod.\nSection GCD_mod.\n  Variable M: nat -> nat -> nat.\n  Variable M_eq : forall x y, M x y = if le_lt_dec x y then x else M (x - S y) y.\n\n  Fact M_le {x y} :\n    M x y <= y.\n  Proof.\n    revert x.\n    refine (size_rec (fun x => x) _).\n    intros x IH. rewrite M_eq.\n    destruct le_lt_dec as [H|H]. exact H.\n    apply IH. lia.\n  Qed.\n  \n  Variable gamma: nat -> nat -> nat -> Prop.\n  Variable gamma1: forall y, gamma 0 y y.\n  Variable gamma2: forall x y z, gamma x y z -> gamma y x z.\n  Variable gamma3: forall x y z, x <= y -> gamma x (y - x) z -> gamma x y z.\n\n  Fact gamma_M x y z :\n    gamma (M y x) (S x) z -> gamma (S x) y z.\n  Proof.\n    revert y.\n    refine (size_rec (fun x => x) _).\n    intros y IH.\n    rewrite M_eq.\n    destruct le_lt_dec as [H|H].\n    - apply gamma2.\n    - intros H1. apply gamma3. lia. apply IH. lia. exact H1.\n  Qed.\n  \n  Variable G: nat -> nat -> nat.\n  Variable G_eq: forall x y, G x y = match x with 0 => y | S x' => G (M y x') x end.\n\n  Fact G_gamma :\n    respects G gamma.\n  Proof.\n    refine (size_rec (fun x => x) _).\n    intros x IH y. rewrite G_eq.\n    destruct x; cbn.\n    - apply gamma1.\n    - apply gamma_M. apply IH.\n      enough (M y x <= x) by lia.\n      apply M_le.\n  Qed.\n\n  Fact gamma_functional_respects g :\n    respects g gamma -> functional gamma ->\n    forall x y, g x y = match x with 0 => y | S x' => g (M y x') x end.\n  Proof.\n    intros HR HF x y.\n    apply (HF x y).\n    - apply HR.\n    - destruct x.\n      + apply gamma1.\n      + apply gamma_M, HR.\n  Qed.\nEnd GCD_mod.\nEnd GCD_mod.\n\n(*** Predefined gcd function *)\n\nFact predefined_gcd x y :\n  gamma x y (Nat.gcd x y).\nProof.\n  intros n. split.\n  - unfold divides. intros [k1 H]. split.\n    + destruct (Nat.gcd_divide_l x y) as [k2 H1]. exists (k2 * k1). lia.\n    + destruct (Nat.gcd_divide_r x y) as [k2 H1]. exists (k2 * k1). lia.\n  - intros [H1 H2]. apply Nat.gcd_greatest; assumption.\nQed.\n\n\n(*** Step-indexed GCD *)\n\nModule Gcd_Step_Indexed.\nFixpoint G k x y := match k with 0 => 0 | S k' => Gamma (G k') x y end.\nDefinition gcd x y := G (S (x + y)) x y.\n\nCompute gcd 12 16.\n\nFact G_index k k' x y :\n  k > x + y -> k' >  x + y -> G k x y = G k' x y.\nProof.\n  induction k as [|k IH] in k',x,y |-*;\n    intros H1 H2.\n  - exfalso. lia.\n  - destruct k'; cbn.\n    + exfalso. lia.\n    + destruct x. reflexivity. \n      destruct y. reflexivity.\n      cbn. destruct le_lt_dec; eapply IH;  lia.\nQed.\n\nFact Gamma_sat_gcd :\n  agree gcd (Gamma gcd).\nProof.\n  hnf. intros [|x] y. reflexivity.\n  destruct y as [|y]. reflexivity.\n  unfold gcd at 1. cbn [Gamma G]. \n  destruct le_lt_dec as [H|H];\n    apply G_index; lia.\nQed.\nEnd Gcd_Step_Indexed.\n\n(*** Step-indexed Fibonacci *)\n\nDefinition Phi (f: nat -> nat) (n: nat) : nat :=\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | S (S n') => f n' + f (S n')\n  end.\n\nNotation agree1 f g := (forall n, f n = g n).\n\nFact phi_unique f g :\n  agree1 f (Phi f) -> agree1 g (Phi g) -> agree1 f g.\nProof.\n  intros H1 H2.\n  apply (size_rec (fun n => n)).\n  intros n IH. rewrite H1, H2.\n  destruct n. reflexivity.\n  destruct n. reflexivity.\n  cbn. f_equal; apply IH; lia.\nQed.\n\nFixpoint Fib k n := match k with 0 => 0 | S k' => Phi (Fib k') n end.\nDefinition fib n := Fib (S n) n.\n\nCompute fib 10.\n\nFact Fib_index n k k' :\n  n < k -> n < k' -> Fib k n = Fib k' n.\nProof.\n  induction k as [|k IH] in k', n |-*;\n    intros H1 H2.\n  - exfalso. lia.\n  - destruct k'.\n    + exfalso. lia.\n    + destruct n. reflexivity.\n      destruct n. reflexivity.\n      cbn. f_equal; apply IH; lia.\nQed.\n\nFact Phi_fib :\n  agree1 fib (Phi fib).\nProof.\n  intros [|n]. reflexivity.\n  destruct n. reflexivity.\n  (* simplification of Fib overshoots *)\n  change (fib (S (S n))) with (Phi (Fib (S (S n))) (S (S n))).\n  cbn [Phi]. f_equal. apply Fib_index; lia.\nQed.\n\nDefinition fib_rec {p: nat -> Type} :\n  p 0 ->\n  p 1 ->\n  (forall n, p n -> p (S n) -> p (S(S n))) ->\n  forall n, p n.\nProof.\n  intros e1 e2 e3.\n  apply (size_rec (fun n => n)).\n  intros n IH.\n  destruct n. exact e1.\n  destruct n. exact e2.\n  apply e3; apply IH; lia.\nDefined.\n\nDefinition fib' : nat -> nat.\nProof.\n  refine (fib_rec 0 1 _).\n  exact (fun n a b => a + b).\nDefined.\n\nCompute fib' 10.\n",
      "theorem": "Fact delta1 x y :\n  x <= y -> delta x y 0.",
      "ground_truth": "Proof.\n  unfold delta. lia.\nQed."
    },
    {
      "split": "train-sft",
      "index": 7,
      "prefix": "Require Import Bool String List Program.Equality Program.Basics.\nRequire Import FunctionalExtensionality Classes.Morphisms.\nRequire Import Lib.CommonTactics Lib.FMap Lib.Struct Lib.StringEq.\nRequire Import Kami.Syntax Kami.Semantics Kami.Wf.\n\nSet Implicit Arguments.\nSet Asymmetric Patterns.\n\nLocal Ltac Tauto.intuition_solver ::= auto with exfalso datatypes.\n\nLtac specializeAll k :=\n  repeat\n    match goal with\n    | [H: forall _, _ |- _] => specialize (H k)\n    end.\n\nSection LiftToMap.\n  Variable A: Type.\n  Variable p: M.key -> A -> option A.\n\n  Lemma transpose_neqkey_rmModify:\n    M.F.P.transpose_neqkey eq (rmModify p).\n  Proof.\n    unfold M.F.P.transpose_neqkey; intros.\n    unfold rmModify.\n    destruct (p k e), (p k' e'); intuition.\n  Qed.\n\n  Theorem liftToMap1_empty: liftToMap1 p (M.empty _) = M.empty _.\n  Proof.\n    unfold liftToMap1, M.fold; reflexivity.\n  Qed.\n\n  Theorem liftToMap1_MapsTo:\n    forall m k v, M.MapsTo k v (liftToMap1 p m) <->\n                  exists v', p k v' = Some v /\\ M.MapsTo k v' m.\n  Proof.\n    intros m; M.mind m.\n    - constructor; intros.\n      + apply M.F.P.F.empty_mapsto_iff in H; intuition.\n      + dest; subst.\n        apply M.F.P.F.empty_mapsto_iff in H0; intuition.\n    - constructor; intros.\n      unfold liftToMap1 in H1.\n      rewrite (M.F.P.fold_add (eqA := eq)) in H1; try apply transpose_neqkey_rmModify; intuition.\n      fold (liftToMap1 p m) in H1.\n      unfold rmModify in H1.\n      case_eq (p k v); intros; subst.\n      rewrite H2 in H1.\n      + apply M.F.P.F.add_mapsto_iff in H1; dest.\n        destruct H1; dest; subst.\n        * exists v; intuition.\n          apply M.F.P.F.add_mapsto_iff; intuition.\n        * destruct (H k0 v0); dest; subst.\n          specialize (H4 H3); dest; subst.\n          exists x.\n          intuition.\n          apply M.F.P.F.add_mapsto_iff; intuition.\n      + rewrite H2 in H1.\n        destruct (H k0 v0); dest; subst.\n        specialize (H3 H1); dest; subst.\n        exists x.\n        intuition.\n        apply M.F.P.F.add_mapsto_iff; right; intuition.\n        subst.\n        apply M.MapsToIn1 in H5.\n        intuition.\n      + dest; subst.\n        apply M.F.P.F.add_mapsto_iff in H2; dest.\n        destruct H2; dest; try subst.\n        * unfold liftToMap1.\n          rewrite (M.F.P.fold_add (eqA := eq)); try apply transpose_neqkey_rmModify; intuition.\n          unfold rmModify at 1.\n          rewrite H1.\n          apply M.F.P.F.add_mapsto_iff; intuition.\n        * unfold liftToMap1.\n          rewrite (M.F.P.fold_add (eqA := eq)); try apply transpose_neqkey_rmModify; intuition.\n          unfold rmModify at 1.\n          fold (liftToMap1 p m).\n          specialize (H k0 v0).\n          assert (sth: exists x, p k0 x = Some v0 /\\ M.MapsTo k0 x m) by (eexists; eauto).\n          apply H in sth.\n          destruct (p k v); intuition.\n          apply M.F.P.F.add_mapsto_iff; intuition.\n  Qed.\n\n  Lemma liftToMap1_DomainSubset s: M.DomainSubset (liftToMap1 p s) s.\n  Proof.\n    apply (M.map_induction (P := fun s => M.DomainSubset (liftToMap1 p s) s));\n      unfold M.DomainSubset; intros.\n    - rewrite liftToMap1_empty in *.\n      intuition.\n    - unfold liftToMap1 in H1.\n      rewrite M.F.P.fold_add in H1; fold (liftToMap1 p m) in *; unfold rmModify.\n      + apply M.F.P.F.add_in_iff.\n        unfold rmModify in *.\n        destruct (p k v).\n        apply M.F.P.F.add_in_iff in H1.\n        destruct H1; intuition.\n        right; apply (H _ H1).\n      + intuition.\n      + clear; unfold Morphisms.Proper, Morphisms.respectful; intros; subst.\n        apply M.leibniz in H1; subst.\n        intuition auto with MapDefs.\n      + clear; unfold M.F.P.transpose_neqkey; intros.\n        unfold rmModify.\n        destruct (p k e), (p k' e');\n          try apply M.transpose_neqkey_Equal_add; intuition auto with MapDefs.\n      + intuition.\n  Qed.\n        \n  Theorem liftToMap1_add_one k v:\n    liftToMap1 p (M.add k v (M.empty _)) =\n    match p k v with\n      | Some argRet => M.add k argRet (M.empty _)\n      | None => M.empty _\n    end.\n  Proof.\n    case_eq (p k v); unfold liftToMap1, rmModify, M.fold; simpl.\n    intros a H.\n    rewrite H; reflexivity.\n    intros H.\n    rewrite H; reflexivity.\n  Qed.\n\n  Lemma liftToMap1_find:\n    forall (m: M.t A) k,\n      M.find k (liftToMap1 p m) = match M.find k m with\n                                   | Some v => p k v\n                                   | None => None\n                                   end.\n  Proof.\n    intros.\n    case_eq (M.find k (liftToMap1 p m)); intros.\n    - apply M.Facts.P.F.find_mapsto_iff in H.\n      apply liftToMap1_MapsTo in H; dest; subst.\n      apply M.F.P.F.find_mapsto_iff in H0.\n      rewrite H0; auto.\n    - apply M.F.P.F.not_find_in_iff in H.\n      case_eq (M.find k m); intros; auto.\n      apply M.Facts.P.F.find_mapsto_iff in H0.\n      case_eq (p k a); intros; auto.\n      assert (exists v', p k v' = Some a0 /\\ M.MapsTo k v' m).\n      { eexists; eauto. }\n      apply liftToMap1_MapsTo in H2.\n      elim H. \n      eapply M.MapsToIn1; eauto.\n  Qed.\n\n  Ltac liftToMap1_find_tac :=\n    repeat\n      match goal with\n      | [H: context [M.find _ (liftToMap1 _ _)] |- _] =>\n        rewrite liftToMap1_find in H\n      | [ |- context [M.find _ (liftToMap1 _ _)] ] =>\n        rewrite liftToMap1_find\n      end.\n\n  Lemma liftToMap1_union:\n    forall (m1 m2: M.t A),\n      M.Disj m1 m2 ->\n      liftToMap1 p (M.union m1 m2) = M.union (liftToMap1 p m1) (liftToMap1 p m2).\n  Proof.\n    intros; M.ext y.\n    findeq.\n    findeq_custom liftToMap1_find_tac.\n    destruct (p y a); auto.\n  Qed.\n\n  Lemma liftToMap1_subtractKV_1:\n    forall (deceqA: forall x y : A, sumbool (x = y) (x <> y)) (m1 m2: M.t A),\n      M.Disj m1 m2 ->\n      M.subtractKV deceqA (liftToMap1 p m1) (liftToMap1 p m2) =\n      liftToMap1 p (M.subtractKV deceqA m1 m2).\n  Proof.\n    intros; M.ext y.\n    findeq.\n    findeq_custom liftToMap1_find_tac.\n    destruct (p y a); auto.\n  Qed.\n\n  Lemma liftToMap1_subtractKV_2:\n    forall (deceqA: forall x y : A, sumbool (x = y) (x <> y)) (m1 m2: M.t A),\n      (forall k v1 v2, M.find k m1 = Some v1 -> M.find k m2 = Some v2 -> v1 = v2) ->\n      M.subtractKV deceqA (liftToMap1 p m1) (liftToMap1 p m2) =\n      liftToMap1 p (M.subtractKV deceqA m1 m2).\n  Proof.\n    intros; M.ext y.\n    findeq.\n    findeq_custom liftToMap1_find_tac.\n    - specialize (H _ _ _ (eq_sym Heqv) (eq_sym Heqv0)); subst.\n      destruct (p y a0).\n      + destruct (deceqA a a); [|elim f; reflexivity].\n        destruct (deceqA a0 a0); [|elim f; reflexivity]; auto.\n      + destruct (deceqA a0 a0); [|elim f; reflexivity]; auto.\n    - destruct (p y a); auto.\n  Qed.\n\nEnd LiftToMap.\n\n(* For global use *)\nLtac liftToMap1_find_tac :=\n  repeat\n    match goal with\n    | [H: context [M.find _ (liftToMap1 _ _)] |- _] =>\n      rewrite liftToMap1_find in H\n    | [ |- context [M.find _ (liftToMap1 _ _)] ] =>\n      rewrite liftToMap1_find\n    end.\n\nLemma liftToMap1_idElementwise_add A m:\n  forall k (v: A),\n    liftToMap1 (@idElementwise _) (M.add k v m) =\n    rmModify (@idElementwise _) k v (liftToMap1 (@idElementwise _) m).\nProof.\n  intros; remember (M.find k m) as okm. destruct okm.\n  - apply eq_sym, M.find_add_3 in Heqokm.\n    destruct Heqokm as [sm [? ?]]; subst.\n    rewrite M.add_idempotent.\n    unfold liftToMap1.\n    rewrite M.F.P.fold_add; [|auto|auto| |auto].\n    rewrite M.F.P.fold_add; [|auto|auto| |auto].\n    unfold rmModify; simpl in *.\n    rewrite M.add_idempotent; reflexivity.\n    + apply M.transpose_neqkey_eq_add; intuition.\n    + apply M.transpose_neqkey_eq_add; intuition.\n  - unfold liftToMap1, rmModify; simpl in *.\n    rewrite M.F.P.fold_add; auto.\n    apply M.F.P.F.not_find_in_iff; auto.\nQed.\n\nLemma liftToMap1_idElementwise_id A m:\n  liftToMap1 (@idElementwise A) m = m.\nProof.\n  M.mind m; simpl in *.\n  - rewrite liftToMap1_empty; reflexivity.\n  - rewrite liftToMap1_idElementwise_add.\n    unfold rmModify; simpl in *.\n    rewrite H.\n    reflexivity.\nQed.\n\nLemma idElementwiseId A: liftToMap1 (@idElementwise A) = id.\nProof.\n  apply functional_extensionality; intros.\n  apply liftToMap1_idElementwise_id.\nQed.\n\nLemma wellHidden_find_1:\n  forall m a (l: LabelT),\n    In a (namesOf (getDefsBodies m)) ->\n    wellHidden m (hide l) ->\n    M.find a (calls l) = None \\/ M.find a (defs l) = M.find a (calls l).\nProof.\n  unfold wellHidden, hide; intros.\n  destruct l as [rm dm cm]; simpl in *; dest.\n  specialize (H1 _ H).\n  findeq.\nQed.\n\nLemma wellHidden_find_2:\n  forall m a (l: LabelT),\n    In a (namesOf (getDefsBodies m)) ->\n    In a (getCalls m) ->\n    wellHidden m (hide l) ->\n    M.find a (defs l) = M.find a (calls l).\nProof.\n  unfold wellHidden, hide; intros.\n  destruct l as [rm dm cm]; simpl in *; dest.\n  specialize (H1 _ H0); specialize (H2 _ H).\n  findeq.\nQed.\n\nLemma wellHidden_weakening:\n  forall l m1 m2,\n    SubList (getCalls m1) (getCalls m2) ->\n    SubList (getDefs m1) (getDefs m2) ->\n    wellHidden m2 l ->\n    wellHidden m1 l.\nProof.\n  unfold wellHidden; intros.\n  dest; split.\n  - eapply M.KeysDisj_SubList; eauto.\n  - eapply M.KeysDisj_SubList; eauto.\nQed.\n\nLemma wellHidden_split:\n  forall ma mb la lb,\n    wellHidden (ConcatMod ma mb) (hide (mergeLabel la lb)) ->\n    DisjList (getDefs ma) (getDefs mb) ->\n    DisjList (getCalls ma) (getIntCalls mb) ->\n    DisjList (getIntCalls ma) (getCalls mb) ->\n    M.KeysSubset (calls la) (getCalls ma) ->\n    M.KeysSubset (calls lb) (getCalls mb) ->\n    M.KeysSubset (defs la) (getDefs ma) ->\n    M.KeysSubset (defs lb) (getDefs mb) ->\n    wellHidden ma (hide la) /\\ wellHidden mb (hide lb).\nProof.\n  intros.\n\n  assert (M.Disj (defs la) (defs lb))\n    by (eapply M.DisjList_KeysSubset_Disj with (d1:= getDefs ma); eauto).\n  \n  unfold wellHidden in *; dest.\n  destruct la as [anna dsa csa], lb as [annb dsb csb].\n  simpl in *; split; dest.\n\n  - split.\n    + clear H8; red in H1, H2.\n      unfold M.KeysDisj, M.KeysSubset in *; intros.\n      specializeAll k.\n      specialize (H (getCalls_in_1 ma mb _ H8)).\n      rewrite M.F.P.F.in_find_iff in *.\n      intro Hx; elim H; clear H.\n      findeq.\n      apply H1.\n      apply filter_In; split; [assumption|].\n      unfold string_in; apply existsb_exists; exists k.\n      split; [assumption|apply string_eq_true].\n    + clear H; red in H0.\n      unfold M.KeysDisj, M.KeysSubset in *; intros.\n      specializeAll k.\n      specialize (H8 (getDefs_in_1 ma mb _ H)).\n      rewrite M.F.P.F.in_find_iff in *.\n      intro Hx; elim H8; clear H8.\n      findeq.\n        \n  - split.\n    + clear H8; red in H1, H2.\n      unfold M.KeysDisj, M.KeysSubset in *; intros.\n      specializeAll k.\n      specialize (H (getCalls_in_2 ma mb _ H8)).\n      rewrite M.F.P.F.in_find_iff in *.\n      intro Hx; elim H; clear H.\n      findeq;\n        try (remember (M.find k dsb) as v; destruct v;\n             remember (M.find k csb) as v; destruct v; findeq).\n      * apply H9.\n        apply filter_In; split; [assumption|].\n        unfold string_in; apply existsb_exists; exists k.\n        split; [assumption|apply string_eq_true].\n      * apply H9.\n        apply filter_In; split; [assumption|].\n        unfold string_in; apply existsb_exists; exists k.\n        split; [assumption|apply string_eq_true].\n\n    + clear H; red in H0.\n      unfold M.KeysDisj, M.KeysSubset in *; intros.\n      specializeAll k.\n      specialize (H8 (getDefs_in_2 ma mb _ H)).\n      rewrite M.F.P.F.in_find_iff in *.\n      intro Hx; elim H8; clear H8.\n      findeq;\n        try (remember (M.find k csb) as v; destruct v;\n             remember (M.find k dsb) as v; destruct v; findeq).\n      * apply H9, H5; intros; discriminate.\n      * specialize (H1 k); destruct H1.\n        { elim H1; apply H3; intros; discriminate. }\n        { elim H1.\n          apply filter_In; split; [assumption|].\n          unfold string_in; apply existsb_exists; exists k.\n          split; [assumption|apply string_eq_true].\n        }\nQed.\n\nLemma hide_mergeLabel_disj:\n  forall la lb,\n    M.Disj (defs la) (calls lb) ->\n    M.Disj (defs lb) (calls la) ->\n    hide (mergeLabel la lb) = mergeLabel (hide la) (hide lb).\nProof.\n  unfold hide; destruct la as [anna dsa csa], lb as [annb dsb csb]; simpl; intros.\n  f_equal; meq.\nQed.\n\nLemma hide_mergeLabel_idempotent:\n  forall la lb,\n    M.Disj (defs la) (defs lb) ->\n    M.Disj (calls la) (calls lb) ->\n    hide (mergeLabel la lb) = hide (mergeLabel (hide la) (hide lb)).\nProof.\n  intros; destruct la as [anna dsa csa], lb as [annb dsb csb].\n  simpl in *; unfold hide; simpl; f_equal; meq.\nQed.\n\nLemma wellHidden_combine:\n  forall m la lb,\n    wellHidden m la ->\n    wellHidden m lb ->\n    wellHidden m (mergeLabel la lb).\nProof.\n  intros.\n  destruct la as [anna dsa csa], lb as [annb dsb csb].\n  unfold wellHidden in *; simpl in *; dest.\n  split; unfold M.KeysDisj in *; intros.\n  - specialize (H k H3); specialize (H0 k H3); findeq.\n  - specialize (H2 k H3); specialize (H1 k H3); findeq.\nQed.\n\nLemma wellHidden_mergeLabel_hide:\n  forall m la lb,\n    wellHidden m (hide la) ->\n    wellHidden m (hide lb) ->\n    M.KeysSubset (defs la) (getDefs m) ->\n    M.KeysSubset (calls la) (getCalls m) ->\n    M.KeysSubset (defs lb) (getDefs m) ->\n    M.KeysSubset (calls lb) (getCalls m) ->\n    mergeLabel (hide la) (hide lb) = hide (mergeLabel la lb).\nProof.\n  intros; destruct la as [anna dsa csa], lb as [annb dsb csb].\n  unfold hide, wellHidden in *; simpl in *; dest.\n  unfold M.KeysDisj, M.KeysSubset in *.\n  f_equal.\n\n  - meq; repeat\n           match goal with\n           | [H: forall _, _ |- _] => specialize (H y)\n           end.\n    + elim H0; [apply H4; findeq|findeq].\n    + elim H0; [apply H2; findeq|findeq].\n    + elim H; [apply H4; findeq|findeq].\n    + elim H6; [apply H3; findeq|findeq].\n    + elim H6; [apply H3; findeq|findeq].\n    + elim H6; [apply H3; findeq|findeq].\n\n  - meq; repeat\n           match goal with\n           | [H: forall _, _ |- _] => specialize (H y)\n           end.\n    + elim H0; [apply H4; findeq|findeq].\n    + elim H5; [apply H1; findeq|findeq].\n    + elim H6; [apply H3; findeq|findeq].\n    + elim H; [apply H4; findeq|findeq].\n    + elim H; [apply H4; findeq|findeq].\n    + elim H; [apply H4; findeq|findeq].\nQed.\n\nLemma canCombine_CanCombineUL:\n  forall m o u1 u2 ul1 ul2 cs1 cs2\n         (Hss1: Substep m o u1 ul1 cs1)\n         (Hss2: Substep m o u2 ul2 cs2),\n    canCombine {| substep := Hss1 |} {| substep := Hss2 |} <->\n    CanCombineUL u1 u2 (getLabel ul1 cs1) (getLabel ul2 cs2).\nProof.\n  unfold canCombine, CanCombineUL, CanCombineLabel; simpl; intros; split; intros; dest.\n  - repeat split; auto.\n    + destruct ul1 as [[r1|]|[[dmn1 dmb1]|]], ul2 as [[r2|]|[[dmn2 dmb2]|]]; auto.\n      specialize (H0 _ _ eq_refl eq_refl); simpl in H0.\n      auto.\n    + destruct ul1 as [[r1|]|[[dmn1 dmb1]|]], ul2 as [[r2|]|[[dmn2 dmb2]|]]; auto;\n        try (destruct H1; discriminate; fail).\n  - repeat split; auto.\n    + intros; destruct ul1 as [[r1|]|[[dmn1 dmb1]|]], ul2 as [[r2|]|[[dmn2 dmb2]|]];\n        try discriminate.\n      inv H3; inv H4; simpl.\n      intro Hx; subst.\n      specialize (H0 dmn2); destruct H0; findeq.\n    + intros; destruct ul1 as [[r1|]|[[dmn1 dmb1]|]], ul2 as [[r2|]|[[dmn2 dmb2]|]];\n        eexists; intuition idtac.\n\n      Unshelve.\n      exact None.\n      exact None.\n      exact None.\n      exact None.\nQed.\n   \nLemma CanCombineLabel_hide:\n  forall la lb,\n    CanCombineLabel la lb ->\n    CanCombineLabel (hide la) (hide lb).\nProof.\n  intros; destruct la as [anna dsa csa], lb as [annb dsb csb].\n  inv H; simpl in *; dest.\n  repeat split; unfold hide; simpl in *; auto.\n  - apply M.Disj_Sub with (m2:= dsa); [|apply M.subtractKV_sub].\n    apply M.Disj_comm.\n    apply M.Disj_Sub with (m2:= dsb); [|apply M.subtractKV_sub].\n    auto.\n  - apply M.Disj_Sub with (m2:= csa); [|apply M.subtractKV_sub].\n    apply M.Disj_comm.\n    apply M.Disj_Sub with (m2:= csb); [|apply M.subtractKV_sub].\n    auto.\nQed.\n\nLemma equivalentLabelSeq_length:\n  forall p lsa lsb,\n    equivalentLabelSeq p lsa lsb ->\n    List.length lsa = List.length lsb.\nProof. induction lsa; intros; inv H; simpl; auto. Qed.\n\nLemma equivalentLabelSeq_CanCombineLabelSeq:\n  forall p (Hp: Proper (equivalentLabel p ==> equivalentLabel p ==> impl) CanCombineLabel)\n         lsa lsb lsc lsd,\n    equivalentLabelSeq p lsa lsb ->\n    equivalentLabelSeq p lsc lsd ->\n    CanCombineLabelSeq lsa lsc ->\n    CanCombineLabelSeq lsb lsd.\nProof.\n  ind lsa.\n  - destruct lsc; intuition idtac.\n    inv H; inv H0; constructor.\n  - destruct lsc; intuition idtac.\n    inv H; inv H0; constructor; [|eapply IHlsa; eauto].\n    eapply Hp; eauto.\nQed.\n\nLemma hide_idempotent:\n  forall (l: LabelT), hide l = hide (hide l).\nProof.\n  intros; destruct l as [ann ds cs].\n  unfold hide; simpl; f_equal;\n  apply M.subtractKV_idempotent.\nQed.\n\nLemma hide_empty:\n  forall a,\n    hide {| annot := a; defs := []%fmap; calls := []%fmap |} =\n    {| annot := a; defs := []%fmap; calls := []%fmap |}.\nProof. reflexivity. Qed.\n\nLemma step_empty:\n  forall m o a,\n    (a = None \\/ a = Some None) ->\n    Step m o []%fmap {| annot := a; defs := []%fmap; calls := []%fmap |}.\nProof.\n  intros; apply step_consistent.\n  rewrite <-hide_empty.\n  constructor; [|unfold wellHidden; cbn; split; apply M.KeysDisj_empty].\n\n  destruct H; subst.\n  - constructor.\n  - eapply SubstepsCons.\n    + apply SubstepsNil.\n    + apply EmptyRule.\n    + repeat split; auto.\n    + reflexivity.\n    + reflexivity.\nQed.\n\nLemma step_hide:\n  forall m o u l,\n    Step m o u l -> hide l = l.\nProof.\n  intros; apply step_consistent in H; inv H.\n  rewrite <-hide_idempotent; auto.\nQed.\n\nInductive HiddenLabelSeq: LabelSeqT -> Prop :=\n| HLSNil: HiddenLabelSeq nil\n| HLSCons:\n    forall l ll,\n      HiddenLabelSeq ll ->\n      hide l = l ->\n      HiddenLabelSeq (l :: ll).\n\nLemma behavior_hide:\n  forall m n ll,\n    Behavior m n ll -> HiddenLabelSeq ll.\nProof.\n  intros; inv H.\n  induction HMultistepBeh; [constructor|].\n  constructor; auto.\n  eapply step_hide; eauto.\nQed.\n\nSection EmptyDefs.\n  Variable m: Modules.\n  Variable o: RegsT.\n  Variable defsZero: getDefsBodies m = nil.\n  \n  Theorem substepsInd_zero u l:\n    SubstepsInd m o u l ->\n    defs l = M.empty _ /\\\n    Substep m o u match annot l with\n                    | None => Meth None\n                    | Some r => Rle r\n                  end (calls l).\n  Proof.\n    intros si.\n    dependent induction si.\n    - constructor; econstructor; eauto.\n    - dest; destruct l; subst.\n      inv H; simpl in *; repeat rewrite M.union_empty_L; constructor; auto;\n      repeat rewrite M.union_empty_R; unfold CanCombineUUL in *; simpl in *; dest.\n      + destruct annot; intuition.\n        inversion H4.\n        econstructor; eauto.\n      + destruct annot; auto.\n      + destruct annot.\n        * intuition.\n        * inversion H4.\n          rewrite M.union_empty_L, M.union_empty_R.\n          econstructor; eauto.\n      + rewrite defsZero in *.\n        intuition.\n      + rewrite defsZero in *.\n        intuition.\n  Qed.\n\n  Theorem substepsInd_zero_hide u l:\n    SubstepsInd m o u l ->\n    hide l = l.\n  Proof.\n    intros si.\n    apply substepsInd_zero in si; dest.\n    unfold hide; destruct l; simpl in *; subst.\n    rewrite M.subtractKV_empty_1.\n    rewrite M.subtractKV_empty_2.\n    reflexivity.\n  Qed.\n\n  Theorem step_zero u l:\n    Step m o u l ->\n    defs l = M.empty _ /\\\n    Substep m o u match annot l with\n                    | None => Meth None\n                    | Some r => Rle r\n                  end (calls l).\n  Proof.\n    intros si.\n    apply step_consistent in si.\n    inv si.\n    apply substepsInd_zero.\n    rewrite substepsInd_zero_hide with (u := u); auto.\n  Qed.\n\n  Theorem substepZero_imp_step u a cs:\n    Substep m o u a cs ->\n    Step m o u (getLabel a cs).\n  Proof.\n    intros si.\n    assert (sth: substepsComb ({| substep := si |} :: nil)).\n    { constructor 2.\n      constructor.\n      intuition.\n    }\n    pose proof (StepIntro sth); simpl in *.\n    unfold addLabelLeft in H;\n      unfold getSLabel in H.\n    assert (ua: unitAnnot\n                  {| upd := u; unitAnnot := a; cms := cs; substep := si |} = a) by reflexivity.\n    rewrite ua in H.\n    assert (ub: cms\n                  {| upd := u; unitAnnot := a; cms := cs; substep := si |} = cs) by reflexivity.\n    rewrite ub in H.\n    clear ua ub.\n    assert (st: mergeLabel (getLabel a cs) {| annot := None;\n                                          defs := M.empty _;\n                                          calls := M.empty _ |} = getLabel a cs).\n    { simpl.\n      destruct a.\n      - repeat rewrite M.union_empty_L, M.union_empty_R.\n        reflexivity.\n      - destruct o0;\n        try destruct a; repeat rewrite M.union_empty_L; repeat rewrite M.union_empty_R;\n        try reflexivity.\n    }\n    rewrite st in H; clear st.\n    rewrite M.union_empty_L in H.\n    assert (s: hide (getLabel a cs) = getLabel a cs).\n    { clear H sth.\n      unfold hide.\n      simpl.\n      destruct a; destruct o0; try destruct a; repeat rewrite M.subtractKV_empty_1;\n      repeat rewrite M.subtractKV_empty_2; try reflexivity.\n      inv si.\n      rewrite defsZero in HIn.\n      intuition.\n    }\n    rewrite s in *; clear s.\n    assert (t: wellHidden m (getLabel a cs)).\n    { clear sth H.\n      unfold wellHidden.\n      simpl in *.\n      unfold getDefs.\n      rewrite defsZero.\n      simpl in *.\n      destruct a;\n      constructor;\n      destruct o0; try destruct a;\n      try apply M.KeysDisj_empty; try apply M.KeysDisj_nil.\n      inversion si.\n      rewrite defsZero in HIn.\n      intuition.\n    }\n    apply H; intuition.\n  Qed.\n\nEnd EmptyDefs.\n\nLemma DisjList_string_cons:\n  forall l1 l2 (e: string),\n    ~ In e l2 -> DisjList l1 l2 -> DisjList (e :: l1) l2.\nProof.\n  unfold DisjList; intros.\n  destruct (string_dec e e0); subst; auto.\n  pose proof (H0 e0); clear H0.\n  inv H1; auto.\n  left; intro Hx; inv Hx; auto.\nQed.\n\nLemma isLeaf_implies_disj:\n  forall {retK} (a: ActionT typeUT retK) calls,\n    true = isLeaf a calls -> DisjList (getCallsA a) calls.\nProof.\n  induction a; simpl; intros; auto.\n  - apply eq_sym, andb_true_iff in H0; dest.\n    remember (string_in _ _) as sin; destruct sin; [inv H0|].\n    apply string_in_dec_not_in in Heqsin.\n    apply DisjList_string_cons; auto.\n  - apply eq_sym, andb_true_iff in H0; dest.\n    apply andb_true_iff in H0; dest.\n    apply DisjList_app_4; auto.\n    apply DisjList_app_4; auto.\n  - apply DisjList_nil_1.\nQed.\n\nLemma noCallsRules_implies_disj:\n  forall calls rules,\n    noCallsRules rules calls = true ->\n    DisjList (getCallsR rules) calls.\nProof.\n  induction rules; simpl; intros; [apply DisjList_nil_1|].\n  remember (isLeaf (attrType a typeUT) calls) as blf; destruct blf; [|discriminate].\n  apply DisjList_app_4.\n  - apply isLeaf_implies_disj; auto.\n  - apply IHrules; auto.\nQed.\n\nLemma noCallsDms_implies_disj:\n  forall calls dms,\n    noCallsDms dms calls = true ->\n    DisjList (getCallsM dms) calls.\nProof.\n  induction dms; simpl; intros; [apply DisjList_nil_1|].\n  remember (isLeaf (projT2 (attrType a) typeUT tt) calls) as blf; destruct blf; [|discriminate].\n  apply DisjList_app_4.\n  - apply isLeaf_implies_disj; auto.\n  - apply IHdms; auto.\nQed.\n\nLemma noInternalCalls_implies_disj:\n  forall m,\n    noInternalCalls m = true ->\n    DisjList (getCalls m) (getDefs m).\nProof.\n  unfold noInternalCalls, noCalls, getCalls, getDefs; simpl; intros.\n  apply andb_true_iff in H; dest.\n  apply DisjList_app_4.\n  - apply noCallsRules_implies_disj; auto.\n  - apply noCallsDms_implies_disj; auto.\nQed.\n\nSection Calls.\n  Variable m: Modules.\n  Variable mEquiv: ModEquiv type typeUT m.\n\n  Lemma callsA_subset k (a1: ActionT type k) (a2: ActionT typeUT k):\n    ActionEquiv a1 a2 ->\n    forall o u cs r,\n      SemAction o a1 u cs r ->\n      forall x, M.In x cs -> In x (getCallsA a2).\n  Proof.\n    intro ae.\n    induction ae; fold type in *; fold typeUT in *; subst; intros.\n    - dependent destruction H1.\n      apply M.F.P.F.add_in_iff in H2.\n      specialize (@H0 _ tt _ _ _ _ H1 x).\n      simpl in *.\n      destruct H2; subst; intuition.\n    - dependent destruction H1.\n      specialize (H0 (evalExpr e1)).\n      apply (H0 _ _ _ _ _ H1 x H2).\n    - dependent destruction H1.\n      apply (H0 _ _ _ _ _ _ H1 x H2).\n    - dependent destruction H1.\n      apply (H0 _ _ _ _ _ _ H1 x H2).\n    - dependent destruction H.\n      apply (@IHae _ _ _ _ H x H0).\n    - dependent destruction H1.\n      apply M.union_In in H2.\n      simpl in *.\n      specialize (IHae1 _ _ _ _ H1_ x).\n      specialize (H0 _ tt _ _ _ _ H1_0 x).\n      destruct H2.\n      + apply in_or_app.\n        intuition.\n      + apply in_or_app; right; apply in_or_app.\n        intuition.\n      + specialize (IHae2 _ _ _ _ H1_ x).\n        specialize (H0 _ tt _ _ _ _ H1_0 x).\n        simpl in *.\n        apply M.union_In in H2.\n        destruct H2;\n          apply in_or_app; right; apply in_or_app;\n            intuition.\n    - dependent destruction H.\n      apply (IHae _ _ _ _ H x H0).\n    - dependent destruction H.\n      apply M.F.P.F.empty_in_iff in H0; intuition.\n  Qed.\n\n  Lemma callsR_subset:\n    forall o u rName cs,\n      Substep m o u (Rle (Some rName)) cs ->\n      forall x, M.In x cs -> exists a, In (rName :: a)%struct (getRules m) /\\\n                                       In x (getCallsA (a typeUT)).",
      "suffix": "\n\n  Lemma callsM_subset:\n    forall o u mName argRet cs,\n      Substep m o u (Meth (Some (mName :: argRet)%struct)) cs ->\n      forall x, M.In x cs -> exists a, In (mName :: a)%struct (getDefsBodies m) /\\\n                                      In x (getCallsA (projT2 a typeUT tt)).\n  Proof.\n    destruct mEquiv.\n    clear mEquiv H.\n    intros.\n    dependent destruction H.\n    destruct f.\n    exists attrType.\n    constructor.\n    intuition.\n    pose proof (proj1 (MethsEquiv_in type typeUT (getDefsBodies m)) H0  _ HIn argV tt).\n    apply (callsA_subset H HAction); intuition.\n  Qed.\n\n  Lemma getCalls_rules_subset (a: Action Void) rName:\n    forall x,\n      In x (getCallsA (a typeUT)) ->\n      In (rName :: a)%struct (getRules m) ->\n      In x (getCalls m).\n  Proof.\n    intros.\n    unfold getCalls.\n    apply in_or_app.\n    left.\n    induction (getRules m).\n    - intuition.\n    - simpl in *.\n      destruct H0; subst; apply in_or_app; intuition.\n  Qed.\n\n  Lemma getCalls_meths_subset (a: sigT MethodT) mName:\n    forall x,\n      In x (getCallsA (projT2 a typeUT tt)) ->\n      In (mName :: a)%struct (getDefsBodies m) ->\n      In x (getCalls m).\n  Proof.\n    intros.\n    unfold getCalls.\n    apply in_or_app.\n    right.\n    induction (getDefsBodies m).\n    - intuition.\n    - simpl in *.\n      destruct H0; subst; apply in_or_app; intuition.\n  Qed.\n\n  Theorem getCalls_substep o u rm cs:\n    Substep m o u rm cs ->\n    forall f, M.In f cs -> In f (getCalls m).\n  Proof.\n    dependent induction rm; dependent induction o0; intros.\n    - eapply callsR_subset in H; dest; subst;\n        try eapply getCalls_rules_subset in H1; eauto.\n    - dependent destruction H.\n      apply M.F.P.F.empty_in_iff in H0; intuition.\n    - destruct a.\n      eapply callsM_subset  in H; dest; subst;\n        try eapply getCalls_meths_subset in H1; eauto.\n    - dependent destruction H.\n      apply M.F.P.F.empty_in_iff in H0; intuition.\n  Qed.\n\n  Theorem getCalls_substeps o ss:\n    forall f, M.In f (calls (foldSSLabel (m := m) (o := o) ss)) -> In f (getCalls m).\n  Proof.\n    intros.\n    induction ss; simpl in *.\n    - exfalso.\n      apply (proj1 (M.F.P.F.empty_in_iff _ _) H).\n    - unfold addLabelLeft, mergeLabel in *.\n      destruct a.\n      simpl in *.\n      destruct unitAnnot.\n      + destruct (foldSSLabel ss); simpl in *.\n        pose proof (M.union_In H) as sth.\n        destruct sth.\n        * apply (getCalls_substep substep); intuition.\n        * intuition.\n      + destruct (foldSSLabel ss); simpl in *.\n        dependent destruction o0; simpl in *.\n        * dependent destruction a; simpl in *.\n          pose proof (M.union_In H) as sth.\n          { destruct sth.\n            - apply (getCalls_substep substep); intuition.\n            - intuition.\n          }\n        * pose proof (M.union_In H) as sth.\n          { destruct sth.\n            - apply (getCalls_substep substep); intuition.\n            - intuition.\n          }\n  Qed.\n\nEnd Calls.\n\nTheorem getDefs_substep m o u far cs:\n  Substep m o u (Meth (Some far)) cs ->\n  List.In (attrName far) (getDefs m).\nProof.\n  intros.\n  dependent induction H; simpl in *.\n  unfold getDefs in *.\n  clear - HIn.\n  induction (getDefsBodies m).\n  - intuition.\n  - simpl in *.\n    destruct HIn.\n    + subst.\n      left; intuition.\n    + right; intuition.\nQed.\n\nTheorem getDefs_substepsInd m o u l:\n  SubstepsInd m o u l ->\n  forall x, M.In x (defs l) -> List.In x (getDefs m).\nProof.\n  intros.\n  dependent induction H; simpl in *.\n  - apply M.F.P.F.empty_in_iff in H0; intuition.\n  - destruct sul.\n    destruct l.\n    destruct annot; simpl in *; subst; simpl in *;\n    rewrite M.union_empty_L in H4; simpl in *; apply IHSubstepsInd; intuition.\n    destruct l.\n    destruct o0.\n    + destruct a.\n      destruct ll.\n      simpl in *.\n      inv H3.\n      apply M.union_In in H4.\n      destruct H4.\n      * apply M.F.P.F.add_in_iff in H2.\n        { destruct H2; subst.\n          - apply getDefs_substep in H0.\n            assumption.\n          - apply M.F.P.F.empty_in_iff in H2; intuition.\n        }\n      * apply IHSubstepsInd; intuition.\n    + destruct ll.\n      simpl in *.\n      rewrite M.union_empty_L in H3.\n      inv H3.\n      apply IHSubstepsInd; intuition.\nQed.\n\nTheorem getDefs_substeps m o ss:\n  forall f, M.In f (defs (foldSSLabel (m := m) (o := o) ss)) -> In f (getDefs m).\nProof.\n  intros.\n  induction ss; simpl in *.\n  - exfalso.\n    apply (proj1 (M.F.P.F.empty_in_iff _ _) H).\n  - unfold addLabelLeft, mergeLabel in *.\n    destruct a.\n    simpl in *.\n    destruct unitAnnot.\n    + destruct (foldSSLabel ss); simpl in *.\n      rewrite M.union_empty_L in H.\n      intuition.\n    + destruct (foldSSLabel ss); simpl in *.\n      dependent destruction o0; simpl in *.\n      * dependent destruction a; simpl in *.\n        pose proof (M.union_In H) as sth.\n        { destruct sth.\n          - apply M.F.P.F.add_in_iff in H0.\n            destruct H0.\n            + subst.\n              apply (getDefs_substep substep).\n            + exfalso; apply ((proj1 (M.F.P.F.empty_in_iff _ _)) H0).\n          - intuition.\n        }\n      * rewrite M.union_empty_L in H.\n        intuition.\nQed.\n\nLemma mergeLabel_assoc:\n  forall l1 l2 l3,\n    mergeLabel (mergeLabel l1 l2) l3 = mergeLabel l1 (mergeLabel l2 l3).\nProof.\n  intros; destruct l1 as [[[|]|] ? ?], l2 as [[[|]|] ? ?], l3 as [[[|]|] ? ?];\n    unfold mergeLabel; try reflexivity; try (f_equal; auto).\nQed.\n\nLemma substepsInd_defs_sig:\n  forall m dm,\n    NoDup (getDefs m) ->\n    In dm (getDefsBodies m) ->\n    forall o u l,\n      SubstepsInd m o u l ->\n      forall s,\n        Some s = M.find (elt:=sigT SignT) (attrName dm) (defs l) ->\n        projT1 s = projT1 (attrType dm).\nProof.\n  induction 3; simpl; intros; [mred|].\n  subst; destruct sul as [|odm].\n\n  - apply IHSubstepsInd.\n    destruct l as [ann ds cs]; simpl in *; findeq.\n\n  - destruct odm as [dm'|].\n    + destruct dm as [dmn dmb], dm' as [dmn' dmb'], l as [ann ds cs]; simpl in *.\n      destruct (string_dec dmn dmn').\n      * subst; mred.\n        inv H2; inv Hsig; simpl in *.\n        destruct f as [fn fb]; simpl in *.\n        f_equal.\n        assert ((fn :: fb)%struct = (fn :: dmb)%struct).\n        { eapply in_NoDup_attr; eauto. }\n        inv H2; auto.\n      * apply IHSubstepsInd; findeq.\n    + apply IHSubstepsInd.\n      destruct l as [ann ds cs]; simpl in *; findeq.\nQed.\n\nLemma substepsInd_defs_in:\n  forall m or u l,\n    SubstepsInd m or u l -> M.KeysSubset (defs l) (getDefs m).\nProof.\n  induction 1; simpl; [apply M.KeysSubset_empty|].\n  subst; destruct l as [ann ds cs]; simpl in *.\n  apply M.KeysSubset_union; auto.\n  destruct sul as [|[[dmn dmv]|]]; try (apply M.KeysSubset_empty).\n  apply M.KeysSubset_add; [apply M.KeysSubset_empty|].\n  pose proof (getDefs_substep H0); auto.\nQed.\n\nLemma substepsInd_calls_in:\n  forall m (Hequiv: ModEquiv type typeUT m) or u l,\n    SubstepsInd m or u l -> M.KeysSubset (calls l) (getCalls m).\nProof.\n  induction 2; simpl; [apply M.KeysSubset_empty|].\n  subst; destruct l as [ann ds cs]; simpl in *.\n  apply M.KeysSubset_union; auto.\n  pose proof (getCalls_substep Hequiv H0); auto.\nQed.\n\nLemma step_defs_in:\n  forall m or u l,\n    Step m or u l -> M.KeysSubset (defs l) (getDefs m).\nProof.\n  intros; apply step_consistent in H; inv H.\n  apply substepsInd_defs_in in HSubSteps; auto.\n  destruct l0 as [ann ds cs]; unfold hide in *; simpl in *.\n  eapply M.KeysSubset_Sub; eauto.\n  apply M.subtractKV_sub.\nQed.\n\nLemma step_calls_in:\n  forall m (Hequiv: ModEquiv type typeUT m) or u l,\n    Step m or u l -> M.KeysSubset (calls l) (getCalls m).\nProof.\n  intros; apply step_consistent in H; inv H.\n  apply substepsInd_calls_in in HSubSteps; auto.\n  destruct l0 as [ann ds cs]; unfold hide in *; simpl in *.\n  eapply M.KeysSubset_Sub; eauto.\n  apply M.subtractKV_sub.\nQed.\n\nLemma multistep_defs_in:\n  forall m or ll u,\n    Multistep m or u ll -> Forall (fun l => M.KeysSubset (defs l) (getDefs m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; constructor; eauto.\n  eapply step_defs_in; eauto.\nQed.\n\nLemma multistep_calls_in:\n  forall m (Hequiv: ModEquiv type typeUT m) or ll u,\n    Multistep m or u ll -> Forall (fun l => M.KeysSubset (calls l) (getCalls m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; constructor; eauto.\n  eapply step_calls_in; eauto.\nQed.\n\nLemma behavior_defs_in:\n  forall m ll u,\n    Behavior m u ll -> Forall (fun l => M.KeysSubset (defs l) (getDefs m)) ll.\nProof.\n  intros; inv H.\n  eapply multistep_defs_in; eauto.\nQed.\n\nLemma behavior_calls_in:\n  forall m (Hequiv: ModEquiv type typeUT m) ll u,\n    Behavior m u ll -> Forall (fun l => M.KeysSubset (calls l) (getCalls m)) ll.\nProof.\n  intros; inv H.\n  eapply multistep_calls_in; eauto.\nQed.\n      \nLemma step_defs_disj:\n  forall m or u l,\n    Step m or u l -> M.KeysDisj (defs l) (getCalls m).\nProof.\n  intros; apply step_consistent in H.\n  inv H; destruct l0 as [ann ds cs].\n  unfold wellHidden, hide in *; simpl in *; dest; auto.\nQed.\n\nLemma step_calls_disj:\n  forall m or u l,\n    Step m or u l -> M.KeysDisj (calls l) (getDefs m).\nProof.\n  intros; apply step_consistent in H.\n  inv H; destruct l0 as [ann ds cs].\n  unfold wellHidden, hide in *; simpl in *; dest; auto.\nQed.\n\nLemma multistep_defs_disj:\n  forall m or ll u,\n    Multistep m or u ll ->\n    Forall (fun l => M.KeysDisj (defs l) (getCalls m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; constructor.\n  - eapply step_defs_disj; eauto.\n  - eapply IHll; eauto.\nQed.\n\nLemma multistep_calls_disj:\n  forall m or ll u,\n    Multistep m or u ll ->\n    Forall (fun l => M.KeysDisj (calls l) (getDefs m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; constructor.\n  - eapply step_calls_disj; eauto.\n  - eapply IHll; eauto.\nQed.\n\nLemma behavior_defs_disj:\n  forall m ll n,\n    Behavior m n ll ->\n    Forall (fun l => M.KeysDisj (defs l) (getCalls m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; inv HMultistepBeh; constructor.\n  - eapply step_defs_disj; eauto.\n  - eapply IHll.\n    econstructor; eauto.\nQed.\n\nLemma behavior_calls_disj:\n  forall m ll n,\n    Behavior m n ll ->\n    Forall (fun l => M.KeysDisj (calls l) (getDefs m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; inv HMultistepBeh; constructor.\n  - eapply step_calls_disj; eauto.\n  - eapply IHll.\n    econstructor; eauto.\nQed.\n\nLemma step_defs_extDefs_in:\n  forall m (Hequiv: ModEquiv type typeUT m) o u l,\n    Step m o u l ->\n    M.KeysSubset (defs l) (getExtDefs m).\nProof.\n  intros.\n  pose proof (step_defs_in H).\n  pose proof (step_defs_disj H).\n\n  unfold M.KeysSubset, M.KeysDisj in *; intros.\n  specialize (H0 k H2).\n  specialize (H1 k).\n  destruct (in_dec string_dec k (getCalls m)); intuition idtac.\n  apply filter_In; split; auto.\n  apply negb_true_iff.\n  remember (string_in k (getCalls m)) as kin; destruct kin; auto.\n  apply string_in_dec_in in Heqkin; elim n; auto.\nQed.\n\nLemma step_defs_ext_in:\n  forall m (Hequiv: ModEquiv type typeUT m) o u l,\n    Step m o u l ->\n    M.KeysSubset (defs l) (getExtMeths m).\nProof.\n  intros.\n  pose proof (step_defs_extDefs_in Hequiv H).\n  eapply M.KeysSubset_SubList; eauto.\n  apply SubList_app_1, SubList_refl.\nQed.\n\nLemma step_calls_extCalls_in:\n  forall m (Hequiv: ModEquiv type typeUT m) o u l,\n    Step m o u l ->\n    M.KeysSubset (calls l) (getExtCalls m).\nProof.\n  intros.\n  pose proof (step_calls_in Hequiv H).\n  pose proof (step_calls_disj H).\n\n  unfold M.KeysSubset, M.KeysDisj in *; intros.\n  specialize (H0 k H2).\n  specialize (H1 k).\n  destruct (in_dec string_dec k (getDefs m)); intuition idtac.\n  apply filter_In; split; auto.\n  apply negb_true_iff.\n  remember (string_in k (getDefs m)) as kin; destruct kin; auto.\n  apply string_in_dec_in in Heqkin; elim n; auto.\nQed.\n\nLemma step_calls_ext_in:\n  forall m (Hequiv: ModEquiv type typeUT m) o u l,\n    Step m o u l ->\n    M.KeysSubset (calls l) (getExtMeths m).\nProof.\n  intros.\n  pose proof (step_calls_extCalls_in Hequiv H).\n  eapply M.KeysSubset_SubList; eauto.\n  apply SubList_app_2, SubList_refl.\nQed.\n\nLemma multistep_defs_extDefs_in:\n  forall m (Hequiv: ModEquiv type typeUT m) or ll u,\n    Multistep m or u ll -> Forall (fun l => M.KeysSubset (defs l) (getExtDefs m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; constructor; eauto.\n  eapply step_defs_extDefs_in; eauto.\nQed.\n\nLemma multistep_calls_extCalls_in:\n  forall m (Hequiv: ModEquiv type typeUT m) or ll u,\n    Multistep m or u ll -> Forall (fun l => M.KeysSubset (calls l) (getExtCalls m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; constructor; eauto.\n  eapply step_calls_extCalls_in; eauto.\nQed.\n\nLemma multistep_defs_ext_in:\n  forall m (Hequiv: ModEquiv type typeUT m) or ll u,\n    Multistep m or u ll -> Forall (fun l => M.KeysSubset (defs l) (getExtMeths m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; constructor; eauto.\n  apply M.KeysSubset_SubList with (d1:= getExtDefs m).\n  - eapply step_defs_extDefs_in; eauto.\n  - apply SubList_app_1, SubList_refl.\nQed.\n\nLemma multistep_calls_ext_in:\n  forall m (Hequiv: ModEquiv type typeUT m) or ll u,\n    Multistep m or u ll -> Forall (fun l => M.KeysSubset (calls l) (getExtMeths m)) ll.\nProof.\n  induction ll; intros; auto.\n  inv H; constructor; eauto.\n  apply M.KeysSubset_SubList with (d1:= getExtCalls m).\n  - eapply step_calls_extCalls_in; eauto.\n  - apply SubList_app_2, SubList_refl.\nQed.\n\nLemma behavior_defs_extDefs_in:\n  forall m (Hequiv: ModEquiv type typeUT m) ll u,\n    Behavior m u ll -> Forall (fun l => M.KeysSubset (defs l) (getExtDefs m)) ll.\nProof.\n  intros; inv H.\n  eapply multistep_defs_extDefs_in; eauto.\nQed.\n\nLemma behavior_calls_extCalls_in:\n  forall m (Hequiv: ModEquiv type typeUT m) ll u,\n    Behavior m u ll -> Forall (fun l => M.KeysSubset (calls l) (getExtCalls m)) ll.\nProof.\n  intros; inv H.\n  eapply multistep_calls_extCalls_in; eauto.\nQed.\n\nLemma behavior_defs_ext_in:\n  forall m (Hequiv: ModEquiv type typeUT m) ll u,\n    Behavior m u ll -> Forall (fun l => M.KeysSubset (defs l) (getExtMeths m)) ll.\nProof.\n  intros; inv H.\n  eapply multistep_defs_ext_in; eauto.\nQed.\n\nLemma behavior_calls_ext_in:\n  forall m (Hequiv: ModEquiv type typeUT m) ll u,\n    Behavior m u ll -> Forall (fun l => M.KeysSubset (calls l) (getExtMeths m)) ll.\nProof.\n  intros; inv H.\n  eapply multistep_calls_ext_in; eauto.\nQed.\n\nLemma substepsInd_rule_split:\n  forall m o u l,\n    SubstepsInd m o u l ->\n    forall or,\n      annot l = Some or ->\n      exists ru rcs pu pl,\n        Substep m o ru (Rle or) rcs /\\\n        SubstepsInd m o pu pl /\\\n        CanCombineUUL pu pl ru rcs (Rle or) /\\\n        u = M.union pu ru /\\\n        l = mergeLabel (getLabel (Rle or) rcs) pl.\nProof.\n  induction 1; simpl; intros; [inv H|].\n\n  subst; destruct sul as [|].\n\n  - clear IHSubstepsInd.\n    exists su, scs, u, l.\n\n    destruct l as [ann ds cs]; inv H1; dest; simpl in *.\n    destruct ann; [inv H3|].\n    inv H4.\n    repeat split; auto.\n\n  - clear H.\n    destruct l as [ann ds cs]; simpl in *; subst.\n    specialize (IHSubstepsInd _ eq_refl).\n    destruct IHSubstepsInd as [ru [rcs [pu [pl ?]]]]; dest; subst.\n\n    exists ru, rcs, (M.union pu su), (mergeLabel (getLabel (Meth o0) scs) pl).\n    \n    destruct pl as [pann pds pcs]; inv H1; inv H3; dest; simpl in *.\n    destruct pann as [|]; [inv H7|]; inv H5.\n\n    repeat split; auto.\n    + econstructor.\n      * exact H2.\n      * exact H0.\n      * repeat split; auto.\n      * reflexivity.\n      * reflexivity.\n    + simpl; auto.\n    + f_equal; auto.\n      \nQed.\n\nLemma substep_filterDm:\n  forall regs rules dms o u ul cs dmn,\n    Substep (Mod regs rules dms) o u ul cs ->\n    (forall s, ul <> Meth (Some (dmn :: s)%struct)) ->\n    Substep (Mod regs rules (filterDm dms dmn)) o u ul cs.\nProof.\n  intros; inv H; try (econstructor; eauto; fail).\n  destruct f as [fn fb]; simpl in *.\n  destruct (string_dec fn dmn).\n\n  - subst; exfalso; eapply H0; eauto.\n  - econstructor.\n    + simpl; apply filter_In; split.\n      * exact HIn.\n      * simpl; destruct (string_dec _ _); [elim n; auto|]; auto.\n    + simpl; eassumption.\n    + reflexivity.\nQed.\n\nLemma substepsInd_filterDm:\n  forall regs rules dms o u l dmn,\n    SubstepsInd (Mod regs rules dms) o u l ->\n    M.find dmn (defs l) = None ->\n    SubstepsInd (Mod regs rules (filterDm dms dmn)) o u l.\nProof.\n  induction 1; simpl; intros; [constructor|].\n\n  subst; econstructor.\n  - apply IHSubstepsInd.\n    destruct l as [ann ds cs]; simpl in *; findeq.\n  - apply substep_filterDm; eauto.\n    intros.\n    destruct sul as [|]; [discriminate|].\n    destruct o0 as [[dmn' dmb]|]; [|discriminate].\n    destruct (string_dec dmn dmn').\n    + subst; destruct l as [ann ds cs]; simpl in *; mred.\n    + intro Hx; elim n; clear n.\n      inv Hx; reflexivity.\n  - assumption.\n  - reflexivity.\n  - reflexivity.\nQed.\n\nLemma filterDms_getCalls:\n  forall regs rules dms filt,\n    SubList (getCalls (Mod regs rules (filterDms dms filt)))\n            (getCalls (Mod regs rules dms)).\nProof.\n  unfold getCalls; simpl; intros.\n  apply SubList_app_3; [apply SubList_app_1, SubList_refl|].\n  apply SubList_app_2.\n\n  clear.\n  induction dms; simpl; [apply SubList_nil|].\n  destruct (string_in _ _).\n  - apply SubList_app_2; auto.\n  - apply SubList_app_3.\n    + apply SubList_app_1, SubList_refl.\n    + apply SubList_app_2; auto.\nQed.\n\nLemma filterDms_wellHidden:\n  forall regs rules dms l,\n    wellHidden (Mod regs rules dms) (hide l) ->\n    forall filt,\n      wellHidden (Mod regs rules (filterDms dms filt)) (hide l).\nProof.\n  unfold wellHidden, hide; simpl; intros; dest.\n  split.\n  - eapply M.KeysDisj_SubList; eauto.\n    apply filterDms_getCalls.\n  - unfold getDefs in *; simpl in *.\n    eapply M.KeysDisj_SubList; eauto.\n\n    clear.\n    induction dms; simpl; auto.\n    + apply SubList_nil.\n    + destruct (string_in _ _).\n      * apply SubList_cons_right; auto.\n      * simpl; apply SubList_cons; intuition.\n        apply SubList_cons_right; auto.\nQed.\n\nLemma module_structure_indep_substep:\n  forall m1 m2 or u ul cs,\n    SubList (getRules m1) (getRules m2) ->\n    SubList (getDefsBodies m1) (getDefsBodies m2) ->\n    Substep m1 or u ul cs ->\n    Substep m2 or u ul cs.\nProof.\n  induction 3; simpl; intros; try (econstructor; eauto).\nQed.\n\nLemma module_structure_indep_substepsInd:\n  forall m1 m2 or u l,\n    SubList (getRules m1) (getRules m2) ->\n    SubList (getDefsBodies m1) (getDefsBodies m2) ->\n    SubstepsInd m1 or u l ->\n    SubstepsInd m2 or u l.\nProof.\n  induction 3; simpl; intros; [constructor|].\n  subst; econstructor; eauto.\n  eapply module_structure_indep_substep; eauto.\nQed.\n\nLemma module_structure_indep_step:\n  forall m1 m2 or u l,\n    EquivList (getRules m1) (getRules m2) ->\n    EquivList (getDefsBodies m1) (getDefsBodies m2) ->\n    Step m1 or u l ->\n    Step m2 or u l.\nProof.\n  intros.\n  apply step_consistent in H1.\n  apply step_consistent.\n  inv H1; constructor.\n  - inv H; inv H0.\n    eapply module_structure_indep_substepsInd; eauto.\n  - destruct (hide l0) as [a d c].\n    unfold wellHidden in *; simpl in *.\n    inv H; inv H0.\n    pose proof (module_structure_indep_getCalls _ _ H2 H3); dest; split.\n    + eapply M.KeysDisj_SubList; eauto.\n    + eapply M.KeysDisj_SubList; eauto.\n      apply SubList_map; auto.\nQed.\n\nLemma flatten_preserves_substep:\n  forall m or u ul cs,\n    Substep m or u ul cs ->\n    Substep (Mod (getRegInits m) (getRules m) (getDefsBodies m)) or u ul cs.\nProof.\n  intros; apply module_structure_indep_substep with (m1:= m);\n    auto; apply SubList_refl.\nQed.\n\nLemma flatten_preserves_substepsInd:\n  forall m or u l,\n    SubstepsInd m or u l ->\n    SubstepsInd (Mod (getRegInits m) (getRules m) (getDefsBodies m)) or u l.\nProof.\n  intros; apply module_structure_indep_substepsInd with (m1:= m);\n    auto; apply SubList_refl.\nQed.\n\nLemma flatten_preserves_step:\n  forall m or nr l,\n    Step m or nr l ->\n    Step (Mod (getRegInits m) (getRules m) (getDefsBodies m)) or nr l.\nProof.\n  intros; apply module_structure_indep_step with (m1:= m);\n    auto; apply EquivList_refl.\nQed.\n\nLemma substep_dm_weakening:\n  forall regs rules dms dmn o u ul cs,\n    Substep (Mod regs rules dms) o u ul cs ->\n    None = M.find (elt:=sigT SignT) dmn (defs (getLabel ul cs)) ->\n    None = M.find (elt:=sigT SignT) dmn (calls (getLabel ul cs)) ->\n    Substep (Mod regs rules (filterDm dms dmn)) o u ul cs.\nProof.\n  induction 1; simpl; intros; try (econstructor; eauto; fail).\n\n  econstructor; eauto.\n  simpl; apply filter_In; split; auto.\n  destruct (string_dec _ _); subst; auto.\n  mred.\nQed.\n\nLemma substepsInd_dm_weakening:\n  forall regs rules dms dmn o u l,\n    SubstepsInd (Mod regs rules dms) o u l ->\n    None = M.find (elt:=sigT SignT) dmn (defs l) ->\n    None = M.find (elt:=sigT SignT) dmn (calls l) ->\n    SubstepsInd (Mod regs rules (filterDm dms dmn)) o u l.\nProof.\n  induction 1; simpl; intros; [constructor|subst].\n\n  destruct l as [a d c]; simpl in *.\n  econstructor.\n  - apply IHSubstepsInd.\n    + rewrite M.find_union in H4.\n      match goal with\n      | [H: None = match M.find dmn ?lm with Some _ => _ | None => _ end |- _] =>\n        destruct (M.find dmn lm); [inv H|]\n      end.\n      auto.\n    + rewrite M.find_union in H5.\n      destruct (M.find dmn scs); [inv H5|]; auto.\n  - apply substep_dm_weakening; eauto.\n    + rewrite M.find_union in H4; simpl.\n      match goal with\n      | [H: None = match M.find dmn ?lm with Some _ => _ | None => _ end |- _] =>\n        destruct (M.find dmn lm); [inv H|]\n      end.\n      auto.\n    + simpl; findeq.\n  - inv H1; dest; simpl in *.\n    repeat split; auto.\n  - reflexivity.\n  - reflexivity.\nQed.\n\nLemma filterDm_wellHidden:\n  forall regs rules dms dmn l,\n    wellHidden (Mod regs rules dms) l ->\n    wellHidden (Mod regs rules (filterDm dms dmn)) l.\nProof.\n  intros; eapply wellHidden_weakening; eauto.\n  - apply SubList_app_3.\n    + apply SubList_app_1, SubList_refl.\n    + apply SubList_app_2; simpl.\n      clear; induction dms; simpl; [apply SubList_nil|].\n      destruct (string_dec _ _).\n      * apply SubList_app_2; auto.\n      * simpl; apply SubList_app_3.\n        { apply SubList_app_1, SubList_refl. }\n        { apply SubList_app_2; auto. }\n  - unfold getDefs; simpl.\n    apply SubList_map.\n    unfold SubList; intros.\n    unfold filterDm in H0; apply filter_In in H0; dest; auto.\nQed.\n\nLemma substep_dms_weakening:\n  forall regs rules dms or u ul cs,\n    Substep (Mod regs rules dms) or u ul cs ->\n    forall filt,\n      M.KeysDisj (defs (getLabel ul cs)) filt ->\n      Substep (Mod regs rules (filterDms dms filt)) or u ul cs.\nProof.\n  induction 1; simpl; intros; try (econstructor; eauto; fail).\n\n  eapply SingleMeth; eauto; subst.\n  clear -H HIn; simpl in *.\n  specialize (H (attrName f)).\n  apply filter_In.\n  remember (string_in _ _) as sin; destruct sin; auto.\n  apply string_in_dec_in in Heqsin.\n  elim H; auto.\n  apply M.F.P.F.add_in_iff; auto.\nQed.\n\nLemma substepInd_dms_weakening:\n  forall regs rules dms or u l,\n    SubstepsInd (Mod regs rules dms) or u l ->\n    forall filt,\n      M.KeysDisj (defs l) filt ->\n      SubstepsInd (Mod regs rules (filterDms dms filt)) or u l.\nProof.\n  induction 1; intros; subst; simpl; [constructor|].\n  eapply SubstepsCons; eauto.\n  - apply IHSubstepsInd.\n    clear -H4.\n    destruct (getLabel sul scs) as [ann ds cs], l as [lann lds lcs].\n    simpl in *; eapply M.KeysDisj_union_2; eauto.\n  - apply substep_dms_weakening; auto.\n    clear -H4.\n    destruct (getLabel sul scs) as [ann ds cs], l as [lann lds lcs].\n    simpl in *; eapply M.KeysDisj_union_1; eauto.\nQed.\n\nLemma substepsInd_meths_disj:\n  forall regs rules dms\n    (mEquiv: ModEquiv type typeUT (Mod regs rules dms)),\n    DisjList (getCalls (Mod regs rules dms)) (getDefs (Mod regs rules dms)) ->\n    forall or u l,\n      SubstepsInd (Mod regs rules dms) or u l ->\n      M.Disj (calls l) (defs l).\nProof.\n  intros.\n  pose proof (substepsInd_calls_in mEquiv H0).\n  pose proof (substepsInd_defs_in H0).\n  eapply M.DisjList_KeysSubset_Disj; eauto.\nQed.\n\nLemma substepsInd_hide_void:\n  forall regs rules dms\n    (mEquiv: ModEquiv type typeUT (Mod regs rules dms)),\n    DisjList (getCalls (Mod regs rules dms)) (getDefs (Mod regs rules dms)) ->\n    forall or u l,\n      SubstepsInd (Mod regs rules dms) or u l ->\n      hide l = l.\nProof.\n  intros; destruct l as [ann ds cs].\n  pose proof (substepsInd_meths_disj mEquiv H H0).\n  unfold hide; simpl in *; f_equal; apply M.subtractKV_disj_invalid; mdisj.\nQed.\n\nLemma stepInd_dms_weakening:\n  forall regs rules dms or u l\n         (mEquiv: ModEquiv type typeUT (Mod regs rules dms)),\n    DisjList (getCalls (Mod regs rules dms)) (getDefs (Mod regs rules dms)) ->\n    StepInd (Mod regs rules dms) or u l ->\n    forall filt,\n      M.KeysDisj (defs l) filt ->\n      StepInd (Mod regs rules (filterDms dms filt)) or u l.\nProof.\n  induction 3; intros.\n  constructor.\n  - erewrite substepsInd_hide_void in H0; eauto.\n    apply substepInd_dms_weakening; auto.\n  - apply filterDms_wellHidden; auto.\nQed.\n\nLemma step_dms_weakening:\n  forall regs rules dms or u l,\n    ModEquiv type typeUT (Mod regs rules dms) ->\n    DisjList (getCalls (Mod regs rules dms))\n             (getDefs (Mod regs rules dms)) ->\n    Step (Mod regs rules dms) or u l ->\n    forall filt,\n      M.KeysDisj (defs l) filt ->\n      Step (Mod regs rules (filterDms dms filt)) or u l.\nProof.\n  intros; subst; simpl.\n  apply step_consistent.\n  apply step_consistent in H1.\n  apply stepInd_dms_weakening; auto.\nQed.\n\nDefinition IsChild (c p: Modules) :=\n  (exists c', p = ConcatMod c c' \\/ p = ConcatMod c' c).\n#[global] Hint Unfold IsChild.\n\nLemma substep_modules_weakening:\n  forall mc o u ul cs,\n    Substep mc o u ul cs ->\n    forall mp,\n      IsChild mc mp ->\n      Substep mp o u ul cs.\nProof.\n  induction 1; simpl; intros; subst; try (constructor; auto; fail).\n  - eapply SingleRule; eauto.\n    inv H; inv H0; apply in_or_app; auto.\n  - eapply SingleMeth; eauto.\n    inv H; inv H0; apply in_or_app; auto.\nQed.\n\nLemma substepsInd_modules_weakening:\n  forall mc o u l,\n    SubstepsInd mc o u l ->\n    forall mp,\n      IsChild mc mp ->\n      SubstepsInd mp o u l.\nProof.\n  induction 1; simpl; intros; subst; [constructor|].\n  eapply SubstepsCons; eauto.\n  eapply substep_modules_weakening; eauto.\nQed.\n\nLemma semAction_oldRegs_weakening:\n  forall o {retK} retv (a: ActionT type retK) u cs,\n    SemAction o a u cs retv ->\n    forall so,\n      M.Sub o so ->\n      SemAction so a u cs retv.\nProof.\n  induction 1; simpl; intros; subst.\n  - econstructor; eauto.\n  - econstructor; eauto.\n  - econstructor; eauto.\n  - econstructor; eauto.\n  - econstructor; eauto.\n  - eapply SemIfElseTrue; eauto.\n  - eapply SemIfElseFalse; eauto.\n  - econstructor; eauto.\n  - econstructor; eauto.\n  - econstructor; eauto.\nQed.\n\nLemma substep_oldRegs_weakening:\n  forall m o u ul cs,\n    Substep m o u ul cs ->\n    forall so,\n      M.Sub o so ->\n      Substep m so u ul cs.\nProof.\n  induction 1; simpl; intros; subst; try (constructor; auto; fail).\n  - eapply SingleRule; eauto.\n    eapply semAction_oldRegs_weakening; eauto.\n  - eapply SingleMeth; eauto.\n    eapply semAction_oldRegs_weakening; eauto.\nQed.\n\nLemma substepsInd_oldRegs_weakening:\n  forall m o u l,\n    SubstepsInd m o u l ->\n    forall so,\n      M.Sub o so ->\n      SubstepsInd m so u l.\nProof.\n  induction 1; simpl; intros; subst; [constructor|].\n  eapply SubstepsCons; eauto.\n  eapply substep_oldRegs_weakening; eauto.\nQed.\n\nDefinition ValidLabel (m: Modules) (l: LabelT) :=\n  M.KeysSubset (defs l) (getDefs m) /\\ M.KeysSubset (calls l) (getCalls m).\n\nLemma validLabel_wellHidden_getExtDefs:\n  forall m l, ValidLabel m l -> wellHidden m l -> M.KeysSubset (defs l) (getExtDefs m).\nProof.\n  unfold ValidLabel, wellHidden; intros; dest.\n  clear H1 H2.\n  unfold M.KeysSubset, M.KeysDisj in *; intros.\n  specialize (H k H1).\n  specialize (H0 k).\n  destruct (in_dec string_dec k (getCalls m)); intuition idtac.\n  apply filter_In; split; auto.\n  apply negb_true_iff.\n  remember (string_in k (getCalls m)) as kin; destruct kin; auto.\n  apply string_in_dec_in in Heqkin; elim n; auto.\nQed.\n\nLemma validLabel_wellHidden_getExtCalls:\n  forall m l, ValidLabel m l -> wellHidden m l -> M.KeysSubset (calls l) (getExtCalls m).\nProof.\n  unfold ValidLabel, wellHidden; intros; dest.\n  clear H H0.\n  unfold M.KeysSubset, M.KeysDisj in *; intros.\n  specialize (H2 k H).\n  specialize (H1 k).\n  destruct (in_dec string_dec k (getDefs m)); intuition idtac.\n  apply filter_In; split; auto.\n  apply negb_true_iff.\n  remember (string_in k (getDefs m)) as kin; destruct kin; auto.\n  apply string_in_dec_in in Heqkin; elim n; auto.\nQed.\n\nLemma extDefs_calls_disj:\n  forall m, DisjList (getExtDefs m) (getCalls m).\nProof.\n  unfold DisjList; intros.\n  destruct (in_dec string_dec e (getExtDefs m)) as [Hin|Hin].\n  - right; intro Hx; unfold getExtDefs in *.\n    apply filter_In in Hin; dest.\n    apply negb_true_iff, eq_sym, string_in_dec_not_in in H0; auto.\n  - left; auto.\nQed.\n\nLemma extCalls_defs_disj:\n  forall m, DisjList (getExtCalls m) (getDefs m).\nProof.\n  unfold DisjList; intros.\n  destruct (in_dec string_dec e (getExtCalls m)) as [Hin|Hin].\n  - right; intro Hx; unfold getExtCalls in *.\n    apply filter_In in Hin; dest.\n    apply negb_true_iff, eq_sym, string_in_dec_not_in in H0; auto.\n  - left; auto.\nQed.\n\nLemma extDefs_extCalls_disj:\n  forall m, DisjList (getExtDefs m) (getExtCalls m).\nProof.\n  intros; apply DisjList_comm, DisjList_SubList with (l1:= getCalls m).\n  - apply getExtCalls_getCalls.\n  - apply DisjList_comm, extDefs_calls_disj.\nQed.\n\nLemma validLabel_wellHidden_disj:\n  forall m l, ValidLabel m l -> wellHidden m l -> M.Disj (defs l) (calls l).\nProof.\n  intros.\n  pose proof (validLabel_wellHidden_getExtCalls H H0).\n  pose proof (validLabel_wellHidden_getExtDefs H H0).\n  pose proof (extDefs_extCalls_disj m).\n  eauto using M.DisjList_KeysSubset_Disj.\nQed.\n\nLemma getCalls_not_getDefs_getExtCalls:\n  forall m k, In k (getCalls m) -> ~ In k (getDefs m) -> In k (getExtCalls m).\nProof.\n  intros; unfold getExtCalls.\n  apply filter_In; split; auto.\n  remember (string_in k (getDefs m)) as kin; destruct kin; auto.\n  apply string_in_dec_in in Heqkin; auto.\nQed.\n\nLemma getDefs_not_getCalls_getExtDefs:\n  forall m k, In k (getDefs m) -> ~ In k (getCalls m) -> In k (getExtDefs m).\nProof.\n  intros; unfold getExtCalls.\n  apply filter_In; split; auto.\n  remember (string_in k (getCalls m)) as kin; destruct kin; auto.\n  apply string_in_dec_in in Heqkin; auto.\nQed.\n\nLemma step_wellHidden: forall m o u l, Step m o u l -> wellHidden m l.\nProof. intros; inv H; auto. Qed.\n\nLemma multistep_wellHidden:\n  forall m o ll n, Multistep m o n ll -> Forall (fun l => wellHidden m l) ll.\nProof.\n  induction ll; simpl; intros; constructor; auto; inv H; eauto.\n  eapply step_wellHidden; eauto.\nQed.\n\nLemma behavior_wellHidden:\n  forall m ll n, Behavior m n ll -> Forall (fun l => wellHidden m l) ll.\nProof.\n  intros; inv H; eapply multistep_wellHidden; eauto.\nQed.\n\nLemma multistep_app:\n  forall m ll1 ll2 o n,\n    Multistep m o n (ll1 ++ ll2) ->\n    exists n', Multistep m o n' ll2 /\\ Multistep m n' n ll1.\nProof.\n  induction ll1; simpl; intros.\n  - eexists; split; eauto.\n    constructor; auto.\n  - inv H; specialize (IHll1 _ _ _ HMultistep); dest.\n    eexists; split; eauto.\n    constructor; auto.\nQed.\n\nLemma multistep_app_inv:\n  forall m ll1 ll2 o n n',\n    Multistep m o n' ll2 ->\n    Multistep m n' n ll1 ->\n    Multistep m o n (ll1 ++ ll2).\nProof.\n  induction ll1; simpl; intros.\n  - inv H0; auto.\n  - inv H0; constructor; eauto.\nQed.\n\nLemma reachable_init:\n  forall m, reachable (initRegs (getRegInits m)) m.\nProof.\n  intros; repeat econstructor.\nQed.\n\nLemma reachable_multistep:\n  forall m o n ll,\n    reachable o m ->\n    Multistep m o n ll ->\n    reachable n m.\nProof.\n  intros.\n  inversion_clear H.\n  inversion_clear H1.\n  do 2 econstructor.\n  eapply multistep_app_inv; eassumption.\nQed.\n\nSection NoRules.\n  Variable m: Modules.\n  Hypothesis (Hrules: getRules m = nil).\n\n  Lemma substep_getRules_nil:\n    forall o u ul cs,\n      Substep m o u ul cs -> ul = Rle None \\/ exists d, ul = Meth d.\n  Proof.\n    destruct 1; auto.\n    - right; eexists; auto.\n    - rewrite Hrules in HInRules; inv HInRules.\n    - right; eexists; auto.\n  Qed.\n\n  Lemma substepsInd_getRules_nil:\n    forall o u l,\n      SubstepsInd m o u l -> annot l = Some None \\/ annot l = None.\n  Proof.\n    induction 1; auto.\n    apply substep_getRules_nil in H0; destruct H0; dest; subst.\n    - destruct l as [a d c]; simpl in *.\n      destruct IHSubstepsInd; subst; simpl; auto.\n    - destruct l as [a d c]; simpl in *; auto.\n  Qed.\n\n  Lemma step_getRules_nil:\n    forall o u l,\n      Step m o u l -> annot l = Some None \\/ annot l = None.\n  Proof.\n    intros; apply step_consistent in H.\n    inv H; apply substepsInd_getRules_nil in HSubSteps.\n    destruct l0 as [a d c]; simpl in *; auto.\n  Qed.\n\n  Lemma substepsInd_rule_annot_1:\n    forall o u ds cs,\n      SubstepsInd m o u {| annot := None; defs := ds; calls := cs |} ->\n      SubstepsInd m o u {| annot := Some None; defs := ds; calls := cs |}.\n  Proof.\n    intros.\n    econstructor.\n    - eassumption.\n    - apply EmptyRule.\n    - repeat split; auto.\n    - auto.\n    - reflexivity.\n  Qed.\n\n  Lemma substepsInd_rule_annot_2:\n    forall o u l,\n      SubstepsInd m o u l ->\n      forall ds cs,\n        l = {| annot := Some None; defs := ds; calls := cs |} ->\n        SubstepsInd m o u {| annot := None; defs := ds; calls := cs |}.\n  Proof.\n    induction 1; simpl; intros; [inv H|].\n    subst; inv H0.\n    - mred; replace {| annot := None; defs := ds; calls := cs |} with l; auto.\n      destruct l as [ann d c]; inv H1; simpl in *; dest; inv H4.\n      destruct ann; intuition idtac.\n    - destruct l as [ann d c]; inv H1; simpl in *; dest; inv H4.\n      mred; auto.\n    - rewrite Hrules in HInRules; inv HInRules.\n    - destruct l as [ann d c]; inv H1; simpl in *; dest; inv H4.\n      econstructor.\n      + apply IHSubstepsInd; auto.\n      + eapply SingleMeth; eauto.\n      + repeat split; auto.\n      + auto.\n      + reflexivity.\n  Qed.\n\n  Lemma step_rule_annot_1:\n    forall o u ds cs,\n      Step m o u {| annot := None; defs := ds; calls := cs |} ->\n      Step m o u {| annot := Some None; defs := ds; calls := cs |}.\n  Proof.\n    intros.\n    apply step_consistent; apply step_consistent in H.\n    inv H.\n    destruct l as [a d c]; simpl in *; subst.\n    change {| annot := _; defs := _; calls := _ |}\n    with (hide {| annot := Some None; defs := d; calls := c |}).\n    constructor; auto.\n    apply substepsInd_rule_annot_1; auto.\n  Qed.\n\n  Lemma step_rule_annot_2:\n    forall o u ds cs,\n      Step m o u {| annot := Some None; defs := ds; calls := cs |} ->\n      Step m o u {| annot := None; defs := ds; calls := cs |}.\n  Proof.\n    intros.\n    apply step_consistent; apply step_consistent in H.\n    inv H.\n    destruct l as [a d c]; simpl in *; subst.\n    change {| annot := _; defs := _; calls := _ |}\n    with (hide {| annot := None; defs := d; calls := c |}).\n    constructor; auto.\n    eapply substepsInd_rule_annot_2; eauto.\n  Qed.\n\nEnd NoRules.\n\n",
      "theorem": "Lemma callsR_subset:\n    forall o u rName cs,\n      Substep m o u (Rle (Some rName)) cs ->\n      forall x, M.In x cs -> exists a, In (rName :: a)%struct (getRules m) /\\\n                                       In x (getCallsA (a typeUT)).",
      "ground_truth": "Proof.\n    destruct mEquiv.\n    clear mEquiv H0.\n    intros.\n    dependent destruction H0.\n    exists a.\n    constructor.\n    intuition.\n    pose proof (proj1 (RulesEquiv_in type typeUT (getRules m)) H _ HInRules).\n    apply (callsA_subset H0 HAction); intuition.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 8,
      "prefix": "Require Export Utf8.\nRequire Export Arith.\nRequire Export Lia.\nRequire Export Recdef.\n\nFixpoint Sum (n0 : nat) :=\n  match n0 with\n  | 0   => 0\n  | S n => S (n + Sum n)\n  end.\n\nLemma le_sum : forall n, n <= Sum n.\nProof.\n  induction n.\n  simpl. lia.\n  simpl.\n  lia.\nQed.\n\nDefinition cpair (n m : nat) : nat := n + Sum (n + m).\nNotation \"( x ; y )\" := (cpair x y) (at level 0).\n\nLemma le_cpair_fst n m : n <= cpair n m.",
      "suffix": "\n\nLemma le_cpair_snd n m : m <= cpair n m.\nProof.\n  unfold cpair.\n  assert(H := le_sum (n + m)).\n  lia.\nQed.\n\n(* Sum (summax n) <= n < n + Sum (summax n) *)\n\nFixpoint summax (n0 : nat) :=\n  match n0 with\n  | 0 => 0\n  | S n =>\n    let m := summax n in\n    match (le_lt_dec (Sum (S m)) (S n)) with\n    | left _  => S m\n    | right _ => m\n    end\n  end.\n\nDefinition fst (n : nat) := n - Sum (summax n).\nDefinition snd (n : nat) := summax n - fst n.\n\nCompute fst 5.\nCompute snd 5.\n\nLemma lt_I_lt_sum_sum : forall n m,\n  n < m -> Sum n < Sum m.\nProof.\n  assert(forall n m, Sum m < Sum (S n + m)).\n  {\n    induction n.\n    simpl. lia.\n    simpl.\n    intros.\n    specialize (IHn m).\n    simpl in IHn.\n    lia.\n  }\n  intros.\n  pose (l := m - S n).\n  assert (m = S l + n). lia.\n  rewrite H1.\n  auto.\nQed.\n\nLemma lt_sum_sum_I_lt : forall n m,\n  Sum n < Sum m -> n < m.\nProof.\n  assert(forall n m, Sum m <= Sum (n + m)).\n  {\n    induction n.\n    simpl. lia.\n    simpl.\n    intros.\n    specialize (IHn m).\n    lia.\n  }\n  intros.\n  destruct(le_lt_dec m n).\n  - assert(Sum m <= Sum n).\n    pose (s := n - m).\n    assert (n = s + m). lia.\n    rewrite H1. auto.\n    lia.\n  - lia.\nQed.\n\nLemma le_sum_sum_I_le : forall n m,\n  Sum n <= Sum m -> n <= m.\nProof.\n  intros.\n  destruct (le_lt_eq_dec (Sum n) (Sum m) H).\n  apply lt_sum_sum_I_lt in l.\n  lia.\n  destruct(le_lt_dec n m).\n  lia.\n  apply lt_I_lt_sum_sum in l.\n  lia.\nQed.\n    \nLemma le_sum_summax_A_lt_sum_s_summax : forall n,\n  Sum (summax n) <= n < Sum (S (summax n)).\nProof.\n  induction n.\n  - simpl. lia.\n  - destruct IHn.\n    Opaque Sum.\n    simpl.\n    Transparent Sum.\n    destruct (le_lt_dec (Sum (S (summax n))) (S n)).\n    split. lia.\n    simpl. simpl in H0. simpl in l.\n    lia.\n    split.\n    lia.\n    lia.\nQed.\n\nLemma summax_cpair_E_plus : forall n m,\n  summax (cpair n m) = n + m.\nProof.\n  unfold cpair.\n  intros.\n  assert (H := le_sum_summax_A_lt_sum_s_summax (n + Sum (n + m))).\n  destruct H.\n  assert (n + Sum (n + m) < Sum (S (n + m))).\n  simpl. lia.\n  assert (summax (n + Sum (n + m)) < S (n + m)).\n  apply lt_sum_sum_I_lt. lia.\n  assert (n + m < S (summax (n + Sum (n + m)))).\n  apply lt_sum_sum_I_lt. lia.\n  lia.\nQed.\n\nTheorem pairing_fst : forall n m, fst (n; m) = n.\nProof.\n  unfold fst.\n  intros.\n  rewrite summax_cpair_E_plus.\n  unfold cpair.\n  lia.\nQed.\n\nTheorem pairing_snd : forall n m, snd (n; m) = m.\nProof.\n  intros.\n  unfold snd.\n  rewrite pairing_fst.\n  rewrite summax_cpair_E_plus.\n  lia.\nQed.\n\nTheorem pairing_inj_fst : forall x y u v,\n  cpair x y = cpair u v -> x = u.\nProof.\n  intros.\n  assert(H0 := pairing_fst x y).\n  rewrite <- H0.\n  rewrite H.\n  apply pairing_fst.\nQed.\n\nTheorem pairing_inj_snd : forall x y u v,\n  cpair x y = cpair u v -> y = v.\nProof.\n  intros.\n  assert(H0 := pairing_snd x y).\n  rewrite <- H0.\n  rewrite H.\n  apply pairing_snd.\nQed.\n\nTheorem n_E_cpair_fst_snd : forall n,\n  n = (fst n; snd n).\nProof.\n  intros.\n  unfold cpair, snd, fst.\n  assert (H := le_sum_summax_A_lt_sum_s_summax n).\n  destruct H.\n  simpl in H0.\n  assert (n - Sum (summax n) + (summax n - (n - Sum (summax n))) = summax n). lia.\n  rewrite H1.\n  lia.\nQed.\n\nLemma fst_descending : forall n,\n  fst n < S n.\nProof.\n  unfold fst.\n  intros.\n  lia.\nQed.\n\nLemma snd_descending : forall n,\n  snd n < S n.\nProof.\n  intros.\n  rewrite (n_E_cpair_fst_snd n) at 2.\n  assert (H := le_cpair_snd (fst n) (snd n)).\n  lia.\nQed.\n\nDefinition cnil := 0.\nDefinition ccons (n m : nat) := S (n; m).\n\nNotation \"`( x ; y ; .. ; z )\" := (ccons x (ccons y .. (ccons z cnil) ..)).\n\nCompute `(0;1;0;0).\n\nFixpoint nth (n0 m0 : nat) : nat :=\n  match n0, m0 with\n  | 0, S m   => S (fst m)\n  | S n, S m => nth n (snd m)\n  | _, 0     => 0 \n  end.\n\nFunction lh (n0 : nat) {wf lt n0}: nat :=\n  match n0 with\n  | 0 => 1\n  | S n => S (lh (snd n))\n  end.\nProof.\n  intros.\n  apply snd_descending.\n  exact lt_wf.\nQed.",
      "theorem": "Lemma le_cpair_fst n m : n <= cpair n m.",
      "ground_truth": "Proof.\n  unfold cpair.\n  lia.\nQed."
    },
    {
      "split": "train-sft",
      "index": 9,
      "prefix": "Require Import Coq.Lists.List.\nImport ListNotations.\n\nRequire Import Cap.\nRequire Import CapSets.\nRequire Import CapGroups.\nRequire Import Notations.\n\nLtac unfold_classes := repeat unfold\n  alias, unalias,\n  blob, blob_combine, blob_combine_one,\n  elemOf, elemOf_union, elemOf_list, elemOf_bot,\n  READABLE, NONWRITABLE, WRITABLE, STABLE, ISO, TRN, REF, VAL, BOX, TAG in *.\nLtac finish := solve [subst; unfold_classes; tauto].\nHint Extern 4 (~(_ = _)) => discriminate.\nHint Extern 4 ((_ = _)) => symmetry.\nHint Extern 4 => unfold_classes.\n\nTactic Notation \"destruct_ecap\" constr(e) :=\n  (destruct e as [[]| |]).\nTactic Notation \"destruct_ecap\" constr(e1) \",\" constr(e2) :=\n  (destruct_ecap e1 ; destruct_ecap e2).\nTactic Notation \"destruct_ecap\" constr(e1) \",\" constr(e2) \",\" constr(e3) :=\n  (destruct_ecap e1 ; destruct_ecap e2 ; destruct_ecap e3).\n\nTactic Notation \"destruct'\" constr(H) := destruct H.\nTactic Notation \"destruct'\" constr(H) \"by\" tactic(tac) :=\n  (let h := fresh \"H\" in assert H as h by tac; destruct h).\nTactic Notation \"destruct'\" constr(H) \"as\" simple_intropattern(pat) \"by\" tactic(tac) :=\n  (let h := fresh \"H\" in assert H as h by tac; destruct h as pat).\n\nTactic Notation \"replace'\" constr(e1) \"with\" constr(e2) \"by\" tactic(tac) :=\n  replace e1 with e2 in * by (symmetry; tac).\n\nLemma lemma1 {A} : forall (x y: A), In x [y] -> x = y.\nProof. intros. destruct H; [auto | destruct H]. Qed.\nHint Resolve lemma1.\n\nLemma lemma2 {A} : forall (x: A) (xs: list A), In x (x::xs).\nProof. simpl. finish. Qed.\nHint Resolve lemma2.\n\nLemma lemma3 {A} : forall (x y: A) (xs: list A), In y xs -> In y (x::xs).\nProof. simpl. finish. Qed.\nHint Resolve lemma3.\n\nLemma lemma4 : forall \u03bb \u03bbs \u03ba,\n  \u03bb \u2208 (\u03bbs \u2218 \u03ba) -> exists o \u03bb0, \u03bb0 \u2208 \u03bbs /\\ adapt o \u03bb0 \u03ba = Some \u03bb.\nProof with auto.\nintros.\ninduction \u03bbs as [|\u03bb0].\n- exfalso. auto.\n- assert (\u03bb \u2208 (\u03bbs \u2218 \u03ba) -> exists (o : op) (\u03bb1 : ecap), \u03bb1 \u2208 (\u03bb0::\u03bbs) /\\ adapt o \u03bb1 \u03ba = Some \u03bb) as IH\u03bbs'.\n  + intro.\n    destruct IH\u03bbs as [o [\u03bb10 [? ?]]]. auto.\n    exists o, \u03bb10. split. apply lemma3. auto. auto.\n\n  + unfold_classes; unfold combine_one in H; fold combine_one in H.\n    destruct (adapt read \u03bb0 \u03ba) eqn:?; destruct (adapt extract \u03bb0 \u03ba) eqn:?.\n    1:   inversion_clear H; [subst; eexists read, \u03bb0; eauto | rename H0 into H].\n    1-3: inversion_clear H; [subst; eexists _, \u03bb0; eauto |].\n    all: apply IH\u03bbs'; auto.\nQed.\n\nLemma lemma5: forall o \u03bb0 \u03bbs \u03ba \u03bb1,\n  \u03bb0 \u2208 \u03bbs -> adapt o \u03bb0 \u03ba = Some \u03bb1 -> \u03bb1 \u2208 (\u03bbs \u2218 \u03ba).\nProof with auto.\nintros.\ninduction \u03bbs.\n- inversion H.\n- destruct H; unfold_classes; unfold combine_one.\n  + destruct o.\n    * subst. rewrite H0.\n      destruct (adapt extract \u03bb0 \u03ba)...\n    * subst. rewrite H0.\n      destruct (adapt read \u03bb0 \u03ba)...\n  + destruct (adapt extract a \u03ba); destruct (adapt read a \u03ba)...\nQed.\n\nLemma lemma6: forall \u03bb \u03bb',\n  subcap \u03bb \u03bb' -> subcap \u03bb' \u03bb -> \u03bb = \u03bb'.\nProof with auto.\nintros.\ndestruct_ecap \u03bb, \u03bb';\ninversion H; inversion H0; auto.\nQed.\n\nLemma lemma7: forall \u03bb \u03bb' \u03bb'',\n  subcap \u03bb \u03bb' -> subcap \u03bb' \u03bb'' -> subcap \u03bb \u03bb''.\nProof.\nintros.\ninversion H; inversion H0; subst; try inversion H3; auto.\nQed.\n\nLemma lemma8: forall \u03ba \u03ba',\n  unalias \u03ba = unalias \u03ba' -> \u03ba = \u03ba'.\nProof with auto.\ndestruct \u03ba, \u03ba'; unfold unalias; inversion 1...\nQed.\n\nLemma lemma9: forall \u03bbs \u03ba \u03ba',\n  \u03bbs \u2208 (G \u03ba) ->\n  \u03bbs \u2208 (G \u03ba') ->\n  \u03ba = \u03ba'.\nProof with auto.\nintros \u03bbs \u03ba \u03ba' [H\u03baA H\u03baB] [H\u03ba'A H\u03ba'B].\napply lemma8, lemma6...\nQed.\n\nLemma lemma10: forall \u03bb \u03ba \u03ba',\n  adapt extract (unalias \u03ba) \u03ba' = Some \u03bb ->\n  unalias (alias \u03bb) = \u03bb.\nProof.\nintros.\ndestruct \u03ba, \u03ba'; inversion H; subst; auto.\nQed.\n\nLemma lemma11: forall \u03bb \u03ba \u03ba',\n  adapt extract (unalias \u03ba) \u03ba' = None ->\n  adapt read (unalias \u03ba) \u03ba' = Some \u03bb ->\n  unalias (alias \u03bb) = \u03bb.\nProof.\nintros.\ndestruct \u03ba, \u03ba'; inversion H0; inversion H; subst; auto.\nQed.\n\nLemma lemma12: forall o \u03bb0 \u03bb0' \u03ba \u03bb1 \u03bb1',\n  subcap \u03bb0 \u03bb0' ->\n  adapt o \u03bb0 \u03ba = Some \u03bb1 ->\n  adapt o \u03bb0' \u03ba = Some \u03bb1' ->\n  subcap \u03bb1 \u03bb1'.\nProof.\nintros.\ninversion H.\n1: subst. rewrite H0 in H1. inversion H1. subst. apply subcap_refl.\nall: destruct o, \u03ba ; subst; inversion H0; inversion H1; auto.\nQed.\n\nLemma lemma13: forall \u03ba \u03ba' \u03bbe \u03bbr,\n  adapt extract (unalias \u03ba) \u03ba' = Some \u03bbe ->\n  adapt read (unalias \u03ba) \u03ba' = Some \u03bbr ->\n  subcap \u03bbe \u03bbr.\nProof with auto.\ndestruct \u03ba, \u03ba'; inversion 1; inversion 1; subst...\nQed.\n\nLemma lemma14: forall \u03bb \u03ba \u03bbe,\n  adapt extract \u03bb \u03ba = Some \u03bbe ->\n  exists \u03bbr, adapt read \u03bb \u03ba = Some \u03bbr.\nProof with auto.\nintros.\ndestruct (adapt read \u03bb \u03ba) as [\u03bbr|] eqn:?.\n- exists \u03bbr...\n- destruct_ecap \u03bb; destruct \u03ba; inversion Heqo; inversion H.\nQed.\n\nLemma lemma15 : forall \u03bbs \u03ba \u03ba' \u03bb,\n  \u03bbs \u2208 (G \u03ba) ->\n  adapt extract (unalias \u03ba) \u03ba' = Some \u03bb ->\n  (\u03bbs \u2218 \u03ba') \u2208 (G (alias \u03bb)).\nProof with eauto.\nintros \u03bbs \u03ba \u03ba' \u03bb [? ?] ?.\nunfold elemOf, elemOf_capgroup in *.\nerewrite lemma10; eauto.\nsplit.\n- eapply lemma5...\n- intros \u03bb0 ?.\n  edestruct lemma4 as [[] [\u03bb' [? Hadapt]]]; eauto.\n  * edestruct lemma14 as [\u03bb'']; eauto.\n    apply lemma7 with (\u03bb':=\u03bb'').\n    + eapply lemma13...\n    + eapply lemma12; [apply H0|..] ...\n  * eapply lemma12; [apply H0|..] ...\nQed.\n\n\nLemma lemma16 : forall \u03bbs \u03ba \u03ba' \u03bb,\n  \u03bbs \u2208 (G \u03ba) -> \u03bb \u2208 \u03bbs ->\n  adapt extract (unalias \u03ba) \u03ba' = None ->\n  adapt extract \u03bb \u03ba' = None.\nProof.\nintros.\nassert (subcap (unalias \u03ba) \u03bb) by (apply H; auto).\ndestruct_ecap \u03bb; destruct \u03ba, \u03ba'; simpl in *;\ninversion H1; inversion H2; auto.\nQed.\n\nLemma lemma17 : forall \u03bbs \u03ba \u03ba' \u03bb,\n  \u03bbs \u2208 (G \u03ba) ->\n  adapt extract (unalias \u03ba) \u03ba' = None ->\n  adapt read (unalias \u03ba) \u03ba' = Some \u03bb ->\n  (\u03bbs \u2218 \u03ba') \u2208 (G (alias \u03bb)).\nProof with eauto.\nintros \u03bbs \u03ba \u03ba' \u03bb [? ?] ? ?.\nunfold elemOf, elemOf_capgroup in *.\nerewrite lemma11; eauto.\nsplit.\n- eapply lemma5...\n- intros \u03bb0 ?.\n  edestruct lemma4 as [[] [\u03bb' [? Hadapt]]]; eauto.\n  * eapply lemma12; [apply H0|..] ...\n  * assert (adapt extract \u03bb' \u03ba' = None)\n      by (eapply lemma16; unfold elemOf, elemOf_capgroup; eauto).\n    rewrite H5 in Hadapt. inversion Hadapt.\nQed.\n\nLemma lemma18 : forall \u03bbs \u03ba,\n  (\u03bbs \u2208 (G iso \u222a G trn \u222a G val)) ->\n  (\u03bbs \u2218 \u03ba \u2208 (G iso \u222a G trn \u222a G val) \\/ \u03ba = tag).\nProof with auto.\nintros.\ndestruct H as [|[|]].\n\nall: try solve [\n  destruct \u03ba eqn:?;\n  eassert ((\u03bbs \u2218 \u03ba) \u2208 (G _))\n    by (eapply lemma15 + eapply lemma17; eauto; subst \u03ba; finish);\n  subst \u03ba; finish].\nQed.\n\nLemma lemma19 : forall \u03bbs \u03bas \u03ba,\n  \u03bbs \u2218 (\u03bas++[\u03ba]) = \u03bbs \u2218 \u03bas \u2218 \u03ba.\nProof.\nintros. unfold_classes. unfold combine. rewrite fold_left_app. auto.\nQed.\n\nLemma lemma20: [C ref] \u2208 (G ref).\nProof with auto.\nsplit; simpl; auto.\nintros. rewrite lemma1 with (y:=C ref); auto.\nQed.\nHint Resolve lemma20.\n\nLemma lemma21 {A}: forall (xs: list A),\n  (forall x, x \u2208 xs -> False) -> xs = [].\nProof.\nintros.\ndestruct xs; [auto | exfalso; apply H with (x:=a); apply lemma2].\nQed.\n\nLemma lemma22: forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 TAG -> (\u03bbs \u2218 \u03ba) \u2208 BOT.\nProof.\nintros.\nunfold_classes.\napply lemma21.\nintros \u03bb1 ?.\nedestruct lemma4 as [o [\u03bb0 [? Hadapt]]]; only 1: apply H0.\nassert (subcap (C tag) \u03bb0) by (apply H; auto).\nassert (\u03bb0 = C tag) by (inversion H2; auto).\nsubst \u03bb0.\ndestruct o, \u03ba; inversion Hadapt.\nQed.\n\nLemma lemma23: forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 BOT -> (\u03bbs \u2218 \u03ba) \u2208 BOT.\nProof.\nintros; unfold_classes; subst \u03bbs; unfold combine_one; trivial.\nQed.\n\nLemma lemma24: forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 READABLE -> exists \u03ba', (\u03bbs \u2218 \u03ba) \u2208 G(\u03ba').\nProof.\nintros.\ndestruct_READABLE H.\nall:\n  destruct \u03ba eqn:?;\n  eassert ((\u03bbs \u2218 \u03ba) \u2208 (G (alias _)))\n    by (eapply lemma15 + eapply lemma17; eauto; subst \u03ba; finish);\n  eexists _; subst; apply H0.\nQed.\n\nLemma lemma25: forall \u03bbs (\u03ba: cap),\n  \u03bbs \u2208 G \u03ba -> \u03bbs \u2208 STABLE.",
      "suffix": "\nHint Resolve lemma25.\n\nLemma lemma26: forall \u03bbs (\u03ba: cap),\n  \u03bbs \u2208 STABLE -> (\u03bbs \u2218 \u03ba) \u2208 STABLE.\nProof with auto.\nintros.\nunfold STABLE in *.\ndestruct_STABLE H.\n\n1-5: edestruct lemma24 with (\u03bbs:=\u03bbs);\n     [ unfold_classes; unfold READABLE; auto\n     | eapply lemma25; eauto].\n\nall: assert ((\u03bbs \u2218 \u03ba) \u2208 BOT) by (apply lemma22 + apply lemma23; auto);\n     unfold_classes; finish.\nQed.\nHint Resolve lemma26.\n\nLemma lemma27: forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 STABLE -> (\u03bbs \u2218 \u03bas) \u2208 STABLE.\nProof.\ninduction \u03bas using rev_ind.\n- unfold blob, blob_combine, combine, fold_left; auto.\n- intros. erewrite lemma19. apply lemma26. auto.\nQed.\nHint Resolve lemma27.\n\nLemma lemma28: forall (\u03bbs: capset),\n  \u03bbs \u2208 READABLE -> \u03bbs \u2218 tag \u2208 TAG.\nProof with auto.\nintros.\ndestruct_READABLE H.\nall:\n  eassert ((\u03bbs \u2218 tag) \u2208 (G (alias (C tag))))\n    by (eapply lemma15 + eapply lemma17; eauto)...\nQed.\n\nLemma lemma29 : forall \u03bbs,\n  \u03bbs \u2208 STABLE -> \u03bbs \u2218 tag \u2208 TAG \\/ \u03bbs \u2218 tag \u2208 BOT.\nProof with finish.\nintros.\ndestruct_STABLE H.\n1-5: left; apply lemma28; unfold READABLE...\n- right; apply lemma22...\n- right; apply lemma23...\nQed.\n\nLemma lemma30 : forall \u03ba, [unalias \u03ba] \u2208 G \u03ba.\nProof.\nsplit.\nunfold_classes; auto.\ninversion 1; [subst; auto | inversion H0].\nQed.\nHint Resolve lemma30.\n\nLemma lemma31 : forall \u03ba, [unalias \u03ba] \u2208 STABLE.\nProof.\nintros.\nassert ([unalias \u03ba] \u2208 G \u03ba) by apply lemma30.\ndestruct \u03ba; finish.\nQed.\nHint Resolve lemma31.\n\nLemma lemma32 : [C ref] \u2208 STABLE.\nProof.\nreplace (C ref) with (unalias ref) by auto. apply lemma31.\nQed.\nHint Resolve lemma32.\n\nLemma lemma34 : forall (\u03bbs: capset) (\u03bas: list cap),\n  (\u03bbs \u2208 (ISO \u222a TRN \u222a VAL)) ->\n  \u03bbs \u2218 \u03bas \u2208 (ISO \u222a TRN \u222a VAL)\n  \\/ (\u03bbs \u2218 \u03bas \u2208 TAG /\\ [C ref] \u2218 \u03bas \u2208 TAG)\n  \\/ ([C ref] \u2218 \u03bas \u2208 BOT).\nProof with finish.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind.\n1: destruct H as [|[|]]...\n\ndestruct IH\u03bas as [|[|]]; repeat rewrite lemma19.\n- edestruct lemma18 with (\u03bbs:=combine \u03bbs \u03bas) (\u03ba:=\u03ba) as [|]; auto.\n\n  assert (\u03bbs \u2218 \u03bas \u2218 tag \u2208 TAG)\n    by (apply lemma28; finish).\n\n  destruct lemma29 with ([C ref] \u2218 \u03bas);\n    [apply lemma27, lemma32 | ..]...\n\n- assert ([C ref] \u2218 \u03bas \u2218 \u03ba \u2208 BOT) by (apply lemma22; finish)...\n- assert ([C ref] \u2218 \u03bas \u2218 \u03ba \u2208 BOT) by (apply lemma23; finish)...\nQed.\n\nLemma lemma35 : forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 (ISO \u222a TRN \u222a VAL) ->\n  \u03bbs \u2218 \u03bas \u2208 TAG ->\n  [C ref] \u2218 \u03bas \u2208 TAG \u222a BOT.\nProof with finish.\nintros.\nedestruct lemma34 as [|[|]]; eauto.\n- destruct H1 as [|[|]];\n  eassert (_=tag) as H2 by (eapply lemma9; [eapply H1 | eapply H0]);\n  inversion H2.\n- finish.\nQed.\n\nLemma lemma36 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 G \u03ba -> \u03bbs \u2208 BOT -> False.\nProof.\nintros.\ninversion H0. subst.\ndestruct H. destruct H.\nQed.\n\nLemma lemma37 : forall (\u03bbs: capset) (\u03ba: cap) (\u03ba': cap),\n  \u03bbs \u2208 STABLE -> \u03bbs \u2218 \u03ba \u2208 G \u03ba' -> \u03bbs \u2208 READABLE.\nProof.\nintros.\ndestruct_STABLE H.\n1-5: finish.\n- exfalso; eapply lemma36; [apply H0 | apply lemma22; auto].\n- exfalso; eapply lemma36; [apply H0 | apply lemma23; auto].\nQed.\n\nLemma lemma38 : forall (\u03bbs \u03bbs': capset) (\u03ba1: cap) (\u03ba \u03ba': cap),\n  \u03bbs \u2208 G \u03ba -> \u03bbs' \u2208 G \u03ba -> \u03bbs \u2218 \u03ba1 \u2208 G \u03ba' ->\n  \u03bbs' \u2218 \u03ba1 \u2208 G \u03ba'.\nProof with finish.\nintros.\nassert (\u03bbs \u2208 READABLE)\n  by (eapply lemma37; [eapply lemma25|]; eauto).\ndestruct_READABLE H2; try (\n  eassert (\u03ba=_) by (eapply lemma9; [apply H | apply H2]); subst \u03ba;\n  destruct \u03ba1 eqn:?; (\n    eassert (\u03ba' = alias _)\n      by (eapply lemma9; [apply H1 | eapply lemma15 + eapply lemma17; [apply H2 | tauto..]]);\n     subst \u03ba'; eapply lemma15 + eapply lemma17 ; [apply H0 | solve [auto]..]\n  )\n).\nQed.\n\nLemma lemma39 (P: capset -> Prop):\n  (forall \u03bbs, P \u03bbs) -> (forall \u03bbs (\u03ba: cap), P \u03bbs -> P (\u03bbs \u2218 \u03ba)) -> forall \u03bbs \u03bas, P (\u03bbs \u2218 \u03bas).\nProof.\nintros.\ninduction \u03bas as [|\u03ba0] using rev_ind.\n- apply H.\n- rewrite lemma19. apply H0. apply IH\u03bas.\nQed.\n\nLemma lemma40 : forall (\u03bbs: capset), \u03bbs \u2208 READABLE -> exists \u03ba, \u03bbs \u2208 G \u03ba.\nProof.\nintros.\ndestruct_READABLE H.\n1-5: eexists _; apply H.\nQed.\n\nLemma lemma41 : forall (\u03ba \u03ba': cap) (\u03bbs \u03bbs': capset) (\u03bas: list cap),\n  \u03bbs \u2208 G \u03ba ->\n  \u03bbs' \u2208 G \u03ba ->\n  \u03bbs \u2218 \u03bas \u2208 G \u03ba' ->\n  \u03bbs' \u2218 \u03bas \u2208 G \u03ba'.\nProof with finish.\nintros.\ngeneralize dependent \u03bbs; generalize dependent \u03bbs'; generalize dependent \u03ba; generalize dependent \u03ba'.\ninduction \u03bas as [|\u03ba] using rev_ind.\n- intros.\n  assert (\u03ba=\u03ba') by (eapply lemma9; [apply H | apply H1]).\n  subst. auto.\n\n- intros \u03ba2 \u03ba0.\n  intros.\n  rewrite lemma19 in *.\n  destruct lemma40 with (\u03bbs:=combine \u03bbs \u03bas) as [\u03ba1]; auto.\n  eapply lemma37; [apply lemma27; eapply lemma25; apply H | apply H1].\n  apply lemma38 with (\u03bbs:=combine \u03bbs \u03bas) (\u03ba:=\u03ba1); auto.\n  apply IH\u03bas with (\u03ba:=\u03ba0) (\u03bbs:=\u03bbs); auto.\nQed.\n\nLemma lemma42 : forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  \u03bbs \u2218 \u03bas \u2208 TAG ->\n  [C ref] \u2218 \u03bas \u2208 TAG \u222a BOT.\nProof.\nintros.\ndestruct_WRITABLE H.\n1-2: eapply lemma35; unfold_classes; eauto.\nassert ([C ref] \u2218 \u03bas \u2208 TAG)\n  by (apply lemma41 with (\u03bbs:=\u03bbs) (\u03ba:=ref); auto).\nfinish.\nQed.\n\nLemma lemma43 : forall (\u03ba \u03ba': cap),\n  compatible (C \u03ba) (C \u03ba') ->\n  compatible (unalias \u03ba) (unalias \u03ba').\nProof.\nintros.\ninversion H; unfold unalias; auto.\nQed.\n\nLemma lemma44 : forall (\u03bb \u03bb' \u03bb'': ecap),\n  compatible \u03bb \u03bb' ->\n  subcap \u03bb' \u03bb'' ->\n  compatible \u03bb \u03bb''.\nProof.\nintros.\ninversion H; subst; inversion H0; subst; auto.\nQed.\n\nLemma lemma45 : forall (\u03bb1 \u03bb2: ecap),\n  compatible \u03bb1 \u03bb2 ->\n  compatible \u03bb2 \u03bb1.\nProof.\nintros.\ninversion H; auto.\n- destruct_ecap \u03bb2; auto.\nQed.\n\nLemma lemma46 : forall (\u03bb1 \u03bb1' \u03bb2 \u03bb2': ecap),\n  compatible \u03bb1 \u03bb2 ->\n  subcap \u03bb1 \u03bb1' ->\n  subcap \u03bb2 \u03bb2' ->\n  compatible \u03bb1' \u03bb2'.\nProof.\nintros.\napply lemma44 with \u03bb2; [ apply lemma45 |].\napply lemma44 with \u03bb1; [ apply lemma45 |].\nall: auto.\nQed.\n\nLemma lemma47 : forall (\u03ba \u03ba': cap),\n  compatible (unalias \u03ba) (unalias \u03ba') ->\n  compatible (C \u03ba) (C \u03ba').\nProof.\nintros.\ndestruct \u03ba, \u03ba'; inversion H; auto.\nQed.\n\nLemma lemma48 : forall (\u03bbs \u03bbs': capset) (\u03ba \u03ba': cap),\n  \u03bbs \u2208 G \u03ba ->\n  \u03bbs' \u2208 G \u03ba' ->\n  compatible (C \u03ba) (C \u03ba') ->\n  compatible_set \u03bbs \u03bbs'.\nProof.\nintros.\nintros \u03bb \u03bb' ? ?.\napply lemma46 with (unalias \u03ba) (unalias \u03ba') ;\n[ apply lemma43 | apply H | apply H0 ]; auto.\nQed.\n\nLemma lemma49 : forall (\u03bbs \u03bbs': capset) (\u03ba \u03ba': cap),\n  \u03bbs \u2208 G \u03ba ->\n  \u03bbs' \u2208 G \u03ba' ->\n  compatible_set \u03bbs \u03bbs' ->\n  compatible (C \u03ba) (C \u03ba').\nProof.\nintros.\napply lemma47.\napply H1; [ apply H | apply H0 ].\nQed.\n\nLemma lemma50 : forall (\u03bbs: capset),\n  \u03bbs \u2208 STABLE -> \u03bbs \u2208 BOT \\/ exists \u03ba, \u03bbs \u2208 G \u03ba.\nProof.\nintros.\ndestruct_STABLE H;\nsolve [ right; eexists _; apply H | auto ].\nQed.\n\nLemma lemma52 : forall (\u03bbs \u03bbs': capset),\n  \u03bbs \u2208 BOT -> compatible_set \u03bbs \u03bbs'.\nProof.\nintros.\nunfold compatible_set.\nunfold_classes.\nintros. subst. inversion H0.\nQed.\n\nLemma lemma54 : forall (\u03bbs: capset) (\u03bb: ecap),\n  \u03bbs \u2208 TAG -> \u03bb \u2208 \u03bbs -> \u03bb = C tag.\nProof.\nintros.\nassert (subcap (C tag) \u03bb) by (apply H, H0).\ninversion H1. auto.\nQed.\n\nLemma lemma55 : forall (\u03bbs \u03bbs': capset),\n  \u03bbs \u2208 TAG -> compatible_set \u03bbs \u03bbs'.\nProof.\nintros.\nunfold compatible_set.\nintros.\nreplace \u03bb with (C tag)\n  by (symmetry; eapply lemma54; eauto).\napply compatible_tag.\nQed.\n\nLemma lemma56 : forall o \u03bb \u03bb' \u03ba,\n  adapt o \u03bb \u03ba = None ->\n  subcap \u03bb \u03bb' ->\n  adapt o \u03bb' \u03ba = None.\nProof.\nintros.\ninversion H0; subst; auto;\ndestruct o, \u03ba; inversion H; auto.\nQed.\n\nLemma lemma57 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 G \u03ba ->\n  unalias \u03ba :: \u03bbs \u2208 G \u03ba.\nProof.\nintros.\nsplit; auto.\nintros.\ndestruct H0; [subst | apply H]; auto.\nQed.\n\nLemma lemma58 : forall \u03bbs \u03ba \u03ba',\n  (unalias \u03ba :: \u03bbs) \u2208 (G \u03ba) ->\n  adapt extract (unalias \u03ba) \u03ba' = None ->\n  adapt read (unalias \u03ba) \u03ba' = None ->\n  (unalias \u03ba :: \u03bbs) \u2218 \u03ba' \u2208 BOT.\nProof with eauto.\nintros.\nunfold blob, blob_combine_one.\ninduction \u03bbs as [|\u03bb0]; auto.\n- unfold combine_one; fold combine_one.\n  rewrite H0, H1. finish.\n\n- unfold combine_one; fold combine_one.\n  replace (adapt read \u03bb0 \u03ba') with (None : option ecap)\n    by (symmetry; apply lemma56 with (unalias \u03ba); [| apply H]; auto).\n  replace (adapt extract \u03bb0 \u03ba') with (None : option ecap)\n    by (symmetry; apply lemma56 with (unalias \u03ba); [| apply H]; auto).\n\n  apply IH\u03bbs.\n  split; auto.\n  intros.\n  apply H.\n  destruct H2. subst. auto.\n  auto.\nQed.\n\nLemma lemma59 : forall (\u03bbs: capset) (\u03ba: cap) (\u03bb: ecap) (\u03bb1: ecap),\n  \u03bb1 \u2208 \u03bbs \u2218 \u03ba ->\n  \u03bb1 \u2208 (\u03bb :: \u03bbs) \u2218 \u03ba.\nProof.\nintros.\ndestruct lemma4 with \u03bb1 \u03bbs \u03ba as [o [\u03bb0 [? ?]]]; auto.\napply lemma5 with o \u03bb0; [apply lemma3|]; auto.\nQed.\n\nLemma lemma60 : forall (\u03bbs: capset) (\u03ba: cap) (\u03bb: ecap),\n  (\u03bb :: \u03bbs) \u2218 \u03ba \u2208 BOT ->\n  \u03bbs \u2218 \u03ba \u2208 BOT.\nProof.\nintros.\napply lemma21.\nintros \u03bb1 ?.\nassert (\u03bb1 \u2208 (\u03bb :: \u03bbs) \u2218 \u03ba)\n  by (apply lemma59; auto).\nunfold_classes.\nrewrite H in H1.\ndestruct H1.\nQed.\n\nLemma lemma61 : forall (\u03bbs: capset) (\u03ba \u03ba': cap),\n  \u03bbs \u2208 (G \u03ba) ->\n  adapt extract (unalias \u03ba) \u03ba' = None ->\n  adapt read (unalias \u03ba) \u03ba' = None ->\n  \u03bbs \u2218 \u03ba' \u2208 BOT.\nProof with eauto.\nintros.\napply lemma60 with (unalias \u03ba).\napply lemma58; auto.\napply lemma57; auto.\nQed.\n\nInductive group_adapt : cap -> cap -> cap -> Prop :=\n| group_adapt_iso_iso : group_adapt iso iso iso\n| group_adapt_iso_trn : group_adapt iso trn iso\n| group_adapt_iso_ref : group_adapt iso ref iso\n| group_adapt_iso_val : group_adapt iso val val\n| group_adapt_iso_box : group_adapt iso box val\n| group_adapt_iso_tag : group_adapt iso tag tag\n\n| group_adapt_trn_iso : group_adapt trn iso iso\n| group_adapt_trn_trn : group_adapt trn trn trn\n| group_adapt_trn_ref : group_adapt trn ref trn\n| group_adapt_trn_val : group_adapt trn val val\n| group_adapt_trn_box : group_adapt trn box val\n| group_adapt_trn_tag : group_adapt trn tag tag\n\n| group_adapt_ref_iso : group_adapt ref iso iso\n| group_adapt_ref_trn : group_adapt ref trn trn\n| group_adapt_ref_ref : group_adapt ref ref ref\n| group_adapt_ref_val : group_adapt ref val val\n| group_adapt_ref_box : group_adapt ref box box\n| group_adapt_ref_tag : group_adapt ref tag tag\n\n| group_adapt_val_iso : group_adapt val iso val\n| group_adapt_val_trn : group_adapt val trn val\n| group_adapt_val_ref : group_adapt val ref val\n| group_adapt_val_val : group_adapt val val val\n| group_adapt_val_box : group_adapt val box val\n| group_adapt_val_tag : group_adapt val tag tag\n\n| group_adapt_box_iso : group_adapt box iso tag\n| group_adapt_box_trn : group_adapt box trn box\n| group_adapt_box_ref : group_adapt box ref box\n| group_adapt_box_val : group_adapt box val val\n| group_adapt_box_box : group_adapt box box box\n| group_adapt_box_tag : group_adapt box tag tag\n.\nHint Constructors group_adapt.\n\nLemma lemma62 : forall (\u03bbs: capset) (\u03ba \u03ba' \u03ba'': cap),\n  \u03bbs \u2208 G \u03ba ->\n  \u03bbs \u2218 \u03ba' \u2208 G \u03ba'' <-> group_adapt \u03ba \u03ba' \u03ba''.\nProof.\nintros.\nsplit.\n- intro.\n  destruct \u03ba eqn:?, \u03ba' eqn:?;\n  (destruct (adapt extract (unalias \u03ba) \u03ba') as [\u03bb|] eqn:Hextract;\n  [| destruct (adapt read (unalias \u03ba) \u03ba') as [\u03bb|] eqn:Hread];\n  [\n    replace \u03ba'' with (alias \u03bb)\n      by (apply lemma9 with (\u03bbs \u2218 \u03ba'); [apply lemma15 with \u03ba|]; subst; auto);\n    (subst; inversion Hextract; auto)\n  |\n    replace \u03ba'' with (alias \u03bb)\n      by (apply lemma9 with (\u03bbs \u2218 \u03ba'); [apply lemma17 with \u03ba|]; subst; auto);\n    (subst; inversion Hread; auto)\n  |\n    exfalso; subst;\n      eapply lemma36; eauto;\n      eapply lemma61; eauto\n  ]).\n  inversion Hextract.\n  inversion Hextract.\n\n- intro.\n  assert (forall \u03ba, G \u03ba = G (alias (unalias \u03ba))) as Hrewrite\n    by (destruct 0; auto).\n  rewrite Hrewrite.\n  inversion H0; subst;\n  solve [ eapply lemma15; eauto | eapply lemma17; eauto].\nQed.\n\nLemma lemma62a : forall (\u03bbs: capset) (\u03ba \u03ba' \u03ba'': cap),\n  \u03bbs \u2208 G \u03ba ->\n  \u03bbs \u2218 \u03ba' \u2208 G \u03ba'' -> group_adapt \u03ba \u03ba' \u03ba''.\nProof. eapply lemma62. Qed.\n\nLtac destruct_group_adapt \u03ba \u03ba' \u03ba'' :=\n  let H := fresh \"H\" in\n  eassert (group_adapt \u03ba \u03ba' \u03ba'') as H; [apply -> lemma62 | inversion H].\n\nLemma lemma63 : forall (\u03ba: cap),\n  [C ref] \u2218 \u03ba \u2208 ISO -> \u03ba = iso.\nProof.\nintros. destruct_group_adapt ref \u03ba iso; eauto. Qed.\n\nLemma lemma64 (\u03ba: cap) : forall (\u03bbs \u03bbs': capset),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs' \u2208 G \u03ba ->\n  compatible_set \u03bbs \u03bbs' ->\n  match \u03ba with\n  | iso => \u03bbs \u2208 TAG \u222a BOT\n  | trn => \u03bbs \u2208 BOX \u222a TAG \u222a BOT\n  | ref => \u03bbs \u2208 REF \u222a BOX \u222a TAG \u222a BOT\n  | val => \u03bbs \u2208 VAL \u222a BOX \u222a TAG \u222a BOT\n  | box => \u03bbs \u2208 TRN \u222a REF \u222a VAL \u222a BOX \u222a TAG \u222a BOT\n  | tag => \u03bbs \u2208 ISO \u222a TRN \u222a REF \u222a VAL \u222a BOX \u222a TAG \u222a BOT\n  end.\nProof with finish.\nintros.\ndestruct lemma50 with \u03bbs as [|[\u03ba' ?]]; auto.\n- destruct \u03ba; finish.\n- assert (compatible (C \u03ba') (C \u03ba)) as Hcompat\n    by (eapply lemma49; eauto).\n  destruct \u03ba; inversion Hcompat...\nQed.\n\nLemma lemma66 : forall (\u03bbs: capset),\n  \u03bbs \u2208 WRITABLE -> \u03bbs \u2208 STABLE.\nProof. finish. Qed.\nHint Resolve lemma66.\n\nLemma lemma67 : forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 (ISO \u222a TRN \u222a VAL) ->\n  \u03bbs \u2218 \u03bas \u2208 BOT ->\n  [C ref] \u2218 \u03bas \u2208 BOT.\nProof with finish.\nintros.\nedestruct lemma34 as [|[|]]; eauto.\n- exfalso; destruct H1 as [|[|]]; eapply lemma36; eauto.\n- exfalso; eapply lemma36 with (\u03bbs:=\u03bbs \u2218 \u03bas); [eapply H1 | auto].\nQed.\n\nLemma lemma68 : forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  \u03bbs \u2218 \u03bas \u2208 BOT ->\n  [C ref] \u2218 \u03bas \u2208 BOT.\nProof with finish.\nintros.\ndestruct_writable \u03bbs by auto.\n1-2: eapply lemma67 with \u03bbs...\n\nedestruct lemma50 with ([C ref] \u2218 \u03bas) as [|[\u03ba]];\n[apply lemma27, lemma32|..]; auto.\nexfalso.\napply lemma36 with (\u03bbs:=\u03bbs \u2218 \u03bas) (\u03ba:=\u03ba); auto.\napply lemma41 with (\u03bbs:=[C ref]) (\u03ba:=ref); auto.\nQed.\n\nLemma lemma69 : forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 (ISO \u222a TRN \u222a VAL) ->\n  \u03bbs \u2218 \u03bas \u2208 BOX ->\n  [C ref] \u2218 \u03bas \u2208 BOT.\nProof with finish.\nintros.\nedestruct lemma34 as [[|[|]]|[|]]; eauto;\neassert (_=box) as H2 by (eapply lemma9 with (\u03bbs:=\u03bbs \u2218 \u03bas); [apply H1 | apply H0]); inversion H2.\nQed.\n\nLemma lemma70 : forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  \u03bbs \u2218 \u03bas \u2208 BOX ->\n  [C ref] \u2218 \u03bas \u2208 BOX \u222a BOT.\nProof with finish.\nintros.\ndestruct_writable \u03bbs by auto.\n1-2: right; eapply lemma69 with \u03bbs...\n     left; apply lemma41 with ref \u03bbs; auto.\nQed.\n\nLemma lemma71 : forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  \u03bbs \u2218 \u03bas \u2208 BOX \u222a TAG \u222a BOT ->\n  [C ref] \u2218 \u03bas \u2208 BOX \u222a TAG \u222a BOT.\nProof with finish.\nintros.\ndestruct H0 as [|[|]].\n- assert ([C ref] \u2218 \u03bas \u2208 BOX \u222a BOT) by (eapply lemma70; eauto)...\n- assert ([C ref] \u2218 \u03bas \u2208 TAG \u222a BOT) by (eapply lemma42; eauto)...\n- assert ([C ref] \u2218 \u03bas \u2208 BOT) by (eapply lemma68; eauto)...\nQed.\n\nLemma lemma72 : forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  \u03bbs \u2218 \u03bas \u2208 TAG \u222a BOT ->\n  [C ref] \u2218 \u03bas \u2208 TAG \u222a BOT.\nProof with finish.\nintros.\ndestruct H0 as [|].\n- assert ([C ref] \u2218 \u03bas \u2208 TAG \u222a BOT) by (eapply lemma42; eauto)...\n- assert ([C ref] \u2218 \u03bas \u2208 BOT) by (eapply lemma68; eauto)...\nQed.\n\nLemma lemma73 : forall (\u03bbs1 \u03bbs2: capset),\n  compatible_set \u03bbs1 \u03bbs2 ->\n  compatible_set \u03bbs2 \u03bbs1.\nProof.\nunfold compatible_set.\nintros; apply lemma45; auto.\nQed.\n\nLemma lemma74 : forall (\u03bbs1 \u03bbs2: capset) (\u03ba: cap),\n  \u03bbs1 \u2208 STABLE -> \u03bbs2 \u2208 STABLE ->\n  \u03bbs1 \u2218 \u03ba \u2208 ISO ->\n  \u03bbs2 \u2218 \u03ba \u2208 TRN \u222a REF ->\n  \u03bbs1 \u2208 ISO /\\ \u03bbs2 \u2208 TRN \u222a REF.\nProof.\nintros.\ndestruct' (exists \u03ba1 : cap, \u03bbs1 \u2208 G \u03ba1) as [\u03ba1]\n  by (destruct lemma50 with \u03bbs1 as [|[]]; [| exfalso ; apply lemma36 with (\u03bbs1 \u2218 \u03ba) iso; [|apply lemma23]; eauto |]; eauto).\n\ndestruct H2 as [H2|H2];\n\n (destruct' (exists \u03ba2 : cap, \u03bbs2 \u2208 G \u03ba2) as [\u03ba2]\n    by (destruct lemma50 with \u03bbs2 as [|[]]; [| exfalso ; eapply lemma36 with (\u03bbs2 \u2218 \u03ba) _; [|apply lemma23]; eauto |]; eauto));\n\n  eassert (group_adapt \u03ba1 \u03ba iso) as Hadapt1 by (apply -> lemma62; eauto);\n  eassert (group_adapt \u03ba2 \u03ba _) as Hadapt2 by (apply -> lemma62; eauto);\n\n  inversion Hadapt1; subst;\n  inversion Hadapt2; subst;\n\n  finish.\nQed.\n\nLemma lemma75 : forall (\u03bbs1 \u03bbs2: capset) (\u03bas: list cap),\n  \u03bbs1 \u2208 STABLE -> \u03bbs2 \u2208 STABLE ->\n  \u03bbs1 \u2218 \u03bas \u2208 ISO ->\n  \u03bbs2 \u2218 \u03bas \u2208 TRN \u222a REF ->\n  \u03bbs1 \u2208 ISO /\\ \u03bbs2 \u2208 TRN \u222a REF.\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\n- rewrite lemma19 in *.\n  destruct lemma74 with (\u03bbs1 \u2218 \u03bas) (\u03bbs2 \u2218 \u03bas) \u03ba; eauto.\nQed.\n\nLemma lemma76 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03ba \u2208 ISO ->\n  \u03bbs \u2208 ISO \\/ \u03ba = iso.\nProof.\nintros.\nassert (exists \u03ba, \u03bbs \u2208 G \u03ba) as [\u03ba0]\n  by (apply lemma40; apply lemma37 with \u03ba iso; eauto).\ndestruct_group_adapt \u03ba0 \u03ba iso; subst; eauto.\nQed.\n\nLemma lemma77 : forall (\u03ba \u03ba': cap),\n  [unalias \u03ba] \u2208 G \u03ba' -> \u03ba = \u03ba'.\nProof.\nintros.\nsymmetry.\napply lemma8.\napply lemma1.\napply H.\nQed.\n\nLemma lemma78 : forall (\u03bbs: capset) (\u03ba0 \u03ba1 \u03ba2: cap),\n  \u03bbs \u2208 G \u03ba0 ->\n  \u03bbs \u2218 \u03ba1 \u2208 G \u03ba2 ->\n  adapt extract (unalias \u03ba0) \u03ba1 = Some (unalias \u03ba2) \\/\n  adapt extract (unalias \u03ba0) \u03ba1 = None /\\ adapt read (unalias \u03ba0) \u03ba1 = Some (unalias \u03ba2).\nProof.\nintros.\ndestruct_group_adapt \u03ba0 \u03ba1 \u03ba2; eauto.\nQed.\n\nLemma lemma79: forall o \u03bb0 \u03bb0' \u03ba \u03bb1',\n  subcap \u03bb0 \u03bb0' ->\n  adapt o \u03bb0' \u03ba = Some \u03bb1' ->\n  exists \u03bb1, adapt o \u03bb0 \u03ba = Some \u03bb1 /\\ subcap \u03bb1 \u03bb1'.\nProof.\nintros.\ninversion H.\n1: subst. exists \u03bb1'. auto.\nall: destruct o, \u03ba ; subst; inversion H0;\n  (eexists _; unfold adapt; eauto).\nQed.\n\nLemma lemma81 : forall (\u03ba: cap), alias (unalias \u03ba) = \u03ba.\nProof. destruct 0; auto. Qed.\n\nLemma lemma82 : forall (\u03ba \u03ba': cap) \u03bb,\n  adapt extract (unalias \u03ba) \u03ba' = Some \u03bb ->\n  exists \u03ba'', \u03bb = unalias \u03ba''.\nProof.\nintros.\ndestruct \u03ba, \u03ba'; inversion H;\nexists (alias \u03bb); subst; auto.\nQed.\n\nLemma lemma83 : forall (\u03ba \u03ba': cap) \u03bb,\n  adapt extract (unalias \u03ba) \u03ba' = None ->\n  adapt read (unalias \u03ba) \u03ba' = Some \u03bb ->\n  exists \u03ba'', \u03bb = unalias \u03ba''.\nProof.\nintros.\ndestruct \u03ba, \u03ba'; inversion H0;\nexists (alias \u03bb); subst; auto.\n\nall: inversion H.\nQed.\n\nLemma lemma84 : forall (\u03bbs \u03bbs': capset) (\u03ba0 \u03ba0' \u03ba1' \u03ba: cap),\n  \u03bbs \u2208 G \u03ba0 ->\n  \u03bbs' \u2208 G \u03ba0' ->\n  \u03bbs' \u2218 \u03ba \u2208 G \u03ba1' ->\n  subcap (unalias \u03ba0) (unalias \u03ba0') ->\n  exists \u03ba1, \u03bbs \u2218 \u03ba \u2208 G \u03ba1 /\\ subcap (unalias \u03ba1) (unalias \u03ba1').\nProof.\nintros.\ndestruct lemma78 with \u03bbs' \u03ba0' \u03ba \u03ba1' as [|[]]; auto;\n[| destruct (adapt extract (unalias \u03ba0) \u03ba) eqn:? ].\n\n- edestruct lemma79 as [? []]; eauto.\n  edestruct lemma82 with \u03ba0 \u03ba x; auto.\n  exists (alias x).\n  split.\n  + eapply lemma15; [ apply H | auto..].\n  + subst x. rewrite lemma81. auto.\n\n- edestruct lemma79 as [? []]; eauto.\n  edestruct lemma82 with \u03ba0 \u03ba e; auto.\n  exists (alias e).\n  split.\n  + eapply lemma15; [ apply H | auto..].\n  + subst e; try rewrite lemma81.\n    eapply lemma7; [ eapply lemma13 |]; eauto.\n- edestruct lemma79 as [? []]; eauto.\n  destruct lemma83 with \u03ba0 \u03ba x; auto.\n  exists (alias x).\n  split.\n  + eapply lemma17; [ apply H | auto..].\n  + subst x. rewrite lemma81. auto.\nQed.\n\nLemma lemma85 : forall (\u03bbs \u03bbs': capset) (\u03ba0 \u03ba0' \u03ba1': cap) (\u03bas: list cap),\n  \u03bbs \u2208 G \u03ba0 ->\n  \u03bbs' \u2208 G \u03ba0' ->\n  \u03bbs' \u2218 \u03bas \u2208 G \u03ba1' ->\n  subcap (unalias \u03ba0) (unalias \u03ba0') ->\n  exists \u03ba1, \u03bbs \u2218 \u03bas \u2208 G \u03ba1 /\\ subcap (unalias \u03ba1) (unalias \u03ba1').\nProof.\nintros.\ngeneralize dependent \u03ba0.\ngeneralize dependent \u03ba0'.\ngeneralize dependent \u03ba1'.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\n- intros.\n  exists \u03ba0.\n  replace \u03ba1' with \u03ba0' by (eapply lemma9; eauto).\n  auto.\n- intros.\n  rewrite lemma19 in *.\n\n  destruct lemma40 with (\u03bbs' \u2218 \u03bas); [eapply lemma37|]; eauto.\n  edestruct IH\u03bas as [? []]; eauto.\n  eapply lemma84 with (\u03bbs:=\u03bbs \u2218 \u03bas) (\u03bbs':=\u03bbs' \u2218 \u03bas); eauto.\n\nQed.\n\nLemma lemma86 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  [C ref] \u2218 \u03bas \u2208 ISO ->\n  \u03bbs \u2218 \u03bas \u2208 ISO.\nProof.\nintros.\n(destruct_writable \u03bbs by auto); (\n  edestruct lemma85 with (\u03bbs:=\u03bbs) (\u03bbs':=[C ref]) (\u03ba0':=ref) (\u03bas:=\u03bas) as [\u03ba1 [? Hsubcap]]; eauto;\n  destruct \u03ba1; inversion Hsubcap; auto\n).\nQed.\n\nLemma lemma87 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03ba \u2208 REF ->\n  \u03bbs \u2208 REF /\\ \u03ba = ref.\nProof.\nintros.\nassert (exists \u03ba, \u03bbs \u2208 G \u03ba) as [\u03ba0]\n  by (apply lemma40; eapply lemma37; eauto).\nassert (group_adapt \u03ba0 \u03ba ref)\n  by (eapply lemma62; eauto).\ninversion H2.\nsubst; auto.\nQed.\n\nLemma lemma89 {A} : forall (xs: list A) (x y: A),\n  In x (xs ++ [y]) -> In x xs \\/ x =  y.\nProof. intros; edestruct in_app_or; eauto. Qed.\nHint Resolve lemma89.\n\nLemma lemma88 {A} : forall (xs: list A) (x y: A),\n  In x xs -> In x (xs ++ [y]).\nProof. intros; apply in_or_app; auto. Qed.\nHint Resolve lemma88.\n\nLemma lemma90 {A} : forall (xs: list A) (x: A),\n  In x (xs ++ [x]).\nProof. intros; apply in_or_app; auto. Qed.\nHint Resolve lemma90.\n\nLemma lemma91 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03bas \u2208 REF ->\n  \u03bbs \u2208 REF /\\ (forall \u03ba, \u03ba \u2208 \u03bas -> \u03ba = ref).\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\nrewrite lemma19 in *.\ndestruct lemma87 with (\u03bbs \u2218 \u03bas) \u03ba; auto; subst.\nsplit.\n- apply IH\u03bas; auto.\n- intros.\n  destruct (@lemma89 cap) with \u03bas \u03ba ref; auto.\n  apply IH\u03bas; auto.\nQed.\n\nLemma lemma92 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 REF ->\n  (forall \u03ba, \u03ba \u2208 \u03bas -> \u03ba = ref) -> \n  \u03bbs \u2218 \u03bas \u2208 REF.\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\nrewrite lemma19 in *.\neapply lemma62.\n- apply IH\u03bas; (intros; apply H0; apply lemma88; auto).\n- replace \u03ba with ref by (symmetry; apply H0; apply lemma90).\n  auto.\nQed.\n\nLemma lemma94 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03bas \u2208 REF ->\n  \u03bbs \u2208 REF /\\ (forall \u03ba, \u03ba \u2208 \u03bas -> \u03ba = ref).\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\nrewrite lemma19 in *.\ndestruct lemma87 with (\u03bbs \u2218 \u03bas) \u03ba; auto; subst.\nsplit.\n- apply IH\u03bas; auto.\n- intros.\n  destruct (@lemma89 cap) with \u03bas \u03ba ref; auto.\n  apply IH\u03bas; auto.\nQed.\n\nLemma lemma99: forall \u03bbs \u03ba \u03ba',\n  \u03bbs \u2208 G \u03ba ->\n  match \u03ba, \u03ba' with\n  | iso, iso => \u03bbs \u2218 \u03ba' \u2208 ISO\n  | iso, trn => \u03bbs \u2218 \u03ba' \u2208 ISO\n  | iso, ref => \u03bbs \u2218 \u03ba' \u2208 ISO\n  | iso, val => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | iso, box => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | iso, tag => \u03bbs \u2218 \u03ba' \u2208 TAG\n\n  | trn, iso => \u03bbs \u2218 \u03ba' \u2208 ISO\n  | trn, trn => \u03bbs \u2218 \u03ba' \u2208 TRN\n  | trn, ref => \u03bbs \u2218 \u03ba' \u2208 TRN\n  | trn, val => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | trn, box => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | trn, tag => \u03bbs \u2218 \u03ba' \u2208 TAG\n\n  | ref, iso => \u03bbs \u2218 \u03ba' \u2208 ISO\n  | ref, trn => \u03bbs \u2218 \u03ba' \u2208 TRN\n  | ref, ref => \u03bbs \u2218 \u03ba' \u2208 REF\n  | ref, val => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | ref, box => \u03bbs \u2218 \u03ba' \u2208 BOX\n  | ref, tag => \u03bbs \u2218 \u03ba' \u2208 TAG\n\n  | val, iso => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | val, trn => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | val, ref => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | val, val => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | val, box => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | val, tag => \u03bbs \u2218 \u03ba' \u2208 TAG\n\n  | box, iso => \u03bbs \u2218 \u03ba' \u2208 TAG\n  | box, trn => \u03bbs \u2218 \u03ba' \u2208 BOX\n  | box, ref => \u03bbs \u2218 \u03ba' \u2208 BOX\n  | box, val => \u03bbs \u2218 \u03ba' \u2208 VAL\n  | box, box => \u03bbs \u2218 \u03ba' \u2208 BOX\n  | box, tag => \u03bbs \u2218 \u03ba' \u2208 TAG\n  | tag, _ => \u03bbs \u2218 \u03ba' \u2208 BOT\n  end.\nProof.\nintros.\ndestruct \u03ba, \u03ba';\nsolve [ eapply lemma62; eauto | apply lemma22; auto].\nQed.\n\nLemma lemma101 (A: Type): forall (P: A -> Prop) (x: A) (xs: list A),\n  (forall y, In y (xs++[x]) -> P y) ->\n  (forall y, In y xs -> P y).\nProof. auto. Qed.\n\nLemma lemma102 (A: Type): forall (P: A -> Prop) (x: A) (xs: list A),\n  (forall y, In y (xs++[x]) -> P y) ->\n  P x.\nProof. auto. Qed.\n\nLemma lemma104: forall \u03bbs, \u03bbs \u2218 [] = \u03bbs.\nProof. finish. Qed.\n\nLemma lemma105: forall \u03bbs \u03ba \u03ba',\n  \u03bbs \u2208 G \u03ba -> \u03bbs \u2208 G \u03ba' -> \u03ba <> \u03ba' -> False.\nProof. intros; apply H1; eapply lemma9; eauto. Qed.\n\nLemma lemma100: forall \u03bbs (\u03ba: cap),\n  \u03bbs \u2208 REF \u222a BOX \u222a TAG \u222a BOT ->\n  (\u03ba = ref \\/ \u03ba = box \\/ \u03ba = tag) ->\n  \u03bbs \u2218 \u03ba \u2208 REF \u222a BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ndestruct H as [|[|[|]]];\ndestruct H0 as [|[|]]; subst \u03ba.\n\nall: solve\n  [ left; eapply lemma62; eauto\n  | right; left; eapply lemma62; eauto\n  | right; right; left; eapply lemma62; eauto\n  | right; right; right; apply lemma22; auto\n  | right; right; right; apply lemma23; auto].\nQed.\n\nLemma lemma103: forall \u03bbs (\u03bas: list cap),\n  \u03bbs \u2208 REF \u222a BOX \u222a TAG \u222a BOT ->\n  (forall \u03ba, \u03ba \u2208 \u03bas -> \u03ba = ref) ->\n  \u03bbs \u2218 \u03bas \u2208 REF \u222a BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\n\nrewrite lemma19.\napply lemma100.\n- apply IH\u03bas; apply lemma101 with (x:=\u03ba); auto.\n- left; apply lemma102 with (x:=\u03ba) (xs:=\u03bas); auto.\nQed.\n\nLemma lemma107: forall \u03bbs (\u03ba: cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03ba \u2208 BOT ->\n  \u03bbs \u2208 BOT \u222a TAG.\nProof.\nintros.\ndestruct lemma50 with \u03bbs as [|[\u03ba' ?]]; auto.\n- pose (lemma99 \u03bbs \u03ba' \u03ba) as H2.\n  destruct \u03ba eqn:?, \u03ba' eqn:?;\n  solve [ exfalso; eapply lemma36; [ apply H2; auto | auto ]\n        | finish ].\nQed.\n\nLemma lemma109: forall \u03bbs,\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 tag \u2208 TAG \u222a BOT.\nProof.\nintros.\n(destruct_stable \u03bbs by auto);\nsolve [ eassert (\u03bbs \u2218 tag \u2208 G _) by (eapply lemma62; eauto); finish\n      | assert (\u03bbs \u2218 tag \u2208 BOT) by (apply lemma22; auto); finish\n      | assert (\u03bbs \u2218 tag \u2208 BOT) by (apply lemma23; auto); finish ].\nQed.\n\nLemma lemma114 : forall \u03bbs,\n  \u03bbs \u2208 STABLE ->\n  compatible_set \u03bbs [C iso] ->\n  \u03bbs \u2208 TAG \u222a BOT.\nProof.\nintros.\ndestruct lemma50 with \u03bbs as [|[\u03ba' ?]]; auto.\ndestruct \u03ba';\nsolve [ eassert (compatible _ (C _)) as Hcompat by (apply H0; [apply H1 | auto]);\n          inversion Hcompat\n      | finish ].\nQed.\n\nLemma lemma115 : forall \u03bbs,\n  \u03bbs \u2208 STABLE ->\n  compatible_set \u03bbs [C trn] ->\n  \u03bbs \u2208 BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ndestruct lemma50 with \u03bbs as [|[\u03ba' ?]]; auto.\ndestruct \u03ba';\nsolve [ eassert (compatible _ (C _)) as Hcompat by (apply H0; [apply H1 | auto]);\n          inversion Hcompat\n      | finish ].\nQed.\n\nLemma lemma117: forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 ISO \u222a TRN \u222a VAL ->\n  (\u03bbs \u2218 \u03ba) \u2208 TAG ->\n  \u03ba = tag.\nProof.\nintros.\ndestruct H as [|[|]].\n- destruct_group_adapt iso \u03ba tag; eauto.\n- destruct_group_adapt trn \u03ba tag; eauto.\n- destruct_group_adapt val \u03ba tag; eauto.\nQed.\n\nLemma lemma119: forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 ISO \u222a TRN \u222a VAL ->\n  (\u03bbs \u2218 \u03ba) \u2208 TAG ->\n  ([C ref] \u2218 \u03ba) \u2208 TAG.\nProof.\nintros.\nreplace' \u03ba with tag by (apply lemma117 with \u03bbs; auto).\neapply lemma62; eauto.\nQed.\n\nLemma lemma121: forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 ISO \u222a TRN \u222a VAL ->\n  (\u03bbs \u2218 \u03ba) \u2208 ISO \u222a TRN \u222a VAL \\/ \u03ba = tag.\nProof.\nintros.\ndestruct \u03ba; auto;\nleft;\ndestruct H as [|[|]];\nsolve [ left; eapply lemma62; eauto\n      | right; left; eapply lemma62; eauto\n      | right; right; eapply lemma62; eauto ].\nQed.\n\nLemma lemma122: forall \u03bbs (\u03ba: cap),\n  \u03bbs \u2208 TAG \u222a BOT ->\n  \u03bbs \u2218 \u03ba \u2208 BOT.\nProof.\nintros.\ndestruct H.\n- apply lemma22; auto.\n- apply lemma23; auto.\nQed.\n\nLemma lemma123: forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 ISO \u222a TRN \u222a VAL ->\n  (\u03bbs \u2218 \u03bas) \u2208 ISO \u222a TRN \u222a VAL \\/ ([C ref] \u2218 \u03bas) \u2208 TAG \u222a BOT.\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\nrepeat rewrite lemma19 in *.\ndestruct IH\u03bas.\n- destruct lemma121 with (\u03bbs \u2218 \u03bas) \u03ba; auto.\n  right. subst. apply lemma109. auto.\n- right. right. apply lemma122. auto.\nQed.\n\nLemma lemma124: forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 ISO \u222a TRN \u222a VAL ->\n  (\u03bbs \u2218 \u03bas) \u2208 TAG \u222a BOT ->\n  ([C ref] \u2218 \u03bas) \u2208 TAG \u222a BOT.\nProof.\nintros.\ndestruct lemma123 with \u03bbs \u03bas; auto.\nexfalso.\ndestruct H0.\n- destruct H1 as [|[|]];\n  (eapply lemma105 with (\u03bbs:=\u03bbs \u2218 \u03bas); [ apply H0 | apply H1 | auto ]).\n- destruct H1 as [|[|]];\n  (eapply lemma36 with (\u03bbs:=\u03bbs \u2218 \u03bas); eauto).\nQed.\n\nLemma lemma125: forall (\u03bbs \u03bbs': capset) (\u03ba: cap) (\u03bas: list cap),\n  \u03bbs \u2208 G \u03ba ->\n  \u03bbs' \u2208 G \u03ba ->\n  \u03bbs \u2218 \u03bas \u2208 BOT ->\n  \u03bbs' \u2218 \u03bas \u2208 BOT.\nProof.\nintros.\ninduction \u03bas as [|\u03ba'] using rev_ind; intros.\n- exfalso; apply lemma36 with \u03bbs \u03ba; auto.\n- rewrite lemma19 in *.\n  destruct lemma107 with (\u03bbs \u2218 \u03bas) \u03ba'; eauto.\n  + apply lemma23. apply IH\u03bas. auto.\n  + apply lemma22. apply lemma41 with (\u03ba:=\u03ba) (\u03bbs:=\u03bbs); auto.\nQed.\n\nLemma lemma130: forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  (\u03bbs \u2218 \u03bas) \u2208 TAG \u222a BOT ->\n  ([C ref] \u2218 \u03bas) \u2208 TAG \u222a BOT.\nProof.\nintros.\ndestruct_writable \u03bbs by auto.\n- apply lemma124 with \u03bbs; finish.\n- apply lemma124 with \u03bbs; finish.\n- destruct H0.\n  + left; apply lemma41 with ref \u03bbs; auto.\n  + right; apply lemma125 with \u03bbs ref; auto.\nQed.\n\nLemma lemma133: forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  (\u03bbs \u2218 \u03bas) \u2208 REF \u222a BOX \u222a TAG \u222a BOT ->\n  ([C ref] \u2218 \u03bas) \u2208 REF \u222a BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ndestruct H0 as [|[|]].\n1-2:\n  (destruct_writable \u03bbs by auto);\n  try solve [ destruct lemma123 with \u03bbs \u03bas; [finish| |finish];\n              exfalso; destruct H2 as [|[|]]; (eapply lemma105 with (\u03bbs:=\u03bbs \u2218 \u03bas); [apply H0|apply H2|auto])\n            | (left + (right; left)); apply lemma41 with ref \u03bbs; auto ].\n\nright; right; apply lemma130 with \u03bbs; auto.\nQed.\n\nLemma lemma134: forall (\u03bbs1 \u03bbs2: capset),\n  \u03bbs1 \u2208 REF \u222a BOX \u222a TAG \u222a BOT ->\n  \u03bbs2 \u2208 REF \u222a BOX \u222a TAG \u222a BOT ->\n  compatible_set \u03bbs1 \u03bbs2.\nProof.\nintros \u03bbs1 \u03bbs2 [|[|[|]]] [|[|[|]]];\n\nsolve [ eapply lemma48; eauto\n      | apply lemma52; auto\n      | apply lemma73, lemma52; auto].\nQed.\n\nLemma lemma135 : forall (\u03bbs: capset) (\u03bb: ecap),\n  \u03bbs \u2208 STABLE ->\n  safe_to_write \u03bb ref ->\n  compatible_set \u03bbs ([C (alias \u03bb)]) ->\n  \u03bbs \u2208 REF \u222a BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ninversion H0; subst; unfold alias in H1.\n- right; right; apply lemma114; auto.\n- right; apply lemma115; auto.\n- apply (lemma64 ref) with [C ref]; auto.\nQed.\n\nLemma lemma150 : forall (\u03ba: cap) (\u03bas: list cap),\n  [unalias \u03ba] \u2218 \u03bas \u2208 VAL ->\n  (\u03ba = val \\/ \u03ba = box) \\/ (val \u2208 \u03bas \\/ box \u2208 \u03bas).\nProof.\nintros.\ninduction \u03bas as [|\u03ba'] using rev_ind; auto.\n- left. left. apply lemma77. auto.\n- rewrite lemma19 in *.\n  destruct_stable ([unalias \u03ba] \u2218 \u03bas) by auto.\n  + destruct_group_adapt iso \u03ba' val;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt trn \u03ba' val;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt ref \u03ba' val;\n    [ apply H | apply H0 | auto..].\n  + destruct IH\u03bas; auto.\n    destruct H1; auto.\n  + destruct_group_adapt box \u03ba' val;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt tag \u03ba' val;\n    [ apply H | apply H0 | auto..].\n  + exfalso.\n    apply lemma36 with (([unalias \u03ba] \u2218 \u03bas) \u2218 \u03ba') val; auto.\n    apply lemma23; auto.\nQed.\n\nLemma lemma151 : forall (\u03ba \u03ba': cap),\n  \u03ba = val \\/ \u03ba = box ->\n  subcap (C \u03ba) (C \u03ba') ->\n  \u03ba' = val \\/ \u03ba' = box \\/ \u03ba' = tag.\nProof.\nintros.\ninversion H; inversion H0; subst; auto.\nQed.\n\nLemma lemma152 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 NONWRITABLE ->\n  \u03bbs \u2218 \u03ba \u2208 NONWRITABLE.\nProof.\nintros.\ndestruct H as [|[|[|]]];\ndestruct \u03ba;\nsolve [ left; eapply lemma62; eauto\n      | right; left; eapply lemma62; eauto\n      | right; right; left; eapply lemma62; eauto\n      | right; right; right; eapply lemma22; eauto\n      | right; right; right; eapply lemma23; eauto ].\nQed.\n\nLemma lemma153 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 NONWRITABLE ->\n  \u03bbs \u2218 \u03bas \u2208 NONWRITABLE.\nProof.\nintros.\ninduction \u03bas as [|\u03ba0] using rev_ind; auto.\nrewrite lemma19. apply lemma152. auto.\nQed.\n\nLemma lemma154 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 STABLE ->\n  \u03ba = val \\/ \u03ba = box \\/ \u03ba = tag ->\n  \u03bbs \u2218 \u03ba \u2208 NONWRITABLE.\nProof.\nintros.\n(destruct_stable \u03bbs by auto);\ndestruct H0 as [|[|]]; subst;\nsolve [ left; eapply lemma62; eauto\n      | right; left; eapply lemma62; eauto\n      | right; right; left; eapply lemma62; eauto\n      | right; right; right; eapply lemma22; eauto\n      | right; right; right; eapply lemma23; eauto ].\nQed.\n\nLemma lemma155 : forall (\u03bbs: capset) (\u03ba: cap) (\u03bas: list cap),\n  \u03bbs \u2208 STABLE ->\n  \u03ba = val \\/ \u03ba = box \\/ \u03ba = tag ->\n  \u03bbs \u2218 \u03ba \u2218 \u03bas \u2208 NONWRITABLE.\nProof.\nintros; apply lemma153; apply lemma154; auto.\nQed.\n\nLemma lemma156: forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03ba \u2208 BOT ->\n  \u03bbs \u2208 TAG \u222a BOT.\nProof.\nintros.\ndestruct_stable \u03bbs by auto.\n6-7: finish.\n\nall:\nexfalso;\ndestruct \u03ba;\n(eapply lemma36; [| apply H0]);\neapply lemma62; eauto.\nQed.\n\nLemma lemma160 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03ba \u2208 NONWRITABLE ->\n  \u03bbs \u2208 NONWRITABLE \\/ (\u03ba = val \\/ \u03ba = box \\/ \u03ba = tag).\nProof.\nintros.\ndestruct_stable \u03bbs by auto.\n4-7: finish.\n\n- destruct H0 as [|[|[|]]].\n  + destruct_group_adapt iso \u03ba val; eauto.\n  + destruct_group_adapt iso \u03ba box; eauto.\n  + destruct_group_adapt iso \u03ba tag; eauto.\n  + assert (\u03bbs \u2208 TAG \u222a BOT) by (apply lemma156 with \u03ba; auto); finish.\n\n- destruct H0 as [|[|[|]]].\n  + destruct_group_adapt trn \u03ba val; eauto.\n  + destruct_group_adapt trn \u03ba box; eauto.\n  + destruct_group_adapt trn \u03ba tag; eauto.\n  + assert (\u03bbs \u2208 TAG \u222a BOT) by (apply lemma156 with \u03ba; auto); finish.\n\n- destruct H0 as [|[|[|]]].\n  + destruct_group_adapt ref \u03ba val; eauto.\n  + destruct_group_adapt ref \u03ba box; eauto.\n  + destruct_group_adapt ref \u03ba tag; eauto.\n  + assert (\u03bbs \u2208 TAG \u222a BOT) by (apply lemma156 with \u03ba; auto); finish.\nQed.\n\nLemma lemma161 : forall (\u03bbs: capset),\n  \u03bbs \u2208 WRITABLE ->\n  \u03bbs \u2208 NONWRITABLE ->\n  False.\nProof.\nintros.\ndestruct H0 as [|[|[|]]];\ndestruct_writable \u03bbs; auto;\nsolve [ eapply lemma105; [apply H0 | apply H1 | auto]\n      | eapply lemma36; eauto ].\nQed.\n\nLemma lemma162 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  \u03bbs \u2218 \u03bas \u2208 NONWRITABLE ->\n  [C ref] \u2218 \u03bas \u2208 NONWRITABLE.\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\n- exfalso; apply lemma161 with \u03bbs; eauto.\n- rewrite lemma19 in *.\n  destruct lemma160 with (\u03bbs \u2218 \u03bas) \u03ba; eauto.\n  + apply lemma152; auto.\n  + apply lemma154; auto.\nQed.\n\nLemma lemma163 : forall (\u03bbs1 \u03bbs2: capset),\n  \u03bbs1 \u2208 NONWRITABLE ->\n  \u03bbs2 \u2208 NONWRITABLE ->\n  compatible_set \u03bbs1 \u03bbs2.\nProof.\nintros \u03bbs1 \u03bbs2 [|[|[|]]] [|[|[|]]];\n\nsolve [ eapply lemma48; eauto\n      | apply lemma52; auto\n      | apply lemma73, lemma52; auto].\nQed.\n\nLemma lemma164 : forall \u03bbs (\u03bas: list cap) (\u03ba: cap),\n  \u03bbs \u2218 (\u03ba::\u03bas) = \u03bbs \u2218 \u03ba \u2218 \u03bas.\nProof. auto. Qed.\n\nLemma lemma165 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 STABLE ->\n  val \u2208 \u03bas \\/ box \u2208 \u03bas ->\n  \u03bbs \u2218 \u03bas \u2208 NONWRITABLE.\nProof.\nintros.\ngeneralize dependent \u03bbs.\ninduction \u03bas; intros.\n- destruct H0; destruct H0.\n- rewrite lemma164.\n  destruct H0;\n  ( destruct H0; [ subst; apply lemma155; tauto | apply IH\u03bas; auto ] ).\nQed.\n\nLemma lemma177 {A} : forall (x: A) (y: A),\n  x <> y -> not (x \u2208 [y]).\nProof. auto. Qed.\nHint Resolve lemma177.\n\nLemma lemma178 {A} : forall (x: A) (xs ys: list A),\n  not (x \u2208 xs) ->\n  not (x \u2208 ys) ->\n  not (x \u2208 xs ++ ys).\nProof.\nintros.\nintro; subst.\ndestruct in_app_or with A xs ys x; auto.\nQed.\nHint Resolve lemma178.\n\nLemma lemma179 {A} : forall (x y: A) (xs: list A),\n  not (y \u2208 xs) ->\n  x <> y ->\n  not (y \u2208 xs ++ [x]).\nProof. eauto. Qed.\nHint Resolve lemma179.\n\nLemma lemma180 : forall (\u03ba: cap) (\u03bas: list cap),\n  [unalias \u03ba] \u2218 \u03bas \u2208 BOX ->\n  \u03ba = box \\/ box \u2208 \u03bas.\nProof.\nintros.\ninduction \u03bas as [|\u03ba'] using rev_ind; auto.\n- left. apply lemma77. auto.\n- rewrite lemma19 in *.\n  destruct_stable ([unalias \u03ba] \u2218 \u03bas) by auto.\n  + destruct_group_adapt iso \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt trn \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt ref \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt val \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + destruct IH\u03bas; auto.\n  + destruct_group_adapt tag \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + exfalso.\n    apply lemma36 with (([unalias \u03ba] \u2218 \u03bas) \u2218 \u03ba') box; auto.\n    apply lemma23; auto.\nQed.\n\nLemma lemma181 : forall (\u03ba: cap) (\u03bas: list cap),\n  [unalias \u03ba] \u2218 \u03bas \u2208 REF \u222a BOX ->\n  \u03ba <> val /\\ not (val \u2208 \u03bas).\nProof.\nintros.\ninduction \u03bas as [|\u03ba'] using rev_ind; auto.\n- destruct H.\n  + (replace' \u03ba with ref by (apply lemma77; auto)); auto.\n  + (replace' \u03ba with box by (apply lemma77; auto)); auto.\n- rewrite lemma19 in *.\n  destruct H;\n  destruct_stable ([unalias \u03ba] \u2218 \u03bas) by auto.\n  + destruct_group_adapt iso \u03ba' ref;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt trn \u03ba' ref;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt ref \u03ba' ref;\n    [ apply H | apply H0 | auto..].\n    destruct IH\u03bas; auto.\n  + destruct_group_adapt val \u03ba' ref;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt box \u03ba' ref;\n    [ apply H | apply H0 | auto..]; subst;\n    destruct IH\u03bas; auto.\n  + destruct_group_adapt tag \u03ba' ref;\n    [ apply H | apply H0 | auto..].\n  + exfalso.\n    apply lemma36 with (([unalias \u03ba] \u2218 \u03bas) \u2218 \u03ba') ref; auto.\n    apply lemma23; auto.\n  + destruct_group_adapt iso \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt trn \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt ref \u03ba' box;\n    [ apply H | apply H0 | auto..];\n    destruct IH\u03bas; auto.\n  + destruct_group_adapt val \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + destruct_group_adapt box \u03ba' box;\n    [ apply H | apply H0 | auto..]; subst;\n    destruct IH\u03bas; auto.\n  + destruct_group_adapt tag \u03ba' box;\n    [ apply H | apply H0 | auto..].\n  + exfalso.\n    apply lemma36 with (([unalias \u03ba] \u2218 \u03bas) \u2218 \u03ba') box; auto.\n    apply lemma23; auto.\nQed.\n\nLemma lemma182 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 BOX \u222a TAG \u222a BOT ->\n  \u03ba <> val ->\n  \u03bbs \u2218 \u03ba \u2208 BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ndestruct H as [|[|]];\ndestruct \u03ba;\nsolve [ left; eapply lemma62; eauto\n      | right; left; eapply lemma62; eauto\n      | right; right; eapply lemma22; eauto\n      | right; right; eapply lemma23; eauto\n      | elim H0; auto ].\nQed.\n\nLemma lemma183 {A} : forall (x y: A) (xs: list A),\n  not (y \u2208 xs ++ [x]) ->\n  x <> y.\nProof.\nintros.\nintro; subst.\napply H. auto.\nQed.\nHint Resolve lemma183.\n\nLemma lemma184 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 BOX \u222a TAG \u222a BOT ->\n  not (val \u2208 \u03bas) ->\n  \u03bbs \u2218 \u03bas \u2208 BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ninduction \u03bas as [|\u03ba0] using rev_ind; auto.\nrewrite lemma19.\napply lemma182.\n- apply IH\u03bas. auto.\n- eauto.\nQed.\n\nLemma lemma185 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 REF \u222a BOX \u222a TAG \u222a BOT ->\n  \u03ba = box \\/ \u03ba = tag ->\n  \u03bbs \u2218 \u03ba \u2208 BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ndestruct H0; subst;\ndestruct H as [|].\n- left; eapply lemma62; eauto.\n- apply lemma182; eauto.\n- right; left; eapply lemma62; eauto.\n- apply lemma182; eauto.\nQed.\n\nLemma lemma186 : forall (\u03bbs1 \u03bbs2: capset),\n  \u03bbs1 \u2208 BOX \u222a TAG \u222a BOT ->\n  \u03bbs2 \u2208 TRN \u222a REF \u222a VAL \u222a BOX \u222a TAG \u222a BOT ->\n  compatible_set \u03bbs1 \u03bbs2.\nProof.\nintros \u03bbs1 \u03bbs2 [|[|]] [|[|[|[|[|]]]]];\n\nsolve [ eapply lemma48; eauto\n      | apply lemma52; auto\n      | apply lemma73, lemma52; auto].\nQed.\n\nLemma lemma188 : forall (\u03bbs: capset) (\u03bb: ecap),\n  \u03bbs \u2208 STABLE ->\n  safe_to_write \u03bb box ->\n  compatible_set \u03bbs ([C (alias \u03bb)]) ->\n  \u03bbs \u2208 REF \u222a BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ninversion H0; subst; unfold alias in H1.\n- right; right; apply lemma114; auto.\n- right; apply lemma115; auto.\n- apply (lemma64 ref) with [C ref]; auto.\nQed.\n\nLemma lemma189 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03ba \u2208 BOX ->\n  (\u03bbs \u2208 BOX /\\ (\u03ba = trn \\/ \u03ba = ref \\/ \u03ba = box)) \\/\n  (\u03bbs \u2208 REF /\\ (\u03ba = box)).\nProof.\nintros.\n(destruct_stable \u03bbs by auto);\nsolve [ epose (lemma62a _ _ _ box H1 H0); inversion g\n      | epose (lemma62a _ _ _ box H1 H0); inversion g; subst; auto\n      | exfalso; apply lemma36 with (\u03bbs \u2218 \u03ba) box; [| apply lemma23]; auto ].\nQed.\n\nLemma lemma187 {A} : forall (P: A -> Prop),\n  forall x, x \u2208 [] -> P x.\nProof. intros; inversion H. Qed.\n\nLemma lemma191 {A} : forall (P: A -> Prop) (xs ys: list A),\n  (forall x, x \u2208 xs -> P x) ->\n  (forall x, x \u2208 ys -> P x) ->\n  (forall x, x \u2208 xs ++ ys -> P x).\nProof.\nintros.\ndestruct in_app_or with A xs ys x; auto.\nQed.\n\nLemma lemma192 {A} : forall (P: A -> Prop) (x: A),\n  P x -> (forall y, y \u2208 [x] -> P y).\nProof. intros; replace y with x; auto. Qed.\n\nLemma lemma200 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 STABLE ->\n  \u03bbs \u2218 \u03bas \u2208 BOX ->\n  (\u03bbs \u2208 BOX /\\ forall \u03ba, \u03ba \u2208 \u03bas -> \u03ba = trn \\/ \u03ba = ref \\/ \u03ba = box) \\/\n  exists \u03bas' \u03bas'', (\u03bas = \u03bas' ++ [box] ++ \u03bas'' /\\ \u03bbs \u2218 \u03bas' \u2208 REF /\\ forall \u03ba, \u03ba \u2208 \u03bas'' -> \u03ba = trn \\/ \u03ba = ref \\/ \u03ba = box).\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind.\n- left. split. auto. apply lemma187.\n- rewrite lemma19 in *.\n  destruct lemma189 with (\u03bbs \u2218 \u03bas) \u03ba as [[? ?]|[? ?]]; auto.\n  + destruct IH\u03bas as [[? ?]|[\u03bas' [\u03bas'' [? [? ?]]]]]; auto.\n    * left; split; [| apply lemma191; [| apply lemma192]]; auto.\n    * right.\n      eexists \u03bas'; eexists (\u03bas''++[\u03ba]).\n      split; [|split].\n      -- subst \u03bas; repeat rewrite <- app_assoc; auto.\n      -- auto.\n      -- apply lemma191; [| apply lemma192]; auto.\n  + right.\n    eexists \u03bas; eexists [].\n    split; [subst \u03ba|split]; auto.\nQed.\n\nLemma lemma201 : forall (\u03bbs: capset) (\u03ba: cap),\n  \u03bbs \u2208 BOX \u222a TAG \u222a BOT ->\n  \u03ba = trn \\/ \u03ba = ref \\/ \u03ba = box ->\n  \u03bbs \u2218 \u03ba \u2208 BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ndestruct H0 as [|[|]]; subst;\ndestruct H as [|[|]];\ntry solve [ left; eapply lemma62; eauto\n      | right; left; eapply lemma62; eauto\n      | right; right; eapply lemma22; eauto\n      | right; right; eapply lemma23; eauto ].\nQed.\n\nLemma lemma202 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 BOX \u222a TAG \u222a BOT ->\n  (forall \u03ba, \u03ba \u2208 \u03bas -> \u03ba = trn \\/ \u03ba = ref \\/ \u03ba = box) ->\n  \u03bbs \u2218 \u03bas \u2208 BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ninduction \u03bas as [|\u03ba] using rev_ind; auto.\nrewrite lemma19.\napply lemma201; auto.\nQed.\n\nLemma lemma203 : forall \u03bbs \u03bas \u03bas',\n  \u03bbs \u2218 (\u03bas++\u03bas') = \u03bbs \u2218 \u03bas \u2218 \u03bas'.\nProof.\nintros. unfold_classes. unfold combine. rewrite fold_left_app. auto.\nQed.\n\nLemma lemma204 : forall (\u03bbs: capset) (\u03bas \u03bas': list cap),\n  \u03bbs \u2218 \u03bas \u2208 REF \u222a BOX \u222a TAG \u222a BOT ->\n  (forall \u03ba, \u03ba \u2208 \u03bas' -> \u03ba = trn \\/ \u03ba = ref \\/ \u03ba = box) ->\n  \u03bbs \u2218 (\u03bas ++ [box] ++ \u03bas') \u2208 BOX \u222a TAG \u222a BOT.\nProof.\nintros.\nrewrite lemma203; unfold app; rewrite lemma164.\napply lemma202; auto.\napply lemma185; auto.\nQed.\n\nLemma lemma205 : [C ref] \u2208 WRITABLE.\nProof.\nunfold WRITABLE.\nright; right. auto.\nQed.\nHint Resolve lemma205.\n\nLemma lemma206 : forall (\u03bbs: capset) (\u03bas: list cap),\n  \u03bbs \u2208 WRITABLE ->\n  \u03bbs \u2218 \u03bas \u2208 TRN \u222a REF \u222a VAL \u222a BOX \u222a TAG \u222a BOT ->\n  [C ref] \u2218 \u03bas \u2208 TRN \u222a REF \u222a VAL \u222a BOX \u222a TAG \u222a BOT.\nProof.\nintros.\ndestruct_stable ([C ref] \u2218 \u03bas); auto.\ndestruct H0 as [|[|[|[|[|]]]]];\nexfalso;\nsolve [ eapply lemma105; [ apply H0 | apply lemma86 | .. ]; auto\n      | eapply lemma36; [ apply lemma86 | apply H0 | .. ]; auto ].\nall: finish.\nQed.\n\n\nLemma lemmaB1 : forall (\u03bbs: capset) (\u03bas1 \u03bas3 \u03bas4: list cap) (\u03ba \u03ba2: cap),\n  \u03bbs \u2208 WRITABLE ->\n  compatible_set (\u03bbs \u2218 \u03bas4) ([unalias \u03ba] \u2218 \u03bas3) ->\n  [unalias \u03ba] \u2218 \u03bas3 \u2208 ISO ->\n  compatible_set ([C ref] \u2218 \u03bas4) ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3).\nProof.\nintros.\n\nassert (\u03bbs \u2218 \u03bas4 \u2208 TAG \u222a BOT)\n  by (eapply (lemma64 iso) with ([unalias \u03ba] \u2218 \u03bas3); eauto).\n\ndestruct' ([C ref] \u2218 \u03bas4 \u2208 TAG \u222a BOT) as [|]\n  by (apply lemma72 with \u03bbs; auto).\n\n- apply lemma55; auto.\n- apply lemma52; auto.\nQed.\n\nLemma lemmaB2 : forall (\u03bbs: capset) (\u03bb: ecap) (\u03bas1 \u03bas3 \u03bas4: list cap) (\u03ba \u03ba2: cap),\n  \u03bbs \u2208 WRITABLE ->\n  subcap (unalias \u03ba) (C \u03ba2) ->\n  safe_to_write \u03bb \u03ba ->\n  compatible_set (\u03bbs \u2218 \u03bas4) ([unalias \u03ba] \u2218 \u03bas3) ->\n  compatible_set (\u03bbs \u2218 \u03bas1) ([C (alias \u03bb)]) ->\n  [unalias \u03ba] \u2218 \u03bas3 \u2208 TRN ->\n  compatible_set ([C ref] \u2218 \u03bas4) ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3).\nProof.\nintros.\n\n(* -\u03ba \u2218 \u03bas3 \u2208 TRN *)\n\nassert (\u03bbs \u2218 \u03bas4 \u2208 BOX \u222a TAG \u222a BOT)\n  by (eapply (lemma64 trn); [ apply lemma27 | ..]; eauto).\n\nassert ([C ref] \u2218 \u03bas4 \u2208 BOX \u222a TAG \u222a BOT) as [|[|]]\n  by (apply lemma71 with \u03bbs; auto).\n\n(* TAG and BOT are compatible with anything else. *)\n2-3: solve [ apply lemma55; auto | apply lemma52; auto ].\n\n(* ref \u2218 \u03bas4 \u2208 BOX *)\n\n(* All cases except ISO are compatible with BOX.  *)\ndestruct_stable ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3) by eauto.\n2-7: solve [ eapply lemma48; eauto | apply lemma73, lemma52; auto ].\n\n(* ref \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3 \u2208 ISO *)\n\nassert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2208 ISO /\\ [unalias \u03ba] \u2208 TRN \u222a REF) as []\n  by (apply lemma75 with \u03bas3; eauto; finish).\n\nassert ([C ref] \u2218 \u03bas1 \u2208 ISO \\/ \u03ba2 = iso) as [|]\n  by (apply lemma76; eauto).\n\n(* \u03ba2 = iso is impossible as -\u03ba < \u03ba2 and -\u03ba = trn or -\u03ba = ref *)\n2: solve [\n  destruct H9;\n  [ assert (\u03ba=trn) by (apply lemma77; auto)\n  | assert (\u03ba=ref) by (apply lemma77; auto)];\n  subst; inversion H0\n].\n\n(* ref \u2218 \u03bas1 \u2208 ISO *)\nassert (\u03bbs \u2218 \u03bas1 \u2208 ISO) by (apply lemma86; auto).\n\nassert (compatible (unalias iso) (C (alias \u03bb)))\n  by (apply H3; [apply H11|auto]).\ndestruct \u03bb as [[]| |] eqn:?; inversion H12.\n2: solve [ inversion H1 ].\n\n(* \u03bb = C iso *)\n\n(* \u03ba = iso \\/ \u03ba = val \\/ \u03ba = tag *)\ninversion H1;\n(destruct H9;\n  [ assert (\u03ba=trn) by (apply lemma77; auto)\n  | assert (\u03ba=ref) by (apply lemma77; auto)]);\nsubst; inversion H13.\nQed.\n\nLemma lemmaB3 : forall (\u03bbs: capset) (\u03bb: ecap) (\u03bas1 \u03bas3 \u03bas4: list cap) (\u03ba \u03ba2: cap),\n  \u03bbs \u2208 WRITABLE ->\n  subcap (unalias \u03ba) (C \u03ba2) ->\n  safe_to_write \u03bb \u03ba ->\n  compatible_set (\u03bbs \u2218 \u03bas4) ([unalias \u03ba] \u2218 \u03bas3) ->\n  compatible_set (\u03bbs \u2218 \u03bas1) ([C (alias \u03bb)]) ->\n  [unalias \u03ba] \u2218 \u03bas3 \u2208 REF ->\n  compatible_set ([C ref] \u2218 \u03bas4) ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3).\nProof.\nintros.\n\nassert (\u03bbs \u2218 \u03bas4 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n  by (apply (lemma64 ref) with ([unalias \u03ba] \u2218 \u03bas3); auto).\nassert ([C ref] \u2218 \u03bas4 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n  by (apply lemma133 with \u03bbs; auto).\n\nassert ([unalias \u03ba] \u2208 REF /\\ forall \u03ba, \u03ba \u2208 \u03bas3 -> \u03ba = ref) as []\n  by (apply lemma91; auto).\n\nreplace' \u03ba with ref by (apply lemma77; auto).\n\nassert (\u03ba2 = ref \\/ \u03ba2 = box \\/ \u03ba2 = tag)\n  by (inversion H0; auto).\n\nassert (\u03bbs \u2218 \u03bas1 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n  by (apply lemma135 with (\u03bb:=\u03bb); auto).\nassert ([C ref] \u2218 \u03bas1 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n  by (apply lemma133 with \u03bbs; auto).\nassert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n  by (apply lemma100; auto).\nassert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n  by (apply lemma103; auto).\n\napply lemma134; auto.\n\nQed.\n\nLemma lemmaB4 : forall (\u03bbs: capset) (\u03bb: ecap) (\u03bas1 \u03bas3 \u03bas4: list cap) (\u03ba \u03ba2: cap),\n  \u03bbs \u2208 WRITABLE ->\n  subcap (unalias \u03ba) (C \u03ba2) ->\n  safe_to_write \u03bb \u03ba ->\n  compatible_set (\u03bbs \u2218 \u03bas4) ([unalias \u03ba] \u2218 \u03bas3) ->\n  compatible_set (\u03bbs \u2218 \u03bas1) ([C (alias \u03bb)]) ->\n  [unalias \u03ba] \u2218 \u03bas3 \u2208 VAL ->\n  compatible_set ([C ref] \u2218 \u03bas4) ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3).\nProof.\nintros.\n\nassert (\u03bbs \u2218 \u03bas4 \u2208 NONWRITABLE)\n  by (apply (lemma64 val) with ([unalias \u03ba] \u2218 \u03bas3); auto).\nassert ([C ref] \u2218 \u03bas4 \u2208 NONWRITABLE)\n  by (apply lemma162 with \u03bbs; auto).\n\ndestruct lemma150 with \u03ba \u03bas3 as [|]; auto.\n\n- (* \u03ba = val \\/ \u03ba = box *)\n  assert (\u03ba2 = val \\/ \u03ba2 = box \\/ \u03ba2 = tag)\n    by (apply lemma151 with \u03ba; [| destruct H7; subst]; auto).\n  assert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3 \u2208 NONWRITABLE)\n    by (apply lemma155; auto).\n  apply lemma163; auto.\n\n- (* val \u2208 \u03bas3 \\/ box \u2208 \u03bas3 *)\n  assert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3 \u2208 NONWRITABLE)\n    by (apply lemma165; auto; auto).\n  apply lemma163; auto.\nQed.\n\nLemma lemmaB5 : forall (\u03bbs: capset) (\u03bb: ecap) (\u03bas1 \u03bas3 \u03bas4: list cap) (\u03ba \u03ba2: cap),\n  \u03bbs \u2208 WRITABLE ->\n  subcap (unalias \u03ba) (C \u03ba2) ->\n  safe_to_write \u03bb \u03ba ->\n  compatible_set (\u03bbs \u2218 \u03bas4) ([unalias \u03ba] \u2218 \u03bas3) ->\n  compatible_set (\u03bbs \u2218 \u03bas1) ([C (alias \u03bb)]) ->\n  [unalias \u03ba] \u2218 \u03bas3 \u2208 BOX ->\n  compatible_set ([C ref] \u2218 \u03bas4) ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3).\nProof.\nintros.\n\nassert (\u03bbs \u2218 \u03bas4 \u2208 TRN \u222a REF \u222a VAL \u222a BOX \u222a TAG \u222a BOT)\n  by (apply (lemma64 box) with ([unalias \u03ba] \u2218 \u03bas3); auto).\n\nassert ([C ref] \u2218 \u03bas4 \u2208 TRN \u222a REF \u222a VAL \u222a BOX \u222a TAG \u222a BOT) by\n  (apply lemma206 with \u03bbs; auto).\n\ndestruct lemma200 with [unalias \u03ba] \u03bas3 as [[? ?]|[\u03bas3' [\u03bas3'' [? [? ?]]]]]; auto.\n- replace' \u03ba with box by (apply lemma77; auto).\n\n  assert (\u03ba2 = box \\/ \u03ba2 = tag)\n    by (inversion H0; auto).\n\n  assert (\u03bbs \u2218 \u03bas1 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n   by (eapply lemma188 with (\u03bb:=\u03bb); auto).\n\n  assert ([C ref] \u2218 \u03bas1 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n    by (apply lemma133 with \u03bbs; auto).\n\n  assert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2208 BOX \u222a TAG \u222a BOT)\n    by (apply lemma185; auto).\n\n  assert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3 \u2208 BOX \u222a TAG \u222a BOT)\n    by (apply lemma202; auto).\n\n  apply lemma73, lemma186; auto.\n\n- assert ([unalias \u03ba] \u2208 REF /\\ forall \u03ba, \u03ba \u2208 \u03bas3' -> \u03ba = ref) as []\n    by (apply lemma91; auto).\n  replace' \u03ba with ref by (apply lemma77; auto).\n\n  assert (\u03ba2 = ref \\/ \u03ba2 = box \\/ \u03ba2 = tag)\n    by (inversion H0; tauto).\n\n  assert (\u03bbs \u2218 \u03bas1 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n    by (apply lemma135 with \u03bb; auto).\n\n  assert ([C ref] \u2218 \u03bas1 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n    by (apply lemma133 with \u03bbs; auto).\n\n  assert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n    by (apply lemma100; auto).\n\n  assert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3' \u2208 REF \u222a BOX \u222a TAG \u222a BOT)\n    by (apply lemma103; auto).\n\n  assert ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3 \u2208 BOX \u222a TAG \u222a BOT)\n    by (subst \u03bas3; apply lemma204; auto).\n\n  apply lemma73, lemma186; auto.\nQed.\n\nLemma lemmaB : forall (\u03bbs: capset) (\u03bb: ecap) (\u03bas1 \u03bas3 \u03bas4: list cap) (\u03ba \u03ba2: cap),\n  \u03bbs \u2208 WRITABLE ->\n  subcap (unalias \u03ba) (C \u03ba2) ->\n  safe_to_write \u03bb \u03ba ->\n  compatible_set (\u03bbs \u2218 \u03bas4) ([unalias \u03ba] \u2218 \u03bas3) ->\n  compatible_set (\u03bbs \u2218 \u03bas1) ([C (alias \u03bb)]) ->\n  compatible_set ([C ref] \u2218 \u03bas4) ([C ref] \u2218 \u03bas1 \u2218 \u03ba2 \u2218 \u03bas3).\nProof with finish.\nintros.\ndestruct_stable ([unalias \u03ba] \u2218 \u03bas3) by auto.\n- (* [unalias \u03ba] \u2218 \u03bas3 \u2208 ISO *) apply lemmaB1 with \u03bbs \u03ba...\n- (* [unalias \u03ba] \u2218 \u03bas3 \u2208 TRN *) apply lemmaB2 with \u03bbs \u03bb \u03ba...\n- (* [unalias \u03ba] \u2218 \u03bas3 \u2208 REF *) apply lemmaB3 with \u03bbs \u03bb \u03ba...\n- (* [unalias \u03ba] \u2218 \u03bas3 \u2208 VAL *) apply lemmaB4 with \u03bbs \u03bb \u03ba...\n- (* [unalias \u03ba] \u2218 \u03bas3 \u2208 BOX *) apply lemmaB5 with \u03bbs \u03bb \u03ba...\n- (* [unalias \u03ba] \u2218 \u03bas3 \u2208 TAG *) admit.\n- (* [unalias \u03ba] \u2218 \u03bas3 \u2208 BOT *) admit.\nAdmitted.\n",
      "theorem": "Lemma lemma25: forall \u03bbs (\u03ba: cap),\n  \u03bbs \u2208 G \u03ba -> \u03bbs \u2208 STABLE.",
      "ground_truth": "Proof.\nintros.\ndestruct \u03ba; unfold STABLE; unfold_classes; finish.\nQed."
    },
    {
      "split": "train-sft",
      "index": 10,
      "prefix": "(**\n\n   Some handy facts and definitions for lists.\n\n*)\n\nRequire Import Lists.List.\n\nSet Implicit Arguments.\n\nFixpoint take (A : Type) (n : nat) (xs : list A) : list A :=\n  match n with\n  | O => nil\n  | S k =>\n    match xs with\n    | nil => nil\n    | cons x xs' => cons x (take k xs')\n    end\n  end.\n\nLemma take_nil (A : Type) n\n  : take n (nil (A := A)) = nil.\nProof.\n  induction n; auto.\nQed.\n\nLemma in_take (A : Type) n x (xs : list A)\n  : In x (take n xs) -> In x xs.\nProof.\n  revert xs; induction n as [ | n IH ]; [ contradiction | ]; intro xs.\n  destruct xs as [ | a xs ]; auto.\n  simpl. destruct 1; auto.\nQed.\n\nLemma map_take (A B : Type) (f : A -> B) n xs\n  : map f (take n xs) = take n (map f xs).",
      "suffix": "\n\nLemma take_take (A : Type) n m (xs : list A)\n  : take n (take m xs) = take (min n m) xs.\nProof.\n  revert xs m; induction n as [ | n IH ]; auto; intros xs m.\n  destruct m; auto.\n  destruct xs; auto.\n  simpl; apply f_equal; auto.\nQed.\n\nLemma take_length (A : Type) (xs : list A)\n  : take (length xs) xs = xs.\nProof.\n  induction xs; simpl; auto using f_equal.\nQed.\n\nLemma map_fst_combine (A B : Type) (xs : list A) (ys : list B)\n  : map fst (combine xs ys) = take (min (length xs) (length ys)) xs.\nProof.\n  revert ys; induction xs as [ | x xs IH ]; auto; intro ys.\n  destruct ys as [ | y ys ]; auto.\n  simpl; apply f_equal; auto.\nQed.\n\nLemma map_snd_combine (A B : Type) (xs : list A) (ys : list B)\n  : map snd (combine xs ys) = take (min (length xs) (length ys)) ys.\nProof.\n  revert ys; induction xs as [ | x xs IH ]; auto; intro ys.\n  destruct ys as [ | y ys ]; auto.\n  simpl; apply f_equal; auto.\nQed.\n",
      "theorem": "Lemma map_take (A B : Type) (f : A -> B) n xs\n  : map f (take n xs) = take n (map f xs).",
      "ground_truth": "Proof.\n  revert n; induction xs as [ | x xs IH ];\n    intro n; [ rewrite !take_nil; auto | ].\n  destruct n; auto.\n  simpl; apply f_equal; auto.\nQed."
    },
    {
      "split": "train-sft",
      "index": 11,
      "prefix": "(** Some useful lemmas of [combine] and [split], which we use extensively. *)\nRequire Import Coq.Sorting.Permutation.\nRequire Import Coq.Lists.List.\nRequire Import Lia.\n\nLemma combine_length3 :\n  forall {T1 T2 T3 : Type} (l1 : list T1) (l2 : list T2) (l3 : list T3),\n    length l1 = length l2 ->\n    length l1 = length l3 ->\n    length (combine l1 l2) = length l3.\nProof.\n  intros.\n  rewrite combine_length.\n  lia.\nQed.\n\nLemma map_project_combine1 :\n  forall {T1 T2 T3 : Type} (l1 : list T1) (l2 : list T2) (f : T1 -> T3),\n    length l1 = length l2 ->\n    map (fun p => f (fst p)) (combine l1 l2) = map f l1.\n  Proof.\n    intros. generalize dependent l2.\n    induction l1; auto.\n    intros l2 Hlength.\n    induction l2.\n    - inversion Hlength.\n    - inversion Hlength.\n      apply IHl1 in H0. rewrite map_cons.\n      rewrite <- H0.\n      simpl. reflexivity.\nQed.\n\nLemma map_project_combine2 :\n  forall {T1 T2 T3 : Type} (l1 : list T1) (l2 : list T2) (f : T2 -> T3),\n    length l1 = length l2 ->\n    map (fun p => f (snd p)) (combine l1 l2) = map f l2.\n  Proof.\n    intros. generalize dependent l1.\n    induction l2.\n    - intros l1 Hlength. inversion Hlength. simpl. rewrite combine_nil. reflexivity.\n    - induction l1; intros Hlength; inversion Hlength.\n      rewrite map_cons.\n      apply IHl2 in H0.\n      rewrite <- H0.\n      simpl. reflexivity.\nQed.\n\nLemma map_combine :\n  forall {T1 T2 T3 T4 : Type} (l1 : list T1) (l2 : list T2) (f1 : T1 -> T3) (f2 : T2 -> T4),\n    map (fun p => (f1 (fst p), f2 (snd p))) (combine l1 l2) =\n      combine (map f1 l1) (map f2 l2).\n  Proof.\n    intros; generalize dependent l2.\n    induction l1; auto.\n    intros l2.\n    rewrite map_cons.\n    induction l2; auto.\n    simpl.\n    rewrite IHl1. reflexivity.\nQed.\n\nLemma map_combine_map :\n  forall {T1 T2 T3 T4 T5 : Type} (l1 : list T1) (l2 : list T2) (f1 : T1 -> T3) (f2 : T2 -> T4) (g : (T3 * T4) -> T5),\n    map (fun p => g (f1 (fst p), f2 (snd p))) (combine l1 l2) =\n      map g (combine (map f1 l1) (map f2 l2)).\nProof.\n  intros.\n  rewrite <- map_combine.\n  rewrite map_map.\n  reflexivity.\nQed.\n\nLemma combine_app :\n  forall {T1 T2 : Type} (l1 l2 : list T1) (l3 l4 : list T2),\n    length l1 = length l3 ->\n    length l2 = length l4 ->\n    combine (l1 ++ l2) (l3 ++ l4) = combine l1 l3 ++ combine l2 l4.\nProof.\n  induction l1; intros.\n  - simpl.\n    symmetry in H.\n    rewrite length_zero_iff_nil in H.\n    subst.\n    reflexivity.\n  - destruct l3 as [| ? l3]; inversion H.\n    specialize (IHl1 l2 l3 l4 H2 H0).\n    simpl.\n    rewrite IHl1.\n    reflexivity.\nQed.\n\nLemma combine_nil2 :\n  forall {T1 T2 : Type} (l1 : list T1) (l2 : list T2),\n    length l1 = length l2 ->\n    combine l1 l2 = nil ->\n    l1 = nil /\\ l2 = nil.\nProof.\n  intros.\n  split.\n  - destruct l1 as [| ? l1].\n    + reflexivity.\n    + destruct l2 as [| ? l2].\n      * inversion H.\n      * inversion H0.\n  - destruct l2 as [| ? l2].\n    + reflexivity.\n    + destruct l1 as [| ? l1].\n      * inversion H.\n      * inversion H0.\nQed.\n\nLemma combine_ext :\n  forall {T1 T2 : Type} (l1 l2 : list T1) (l3 l4 : list T2),\n    length l1 = length l3 ->\n    length l2 = length l4 ->\n    combine l1 l3 = combine l2 l4 ->\n    l1 = l2 /\\ l3 = l4.\nProof.\n  induction l1; intros.\n  - simpl.\n    symmetry in H.\n    rewrite length_zero_iff_nil in H.\n    subst.\n    simpl in H1.\n    symmetry in H1.\n    apply (combine_nil2 l2 l4 H0) in H1.\n    destruct H1.\n    split; congruence.\n  - destruct l3 as [| ? l3]; try solve[inversion H].\n    destruct l2 as [| ? l2]; try solve[inversion H1].\n    destruct l4 as [| ? l4]; try solve[inversion H1].\n    injection H as H.\n    injection H0 as H0.\n    simpl in H1.\n    inversion H1.\n    subst.\n    specialize (IHl1 l2 l3 l4 H H0 H5).\n    destruct IHl1.\n    subst.\n    split; reflexivity.\nQed.\n\nLemma split_map_fst_snd :\n  forall {T1 T2 : Type} (l : list (T1 * T2)),\n    split l = (map fst l, map snd l).",
      "suffix": "\n\nLemma Permutation_split :\n  forall {T1 T2 : Type} (l1 l2 : list (T1 * T2)) (l11 l12 : list T1) (l21 l22 : list T2),\n    Permutation l1 l2 ->\n    split l1 = (l11, l21) ->\n    split l2 = (l12, l22) ->\n    Permutation l11 l12 /\\ Permutation l21 l22.\nProof.\n  intros.\n  generalize dependent l11.\n  generalize dependent l12.\n  generalize dependent l21.\n  generalize dependent l22.\n  induction H; intros.\n  - inversion H0.\n    inversion H1.\n    split; constructor.\n  - assert (Hlen := H).\n    apply Permutation_length in Hlen.\n    assert (H0' := H0).\n    assert (H1' := H1).\n    apply split_combine in H0.\n    apply split_combine in H1.\n    destruct l11; destruct l21; destruct l12; destruct l22; try inversion H0; inversion H1.\n    assert (Hlen12 : length (x :: l') = Datatypes.S (length l12)).\n    { rewrite <- split_length_l. rewrite H1'. simpl. reflexivity. }\n    assert (Hlen11 : length (x :: l) = Datatypes.S (length l11)).\n    { rewrite <- split_length_l. rewrite H0'. simpl. reflexivity. }\n    assert (Hlen22 : length (x :: l') = Datatypes.S (length l22)).\n    { rewrite <- split_length_r. rewrite H1'. simpl. reflexivity. }\n    assert (Hlen21 : length (x :: l) = Datatypes.S (length l21)).\n    { rewrite <- split_length_r. rewrite H0'. simpl. reflexivity. }\n    simpl in Hlen11, Hlen12, Hlen21, Hlen22.\n    injection Hlen12 as Hlen12.\n    injection Hlen11 as Hlen11.\n    injection Hlen22 as Hlen22.\n    injection Hlen21 as Hlen21.\n    subst.\n    inversion H5.\n    subst.\n    specialize (IHPermutation l22 l21 l12).\n    rewrite combine_split in IHPermutation; try congruence.\n    specialize (IHPermutation eq_refl l11).\n    rewrite combine_split in IHPermutation; try congruence.\n    specialize (IHPermutation eq_refl).\n    destruct IHPermutation.\n    split; constructor; assumption.\n  -\n    assert (H0' := H0).\n    assert (H1' := H1).\n    apply split_combine in H0.\n    apply split_combine in H1.\n    do 2 (destruct l11; destruct l21; destruct l12; destruct l22; try inversion H0; inversion H1).\n    assert (Hlen11 : length (y :: x :: l) = 2 + (length l11)).\n    { rewrite <- split_length_l. rewrite H0'. simpl. reflexivity. }\n    assert (Hlen12 : length (x :: y :: l) = 2 + (length l12)).\n    { rewrite <- split_length_l. rewrite H1'. simpl. reflexivity. }\n    assert (Hlen21 : length (y :: x :: l) = 2 + (length l21)).\n    { rewrite <- split_length_r. rewrite H0'. simpl. reflexivity. }\n    assert (Hlen22 : length (x :: y :: l) = 2 + (length l22)).\n    { rewrite <- split_length_r. rewrite H1'. simpl. reflexivity. }\n    simpl in Hlen11, Hlen12, Hlen21, Hlen22.\n    injection Hlen12 as Hlen12.\n    injection Hlen11 as Hlen11.\n    injection Hlen22 as Hlen22.\n    injection Hlen21 as Hlen21.\n    assert (Hlen1: length l11 = length l21) by congruence.\n    assert (Hlen2: length l12 = length l22) by congruence.\n    subst.\n    inversion H7.\n    inversion H9.\n    inversion H10.\n    subst.\n    apply (combine_ext l12 l11 l22 l21 Hlen2 Hlen1) in H11.\n    destruct H11.\n    subst.\n    split; constructor.\n  -\n    assert (H1' := H1).\n    assert (H2' := H2).\n    apply split_combine in H1.\n    apply split_combine in H2.\n    assert (Hlen11 : length l = length l11).\n    { rewrite <- split_length_l. rewrite H2'. simpl. reflexivity. }\n    assert (Hlen12 : length l'' = length l12).\n    { rewrite <- split_length_l. rewrite H1'. simpl. reflexivity. }\n    assert (Hlen21 : length l = length l21).\n    { rewrite <- split_length_r. rewrite H2'. simpl. reflexivity. }\n    assert (Hlen22 : length l'' = length l22).\n    { rewrite <- split_length_r. rewrite H1'. simpl. reflexivity. }\n    assert (Hlen1: length l11 = length l21) by congruence.\n    assert (Hlen2: length l12 = length l22) by congruence.\n    (* now we should express that l' has two components *)\n    assert (exists l1' l2', split l' = (l1', l2')).\n    { exists (map fst l'). exists (map snd l'). apply split_map_fst_snd. }\n    destruct H3 as [l1' [l2' Hl']].\n    assert (Hl'c := Hl').\n    apply split_combine in Hl'c.\n    assert (Hlen1': length l' = length l1').\n    { rewrite <- split_length_l. rewrite Hl'. simpl. reflexivity. }\n    assert (Hlen2': length l' = length l2').\n    { rewrite <- split_length_r. rewrite Hl'. simpl. reflexivity. }\n    assert (Hlen': length l1' = length l2') by congruence.\n    (* and finally we can do forward reasoning through the IHs *)\n    rewrite <- Hl'c in H, H0, IHPermutation1, IHPermutation2.\n    rewrite (combine_split _ _ Hlen') in IHPermutation1.\n    rewrite (combine_split _ _ Hlen') in IHPermutation2.\n    specialize (IHPermutation1 l2' l21 l1' eq_refl l11 H2').\n    specialize (IHPermutation2 l22 l2' l12 H1' l1' eq_refl).\n    destruct IHPermutation1.\n    destruct IHPermutation2.\n    subst.\n    split; eapply perm_trans; eassumption.\nQed.\n\nLemma Permutation_combine_split :\n  forall {T1 T2 : Type} (l1 l2 : list T1) (l3 l4 : list T2),\n    length l1 = length l3 ->\n    length l2 = length l4 ->\n    Permutation (combine l1 l3) (combine l2 l4) ->\n    Permutation l1 l2 /\\ Permutation l3 l4.\nProof.\n  intros.\n  eapply Permutation_split in H1; try apply combine_split; assumption.\nQed.\n\nLemma Permutation_combine_Exists :\n  forall {T1 T2 : Type} (l1 l2 : list T1) (l3 : list T2),\n    Permutation l1 l2 ->\n    exists (l4 : list T2),\n      Permutation l3 l4 ->\n      Permutation (combine l1 l3) (combine l2 l4).\nProof.\n  intros.\n  induction H.\n  - exists nil.\n    intros.\n    apply Permutation_sym in H.\n    apply Permutation_nil in H.\n    subst.\n    constructor.\n  - destruct IHPermutation as [l4 IHP].\n    exists l4.\n    intros.\n    destruct l3; destruct l4;\n      try ((apply Permutation_nil in H0 || (apply Permutation_sym in H0; apply Permutation_nil in H0)); subst; constructor).\n    + apply Permutation_nil_cons in H0. inversion H0.\n    + apply Permutation_sym in H0. apply Permutation_nil_cons in H0. inversion H0.\n    + specialize (IHP H0).\n      simpl.\n      admit.\n  - do 2 (try destruct l3 as [| ? l3]).\n    + exists nil. intros. constructor.\n    + exists nil. intros. apply Permutation_sym, Permutation_nil_cons in H. inversion H.\n    + exists (t0 :: t :: l3).\n      intros.\n      simpl.\n      constructor.\n  - destruct IHPermutation1 as [l4' IHP1].\n    destruct IHPermutation2 as [l4'' IHP2].\n    admit.\nAdmitted.\n",
      "theorem": "Lemma split_map_fst_snd :\n  forall {T1 T2 : Type} (l : list (T1 * T2)),\n    split l = (map fst l, map snd l).",
      "ground_truth": "Proof.\n  induction l; simpl; try reflexivity.\n  destruct a.\n  simpl.\n  rewrite IHl.\n  reflexivity.\nQed."
    },
    {
      "split": "train-sft",
      "index": 12,
      "prefix": "Require Import String.\nRequire FSets.FMapList FSets.FMapFacts.\nRequire Import Lists.SetoidList.\nRequire Import Structures.OrderedType.\nRequire Import Structures.OrderedTypeEx.\nRequire Import Equalities Eqdep_dec FMapInterface.\n\nRequire Import Lib.CommonTactics Lib.StringAsOT Lib.StringEq Lib.Struct.\n\nLocal Ltac Tauto.intuition_solver ::= auto with datatypes.\n\n\nSet Implicit Arguments.\nSet Asymmetric Patterns.\n\nSection Lists. (* For dealing with domains *)\n  Context {A: Type}.\n  \n  Definition DisjList (l1 l2: list A) := forall e, ~ In e l1 \\/ ~ In e l2.\n  Definition SubList (l1 l2: list A) := forall e, In e l1 -> In e l2.\n  Definition EquivList (l1 l2: list A) := SubList l1 l2 /\\ SubList l2 l1.\n\n  Lemma SubList_nil: forall l, SubList nil l.\n  Proof. unfold SubList; intros; inv H. Qed.\n\n  Lemma SubList_nil_inv: forall l, SubList l nil -> l = nil.\n  Proof.\n    unfold SubList; intros; destruct l; auto.\n    specialize (H a (or_introl eq_refl)); inv H.\n  Qed.\n  \n  Lemma SubList_cons: forall a l1 l2, In a l2 -> SubList l1 l2 -> SubList (a :: l1) l2.\n  Proof. unfold SubList; intros; inv H1; auto. Qed.\n\n  Lemma SubList_cons_inv: forall a l1 l2, SubList (a :: l1) l2 -> In a l2 /\\ SubList l1 l2.\n  Proof. unfold SubList; intros; split; intuition. Qed.\n\n  Lemma SubList_cons_right: forall a l1 l2, SubList l1 l2 -> SubList l1 (a :: l2).\n  Proof. unfold SubList; intros; right; auto. Qed.\n  \n  Lemma SubList_refl: forall l, SubList l l.\n  Proof. unfold SubList; intros; auto. Qed.\n\n  Lemma SubList_refl': forall l1 l2, l1 = l2 -> SubList l1 l2.\n  Proof. intros; subst; apply SubList_refl. Qed.\n  \n  Lemma SubList_trans:\n    forall l1 l2 l3, SubList l1 l2 -> SubList l2 l3 -> SubList l1 l3.\n  Proof. unfold SubList; intros; auto. Qed.\n\n  Lemma SubList_app_1: forall l1 l2 l3, SubList l1 l2 -> SubList l1 (l2 ++ l3).\n  Proof.\n    unfold SubList; intros; apply in_or_app; left; auto.\n  Qed.\n\n  Lemma SubList_app_2: forall l1 l2 l3, SubList l1 l3 -> SubList l1 (l2 ++ l3).\n  Proof.\n    unfold SubList; intros; apply in_or_app; right; auto.\n  Qed.\n\n  Lemma SubList_app_3: forall l1 l2 l3, SubList l1 l3 -> SubList l2 l3 -> SubList (l1 ++ l2) l3.\n  Proof.\n    unfold SubList; intros.\n    apply in_app_or in H1; destruct H1; intuition.\n  Qed.\n\n  Lemma SubList_app_4: forall l1 l2 l3, SubList (l1 ++ l2) l3 -> SubList l1 l3.\n  Proof.\n    unfold SubList; intros; apply H; apply in_or_app; left; auto.\n  Qed.\n\n  Lemma SubList_app_5: forall l1 l2 l3, SubList (l1 ++ l2) l3 -> SubList l2 l3.\n  Proof.\n    unfold SubList; intros; apply H; apply in_or_app; right; auto.\n  Qed.\n\n  Lemma SubList_app_6:\n    forall l1 l2 l3 l4, SubList l1 l2 -> SubList l3 l4 -> SubList (l1 ++ l3) (l2 ++ l4).\n  Proof.\n    intros; apply SubList_app_3.\n    - apply SubList_app_1; auto.\n    - apply SubList_app_2; auto.\n  Qed.\n\n  Lemma SubList_app_7:\n    forall l1 l2 l3, SubList (l1 ++ l2) l3 -> SubList l1 l3 /\\ SubList l2 l3.",
      "suffix": "\n\n  Lemma SubList_app_comm:\n    forall l1 l2 l3, SubList l1 (l2 ++ l3) -> SubList l1 (l3 ++ l2).\n  Proof.\n    unfold SubList; intros.\n    apply in_or_app.\n    specialize (H e H0); apply in_app_or in H; intuition.\n  Qed.\n\n  Lemma SubList_app_idempotent:\n    forall l1 l2, SubList l1 (l2 ++ l2) -> SubList l1 l2.\n  Proof.\n    unfold SubList; intros.\n    specialize (H e H0).\n    apply in_app_or in H; intuition.\n  Qed.\n\n  Lemma EquivList_nil: EquivList nil nil.\n  Proof. split; unfold SubList; intros; inv H. Qed.\n\n  Lemma EquivList_nil_inv_1: forall l, EquivList l nil -> l = nil.\n  Proof. intros; inv H; apply SubList_nil_inv; auto. Qed.\n\n  Lemma EquivList_nil_inv_2: forall l, EquivList nil l -> l = nil.\n  Proof. intros; inv H; apply SubList_nil_inv; auto. Qed.\n\n  Lemma EquivList_cons:\n    forall a1 a2 l1 l2,\n      EquivList l1 l2 -> a1 = a2 -> EquivList (a1 :: l1) (a2 :: l2).\n  Proof.\n    intros; inv H; subst; split;\n      try (apply SubList_cons; [left; auto|apply SubList_cons_right; auto]).\n  Qed.\n\n  Lemma EquivList_refl: forall l, EquivList l l.\n  Proof. intros; split; apply SubList_refl. Qed.\n  \n  Lemma EquivList_comm: forall l1 l2, EquivList l1 l2 -> EquivList l2 l1.\n  Proof. unfold EquivList; intros; dest; split; auto. Qed.\n\n  Lemma EquivList_trans:\n    forall l1 l2 l3, EquivList l1 l2 -> EquivList l2 l3 -> EquivList l1 l3.\n  Proof. intros; inv H; inv H0; split; eapply SubList_trans; eauto. Qed.\n\n  Lemma EquivList_app:\n    forall l1 l2 l3 l4,\n      EquivList l1 l2 -> EquivList l3 l4 ->\n      EquivList (l1 ++ l3) (l2 ++ l4).\n  Proof.\n    unfold EquivList; intros; dest; split.\n    - apply SubList_app_3.\n      + apply SubList_app_1; auto.\n      + apply SubList_app_2; auto.\n    - apply SubList_app_3.\n      + apply SubList_app_1; auto.\n      + apply SubList_app_2; auto.\n  Qed.\n\n  Lemma EquivList_app_comm: forall l1 l2, EquivList (l1 ++ l2) (l2 ++ l1).\n  Proof.\n    unfold EquivList; intros; split.\n    - apply SubList_app_3.\n      + apply SubList_app_2, SubList_refl; auto.\n      + apply SubList_app_1, SubList_refl; auto.\n    - apply SubList_app_3.\n      + apply SubList_app_2, SubList_refl; auto.\n      + apply SubList_app_1, SubList_refl; auto.\n  Qed.\n\n  Lemma EquivList_app_idempotent:\n    forall l1 l2, EquivList l1 (l2 ++ l2) -> EquivList l1 l2.\n  Proof.\n    unfold EquivList; intros; dest; split.\n    - apply SubList_app_idempotent; auto.\n    - eapply SubList_app_4; eauto.\n  Qed.\n\n  Lemma DisjList_nil_1: forall l, DisjList nil l.\n  Proof. unfold DisjList; auto. Qed.\n\n  Lemma DisjList_nil_2: forall l, DisjList l nil.\n  Proof. unfold DisjList; auto. Qed.\n\n  Lemma DisjList_cons:\n    forall a l1 l2, DisjList (a :: l1) l2 -> DisjList l1 l2.\n  Proof.\n    unfold DisjList; intros.\n    specialize (H e); intuition.\n  Qed.\n\n  Lemma DisjList_comm: forall l1 l2, DisjList l1 l2 -> DisjList l2 l1.\n  Proof. \n    intros. unfold DisjList in *. intros e. specialize (H e). intuition.\n  Qed.\n\n  Lemma DisjList_SubList: forall sl1 l1 l2, SubList sl1 l1 -> DisjList l1 l2 -> DisjList sl1 l2.\n  Proof. \n    intros. unfold SubList, DisjList in *. intros e. \n    specialize (H e). specialize (H0 e). intuition.\n  Qed.\n\n  Lemma NoDup_DisjList:\n    forall l1 l2,\n      NoDup l1 -> NoDup l2 -> DisjList l1 l2 ->\n      NoDup (l1 ++ l2).\n  Proof.\n    induction l1; simpl; intros; auto.\n    inv H; constructor.\n    - intro Hx; apply in_app_or in Hx; destruct Hx; [auto|].\n      specialize (H1 a); destruct H1; auto.\n      elim H1; simpl; tauto.\n    - apply IHl1; auto.\n      eapply DisjList_cons; eauto.\n  Qed.\n\n  Lemma DisjList_app_1: forall l1 l2 l3, DisjList l1 (l2 ++ l3) -> DisjList l1 l2.\n  Proof. \n    intros. unfold DisjList in *. intros e.\n    destruct (H e); [left | right].\n    - assumption.\n    - intuition.\n  Qed.\n\n  Lemma DisjList_app_2: forall l1 l2 l3, DisjList l1 (l2 ++ l3) -> DisjList l1 l3.\n  Proof. \n    intros. unfold DisjList in *. intros e.\n    destruct (H e); [left | right].\n    - assumption.\n    - intuition.\n  Qed.\n\n  Lemma DisjList_app_3:\n    forall l1 l2 l3, DisjList (l1 ++ l2) l3 -> DisjList l1 l3 /\\ DisjList l2 l3.\n  Proof.\n    intros; unfold DisjList in *; split.\n    - intros; destruct (H e).\n      + left; intuition.\n      + right; intuition.\n    - intros; destruct (H e).\n      + left; intuition.\n      + right; intuition.\n  Qed.\n\n  Lemma DisjList_app_4:\n    forall l1 l2 l3,\n      DisjList l1 l3 -> DisjList l2 l3 -> DisjList (l1 ++ l2) l3.\n  Proof.\n    intros; unfold DisjList in *; intros.\n    specialize (H e); specialize (H0 e).\n    destruct H; auto.\n    destruct H0; auto.\n    left; intro Hx.\n    apply in_app_or in Hx; destruct Hx; auto.\n  Qed.\n\nEnd Lists.\n\nLtac subList_app_tac :=\n  auto;\n  repeat\n    match goal with\n    | [H: SubList _ _ |- _] => apply SubList_app_7 in H; destruct H\n    end;\n  repeat apply SubList_app_3;\n  match goal with\n  | _ => apply SubList_refl\n  | _ => apply SubList_app_1; subList_app_tac\n  | _ => apply SubList_app_2; subList_app_tac\n  end.\nLtac equivList_app_tac := split; subList_app_tac.\n\nLemma SubList_map: forall {A B} (l1 l2: list A) (f: A -> B),\n                     SubList l1 l2 -> SubList (map f l1) (map f l2).\nProof.\n  induction l1; intros; simpl; unfold SubList in *; intros; inv H0.\n  - apply in_map; apply H; left; reflexivity.\n  - apply IHl1; auto.\n    intros; specialize (H e0); apply H; right; assumption.\nQed.\n\nLemma DisjList_logic:\n  forall (l1 l2: list string),\n    (forall e, In e l1 -> In e l2 -> False) ->\n    DisjList l1 l2.\nProof.\n  unfold DisjList; intros.\n  specialize (H e).\n  destruct (in_dec string_dec e l1); intuition.\nQed.\n\nLemma DisjList_logic_inv:\n  forall (l1 l2: list string),\n    DisjList l1 l2 ->\n    (forall e, In e l1 -> In e l2 -> False).\nProof.\n  unfold DisjList; intros.\n  specialize (H e); destruct H; auto.\nQed.\n\nScheme Sorted_ind' := Induction for Sorted Sort Prop.\nScheme HdRel_ind' := Induction for HdRel Sort Prop.\n\nDefinition HdRel_irrel {A : Type} {le : A -> A -> Prop}\n           (le_irrel : forall {x y} (a b : le x y), a = b)\n           (x : A) (xs : list A) (p q : HdRel le x xs)\n: p = q.\nProof.\n  induction p using HdRel_ind'.\n  - refine (\n        match q as q' in HdRel _ _ xs return \n              (match xs with \n                 | nil => fun (q : HdRel le x nil) => HdRel_nil le x = q\n                 | _ :: _ => fun _ => True\n               end q'\n              )\n        with\n          | HdRel_nil => eq_refl\n          | HdRel_cons _ _ _ => I\n        end\n      ).\n  - generalize dependent r.\n    assert (forall r : le x (hd b (b :: l)), HdRel_cons le x b l r = q).\n    2:assumption.\n    refine (\n        match q as q' in HdRel _ _ xs return\n              forall r' : le x (hd b xs),\n                (match xs as xs'\n                       return HdRel le x xs' -> le x (hd b xs') -> Prop with\n                   | nil => fun _ _ => True\n                   | b' :: l' => fun (q'' : HdRel le x _) r''\n                                 => HdRel_cons le x b' l' r'' = q''\n                 end q' r')\n        with\n          | HdRel_nil => fun _ => I\n          | HdRel_cons _ _ _ => fun _ => _\n        end\n      ).\n    replace l2 with l1 by apply le_irrel.\n    reflexivity.\nQed.\n\nTheorem Sorted_irrel {A : Type} {le : A -> A -> Prop}\n        (le_irrel : forall {x y} (a b : le x y), a = b)\n        (xs : list A) p\n: forall (q : Sorted le xs), p = q.\nProof.\n  induction p using Sorted_ind'; intros.\n  - refine (\n        match q as q' in Sorted _ xs return \n              (match xs with \n                 | nil => fun (q : Sorted le nil) => Sorted_nil le = q\n                 | _ :: _ => fun _ => True\n               end q'\n              )\n        with\n          | Sorted_nil => eq_refl\n          | Sorted_cons _ _ _ _ => I\n        end\n      ).\n  - generalize dependent h.\n    generalize dependent p.\n    assert (forall p : Sorted le (tl (a :: l)),\n              (forall q' : Sorted le (tl (a :: l)), p = q') -> \n              forall h : HdRel le (hd a (a :: l)) (tl (a :: l)), Sorted_cons p h = q).\n    2:assumption.\n    refine (\n        match q as q' in Sorted _ xs return\n              (forall p : Sorted le (tl xs),\n                 (forall q' : Sorted le (tl xs), p = q') -> \n                 forall h : HdRel le (hd a xs) (tl xs),\n                   (match xs as xs'\n                          return Sorted le (tl xs') -> HdRel le (hd a xs') (tl xs') ->\n                                 Sorted le xs' -> Prop with\n                      | nil => fun _ _ _ => True\n                      | a' :: l' => fun p' h' q''\n                                    => Sorted_cons p' h' = q''\n                    end p h q'))\n        with\n          | Sorted_nil => fun _ _ _ => I\n          | Sorted_cons _ _ _ _ => fun _ _ _ => _\n        end\n      ).\n    replace h0 with h by (apply HdRel_irrel; assumption).\n    specialize (e s); subst; reflexivity.\nQed.\n\nModule FMapListEq (UOT : UsualOrderedType) <: FMapInterface.S with Module E := UOT.\n\n  Module OT := UOT_to_OT UOT.\n  Module M := FMapList.Make(OT).\n  Include M.\n  Module Facts := FMapFacts.OrdProperties M.\n  \n  Lemma eq_leibniz_list: forall (A:Type) (xs ys: list A),\n                           eqlistA eq xs ys -> xs = ys.\n  Proof. intros ? ? ? H; induction H; simpl; congruence. Qed.\n\n  Lemma eqke_sub_eq A: subrelation (@M.Raw.PX.eqke A) eq.\n  Proof. intros [] [] [??]; simpl in *; subst; auto. Qed.\n\n  Lemma eq_sub_eqke A: subrelation eq (@M.Raw.PX.eqke A).\n  Proof. intro H; split; subst; auto. Qed.\n\n  Add Parametric Morphism A: (@InA A)\n      with signature subrelation ==> eq ==> eq ==> impl\n        as InA_rel_d.\n  Proof.\n    unfold impl; firstorder.\n    apply InA_alt in H0.\n    destruct H0 as [?[??]].\n    apply InA_alt.\n    exists x0; split; auto.\n  Qed.\n\n  Add Parametric Morphism A: (@eqlistA A)\n      with signature subrelation ==> eq ==> eq ==> impl\n        as eqlistA_rel_d.\n  Proof.\n    unfold impl; firstorder.\n    induction H0; auto.\n  Qed.\n\n  Lemma Equal_this: forall elt L1 L2,\n                      Equal (elt:=elt) L1 L2 -> this L1 = this L2.\n  Proof.\n    unfold Equal; destruct L1, L2; simpl; intros.\n    lapply (SortA_equivlistA_eqlistA _ _ _ sorted0 sorted1); intros.\n    - clear H.\n      rewrite eqke_sub_eq in H0.\n      apply eq_leibniz_list in H0.\n      assumption.\n    - red.\n      apply Facts.P.F.Equal_Equiv in H; destruct H.\n      intros [a e].\n      specialize (H a).\n      repeat rewrite Facts.P.F.elements_in_iff in H; simpl in H.\n      specialize (H0 a).\n      setoid_rewrite Facts.P.F.elements_mapsto_iff in H0; simpl in H0.\n      destruct H; split; intros.\n      + assert (exists e, InA (M.eq_key_elt (elt:=elt)) (a, e) this0)\n          by (eexists; eauto).\n        specialize (H H3); dest.\n        specialize (H0 e x0 H2 H); subst; auto.\n      + assert (exists e, InA (M.eq_key_elt (elt:=elt)) (a, e) this1)\n          by (eexists; eauto).\n        specialize (H1 H3); dest.\n        specialize (H0 x0 e H1 H2); subst; auto.\n  Qed.\n\n  Theorem lt_irrel_leibniz {A : Type}\n          (lt_irrel : forall (a b : UOT.t) (x y : UOT.lt a b), x = y) (m m' : t A)\n  : Equal m m' -> m = m'.\n  Proof.\n    intros H. \n    apply Equal_this in H.\n    induction m. induction m'. simpl in H. induction H.\n    replace sorted1 with sorted0.\n    reflexivity. apply Sorted_irrel.\n    intros. destruct x, y. apply lt_irrel.\n  Qed.\n\nEnd FMapListEq.\n\nModule Type LT_IRREL (Import T : OrderedType).\n  Parameter Inline lt_irrel : forall (x y : t) (p q : lt x y), p = q.\nEnd LT_IRREL.\n\nModule Type UsualOrderedTypeLTI := UsualOrderedType <+ LT_IRREL.\n\nModule Type MapLeibniz.\n  Declare Module E : UsualOrderedType.\n  Include Sfun E.\n\n  Parameter leibniz : forall {A : Type} (m m' : t A), Equal m m' -> m = m'.\nEnd MapLeibniz.\n\nModule LeibnizFacts (M : MapLeibniz).\n  Import M.\n  Module F := FMapFacts.OrdProperties M.\n  Import F.\n\n  Ltac ext k := apply leibniz; unfold Equal; intros k.\n\n  Lemma Equal_val: forall {A : Type} (m1 m2: t A) k, m1 = m2 -> find k m1 = find k m2.\n  Proof. intros; subst; reflexivity. Qed.\n\n  Lemma elements_eq_leibniz:\n    forall {A : Type} (m1 m2: t A),\n      elements m1 = elements m2 -> m1 = m2.\n  Proof.\n    intros; ext y.\n    do 2 rewrite P.F.elements_o.\n    rewrite H; auto.\n  Qed.\n\n  Theorem empty_canon {A : Type} : forall (m : t A), Empty m -> m = empty A.\n  Proof.\n    intros; ext k.\n    rewrite P.F.empty_o.\n    apply P.F.not_find_in_iff.\n    unfold In. firstorder.\n  Qed.\n\n  Theorem add_canon {A : Type} {x} {e : A} {m m' : t A} :\n    P.Add x e m m' -> m' = add x e m.\n  Proof. intros; apply leibniz; assumption. Qed.\n\n  Theorem map_induction {A : Type} {P : t A -> Type} :\n    P (empty A)\n    -> (forall m, P m -> forall k v, ~ In k m -> P (add k v m))\n    -> forall m, P m.\n  Proof.\n    intros. apply P.map_induction.\n    intros. replace m0 with (empty A). assumption. symmetry. apply empty_canon.\n    assumption. intros. replace m' with (add x e m0).\n    apply X0; assumption. symmetry. apply add_canon. assumption.\n  Qed.\n\n  Ltac mind v :=\n    generalize dependent v; intro; pattern v;\n    apply map_induction; clear v; intros.\n\n  Ltac cmp k1 k2 :=\n    let e := fresh \"e\" in\n    destruct (E.eq_dec k1 k2) as [e|]; [unfold E.eq in e; subst|].\n  \n  Definition unionL {A} (m m' : t A) := fold (@add A) m m'.\n  Definition union {A} := @unionL A.\n  Definition update {A : Type} (m1 m2: t A) := unionL m2 m1.\n\n  Definition Sub {A : Type} (m m' : t A) :=\n    forall k v, find k m = Some v -> find k m' = Some v.\n\n  Definition subtract {A : Type} (m m' : t A) :=\n    fold (fun k _ => remove k) m' m.\n\n  Definition subtractKV {A}\n             (deceqA : forall x y : A, sumbool (x = y) (x <> y))\n             (m1 m2 : t A) : t A :=\n    fold (fun k v2 m1' =>\n            match find k m1' with\n            | Some v1 =>\n              match deceqA v1 v2 with\n              | left _ => remove k m1'\n              | _ => m1'\n              end\n            | _ => m1'\n            end) m2 m1.\n\n  Definition subtractKVD {A}\n           (deceqA : forall x y : A, sumbool (x = y) (x <> y))\n           (m1 m2 : t A) (dom: list E.t): t A :=\n    fold (fun k v2 m1' =>\n            if in_dec E.eq_dec k dom then\n              match find k m1' with\n              | Some v1 =>\n                match deceqA v1 v2 with\n                | left _ => remove k m1'\n                | _ => m1'\n                end\n              | _ => m1'\n              end\n            else m1') m2 m1.\n\n  Definition restrict {A} (m: t A) (d: list E.t) :=\n    fold (fun k v m' =>\n            if in_dec E.eq_dec k d then add k v m' else m') m (empty _).\n\n  Definition complement {A} (m: t A) (d: list E.t) :=\n    fold (fun k v m' =>\n            if in_dec E.eq_dec k d then m' else add k v m') m (empty _).\n\n  (* NOTE: do not add [subtractKV], [restrict], and [complement] to below *)\n  #[global] Hint Unfold update Sub subtract : MapDefs.\n  #[global] Hint Unfold E.eq.\n\n  Ltac mintros := repeat autounfold with MapDefs; intros.\n\n  #[global] Hint Extern 1 (Empty (empty _)) => apply empty_1.\n\n  Lemma find_empty : forall {A} k, (find k (@empty A)) = None.\n  Proof. intros; apply P.F.empty_o. Qed.\n\n  Lemma find_add_1 : forall {A} k v (m: t A), find k (add k v m) = Some v.\n  Proof. intros; apply find_1, add_1; reflexivity. Qed.\n\n  Lemma find_add_2:\n    forall {A} k k' v (m: t A), k <> k' -> find k (add k' v m) = find k m.\n  Proof. intros; apply P.F.add_neq_o; firstorder. Qed.\n\n  Lemma find_add_3:\n    forall {A} k v (m: t A),\n      find k m = Some v -> exists m', m = add k v m' /\\ ~ In k m'.\n  Proof.\n    intros; exists (remove k m); split.\n    - ext y; cmp y k.\n      + rewrite find_add_1; assumption.\n      + rewrite find_add_2 by assumption.\n        rewrite P.F.remove_neq_o by intuition; auto.\n    - apply remove_1; auto.\n  Qed.\n\n  Ltac find_add_tac :=\n    repeat ((rewrite find_add_1 ||rewrite find_add_2 by auto); try reflexivity).\n\n  Ltac proper_tac := unfold Morphisms.Proper, Morphisms.respectful; intros; subst; auto.\n  #[global] Hint Extern 1 (Proper _ _) => proper_tac.\n\n  Lemma add_idempotent:\n    forall {A} k (e1 e2 : A) m, add k e1 (add k e2 m) = add k e1 m.\n  Proof.\n    mintros; ext y; cmp y k; find_add_tac.\n  Qed.\n\n  Lemma add_comm:\n    forall {A} k1 k2 v1 v2 (m: t A),\n      k1 <> k2 -> add k1 v1 (add k2 v2 m) = add k2 v2 (add k1 v1 m).\n  Proof.\n    intros; ext k.\n    cmp k k1; try cmp k k2; find_add_tac.\n  Qed.\n\n  Lemma transpose_neqkey_Equal_add {A : Type} :\n    P.transpose_neqkey Equal (add (elt:=A)).\n  Proof.\n    unfold P.transpose_neqkey. intros. \n    unfold Equal. intros y. do 4 rewrite P.F.add_o.\n    cmp k y; cmp k' y; unfold E.eq in *; subst; congruence || reflexivity.\n  Qed.\n  #[global] Hint Immediate transpose_neqkey_Equal_add.\n\n  Lemma transpose_neqkey_eq_add {A : Type} :\n    P.transpose_neqkey eq (add (elt:=A)).\n  Proof.\n    unfold P.transpose_neqkey; intros.\n    apply add_comm; auto.\n  Qed.\n  #[global] Hint Immediate transpose_neqkey_eq_add.\n\n  Lemma union_add {A}:\n    forall {m m' : t A} k v,\n      union (add k v m) m' = add k v (union m m').\n  Proof.\n    mintros; unfold union, unionL; mind m.\n    - rewrite P.fold_add; auto.\n      intro Hx; eapply P.F.empty_in_iff; eauto.\n    - cmp k k0.\n      + rewrite add_idempotent, H.\n        rewrite P.fold_add with (eqA:= eq); auto.\n        * rewrite add_idempotent; auto.\n      + rewrite add_comm by assumption.\n        rewrite P.fold_add; auto.\n        * rewrite H.\n          rewrite P.fold_add with (eqA:= eq); auto.\n          apply add_comm; auto.\n        * intro Hx; elim H0.\n          apply P.F.add_in_iff in Hx; destruct Hx; auto; elim n; auto.\n  Qed.\n\n  Lemma union_empty_L {A : Type} : forall m, union (empty A) m = m.\n  Proof.\n    mintros; mind m.\n    - apply leibniz, P.fold_identity.\n    - apply P.fold_Empty; auto.\n  Qed.\n\n  Lemma union_empty_R {A : Type} : forall m, union m (empty A) = m.\n  Proof. mintros; apply leibniz, P.fold_identity. Qed.\n\n  Lemma find_union {A}:\n    forall {m m' : t A} k,\n      find k (union m m') = match find k m with\n                            | Some v => Some v\n                            | None => find k m'\n                            end.\n  Proof.\n    intros m m'. pattern m.\n    apply map_induction; simpl; intros.\n    - rewrite union_empty_L. rewrite P.F.empty_o. reflexivity. \n    - rewrite union_add by assumption. \n      do 2 rewrite P.F.add_o.\n      cmp k k0; auto.\n  Qed.\n\n  Lemma union_empty:\n    forall {A} (m1 m2: t A),\n      union m1 m2 = empty _ -> m1 = empty _ /\\ m2 = empty _.\n  Proof.\n    intros; split.\n    - ext y.\n      rewrite find_empty.\n      assert (find y (union m1 m2) = find y (empty A)) by (rewrite H; reflexivity).\n      rewrite find_union in H0.\n      destruct (find y m1); auto.\n      rewrite find_empty in H0; auto.\n    - ext y.\n      rewrite find_empty.\n      assert (find y (union m1 m2) = find y (empty A)) by (rewrite H; reflexivity).\n      rewrite find_union in H0.\n      destruct (find y m2); auto.\n      rewrite find_empty in H0.\n      destruct (find y m1); inv H0.\n  Qed.\n\n  Lemma union_smothered {A : Type}:\n    forall (m m' : t A), Sub m m' -> union m m' = m'.\n  Proof. \n    intros m. unfold Sub. pattern m. apply map_induction; intros.\n    - apply union_empty_L.\n    - unfold union, unionL in *. ext y.\n      rewrite P.fold_add; auto.\n      + rewrite H. \n        * rewrite P.F.add_o; destruct (E.eq_dec k y); unfold E.eq in *; auto.\n          symmetry. apply P.F.find_mapsto_iff.\n          apply find_2, H1.\n          subst; apply find_add_1.\n        * intros. apply H1. destruct (E.eq_dec k k0); unfold E.eq in *.\n          { subst. apply False_rect. apply H0. exists v0.\n            apply find_2; assumption.\n          }\n          { rewrite find_add_2; auto. }\n      + apply P.F.add_m_Proper.\n  Qed.\n\n  Lemma MapsToIn1 A m k (v: A):\n    MapsTo k v m -> In k m.\n  Proof.\n    unfold In.\n    eexists; eauto.\n  Qed.\n\n  Lemma MapsToIn2 A m k:\n    In k m -> (exists (v: A), MapsTo k v m).\n  Proof.\n    unfold In.\n    intuition.\n  Qed.\n\n  Lemma mapsto_union A:\n    forall (m m': t A) k v,\n      MapsTo k v (union m m') <-> MapsTo k v m \\/ ~ In k m /\\ MapsTo k v m'.\n  Proof.\n    intros.\n    constructor; intros.\n    - apply P.F.find_mapsto_iff in H.\n      rewrite find_union in H.\n      case_eq (find k m); intros; subst.\n      + rewrite H0 in *.\n        inversion H; subst.\n        apply P.F.find_mapsto_iff in H0; intuition.\n      + rewrite H0 in *.\n        inversion H; subst.\n        apply P.F.find_mapsto_iff in H.\n        apply P.F.not_find_in_iff in H0.\n        intuition.\n    - apply P.F.find_mapsto_iff.\n      destruct H.\n      + apply P.F.find_mapsto_iff in H.\n        rewrite find_union.\n        rewrite H; reflexivity.\n      + rewrite find_union.\n        dest.\n        apply P.F.find_mapsto_iff in H0.\n        apply P.F.not_find_in_iff in H.\n        rewrite H, H0.\n        reflexivity.\n  Qed.\n\n  Lemma update_empty_1: forall {A} (m: t A), update (empty A) m = m.\n  Proof.\n    mintros; unfold unionL; mind m.\n    - apply P.fold_Empty; auto.\n    - apply leibniz. rewrite P.fold_add; auto.\n      + rewrite H; apply P.F.Equal_refl.\n      + apply P.F.add_m_Proper.\n  Qed.\n\n  Lemma update_empty_2: forall {A} (m: t A), update m (empty A) = m.\n  Proof. mintros; apply P.fold_Empty; auto. Qed.\n\n  Lemma Sub_empty_1:\n    forall {A} (m: t A), Sub (empty _) m.\n  Proof. mintros; rewrite find_empty in H; inv H. Qed.\n\n  Lemma Sub_empty_2:\n    forall {A} (m: t A), Sub m (empty _) -> m = empty _.\n  Proof.\n    mintros; mind m; auto.\n    specialize (H1 k v).\n    rewrite find_add_1, find_empty in H1.\n    specialize (H1 eq_refl); inv H1.\n  Qed.\n    \n  Lemma Sub_union_1:\n    forall {A} (m1 m2: t A), Sub m1 (union m1 m2).\n  Proof.\n    mintros; mind m1; [rewrite find_empty in H; inv H|].\n    rewrite union_add.\n    cmp k k0.\n    - rewrite find_add_1; rewrite find_add_1 in H1; auto.\n    - rewrite find_add_2 by auto; rewrite find_add_2 in H1 by auto; auto.\n  Qed.\n\n  Lemma remove_empty:\n    forall {A} k, remove k (empty A) = empty A.\n  Proof.\n    mintros; ext y; cmp y k.\n    - rewrite P.F.remove_eq_o by reflexivity.\n      rewrite find_empty; reflexivity.\n    - rewrite P.F.remove_neq_o by auto; reflexivity.\n  Qed.\n\n  Lemma remove_comm:\n    forall {A} k1 k2 (m: t A), remove k1 (remove k2 m) = remove k2 (remove k1 m).\n  Proof.\n    intros; ext y.\n    cmp y k1.\n    - rewrite P.F.remove_eq_o; auto.\n      cmp k1 k2.\n      + rewrite P.F.remove_eq_o; auto.\n      + rewrite P.F.remove_neq_o; auto.\n        rewrite P.F.remove_eq_o; auto.\n    - rewrite P.F.remove_neq_o; auto.\n      cmp y k2.\n      + do 2 (rewrite P.F.remove_eq_o; auto).\n      + do 3 (rewrite P.F.remove_neq_o; auto).\n  Qed.\n      \n  Lemma remove_find_None:\n    forall {A} (m: t A) k,\n      find k m = None -> remove k m = m.\n  Proof.\n    mintros; ext y; cmp y k.\n    - rewrite P.F.remove_eq_o; auto.\n    - rewrite P.F.remove_neq_o; auto.\n  Qed.\n\n  Lemma remove_add:\n    forall {A} (m: t A) k v,\n      remove k (add k v m) = remove k m.\n  Proof.\n    mintros; ext y; cmp y k.\n    - do 2 (rewrite P.F.remove_eq_o; auto).\n    - do 2 (rewrite P.F.remove_neq_o; auto).\n      find_add_tac.\n  Qed.\n\n  Lemma remove_union:\n    forall {A} (m1 m2: t A) k,\n      remove k (union m1 m2) = union (remove k m1) (remove k m2).\n  Proof.\n    mintros; ext y; cmp y k; rewrite find_union.\n    - do 3 (rewrite P.F.remove_eq_o; auto).\n    - do 3 (rewrite P.F.remove_neq_o; auto).\n      rewrite find_union; reflexivity.\n  Qed.\n\n  Lemma transpose_neqkey_subtractKV:\n    forall {A} (deceqA : forall x y : A, sumbool (x = y) (x <> y)),\n      P.transpose_neqkey\n        eq\n        (fun (k0 : key) (v2 : A) (m1' : t A) =>\n           match find k0 m1' with\n           | Some v1 => if deceqA v1 v2 then remove k0 m1' else m1'\n           | None => m1'\n           end).\n  Proof.\n    unfold P.transpose_neqkey; intros.\n    repeat\n      (match goal with\n       (* basic destruction *)\n       | [ |- context [deceqA ?a1 ?a2] ] =>\n         destruct (deceqA a1 a2); [subst|]\n       | [H: _ = find ?k ?m |- context [find ?k ?m] ] =>\n         rewrite <-H\n       | [ |- context [find ?y ?m] ] =>\n         (is_var m;\n          let v := fresh \"v\" in\n          remember (find y m) as v; destruct v)\n       (* goal reduction *)\n       | [H: ?y <> ?k |- context [find ?y (remove ?k ?m)] ] =>\n         rewrite F.P.F.remove_neq_o by intuition auto\n       | [H: ?k <> ?y |- context [find ?y (remove ?k ?m)] ] =>\n         rewrite F.P.F.remove_neq_o by intuition auto\n       end; try discriminate; try reflexivity; try (intuition idtac; fail)).\n    apply remove_comm.\n  Qed.\n  #[global] Hint Immediate transpose_neqkey_subtractKV.\n\n  Lemma transpose_neqkey_subtractKVD:\n    forall {A} (deceqA : forall x y, sumbool (x = y) (x <> y)) d,\n      P.transpose_neqkey\n        eq\n        (fun (k1 : key) (v2 : A) (m1' : t A) =>\n           if in_dec P.F.eq_dec k1 d\n           then\n             match find k1 m1' with\n             | Some v1 => if deceqA v1 v2 then remove k1 m1' else m1'\n             | None => m1'\n             end\n           else m1').\n  Proof.\n    unfold P.transpose_neqkey; intros.\n    repeat\n      (match goal with\n       (* basic destruction *)\n       | [ |- context [deceqA ?a1 ?a2] ] =>\n         destruct (deceqA a1 a2); [subst|]\n       | [ |- context [in_dec ?dc ?k ?d] ] =>\n         destruct (in_dec dc k d)\n       | [H: _ = find ?k ?m |- context [find ?k ?m] ] =>\n         rewrite <-H\n       | [ |- context [find ?y ?m] ] =>\n         (is_var m;\n          let v := fresh \"v\" in\n          remember (find y m) as v; destruct v)\n       (* goal reduction *)\n       | [H: ?y <> ?k |- context [find ?y (remove ?k ?m)] ] =>\n         rewrite F.P.F.remove_neq_o by intuition auto\n       | [H: ?k <> ?y |- context [find ?y (remove ?k ?m)] ] =>\n         rewrite F.P.F.remove_neq_o by intuition auto\n       end; try discriminate; try reflexivity; try (intuition idtac; fail)).\n    apply remove_comm.\n  Qed.\n  #[global] Hint Immediate transpose_neqkey_subtractKVD.\n        \n  Lemma subtractKV_find:\n    forall {A} deceqA (m1 m2: t A) k,\n      find k (subtractKV deceqA m1 m2) =\n      match find k m1 with\n      | None => None\n      | Some v1 =>\n        match find k m2 with\n        | None => Some v1\n        | Some v2 => if deceqA v1 v2 then None else Some v1\n        end\n      end.\n  Proof.\n    mintros; unfold subtractKV; mind m2.\n    - rewrite P.fold_Empty, find_empty; auto.\n      destruct (find k m1); auto.\n\n    - rewrite P.fold_add with (eqA:= eq); auto.\n      remember (fold\n                  (fun (k0 : key) (v2 : A) (m1' : t A) =>\n                     match find k0 m1' with\n                     | Some v1 => if deceqA v1 v2 then remove k0 m1' else m1'\n                     | None => m1'\n                     end) m m1) as mprev; clear Heqmprev.\n      remember (find k0 mprev) as ov0; destruct ov0.\n\n      + destruct (deceqA a v); [subst|].\n        * cmp k k0.\n          { rewrite P.F.remove_eq_o, find_add_1 by auto.\n            remember (find k0 m1) as ov1; destruct ov1; auto.\n            destruct (deceqA a v); auto.\n            exfalso.\n            rewrite <-Heqov0 in H.\n            destruct (find k0 m).\n            { destruct (deceqA a a0); inv H.\n              elim n; auto.\n            }\n            { inv H; elim n; auto. }\n          }\n          { rewrite P.F.remove_neq_o, find_add_2 by auto.\n            rewrite H; auto.\n          }\n\n        * remember (find k m1) as ov1; destruct ov1; auto.\n          cmp k k0.\n          { rewrite find_add_1.\n            destruct (deceqA a0 v); [subst|].\n            { exfalso.\n              rewrite <-Heqov0 in H.\n              destruct (find k0 m).\n              { destruct (deceqA v a0); [inv H|].\n                elim n; inv H; auto.\n              }\n              { elim n; inv H; auto. }\n            }\n            { rewrite <-Heqov0 in *.\n              destruct (find k0 m); auto.\n              destruct (deceqA a0 a1); [inv H|].\n              auto.\n            }\n          }\n          { rewrite find_add_2; auto. }\n\n      + cmp k k0.\n        * rewrite <-Heqov0 in *.\n          rewrite find_add_1.\n          remember (find k0 m1) as ov1; destruct ov1; auto.\n          destruct (deceqA a v); auto.\n          exfalso.\n          remember (find k0 m) as ov; destruct ov; [|inv H].\n          elim H0.\n          apply P.F.in_find_iff; rewrite <-Heqov; discriminate.\n        * rewrite find_add_2 by auto; auto.\n  Qed.\n\n  Lemma subtractKVD_find:\n    forall {A} deceqA (m1 m2: t A) d k,\n      find k (subtractKVD deceqA m1 m2 d) =\n      match find k m1 with\n      | None => None\n      | Some v1 =>\n        if in_dec E.eq_dec k d then\n          match find k m2 with\n          | None => Some v1\n          | Some v2 => if deceqA v1 v2 then None else Some v1\n          end\n        else Some v1\n      end.\n  Proof.\n    mintros; unfold subtractKVD; mind m2.\n    - rewrite P.fold_Empty, find_empty; auto.\n      destruct (find k m1); auto.\n      destruct (in_dec _ _ _); auto.\n\n    - rewrite P.fold_add with (eqA:= eq); auto.\n      remember (fold\n                  (fun (k0 : key) (v2 : A) (m1' : t A) =>\n                     if in_dec P.F.eq_dec k0 d\n                     then\n                       match find k0 m1' with\n                       | Some v1 =>\n                         if deceqA v1 v2 then remove k0 m1' else m1'\n                       | None => m1'\n                       end\n                     else m1') m m1) as mprev; clear Heqmprev.\n      remember (find k0 mprev) as ov0; destruct ov0.\n\n      + destruct (in_dec P.F.eq_dec k0 d).\n        * destruct (deceqA a v); [subst|].\n          { cmp k k0.\n            { rewrite P.F.remove_eq_o by reflexivity.\n              destruct (find k0 m1); auto.\n              destruct (in_dec P.F.eq_dec k0 d); [|elim n; auto].\n              rewrite find_add_1.\n              destruct (deceqA a v); [subst|]; auto.\n              exfalso; rewrite <-Heqov0 in H.\n              destruct (find k0 m).\n              { destruct (deceqA a a0); inv H.\n                elim n; auto.\n              }\n              { elim n; inv H; auto. }\n            }\n            { rewrite P.F.remove_neq_o by auto.\n              destruct (find k m1); auto.\n              destruct (in_dec P.F.eq_dec k d); auto.\n              rewrite find_add_2 by auto.\n              destruct (find k m); auto.\n            }\n          }\n          { destruct (find k m1); auto.\n            destruct (in_dec P.F.eq_dec k d); auto.\n            cmp k k0.\n            { rewrite find_add_1.\n              apply P.F.not_find_in_iff in H0.\n              rewrite H0 in *.\n              destruct (deceqA a0 v); [subst|]; intuition.\n              rewrite <-Heqov0 in H; elim n; inv H; auto.\n            }\n            { rewrite find_add_2; auto. }\n          }\n        * destruct (find k m1); auto.\n          destruct (in_dec P.F.eq_dec k d); auto.\n          cmp k k0; intuition.\n          rewrite find_add_2; auto.\n\n      + destruct (in_dec P.F.eq_dec k0 d).\n        * cmp k k0.\n          { apply P.F.not_find_in_iff in H0.\n            rewrite H0 in *.\n            rewrite find_add_1.\n            destruct (find k0 m1); auto.\n            destruct (in_dec P.F.eq_dec k0 d); auto.\n            destruct (deceqA a v); auto.\n          }\n          { rewrite find_add_2; auto. }\n        * cmp k k0.\n          { apply P.F.not_find_in_iff in H0.\n            rewrite H0 in *.\n            rewrite find_add_1.\n            destruct (find k0 m1); auto.\n            destruct (in_dec P.F.eq_dec k0 d); auto.\n            destruct (deceqA a v); auto.\n          }\n          { rewrite find_add_2; auto. }\n  Qed.\n\n  Ltac subtractKVD_solve deceqA :=\n    repeat\n      (match goal with\n       | [ |- context [find _ (subtractKVD _ _ _ _)] ] =>\n         rewrite subtractKVD_find\n       | [ |- context [M.find ?y ?m] ] =>\n         (is_var m;\n          let v := fresh \"v\" in\n          remember (M.find y m) as v; destruct v)\n       | [ |- context [in_dec E.eq_dec ?k ?d] ] =>\n         destruct (in_dec E.eq_dec k d)\n       | [ |- context [E.eq_dec ?k1 ?k2] ] =>\n         is_var k1; is_var k2; cmp k1 k2\n       | [ |- context [deceqA ?v1 ?v2] ] =>\n         destruct (deceqA v1 v2); [subst|]\n       | [ |- context [deceqA ?v1 ?v2] ] =>\n         destruct (deceqA v1 v2); [subst|]\n       | [ |- context [M.find ?y (M.remove ?k ?m)] ] =>\n         cmp y k;\n         [rewrite F.P.F.remove_eq_o|\n          rewrite F.P.F.remove_neq_o by intuition auto]\n       | [ |- context [M.find ?y (M.remove ?y ?m)] ] =>\n         rewrite F.P.F.remove_eq_o\n       | [H: ~ E.eq ?y ?k |- context [M.find ?y (M.remove ?k ?m)] ] =>\n         rewrite F.P.F.remove_neq_o by intuition auto\n       | [H: ~ E.eq ?k ?y |- context [M.find ?y (M.remove ?k ?m)] ] =>\n         rewrite F.P.F.remove_neq_o by intuition auto\n       | [H: ?y <> ?k |- context [M.find ?y (M.remove ?k ?m)] ] =>\n         rewrite F.P.F.remove_neq_o by intuition auto\n       | [H: ?k <> ?y |- context [M.find ?y (M.remove ?k ?m)] ] =>\n         rewrite F.P.F.remove_neq_o by intuition auto\n       end;\n       repeat\n         match goal with\n         | [H: ~ E.eq ?a ?a |- _] => elim H; auto\n         | [H1: ~ ?p, H2: ?p |- _] => elim H1; auto\n         | [H: Some _ = Some _ |- _] => inv H\n         | [H: ?a <> ?a |- _] => elim H; auto\n         | [H1: Some _ = ?v, H2: None = ?v |- _] =>\n           rewrite <-H1 in H2; inv H2\n         | [H1: Some _ = ?v, H2: Some _ = ?v |- _] =>\n           rewrite <-H1 in H2; inv H2\n         end; simpl; auto).\n\n  Lemma subtractKVD_nil:\n    forall {A} deceqA (m1 m2: t A),\n      subtractKVD deceqA m1 m2 nil = m1.\n  Proof.\n    mintros; ext y.\n    subtractKVD_solve deceqA.\n  Qed.\n    \n  Lemma subtractKVD_cons:\n    forall {A} deceqA (m1 m2: t A) a d,\n      subtractKVD deceqA m1 m2 (a :: d) =\n      match find a m1 with\n      | Some v1 =>\n        match find a m2 with\n        | Some v2 =>\n          if deceqA v1 v2\n          then subtractKVD deceqA (remove a m1) (remove a m2) d\n          else subtractKVD deceqA m1 m2 d\n        | _ => subtractKVD deceqA m1 m2 d\n        end\n      | _ => subtractKVD deceqA m1 m2 d\n      end.\n  Proof.\n    mintros; ext y.\n    subtractKVD_solve deceqA.\n  Qed.\n\n  Lemma subtractKVD_remove:\n    forall {A} (deceqA : forall x y : A, sumbool (x = y) (x <> y))\n           dom m1 m2 a,\n      subtractKVD deceqA (remove a m1) (remove a m2) dom =\n      subtractKVD deceqA (remove a m1) m2 dom.\n  Proof.\n    mintros; ext y.\n    subtractKVD_solve deceqA.\n  Qed.\n\n  Lemma subtractKV_mapsto A (decA: forall x y: A, {x = y} + {x <> y}):\n    forall m1 m2 k e, MapsTo k e (subtractKV decA m1 m2) <-> MapsTo k e m1 /\\ ~ MapsTo k e m2.\n  Proof.\n    intros; constructor; intros.\n    - apply P.F.find_mapsto_iff in H.\n      rewrite subtractKV_find in H.\n      constructor.\n      + apply P.F.find_mapsto_iff.\n        repeat match goal with\n        | H: context [match ?P with\n                      | _ => _\n                      end] |- _ => case_eq P; intros;\n                                     match goal with\n                                     | H : _ = _ |- _ => try rewrite H in *\n                                     end\n               end; intuition; try discriminate.\n      + unfold not; intros Heq; apply P.F.find_mapsto_iff in Heq.\n        repeat match goal with\n        | H: context [match ?P with\n                      | _ => _\n                      end] |- _ => case_eq P; intros;\n                                     match goal with\n                                     | H : _ = _ |- _ => try rewrite H in *\n                                     end\n               end; intuition; try discriminate.\n        injection H; injection Heq; intros; subst; intuition.\n    - destruct H as [c1 c2].\n      apply P.F.find_mapsto_iff.\n      apply P.F.find_mapsto_iff in c1.\n      rewrite subtractKV_find.\n      assert (find k m2 <> Some e) by (unfold not; intros Y; apply P.F.find_mapsto_iff in Y;\n                                      intuition).\n        repeat match goal with\n               | |- context [match ?P with\n                             | _ => _\n                             end] => case_eq P; intros;\n                   match goal with\n                   | H : _ = _ |- _ => try rewrite H in *\n                   end\n               end; intuition; try discriminate.\n        rewrite e0 in *; intuition.\n  Qed.\n\n  Lemma subtractKV_empty_1:\n    forall {A : Type} deceqA (m: t A),\n      subtractKV deceqA (empty A) m = empty A.\n  Proof.\n    mintros; ext y.\n    rewrite subtractKV_find, find_empty; reflexivity.\n  Qed.\n\n  Lemma subtractKV_empty_2:\n    forall {A : Type} deceqA (m: t A),\n      subtractKV deceqA m (empty A) = m.\n  Proof.\n    mintros; unfold subtractKV; apply P.fold_Empty; auto.\n  Qed.\n\n  Lemma subtractKV_empty_3:\n    forall {A} deceqA (m: t A),\n      subtractKV deceqA m m = empty A.\n  Proof.\n    mintros; ext y.\n    rewrite subtractKV_find, find_empty.\n    destruct (find y m); auto.\n    destruct (deceqA a a); auto.\n    elim n; auto.\n  Qed.\n\n  Lemma subtractKV_sub:\n    forall {A} deceqA (m1 m2: t A),\n      Sub (subtractKV deceqA m1 m2) m1.\n  Proof.\n    mintros.\n    rewrite subtractKV_find in H.\n    destruct (find k m1); auto.\n    destruct (find k m2); auto.\n    destruct (deceqA a a0); auto.\n    inv H.\n  Qed.\n\n  Lemma subtractKV_sub_empty:\n    forall {A} deceqA (m1 m2: t A),\n      Sub m1 m2 -> subtractKV deceqA m1 m2 = empty _.\n  Proof.\n    intros; ext y.\n    rewrite subtractKV_find, find_empty.\n    remember (find y m1) as ov1; destruct ov1; auto.\n    remember (find y m2) as ov2; destruct ov2.\n    - destruct (deceqA a a0); auto.\n      exfalso; specialize (H _ _ (eq_sym Heqov1)).\n      rewrite H in Heqov2; inv Heqov2; elim n; auto.\n    - exfalso; specialize (H _ _ (eq_sym Heqov1)).\n      rewrite H in Heqov2; inv Heqov2; elim n; auto.\n  Qed.\n  \n  Lemma subtractKV_not_In_find:\n    forall {A} deceqA (m1 m2: t A) k v,\n      ~ In k (subtractKV deceqA m1 m2) ->\n      find k m1 = Some v ->\n      find k m2 = Some v.\n  Proof.\n    mintros.\n    apply P.F.not_find_in_iff in H; rewrite subtractKV_find in H.\n    destruct (find k m1); inv H0.\n    destruct (find k m2); auto.\n    destruct (deceqA v a); [|inv H].\n    subst; auto.\n  Qed.\n\n  Lemma subtractKV_in_find:\n    forall {A} deceqA k (m1 m2: t A) v1 v2,\n      find k m1 = Some v1 -> find k m2 = Some v2 -> v1 <> v2 ->\n      In k (subtractKV deceqA m1 m2).\n  Proof.\n    intros.\n    apply F.P.F.in_find_iff.\n    rewrite subtractKV_find.\n    rewrite H, H0.\n    destruct (deceqA v1 v2); auto.\n    discriminate.\n  Qed.\n\n  Lemma subtractKV_remove:\n    forall {A : Type} deceqA (m2 m1: t A) k,\n      find k m1 = find k m2 ->\n      subtractKV deceqA (remove k m1) (remove k m2) =\n      subtractKV deceqA m1 m2.\n  Proof.\n    mintros; ext y.\n    do 2 rewrite subtractKV_find.\n    cmp y k.\n    - rewrite P.F.remove_eq_o by auto.\n      destruct (find k m1), (find k m2); auto.\n      destruct (deceqA a a0); auto.\n      inv H; elim n; auto.\n    - do 2 rewrite P.F.remove_neq_o by auto.\n      destruct (find y m1); auto.\n  Qed.\n\n  Lemma subtractKV_idempotent:\n    forall {A} deceqA (m1 m2: t A),\n       subtractKV deceqA m1 m2 =\n       subtractKV deceqA (subtractKV deceqA m1 m2)\n                  (subtractKV deceqA m2 m1).\n  Proof.\n    mintros; ext y.\n    repeat rewrite subtractKV_find.\n    destruct (find y m1); auto.\n    destruct (find y m2); auto.\n    destruct (deceqA a a0); auto.\n    destruct (deceqA a0 a); auto.\n    destruct (deceqA a a0); auto.\n    elim n; auto.\n  Qed.\n\n  Lemma transpose_neqkey_restrict:\n    forall {A} d,\n      P.transpose_neqkey\n        eq\n        (fun (k : key) (v0 : A) (m' : t A) =>\n           if in_dec P.F.eq_dec k d then add k v0 m' else m').\n  Proof.\n    unfold P.transpose_neqkey; intros.\n    destruct (in_dec E.eq_dec k d), (in_dec E.eq_dec k' d); auto.\n    apply add_comm; auto.\n  Qed.\n  #[global] Hint Immediate transpose_neqkey_restrict.\n\n  Lemma restrict_find:\n    forall {A} d (m: t A) k,\n      find k (restrict m d) =\n      if in_dec E.eq_dec k d then find k m else None.\n  Proof.\n    mintros; unfold restrict; mind m.\n    - rewrite P.fold_Empty; auto.\n      rewrite find_empty.\n      destruct (in_dec _ _ _); auto.\n    - cmp k k0.\n      + rewrite P.fold_add with (eqA:= eq); auto.\n        destruct (in_dec E.eq_dec k0 d); auto.\n        do 2 rewrite find_add_1; auto.\n      + rewrite P.fold_add with (eqA:= eq); auto.\n        destruct (in_dec E.eq_dec k0 d).\n        * do 2 rewrite find_add_2 by auto; auto.\n        * rewrite find_add_2 by auto; auto.\n  Qed.\n\n  Lemma restrict_empty:\n    forall A d,\n      restrict (empty A) d = empty A.\n  Proof.\n    intros.\n    ext y.\n    rewrite restrict_find.\n    rewrite find_empty.\n    destruct (in_dec P.F.eq_dec y d); intuition.\n  Qed.\n\n  Lemma restrict_add_in A (m: t A) d:\n    forall k v,\n      List.In k d ->\n      add k v (restrict m d) = restrict (add k v m) d.\n  Proof.\n    intros.\n    ext y.\n    rewrite restrict_find.\n    destruct (in_dec P.F.eq_dec y d).\n    rewrite P.F.add_o.\n    rewrite P.F.add_o.\n    destruct (P.F.eq_dec k y); intuition.\n    rewrite restrict_find.\n    destruct (in_dec P.F.eq_dec y d); intuition.\n    assert (sth: k <> y) by (unfold not; intros; subst; intuition).\n    pose proof (P.F.add_neq_o (restrict m d) v sth).\n    rewrite H0.\n    rewrite restrict_find.\n    destruct (in_dec P.F.eq_dec y d);\n      intuition.\n  Qed.\n\n  Lemma restrict_add_not_in A (m: t A) d:\n    forall k v,\n      ~ List.In k d ->\n      restrict (add k v m) d = restrict m d.\n  Proof.\n    intros.\n    ext y.\n    repeat rewrite restrict_find.\n    destruct (in_dec P.F.eq_dec y d).\n    assert (sth: k <> y) by (unfold not; intros; subst; intuition).\n    apply (P.F.add_neq_o m v sth).\n    intuition.\n  Qed.\n    \n  Lemma restrict_in_find:\n    forall {A} (m: t A) d e,\n      List.In e d -> find e (restrict m d) = find e m.\n  Proof.\n    mintros; rewrite restrict_find.\n    destruct (in_dec E.eq_dec e d); auto.\n    elim n; auto.\n  Qed.\n\n  Lemma restrict_union:\n    forall {A} (m1 m2: t A) d,\n      restrict (union m1 m2) d = union (restrict m1 d) (restrict m2 d).\n  Proof.\n    mintros; ext y.\n    repeat (rewrite restrict_find || rewrite find_union).\n    destruct (in_dec E.eq_dec y d); auto.\n  Qed.\n\n  Lemma restrict_idempotent:\n    forall {A} (m: t A) d,\n      restrict (restrict m d) d = restrict m d.\n  Proof.\n    mintros; ext y.\n    repeat rewrite restrict_find.\n    destruct (in_dec E.eq_dec y d); auto.\n  Qed.\n\n  Lemma restrict_EquivList:\n    forall {A} (m: t A) d1 d2,\n      EquivList d1 d2 ->\n      restrict m d1 = restrict m d2.\n  Proof.\n    mintros; ext y.\n    repeat rewrite restrict_find.\n    destruct (in_dec E.eq_dec y d1), (in_dec E.eq_dec y d2); auto;\n      try (elim n; apply H; auto).\n  Qed.\n\n  Lemma restrict_subtractKV:\n    forall {A} deceqA (m1 m2: t A) d,\n      restrict (subtractKV deceqA m1 m2) d =\n      subtractKV deceqA (restrict m1 d) (restrict m2 d).\n  Proof.\n    mintros; ext y.\n    rewrite restrict_find; destruct (in_dec P.F.eq_dec y d).\n    - rewrite 2! subtractKV_find.\n      rewrite 2! restrict_find.\n      destruct (in_dec P.F.eq_dec y d); [|elim n; auto].\n      reflexivity.\n    - rewrite subtractKV_find.\n      rewrite 2! restrict_find.\n      destruct (in_dec P.F.eq_dec y d); [elim n; auto|].\n      reflexivity.\n  Qed.\n\n  Lemma restrict_subtractKV_empty:\n    forall {A} deceqA (m: t A) d,\n      subtractKV deceqA (restrict m d) m = M.empty _.\n  Proof.\n    mintros; ext y.\n    rewrite subtractKV_find.\n    rewrite restrict_find.\n    destruct (in_dec F.P.F.eq_dec y d); [|rewrite find_empty; reflexivity].\n    destruct (M.find y m); [|rewrite find_empty; reflexivity].\n    destruct (deceqA a a); [|elim n; auto].\n    rewrite find_empty; reflexivity.\n  Qed.\n\n  Lemma transpose_neqkey_complement:\n    forall {A} d,\n      P.transpose_neqkey\n        eq\n        (fun (k : key) (v0 : A) (m' : t A) =>\n           if in_dec P.F.eq_dec k d then m' else add k v0 m').\n  Proof.\n    unfold P.transpose_neqkey; intros.\n    destruct (in_dec E.eq_dec k d), (in_dec E.eq_dec k' d); auto.\n    apply add_comm; auto.\n  Qed.\n  #[global] Hint Immediate transpose_neqkey_complement.\n\n  Lemma complement_find:\n    forall {A} d (m: t A) k,\n      find k (complement m d) =\n      if in_dec E.eq_dec k d then None else find k m.\n  Proof.\n    mintros; unfold complement; mind m.\n    - rewrite P.fold_Empty; auto.\n      rewrite find_empty.\n      destruct (in_dec _ _ _); auto.\n    - cmp k k0.\n      + rewrite P.fold_add with (eqA:= eq); auto.\n        destruct (in_dec E.eq_dec k0 d); auto.\n        do 2 rewrite find_add_1; auto.\n      + rewrite P.fold_add with (eqA:= eq); auto.\n        destruct (in_dec E.eq_dec k0 d).\n        * rewrite find_add_2 by auto; auto.\n        * do 2 rewrite find_add_2 by auto; auto.\n  Qed.\n\n  Lemma complement_nil:\n    forall {A} (m: t A),\n      complement m nil = m.\n  Proof.\n    mintros; ext y.\n    rewrite complement_find.\n    destruct (in_dec P.F.eq_dec y nil); auto.\n    inv i.\n  Qed.\n\n  Lemma complement_empty:\n    forall A d,\n      complement (empty A) d = empty A.\n  Proof.\n    intros.\n    ext y.\n    rewrite complement_find.\n    rewrite find_empty.\n    destruct (in_dec P.F.eq_dec y d); intuition.\n  Qed.\n\n  Lemma complement_EquivList:\n    forall {A} (m: t A) d1 d2,\n      EquivList d1 d2 ->\n      complement m d1 = complement m d2.\n  Proof.\n    mintros; ext y.\n    repeat rewrite complement_find.\n    destruct (in_dec E.eq_dec y d1), (in_dec E.eq_dec y d2); auto;\n      try (elim n; apply H; auto).\n  Qed.\n\n  Lemma complement_add_not_in A (m: t A) d:\n    forall k v,\n      ~ List.In k d ->\n      add k v (complement m d) = complement (add k v m) d.\n  Proof.\n    intros; ext y.\n    rewrite complement_find.\n    destruct (in_dec P.F.eq_dec y d).\n    - cmp k y; intuition.\n      rewrite find_add_2 by auto.\n      rewrite complement_find.\n      destruct (in_dec P.F.eq_dec y d); intuition.\n    - cmp k y.\n      + rewrite 2! find_add_1; auto.\n      + rewrite 2! find_add_2 by auto.\n        rewrite complement_find.\n        destruct (in_dec P.F.eq_dec y d); intuition.\n  Qed.\n\n  Lemma complement_add_in A (m: t A) d:\n    forall k v,\n      List.In k d ->\n      complement (add k v m) d = complement m d.\n  Proof.\n    intros; ext y.\n    rewrite 2! complement_find.\n    destruct (in_dec P.F.eq_dec y d); auto.\n    cmp k y; intuition.\n    rewrite find_add_2 by auto; auto.\n  Qed.\n\n  Lemma complement_union:\n    forall {A} (m1 m2: t A) d,\n      complement (union m1 m2) d = union (complement m1 d) (complement m2 d).\n  Proof.\n    mintros; ext y.\n    repeat (rewrite complement_find || rewrite find_union).\n    destruct (in_dec E.eq_dec y d); auto.\n  Qed.\n\n  Lemma complement_idempotent:\n    forall {A} (m: t A) d,\n      complement (complement m d) d = complement m d.\n  Proof.\n    mintros; ext y.\n    repeat rewrite complement_find.\n    destruct (in_dec E.eq_dec y d); auto.\n  Qed.\n\n  Lemma complement_subtractKV:\n    forall {A} deceqA (m1 m2: t A) d,\n      complement (subtractKV deceqA m1 m2) d =\n      subtractKV deceqA (complement m1 d) (complement m2 d).\n  Proof.\n    mintros; ext y.\n    rewrite complement_find; destruct (in_dec P.F.eq_dec y d).\n    - rewrite subtractKV_find.\n      rewrite 2! complement_find.\n      destruct (in_dec P.F.eq_dec y d); [|elim n; auto].\n      reflexivity.\n    - rewrite 2! subtractKV_find.\n      rewrite 2! complement_find.\n      destruct (in_dec P.F.eq_dec y d); [elim n; auto|].\n      reflexivity.\n  Qed.\n\n  Lemma restrict_complement_union:\n    forall {A} (m: t A) d,\n      m = union (restrict m d) (complement m d).\n  Proof.\n    mintros; ext y.\n    rewrite find_union, restrict_find, complement_find.\n    destruct (in_dec P.F.eq_dec y d); auto.\n    destruct (find y m); auto.\n  Qed.\n\n  Lemma complement_restrict_subtractKV:\n    forall {A} deceqA (m: t A) d,\n      subtractKV deceqA m (restrict m d) = complement m d.\n  Proof.\n    mintros; ext y.\n    rewrite subtractKV_find, complement_find, restrict_find.\n    destruct (in_dec P.F.eq_dec y d).\n    { destruct (M.find y m); auto.\n      destruct (deceqA a a); auto.\n      elim n; auto.\n    }\n    { destruct (M.find y m); auto. }\n  Qed.\n\n  Lemma union_idempotent {A : Type} : forall (m : t A), union m m = m.\n  Proof. \n    intros. apply union_smothered. unfold Sub. auto.\n  Qed.\n\n  Lemma add_empty_neq: forall {A} (m: t A) k v, add k v m <> @empty A.\n  Proof.\n    intros; unfold not; intros H. pose proof (@empty_1 A).\n    rewrite <- H in H0. unfold Empty in H0.\n    eapply H0. apply add_1. reflexivity.\n  Qed.\n\n  Theorem eq_dec {A : Type}\n          (eq_dec_A : forall x y : A, {x = y} + {x <> y })\n          (m1 m2 : t A)\n  : {m1 = m2} + {m1 <> m2}.\n  Proof.\n    pose (cmp := fun x y => if eq_dec_A x y then true else false).\n    pose proof (P.F.Equal_Equivb_eqdec eq_dec_A).\n    destruct (equal cmp m1 m2) eqn:eqtest; [left | right].\n    - apply equal_2 in eqtest.\n      apply leibniz. apply H. assumption.\n    - unfold not. intros contra. induction contra.\n      assert (equal cmp m1 m1 = true).\n      apply equal_1.\n      apply H. apply P.F.Equal_refl. rewrite H0 in eqtest.\n      inversion eqtest.\n  Qed.\n\n  Lemma in_union_L A: forall (m: t A) k, M.In k m -> forall m', In k (union m m').\n  Proof.\n    intros m.\n    mind m.\n    - apply P.F.empty_in_iff in H; intuition.\n    - rewrite union_add.\n      apply P.F.add_in_iff.\n      apply P.F.add_in_iff in H1.\n      destruct H1; intuition.\n  Qed.\n\n  Lemma in_union_R A: forall (m' m: t A) k, M.In k m -> In k (union m' m).\n  Proof.\n    intros m'.\n    mind m'.\n    - rewrite union_empty_L; intuition.\n    - rewrite union_add.\n      apply P.F.add_in_iff.\n      intuition.\n  Qed.\n\n  Lemma union_In {A} : forall {m m' : t A} k, In k (union m m') -> In k m \\/ In k m'.\n  Proof. \n    intros m. pattern m.\n    apply map_induction; simpl; intros.\n    - rewrite union_empty_L in H. right. assumption.\n    - rewrite union_add in H1 by assumption.\n      rewrite P.F.add_in_iff in H1. destruct H1.\n      subst. left. rewrite P.F.add_in_iff. left. reflexivity.\n      specialize (H m' k0 H1). destruct H; [left | right].\n      rewrite P.F.add_in_iff. right. assumption. assumption.\n  Qed.\n\n  Definition Disj {A} (m m' : t A) := forall k, ~ In k m \\/ ~ In k m'.\n  Definition DomainSubset {A B} (s1: t A) (s2: t B) := forall k, In k s1 -> In k s2.\n\n  Definition KeysSubset {A} (m: t A) (d: list E.t) := forall k, In k m -> List.In k d.\n  Definition KeysSupset {A} (m: t A) (d: list E.t) := forall k, List.In k d -> In k m.\n  Definition KeysDisj {A} (m: t A) (d: list E.t) := forall k, List.In k d -> ~ In k m.\n  Definition KeysEq {A} (m: t A) (d: list E.t) := forall k, In k m <-> List.In k d.\n\n  #[global] Hint Unfold Equal Disj Sub DomainSubset KeysSubset KeysSupset KeysDisj KeysEq : MapDefs.\n\n  Lemma Sub_union_2:\n    forall {A} (m1 m2: t A), Disj m1 m2 -> Sub m2 (union m1 m2).\n  Proof.\n    mintros; rewrite find_union.\n    remember (find k m1) as okv; destruct okv; auto.\n    destruct (H k).\n    - elim H1; apply P.F.in_find_iff; rewrite <-Heqokv; discriminate.\n    - elim H1; apply P.F.in_find_iff; rewrite H0; discriminate.\n  Qed.\n\n  Lemma DomainSubset_Disj:\n    forall {A} (m1 m2 m3: t A),\n      Disj m2 m3 -> DomainSubset m1 m2 -> Disj m1 m3.\n  Proof.\n    mintros.\n    specialize (H k); specialize (H0 k).\n    destruct H; auto.\n  Qed.\n\n  Lemma restrict_DomainSubset:\n    forall {A} (m: t A) d,\n      DomainSubset (restrict m d) m.\n  Proof.\n    mintros.\n    apply P.F.in_find_iff; apply P.F.in_find_iff in H.\n    rewrite restrict_find in H.\n    destruct (in_dec P.F.eq_dec k d); auto.\n  Qed.\n\n  Lemma complement_DomainSubset:\n    forall {A} (m: t A) d,\n      DomainSubset (complement m d) m.\n  Proof.\n    mintros.\n    apply P.F.in_find_iff; apply P.F.in_find_iff in H.\n    rewrite complement_find in H.\n    destruct (in_dec P.F.eq_dec k d); auto.\n  Qed.\n\n  Lemma find_KeysSubset {A} :\n    forall {m : t A} k d, KeysSubset m d -> ~ List.In k d -> find k m = None.\n  Proof.\n    mintros; specialize (H k).\n    remember (find k m) as v; destruct v; [|reflexivity].\n    elim H0; apply H; apply P.F.in_find_iff; rewrite <-Heqv; discriminate.\n  Qed.\n    \n  Lemma KeysSubset_empty:\n    forall {A} d, KeysSubset (empty A) d.\n  Proof.\n    mintros; inv H; exfalso; eapply P.F.empty_mapsto_iff; eauto.\n  Qed.\n\n  Lemma KeysSubset_nil:\n    forall {A} m, KeysSubset m nil -> m = M.empty A.\n  Proof.\n    mintros; ext y.\n    rewrite find_empty.\n    apply P.F.not_find_in_iff; intro Hx.\n    specialize (H y Hx); inv H.\n  Qed.\n\n  Lemma KeysSubset_cons:\n    forall {A} (m: t A) a d, KeysSubset m d -> KeysSubset m (a :: d).\n  Proof. mintros; specialize (H k); right; auto. Qed.\n\n  Lemma KeysSubset_find_None:\n    forall {A} (m: t A) k d,\n      KeysSubset m (k :: d) -> find k m = None -> KeysSubset m d.\n  Proof.\n    mintros; specialize (H k0).\n    cmp k k0.\n    - apply P.F.in_find_iff in H1; intuition auto.\n    - specialize (H H1); inv H; auto.\n      elim n; reflexivity.\n  Qed.\n  \n  Lemma KeysSubset_add:\n    forall {A} (m: t A) k v d,\n      KeysSubset m d -> List.In k d -> KeysSubset (add k v m) d.\n  Proof.\n    mintros.\n    apply P.F.add_in_iff in H1. destruct H1.\n    subst. assumption. auto.\n  Qed.\n\n  Lemma KeysSubset_add_1:\n    forall {A} (m: t A) k v d,\n      KeysSubset (add k v m) d -> KeysSubset m d.\n  Proof.\n    mintros; apply H; apply P.F.add_in_iff; auto.\n  Qed.\n\n  Lemma KeysSubset_add_2:\n    forall {A} (m: t A) k v d,\n      KeysSubset (add k v m) d -> List.In k d.\n  Proof.\n    mintros; apply H; apply P.F.add_in_iff; auto.\n  Qed.\n\n  Lemma KeysSubset_remove:\n    forall {A} (m: t A) k d,\n      KeysSubset m (k :: d) -> KeysSubset (remove k m) d.\n  Proof.\n    mintros; specialize (H k0).\n    cmp k k0.\n    - elim (@remove_1 _ m k0 k0 eq_refl); auto.\n    - apply P.F.remove_neq_in_iff in H0; auto.\n      specialize (H H0); inv H; auto.\n      elim n; reflexivity.\n  Qed.\n\n  Lemma KeysSubset_union:\n    forall {A} (m1 m2: t A) (d: list E.t),\n      KeysSubset m1 d -> KeysSubset m2 d -> KeysSubset (union m1 m2) d.\n  Proof.\n    mintros; specialize (H k); specialize (H0 k); case_eq (find k m2); intros.\n    - apply H0. exists a. apply find_2. assumption.\n    - destruct H1. apply find_1 in H1. rewrite find_union in H1.\n      case_eq (find k m1); intros.\n      apply H. exists a. apply find_2. assumption.\n      apply H0. rewrite H3 in H1. exists x. apply find_2. assumption.\n  Qed.\n\n  Lemma KeysSubset_union_app:\n    forall {A} (m1 m2: t A) (d1 d2: list E.t),\n      KeysSubset m1 d1 -> KeysSubset m2 d2 -> KeysSubset (union m1 m2) (d1 ++ d2).\n  Proof.\n    mintros; specialize (H k); specialize (H0 k); apply in_or_app.\n    apply union_In in H1; destruct H1; intuition.\n  Qed.\n\n  Lemma KeysSubset_SubList:\n    forall {A} (m: t A) (d1 d2: list E.t),\n      KeysSubset m d1 -> SubList d1 d2 -> KeysSubset m d2.\n  Proof. mintros; apply H0, H; auto. Qed.\n\n  Lemma KeysSubset_elements:\n    forall {A} (m: t A) (d: list E.t),\n      KeysSubset m d -> SubList (List.map (fun e => fst e) (elements m)) d.\n  Proof.\n    unfold SubList; mintros.\n    apply H; rewrite P.F.elements_in_iff.\n    apply in_map_iff in H0; dest.\n    destruct x; simpl in *; subst.\n    exists a.\n    apply In_InA; auto.\n    apply P.eqke_equiv.\n  Qed.\n\n  Lemma KeysDisj_empty:\n    forall {A} d, KeysDisj (empty A) d.\n  Proof.\n    mintros; auto; intro.\n    eapply P.F.empty_in_iff; eauto.\n  Qed.\n  \n  Lemma KeysDisj_nil A (x: t A):\n    KeysDisj x nil.\n  Proof.\n    unfold KeysDisj.\n    unfold not; intros.\n    intuition.\n  Qed.\n\n  Lemma KeysDisj_app A (x: t A):\n    forall d1 d2, KeysDisj x d1 -> KeysDisj x d2 -> KeysDisj x (d1 ++ d2).\n  Proof.\n    mintros; apply in_app_or in H1; destruct H1; firstorder.\n  Qed.\n\n  Lemma KeysDisj_add:\n    forall {A} k v (m: t A) d,\n      KeysDisj m d -> ~ List.In k d -> KeysDisj (add k v m) d.\n  Proof.\n    mintros; auto; intro.\n    apply P.F.add_in_iff in H2; destruct H2; subst.\n    - elim H0; auto.\n    - elim (H k0 H1); auto.\n  Qed.\n\n  Lemma KeysDisj_union:\n    forall {A} (m1 m2: t A) d,\n      KeysDisj m1 d -> KeysDisj m2 d -> KeysDisj (union m1 m2) d.\n  Proof.\n    mintros.\n    specialize (H _ H1); specialize (H0 _ H1).\n    apply P.F.not_find_in_iff.\n    apply P.F.not_find_in_iff in H.\n    apply P.F.not_find_in_iff in H0.\n    rewrite find_union.\n    destruct (find k m1); auto.\n  Qed.\n\n  Lemma KeysDisj_union_1:\n    forall {A} (m1 m2: t A) d, KeysDisj (union m1 m2) d -> KeysDisj m1 d.\n  Proof.\n    mintros; specialize (H _ H0).\n    apply P.F.not_find_in_iff; apply P.F.not_find_in_iff in H.\n    rewrite find_union in H; destruct (find k m1); auto.\n  Qed.\n\n  Lemma KeysDisj_union_2:\n    forall {A} (m1 m2: t A) d, KeysDisj (union m1 m2) d -> KeysDisj m2 d.\n  Proof.\n    mintros; specialize (H _ H0).\n    apply P.F.not_find_in_iff; apply P.F.not_find_in_iff in H.\n    rewrite find_union in H; destruct (find k m1); auto; inv H.\n  Qed.\n\n  Lemma KeysDisj_SubList:\n    forall {A} (m: t A) (d1 d2: list E.t),\n      KeysDisj m d1 -> SubList d2 d1 -> KeysDisj m d2.\n  Proof. mintros; auto. Qed.\n\n  Lemma KeysSubset_Sub:\n    forall {A} (m1 m2: t A) (d: list E.t),\n      KeysSubset m2 d -> Sub m1 m2 -> KeysSubset m1 d.\n  Proof.\n    mintros.\n    apply H.\n    apply P.F.in_find_iff in H1; apply P.F.in_find_iff.\n    specialize (H0 k); destruct (find k m1); [|elim H1; auto].\n    specialize (H0 a eq_refl); rewrite H0; discriminate.\n  Qed.\n\n  Lemma DisjList_KeysSubset_Disj:\n    forall {A} (m1 m2: t A) (d1 d2: list E.t),\n      DisjList d1 d2 -> KeysSubset m1 d1 -> KeysSubset m2 d2 -> Disj m1 m2.\n  Proof.\n    mintros; unfold DisjList in H.\n    specialize (H k).\n    remember (M.find k m1) as ov; destruct ov.\n    - right.\n      assert (In k m1) by (apply P.F.in_find_iff; rewrite <-Heqov; discriminate).\n      specialize (H0 _ H2).\n      inv H; intuition.\n    - left.\n      inv H; intuition.\n      specialize (H0 _ H).\n      apply eq_sym, P.F.not_find_in_iff in Heqov; intuition.\n  Qed.\n\n  Lemma subtractKV_KeysDisj_1:\n    forall {A} deceqA (m1 m2: t A) d,\n      KeysDisj m1 d -> KeysDisj (subtractKV deceqA m1 m2) d.\n  Proof.\n    mintros.\n    specialize (H k H0).\n    rewrite P.F.not_find_in_iff in *.\n    rewrite subtractKV_find; rewrite H; auto.\n  Qed.\n\n  Lemma subtractKV_KeysDisj_2:\n    forall {A} deceqA (m1 m2: t A) d,\n      (forall k, List.In k d -> find k m1 <> None -> find k m1 = find k m2) ->\n      KeysDisj (subtractKV deceqA m1 m2) d.\n  Proof.\n    mintros.\n    specialize (H k H0).\n    rewrite P.F.not_find_in_iff.\n    rewrite subtractKV_find.\n    destruct (find k m1); auto.\n    rewrite <-H by discriminate.\n    destruct (deceqA _ _); intuition.\n  Qed.\n\n  Lemma subtractKV_KeysDisj_cases:\n    forall {A} deceqA (m1 m2: t A) d,\n      KeysDisj (subtractKV deceqA m1 m2) d ->\n      forall k v, List.In k d -> find k m1 = Some v -> find k m2 = Some v.\n  Proof.\n    unfold KeysDisj; intros.\n    specialize (H _ H0).\n    apply F.P.F.not_find_in_iff in H.\n    rewrite subtractKV_find in H.\n    rewrite H1 in H.\n    destruct (M.find k m2).\n    - destruct (deceqA v a); subst; auto.\n      inv H.\n    - inv H.\n  Qed.\n\n  Lemma subtractKV_disj_1:\n    forall {A} deceqA (m1 m2 m3: t A),\n      Disj m1 m2 -> Disj (subtractKV deceqA m1 m3) m2.\n  Proof.\n    mintros.\n    specialize (H k); destruct H; auto.\n    left; rewrite P.F.not_find_in_iff in *.\n    rewrite subtractKV_find; rewrite H; auto.\n  Qed.\n\n  Lemma subtractKV_disj_2:\n    forall {A} deceqA (m1 m2 m3: t A),\n      Disj m1 m2 -> Disj m1 (subtractKV deceqA m2 m3).\n  Proof.\n    mintros.\n    specialize (H k); destruct H; auto.\n    right; rewrite P.F.not_find_in_iff in *.\n    rewrite subtractKV_find; rewrite H; auto.\n  Qed.\n\n  Lemma subtractKV_disj_invalid:\n    forall {A} deceqA (m1 m2: t A),\n      Disj m1 m2 -> subtractKV deceqA m1 m2 = m1.\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    do 2 rewrite P.F.not_find_in_iff in H.\n    rewrite subtractKV_find.\n    destruct (find y m1); auto.\n    destruct (find y m2); auto.\n    inv H; discriminate.\n  Qed.\n\n  Lemma subtractKV_disj_union_1:\n    forall {A} deceqA (m1 m2 m: t A),\n      Disj m1 m2 ->\n      subtractKV deceqA (union m1 m2) m =\n      union (subtractKV deceqA m1 m) (subtractKV deceqA m2 m).\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    do 2 rewrite P.F.not_find_in_iff in H.\n    repeat (rewrite subtractKV_find || rewrite find_union).\n    destruct (find y m1); auto.\n    destruct (find y m); auto.\n    destruct (deceqA a a0); auto.\n    destruct (find y m2); auto.\n    inv H; inv H0.\n  Qed.\n\n  Lemma subtractKV_disj_union_2:\n    forall {A} deceqA (m m1 m2: t A),\n      Disj m1 m2 ->\n      subtractKV deceqA m (union m1 m2) =\n      subtractKV deceqA (subtractKV deceqA m m1) m2.\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    do 2 rewrite P.F.not_find_in_iff in H.\n    repeat (rewrite subtractKV_find || rewrite find_union).\n    destruct (find y m); auto.\n    destruct (find y m1); auto.\n    destruct (deceqA a a0); auto.\n    destruct (find y m2); auto.\n    inv H; inv H0.\n  Qed.\n\n  Lemma subtractKV_disj_union_3:\n    forall {A} (deceqA : forall x y : A, {x = y} + {x <> y})\n           (m1 m2 m : t A),\n      Disj m1 m ->\n      subtractKV deceqA (union m1 m2) m = union m1 (subtractKV deceqA m2 m).\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    rewrite 2! P.F.in_find_iff in H.\n    repeat (rewrite subtractKV_find || rewrite find_union).\n    destruct (find y m1), (find y m); intuition;\n      try (elim H0; intros; inv H).\n  Qed.\n\n  Lemma subtractKV_disj_union_4:\n    forall {A} (deceqA : forall x y : A, {x = y} + {x <> y})\n           (m1 m2 m : t A),\n      Disj m2 m ->\n      subtractKV deceqA (union m1 m2) m = union (subtractKV deceqA m1 m) m2.\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    rewrite 2! P.F.in_find_iff in H.\n    repeat (rewrite subtractKV_find || rewrite find_union).\n    destruct (find y m1), (find y m), (find y m2); auto.\n    - destruct H; elim H; discriminate.\n    - destruct (deceqA a a0); auto.\n    - destruct H; elim H; discriminate.\n  Qed.\n\n  Lemma subtractKV_disj_union_5:\n    forall {A} deceqA (m m1 m2: t A),\n      Disj m m1 ->\n      subtractKV deceqA m (union m1 m2) =\n      subtractKV deceqA m m2.\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    rewrite 2! P.F.in_find_iff in H.\n    repeat (rewrite subtractKV_find || rewrite find_union).\n    destruct (find y m), (find y m1); auto.\n    destruct H; elim H; discriminate.\n  Qed.\n\n  Lemma subtractKV_disj_union_6:\n    forall {A} deceqA (m m1 m2: t A),\n      Disj m m2 ->\n      subtractKV deceqA m (union m1 m2) =\n      subtractKV deceqA m m1.\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    rewrite 2! P.F.in_find_iff in H.\n    repeat (rewrite subtractKV_find || rewrite find_union).\n    destruct (find y m), (find y m1), (find y m2); auto.\n    destruct H; elim H; discriminate.\n  Qed.\n\n  Lemma subtractKV_disj_union_7:\n    forall {A} deceqA (m m1 m2: t A),\n      Disj m1 m2 ->\n      subtractKV deceqA m (union m1 m2) =\n      subtractKV deceqA m (union m2 m1).\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    rewrite 2! P.F.in_find_iff in H.\n    repeat (rewrite subtractKV_find || rewrite find_union).\n    destruct (find y m), (find y m1), (find y m2); auto.\n    destruct H; elim H; discriminate.\n  Qed.\n    \n  Lemma subtractKV_subtractKVD_1:\n    forall {A} (deceqA : forall x y : A, sumbool (x = y) (x <> y))\n           (m1 m2: t A) dom,\n      KeysSubset m1 dom ->\n      subtractKV deceqA m1 m2 = subtractKVD deceqA m1 m2 dom.\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    rewrite P.F.in_find_iff in H.\n    rewrite subtractKV_find, subtractKVD_find.\n    destruct (find y m1); auto.\n    destruct (in_dec E.eq_dec y dom); auto.\n    elim n; apply H; discriminate.\n  Qed.\n\n  Lemma subtractKV_subtractKVD_2:\n    forall {A} (deceqA : forall x y : A, sumbool (x = y) (x <> y))\n           (m1 m2: t A) dom,\n      KeysSubset m2 dom ->\n      subtractKV deceqA m1 m2 = subtractKVD deceqA m1 m2 dom.\n  Proof.\n    mintros; ext y.\n    specialize (H y).\n    rewrite P.F.in_find_iff in H.\n    rewrite subtractKV_find, subtractKVD_find.\n    destruct (find y m1); auto.\n    destruct (find y m2).\n    - destruct (in_dec E.eq_dec y dom); auto.\n      elim n; apply H; discriminate.\n    - destruct (in_dec E.eq_dec y dom); auto.\n  Qed.\n\n  Lemma Disj_empty_1: forall {A} (m: t A), Disj (empty A) m.\n  Proof.\n    mintros; left; intro.\n    apply (proj1 (P.F.empty_in_iff A k)); auto.\n  Qed.\n\n  Lemma Disj_empty_2: forall {A} (m: t A), Disj m (empty A).\n  Proof.\n    mintros; right; intro.\n    apply (proj1 (P.F.empty_in_iff A k)); auto.\n  Qed.\n\n  Lemma Disj_find_union_1:\n    forall {A} (m1 m2: t A) k v,\n      Disj m1 m2 -> find k m1 = Some v ->\n      find k (union m1 m2) = Some v.\n  Proof. mintros; rewrite find_union; rewrite H0; reflexivity. Qed.\n\n  Lemma Disj_find_union_2:\n    forall {A} (m1 m2: t A) k v,\n      Disj m1 m2 -> find k m2 = Some v ->\n      find k (union m1 m2) = Some v.\n  Proof.\n    mintros; rewrite find_union; rewrite H0.\n    remember (find k m1) as v1; destruct v1; [|reflexivity].\n    exfalso; specialize (H k); inv H.\n    - elim H1; apply P.F.in_find_iff.\n      rewrite <-Heqv1; discriminate.\n    - elim H1; apply P.F.in_find_iff.\n      rewrite H0; discriminate.\n  Qed.\n\n  Lemma Disj_find_union_3:\n    forall {A} (m1 m2: t A) k v1 v2,\n      Disj m1 m2 -> Some v1 = find k m1 -> Some v2 = find k m2 -> False.\n  Proof.\n    mintros; specialize (H k); destruct H.\n    - elim H; apply P.F.in_find_iff; rewrite <-H0; discriminate.\n    - elim H; apply P.F.in_find_iff; rewrite <-H1; discriminate.\n  Qed.\n\n  Lemma Disj_Sub:\n    forall {A} (m1 m2 m3: t A),\n      Disj m2 m3 -> Sub m1 m2 -> Disj m1 m3.\n  Proof.\n    mintros.\n    specialize (H k); specialize (H0 k).\n    destruct H; auto.\n    left; rewrite P.F.not_find_in_iff in *.\n    destruct (find k m1); auto.\n    elim H0; auto.\n  Qed.\n\n  Lemma Disj_add_1 {A}:\n    forall {m m' : t A} k v,\n      Disj m m' -> ~ In k m' -> Disj (add k v m) m'.\n  Proof. \n    intros. unfold Disj in *.\n    intros. destruct (H k0).\n    - cmp k k0.\n      + right; assumption.\n      + left; rewrite P.F.add_in_iff; intuition.\n    - right; assumption.\n  Qed.\n\n  Lemma Disj_add_2 {A}:\n    forall {m m' : t A} k v,\n      Disj (add k v m) m' -> Disj m m' /\\ ~ In k m'.\n  Proof. \n    intros. unfold Disj in *.\n    split.\n    - intros. destruct (H k0).\n      rewrite P.F.add_in_iff in H0. intuition.\n      right.  assumption.\n    - specialize (H k). destruct H.\n      rewrite P.F.add_in_iff in H. intuition. assumption.\n  Qed.\n\n  Lemma Disj_comm {A} : forall {m m' : t A}, Disj m m' -> Disj m' m.\n  Proof. \n    intros. unfold Disj in *. intros k.\n    specialize (H k). intuition.\n  Qed.\n\n  Lemma Disj_remove_1 {A}:\n    forall (m1 m2: t A) k,\n      Disj m1 m2 -> Disj (remove k m1) m2.\n  Proof.\n    mintros; specialize (H k0); destruct H; [left|right]; intro Hx; auto.\n    elim H; apply (proj1 (P.F.remove_in_iff _ k _)); auto.\n  Qed.\n\n  Lemma Disj_remove_2 {A}:\n    forall (m1 m2: t A) k,\n      Disj m1 m2 -> Disj m1 (remove k m2).\n  Proof. intros; apply Disj_comm, Disj_remove_1, Disj_comm; auto. Qed.\n\n  Lemma Disj_union_1 {A}:\n    forall {m m1 m2 : t A},\n      Disj m (union m1 m2) -> Disj m m1.\n  Proof.\n    intros m m1 m2. pattern m1. apply map_induction; simpl; intros.\n    - unfold Disj. intros. right. rewrite P.F.empty_in_iff.\n      intuition.\n    - rewrite union_add in H1 by assumption. apply Disj_comm in H1. \n      apply Disj_add_2 in H1. destruct H1. apply Disj_comm in H1.\n      specialize (H H1). apply Disj_comm. apply Disj_add_1.\n      apply Disj_comm. assumption.\n      assumption.\n  Qed.\n\n  Lemma Disj_union_2 {A}:\n    forall {m m1 m2 : t A}\n    , Disj m (union m1 m2) -> Disj m m2.\n  Proof.\n    intros m m1 m2. pattern m1. apply map_induction; simpl; intros.\n    - rewrite union_empty_L in H. assumption. \n    - apply H. rewrite union_add in H1 by assumption.\n      apply Disj_comm in H1.\n      apply Disj_add_2 in H1. destruct H1. apply Disj_comm. assumption.\n  Qed.\n\n  Lemma Disj_union {A}:\n    forall {m m1 m2 : t A}\n    , Disj m m1 -> Disj m m2 -> Disj m (union m1 m2).\n  Proof.\n    intros. unfold Disj in *.\n    intros k. specialize (H k). specialize (H0 k).\n    intuition. right. intros contra.\n    apply union_In in contra. intuition.\n  Qed.\n\n  Lemma Disj_find_None {A}:\n    forall {m1 m2: t A} k,\n      Disj m1 m2 -> find k m1 = None \\/ find k m2 = None.\n  Proof.\n    intros; autounfold with MapDefs in *.\n    destruct (H k).\n    - left; apply P.F.not_find_in_iff; auto.\n    - right; apply P.F.not_find_in_iff; auto.\n  Qed.\n\n  Lemma union_Disj_reorder {A}:\n    forall (m m1 m2 : M.t A),\n      Disj m1 m2 -> union m2 (union m1 m) = union m1 (union m2 m).\n  Proof.\n    intros; ext k.\n    repeat rewrite find_union.\n    destruct (H k) as [H0 | H0];\n      apply P.F.not_find_in_iff in H0;\n      repeat rewrite H0; reflexivity.\n  Qed.\n\n  Lemma union_assoc {A}:\n    forall (m1 m2 m3: t A)\n    , union m1 (union m2 m3) = union (union m1 m2) m3.\n  Proof.\n    intros; ext y.\n    repeat rewrite find_union. simpl.\n    destruct (find y m1); destruct (find y m2); reflexivity.\n  Qed.\n\n  Lemma union_comm:\n    forall {A} (m1 m2: t A), Disj m1 m2 -> union m1 m2 = union m2 m1.\n  Proof.\n    mintros; mind m1.\n    - rewrite union_empty_L, union_empty_R; reflexivity.\n    - rewrite union_add.\n      assert (forall k, ~ In k m \\/ ~ In k m2).\n      { intros; specialize (H1 k0).\n        cmp k k0.\n        { left; auto. }\n        { destruct H1; [left|right]; auto.\n          intro Hx; elim H1.\n          eapply P.F.add_neq_in_iff in n.\n          eapply n; eauto.\n        }\n      }\n      specialize (H H2); clear H2.\n      specialize (H1 k).\n      destruct H1.\n      + elim H1; apply P.F.add_in_iff; left; auto.\n      + rewrite H; apply leibniz.\n        unfold Equal; intros.\n        apply P.F.not_find_in_iff in H1.\n        cmp y k.\n        * rewrite find_union, H1.\n          find_add_tac.\n        * find_add_tac.\n          do 2 rewrite find_union.\n          destruct (find y m2); find_add_tac; reflexivity.\n  Qed.\n\n  Lemma restrict_KeysSubset:\n    forall {A} (m: t A) d,\n      KeysSubset m d -> restrict m d = m.\n  Proof.\n    mintros; ext y.\n    specialize (H y); rewrite P.F.in_find_iff in H.\n    rewrite restrict_find.\n    destruct (in_dec E.eq_dec y d); auto.\n    destruct (find y m); auto.\n    elim n; apply H; discriminate.\n  Qed.\n\n  Lemma KeysSubset_restrict:\n    forall {A} (m: t A) d, KeysSubset (restrict m d) d.\n  Proof.\n    mintros.\n    apply P.F.in_find_iff in H.\n    rewrite restrict_find in H.\n    destruct (in_dec P.F.eq_dec k d); auto.\n    elim H; auto.\n  Qed.\n\n  Lemma restrict_DisjList:\n    forall {A} (m: t A) d1 d2,\n      KeysSubset m d1 -> DisjList d1 d2 -> restrict m d2 = empty _.\n  Proof.\n    mintros; ext y.\n    specialize (H y); rewrite P.F.in_find_iff in H.\n    rewrite restrict_find, find_empty.\n    destruct (in_dec E.eq_dec y d2); auto.\n    destruct (find y m); auto.\n    specialize (H0 y); destruct H0.\n    - elim H0; apply H; discriminate.\n    - elim H0; auto.\n  Qed.\n\n  Lemma restrict_Disj:\n    forall {A} (m1 m2: t A) d,\n      Disj m1 m2 -> Disj (restrict m1 d) (restrict m2 d).\n  Proof.\n    mintros.\n    rewrite 2! P.F.not_find_in_iff.\n    specialize (H k).\n    rewrite 2! P.F.not_find_in_iff in H.\n    destruct H; [left|right]; rewrite restrict_find; find_if_inside; auto.\n  Qed.\n\n  Lemma complement_KeysSubset:\n    forall {A} (m: t A) d,\n      KeysSubset m d -> complement m d = empty _.\n  Proof.\n    mintros; ext y.\n    specialize (H y); rewrite P.F.in_find_iff in H.\n    rewrite complement_find, find_empty.\n    destruct (in_dec E.eq_dec y d); auto.\n    destruct (find y m); auto.\n    elim n; apply H; discriminate.\n  Qed.\n\n  Lemma complement_DisjList:\n    forall {A} (m: t A) d1 d2,\n      KeysSubset m d1 -> DisjList d1 d2 -> complement m d2 = m.\n  Proof.\n    mintros; ext y.\n    specialize (H y); rewrite P.F.in_find_iff in H.\n    rewrite complement_find.\n    destruct (in_dec E.eq_dec y d2); auto.\n    destruct (find y m); auto.\n    specialize (H0 y); destruct H0.\n    - elim H0; apply H; discriminate.\n    - elim H0; auto.\n  Qed.\n\n  Lemma complement_KeysDisj:\n    forall {A} (m: t A) d, KeysDisj (complement m d) d.\n  Proof.\n    mintros.\n    apply P.F.not_find_in_iff.\n    rewrite complement_find.\n    destruct (in_dec _ k d); auto.\n    elim n; auto.\n  Qed.\n\n  Lemma complement_Disj:\n    forall {A} (m1 m2: t A) d,\n      Disj m1 m2 -> Disj (complement m1 d) (complement m2 d).\n  Proof.\n    mintros.\n    rewrite 2! P.F.not_find_in_iff.\n    specialize (H k).\n    rewrite 2! P.F.not_find_in_iff in H.\n    destruct H; [left|right]; rewrite complement_find; find_if_inside; auto.\n  Qed.\n\n  Lemma restrict_complement_disj:\n    forall {A} (m1 m2: t A) d,\n      Disj (restrict m1 d) (complement m2 d).\n  Proof.\n    mintros.\n    rewrite 2! P.F.not_find_in_iff.\n    rewrite restrict_find, complement_find.\n    destruct (in_dec P.F.eq_dec k d); auto.\n  Qed.\n\n  Lemma KeysSubset_subtractKV:\n    forall {A} (m1 m2: t A) deceqA d,\n      KeysSubset m1 d -> KeysSubset (subtractKV deceqA m1 m2) d.\n  Proof.\n    unfold KeysSubset; intros.\n    apply H; rewrite F.P.F.in_find_iff in *.\n    intro Hx; elim H0; clear H0.\n    rewrite subtractKV_find; rewrite Hx; auto.\n  Qed.\n\n  Lemma DomainSubset_KeysSubset:\n    forall {A} (m1 m2: t A) d,\n      KeysSubset m1 d -> DomainSubset m2 m1 -> KeysSubset m2 d.\n  Proof.\n    unfold KeysSubset, DomainSubset; auto.\n  Qed.\n\nEnd LeibnizFacts.\n\nModule FMapListLeib (UOT : UsualOrderedTypeLTI) <: MapLeibniz.\n  Include (FMapListEq UOT).\n  \n  Theorem leibniz {A : Type} (m m' : t A) : Equal m m' -> m = m'.\n  Proof. apply lt_irrel_leibniz, UOT.lt_irrel. Qed.\nEnd FMapListLeib.\n\nModule String_as_OT' <: UsualOrderedTypeLTI.\n  Include String_as_OT.\n  Lemma lt_irrel : forall (x y : t) (p q : lt x y), p = q.\n  Proof. intros. apply UIP_dec. decide equality. \n  Qed.\nEnd String_as_OT'.\n\nModule M.\n  Module Map := FMapListLeib String_as_OT'.\n  Include Map.\n  Include (LeibnizFacts Map).\nEnd M.\n\n(** FMap Notations *)\n\nDeclare Scope fmap_scope.\nNotation \"'[]'\" := (M.empty _) : fmap_scope.\nNotation \" [ k <- v ] \" := (M.add k%string v (M.empty _)) : fmap_scope.\nNotation \" m +[ k <- v ] \" := (M.add k%string v m) (at level 10) : fmap_scope.\nNotation \" m @[ k ] \" := (M.find k%string m) (at level 10) : fmap_scope.\n\nDelimit Scope fmap_scope with fmap.\n\nLtac dest_disj :=\n  repeat\n    match goal with\n    | [H: M.Disj (M.add _ _ _) _ |- _] =>\n      apply M.Disj_add_2 in H; destruct H\n    | [H: M.Disj _ (M.add _ _ _) |- _] =>\n      apply M.Disj_comm, M.Disj_add_2 in H; destruct H\n    | [H: M.Disj _ (M.union _ _) |- _] =>\n      pose proof (M.Disj_union_1 H); pose proof (M.Disj_union_2 H); clear H\n    | [H: M.Disj (M.union _ _) _ |- _] =>\n      apply M.Disj_comm in H\n    | [H: M.Disj _ (M.empty _) |- _] => clear H\n    | [H: M.Disj (M.empty _) _ |- _] => clear H\n    end.\n\nLtac solve_disj :=\n  repeat\n    (try assumption;\n     match goal with\n     | [ |- M.Disj (M.empty _) _ ] =>\n       apply M.Disj_empty_1\n     | [ |- M.Disj _ (M.empty _) ] =>\n       apply M.Disj_empty_2\n     | [H: M.Disj ?m1 ?m2 |- M.Disj ?m2 ?m1] =>\n       apply M.Disj_comm; auto\n     | [ |- M.Disj (M.add _ _ _) _ ] =>\n       apply M.Disj_add_1; auto\n     | [ |- M.Disj _ (M.add _ _ _) ] =>\n       apply M.Disj_comm, M.Disj_add_1; auto\n     | [ |- M.Disj _ (M.union _ _) ] =>\n       apply M.Disj_union\n     | [ |- M.Disj (M.union _ _) _ ] =>\n       apply M.Disj_comm, M.Disj_union\n     | [ |- M.Disj (M.remove _ _) _ ] =>\n       try (apply M.Disj_remove_1; solve_disj; fail)\n     | [ |- M.Disj _ (M.remove _ _) ] =>\n       try (apply M.Disj_remove_2; solve_disj; fail)\n     end).\n\nLtac dest_in :=\n  repeat\n    match goal with\n    | [H: ~ M.In _ _ |- _] =>\n      apply M.F.P.F.not_find_in_iff in H\n    | [H: M.In _ _ -> False |- _] =>\n      apply M.F.P.F.not_find_in_iff in H\n    | [ |- ~ M.In _ _] =>\n      apply M.F.P.F.not_find_in_iff\n    | [ |- M.In _ _ -> False] =>\n      apply M.F.P.F.not_find_in_iff\n    | [ |- M.In _ _] =>\n      apply M.F.P.F.in_find_iff; intro\n    end.\n\nLtac mred_unit :=\n  match goal with\n  (* basic destruction *)\n  | [H: Some _ = Some _ |- _] => inv H\n  | [H: _ = M.find ?k ?m |- context [M.find ?k ?m] ] =>\n    rewrite <-H\n  | [H1: None = M.find ?k ?m, H2: context [M.find ?k ?m] |- _] =>\n    rewrite <-H1 in H2\n  | [H1: Some _ = M.find ?k ?m, H2: context [M.find ?k ?m] |- _] =>\n    rewrite <-H1 in H2\n  | [ |- context [M.find ?y ?m] ] =>\n    (is_var m;\n     let v := fresh \"v\" in\n     remember (M.find y m) as v; destruct v)\n  (* hypothesis reduction *)\n  | [H: context [M.find _ (M.empty _)] |- _] =>\n    rewrite M.find_empty in H\n  | [H: context [M.union (M.empty _) _] |- _] =>\n    rewrite M.union_empty_L in H\n  | [H: context [M.union _ (M.empty _)] |- _] =>\n    rewrite M.union_empty_R in H\n  | [H: context [M.find _ (M.union _ _)] |- _] =>\n    rewrite M.find_union in H\n  | [H: context [M.find ?k (M.add ?k _ _)] |- _] =>\n    rewrite M.find_add_1 in H\n  | [H: context [M.find ?k1 (M.add ?k2 _ _)] |- _] =>\n    rewrite M.find_add_2 in H by discriminate\n  | [Hk: ?k1 <> ?k2, H: context [M.find ?k1 (M.add ?k2 _ _)] |- _] =>\n    rewrite M.find_add_2 in H by auto\n  | [Hk: ?k1 = ?k2 -> False, H: context [M.find ?k1 (M.add ?k2 _ _)] |- _] =>\n    rewrite M.find_add_2 in H by auto\n  | [H1: In ?y ?d, H2: context [M.find ?y (M.restrict _ ?d)] |- _] =>\n    rewrite M.restrict_in_find in H2 by auto\n  | [H: context [M.find ?y (M.subtractKV _ ?m1 ?m2)] |- _] =>\n    rewrite M.subtractKV_find in H\n  | [H: context [if ?c then _ else _] |- _] =>\n    match type of c with\n    | {_ = _} + {_ <> _} => destruct c; [subst|]\n    end\n  (* goal reduction *)\n  | [ |- context [M.find ?y (M.remove ?k ?m)] ] =>\n    destruct (string_dec y k);\n    [subst; rewrite M.F.P.F.remove_eq_o|\n     rewrite M.F.P.F.remove_neq_o by intuition auto]\n  | [ |- context [M.find _ (M.empty _)] ] =>\n    rewrite M.find_empty\n  | [ |- context [M.union (M.empty _) _] ] =>\n    rewrite M.union_empty_L\n  | [ |- context [M.union _ (M.empty _)] ] =>\n    rewrite M.union_empty_R\n  | [ |- context [M.find ?y (M.union _ _)] ] =>\n    rewrite M.find_union\n  | [ |- context [M.find ?y (M.remove ?y ?m)] ] =>\n    rewrite M.F.P.F.remove_eq_o\n  | [H: ?y <> ?k |- context [M.find ?y (M.remove ?k ?m)] ] =>\n    rewrite M.F.P.F.remove_neq_o by intuition auto\n  | [H: ?k <> ?y |- context [M.find ?y (M.remove ?k ?m)] ] =>\n    rewrite M.F.P.F.remove_neq_o by intuition auto\n  | [H: ?y = ?k -> False |- context [M.find ?y (M.remove ?k ?m)] ] =>\n    rewrite M.F.P.F.remove_neq_o by intuition auto\n  | [H: ?k = ?y -> False |- context [M.find ?y (M.remove ?k ?m)] ] =>\n    rewrite M.F.P.F.remove_neq_o by intuition auto\n  | [ |- context [M.find ?y (M.add ?y _ _)] ] => rewrite M.find_add_1\n  | [ |- context [M.find ?y (M.add ?k _ _)] ] => rewrite M.find_add_2 by discriminate\n  | [H: ?y <> ?k |- context [M.find ?y (M.add ?k _ _)] ] =>\n    rewrite M.find_add_2 by intuition idtac\n  | [H: ?k <> ?y |- context [M.find ?y (M.add ?k _ _)] ] =>\n    rewrite M.find_add_2 by intuition idtac\n  | [H: ?y = ?k -> False |- context [M.find ?y (M.add ?k _ _)] ] =>\n    rewrite M.find_add_2 by intuition idtac\n  | [H: ?k = ?y -> False |- context [M.find ?y (M.add ?k _ _)] ] =>\n    rewrite M.find_add_2 by intuition idtac\n  | [ |- context [M.find ?y (M.add ?k _ _)] ] =>\n    M.cmp y k; [rewrite M.find_add_1|\n                rewrite M.find_add_2 by intuition idtac]\n  | [H: In ?y ?d |- context [M.find ?y (M.restrict _ ?d)] ] =>\n    rewrite M.restrict_in_find by auto\n  | [ |- context [M.find ?y (M.subtractKV _ ?m1 ?m2)] ] =>\n    rewrite M.subtractKV_find\n  | [ |- context [if ?c then _ else _] ] =>\n    match type of c with\n    | {_ = _} + {_ <> _} => destruct c; [subst|]\n    end\n  end;\n  try discriminate; try reflexivity; try (intuition idtac; fail).\n\nLtac mred := repeat mred_unit.\n\nLtac mcontra :=\n  repeat\n    match goal with\n    | [H: M.Disj ?m1' ?m2', Hl: Some _ = M.find ?k ?m1', Hr: Some _ = M.find ?k ?m2' |- _] =>\n      try (exfalso; eapply @M.Disj_find_union_3 with (m1:= m1') (m2:= m2'); eauto; fail)\n    | [H: Some _ = None |- _] => inv H\n    | [H: None = Some _ |- _] => inv H\n    | [H1: None = ?f, H2: Some _ = ?f |- _] => rewrite <-H1 in H2; discriminate\n    | [H1: None = ?f, H2: ?f = Some _ |- _] => rewrite <-H1 in H2; discriminate\n    | [H1: ?f = None, H2: Some _ = ?f |- _] => rewrite H1 in H2; discriminate\n    | [H1: ?f = None, H2: Some _ = ?f |- _] => rewrite <-H1 in H2; discriminate\n    | [H: match ?c with | Some _ => Some _ | None => Some _ end = None |- _] =>\n      destruct c; discriminate\n    | [H: match ?c with | Some _ => None | None => None end = Some _ |- _] =>\n      destruct c; discriminate\n    | [H1: ~ M.In ?k ?m, H2: Some _ = M.find ?k ?m |- _] =>\n      elim H1; apply M.F.P.F.in_find_iff; rewrite <-H2; discriminate\n    end.\n\nLtac findeq := dest_disj; dest_in; mred; mcontra; intuition idtac.\n\nLtac is_new_find y m :=\n  match goal with\n  | [ _: Some _ = M.find y m |- _] => fail 1\n  | [ _: None = M.find y m |- _] => fail 1\n  | [ _: M.find y m = Some _ |- _] => fail 1\n  | [ _: M.find y m = None |- _] => fail 1\n  | _ => idtac\n  end.\n\nLtac dest_find_more :=\n  repeat\n    match goal with\n    | [H: context [M.find ?y ?m] |- _] =>\n      (is_var m; is_new_find y m;\n       let v := fresh \"v\" in\n       remember (M.find y m) as v; destruct v)\n    end.\n\nLtac findeq_custom tac := tac; dest_find_more; mred; mcontra; intuition idtac.\nLtac findeq_more := findeq_custom idtac.\n\nLtac meq := let y := fresh \"y\" in M.ext y; findeq.\nLtac mdisj := mred; dest_disj; solve_disj; try findeq.\n\n#[global] Hint Extern 1 (_ = _) => try (meq; fail).\n#[global] Hint Extern 1 (M.Disj _ _) => try (mdisj; fail).\n\nLemma elements_cons:\n  forall {A} m (k: string) (v: A) l,\n    (k, v) :: l = M.elements m ->\n    exists pm,\n      m = M.add k v pm /\\ M.find k pm = None /\\\n      l = M.elements pm.\nProof.\n  intros.\n  exists (M.remove k m); repeat split.\n  - case_eq (M.find k m); intros.\n    + pose proof H0.\n      rewrite M.F.P.F.elements_o in H0.\n      rewrite <-H in H0.\n      simpl in H0.\n      unfold M.F.P.F.eqb in H0.\n      destruct (M.F.P.F.eq_dec k k); [|elim n; auto].\n      inv H0.\n      meq.\n    + rewrite M.F.P.F.elements_o in H0.\n      rewrite <-H in H0.\n      simpl in H0.\n      unfold M.F.P.F.eqb in H0.\n      destruct (M.F.P.F.eq_dec k k); try discriminate.\n      elim n; auto.\n  - findeq.\n  - unfold M.elements, M.Raw.elements in *.\n    unfold M.remove; simpl.\n    rewrite <-H; simpl.\n    pose proof (@M.F.ME.elim_compare_eq k k eq_refl); dest.\n    rewrite H0; auto.\nQed.\n\nLemma eqlistA_eqke_eq_compat:\n  forall {A} l1 l2,\n    SetoidList.eqlistA (M.F.O.eqke (elt:=A)) l1 l2 ->\n    SetoidList.eqlistA eq l1 l2.\nProof.\n  induction 1; simpl; intros; [constructor|].\n  constructor; auto.\n  destruct x, x'; inv H; simpl in *; subst; auto.\nQed.\n\nSection MakeMap.\n  Variable A: Type.\n  Variable f1 f2: A -> Type.\n  Variable f: forall x, f1 x -> f2 x.\n\n  Fixpoint makeMap (l: list (Attribute (sigT f1))) : M.t (sigT f2) :=\n    match l with\n    | nil => M.empty _\n    | {| attrName := n; attrType := existT _ rv |} :: xs =>\n      M.add n (existT _ _ (f rv)) (makeMap xs)\n    end.\n\n  Lemma makeMap_find:\n    forall l (Hl: NoDup (namesOf l)) k,\n      M.find k (makeMap l) =\n      match getAttribute k l with\n      | None => None\n      | Some {| attrType := existT _ rv |} => Some (existT _ _ (f rv))\n      end.\n  Proof.\n    induction l; simpl; intros; [reflexivity|].\n    destruct a as [an [asig av]]; simpl in *.\n    inv Hl; specialize (IHl H2).\n    remember (string_eq k an) as ka; destruct ka.\n    - apply string_eq_dec_eq in Heqka; subst.\n      rewrite M.find_add_1; auto.\n    - apply string_eq_dec_neq in Heqka.\n      rewrite M.find_add_2; auto.\n  Qed.\n  \n  Lemma makeMap_KeysSubset:\n    forall m, M.KeysSubset (makeMap m) (namesOf m).\n  Proof.\n    induction m; simpl; intros; [apply M.KeysSubset_empty|].\n    destruct a as [an [atype av]]; simpl.\n    apply M.KeysSubset_add; intuition auto with MapDefs datatypes.\n  Qed.\n\n  Lemma makeMap_union:\n    forall m1 m2,\n      DisjList (namesOf m1) (namesOf m2) ->\n      makeMap (m1 ++ m2) = M.union (makeMap m1) (makeMap m2).\n  Proof.\n    induction m1; simpl; intros;\n      [rewrite M.union_empty_L; reflexivity|].\n\n    destruct a as [rn [rk r]].\n    rewrite M.union_add.\n    f_equal.\n    apply IHm1.\n    eapply DisjList_cons; eauto.\n  Qed.\nEnd MakeMap.\n\nInductive MapR {A} : M.t A -> Type :=\n| MRUnknown: forall (m: M.t A), MapR m\n| MREmpty: MapR (M.empty _)\n| MRAdd:\n    forall k v {m},\n      MapR m -> MapR (M.add k v m)\n| MRUnion:\n    forall {m1 m2},\n      MapR m1 -> MapR m2 ->\n      MapR (M.union m1 m2).\n\nFixpoint findMR {A} (k : string) {m} (mr : MapR (A:= A) m): option A :=\n  match mr with\n  | MRUnknown m' => M.find k m'\n  | MREmpty => None\n  | MRAdd k' v _ mr' => if string_eq k k' then Some v else findMR k mr'\n  | MRUnion _ _ mr1 mr2 =>\n    match findMR k mr1 with\n    | Some v => Some v\n    | _ => findMR k mr2\n    end\n  end.\n\nLemma findMR_find:\n  forall {A} k (m: M.t A) (mr: MapR m),\n    findMR k mr = M.find k m.\nProof.\n  induction mr; simpl; intros.\n  - reflexivity.\n  - rewrite M.find_empty; reflexivity.\n  - remember (string_eq k k0) as kb; destruct kb.\n    + apply string_eq_dec_eq in Heqkb; subst.\n      rewrite M.find_add_1; auto.\n    + apply string_eq_dec_neq in Heqkb.\n      rewrite M.find_add_2 by assumption; auto.\n  - rewrite M.find_union.\n    destruct (findMR k mr1).\n    + rewrite <-IHmr1; reflexivity.\n    + rewrite <-IHmr1; auto.\nQed.\n\nLtac mapReify m :=\n  match m with\n  | M.empty ?A => constr:(@MREmpty A)\n  | M.add ?k ?v ?m' =>\n    let mr' := mapReify m' in\n    constr:(MRAdd k v mr')\n  | M.union ?m1 ?m2 =>\n    let mr1 := mapReify m1 in\n    let mr2 := mapReify m2 in\n    constr:(MRUnion mr1 mr2)\n  | _ => constr:(MRUnknown m)\n  end.\n\nLtac findReify :=\n  match goal with\n  | [ |- context[M.find ?k ?m] ] =>\n    tryif is_evar m then idtac\n    else (let rfd := mapReify m in\n          rewrite <-findMR_find with (mr:= rfd))\n  end; unfold findMR;\n  repeat\n    match goal with\n    | [ |- context[string_eq ?s ?s] ] =>\n      rewrite string_eq_true\n    end; cbv [string_eq ascii_eq Bool.eqb andb].\n\n(* NOTE: using f_equal instead of below destructs values also, which may generate\n * subgoals that cannot be proven. In that case, use this reflection. \n *)\nSection FMapRawReflection.\n  Variable A: Type.\n\n  Fixpoint meqReifyRaw (mr1 mr2: list (string * A)) :=\n    match mr1, mr2 with\n    | nil, nil => True\n    | (s1, v1) :: mr1', (s2, v2) :: mr2' =>\n      s1 = s2 /\\ v1 = v2 /\\ meqReifyRaw mr1' mr2'\n    | _, _ => False\n    end.\n\n  Lemma meqReifyRaw_ok: forall mr1 mr2, meqReifyRaw mr1 mr2 -> mr1 = mr2.\n  Proof.\n    induction mr1; simpl; intros.\n    - destruct mr2; intuition idtac.\n    - destruct mr2.\n      + destruct a; intuition idtac.\n      + destruct a, p; dest; subst.\n        f_equal; auto.\n  Qed.\n\nEnd FMapRawReflection.\n\nLtac meqReify_eq_tac := idtac.\n\nLtac meqReify :=\n  simpl; try reflexivity;\n  apply M.elements_eq_leibniz;\n  try reflexivity;\n  simpl; meqReify_eq_tac.\n\nLtac meqReify_eq_tac ::= repeat (unfold M.Raw.key, M.OT.t; f_equal).\nLtac meqReify_eq_tac ::=\n     unfold M.Raw.key, M.OT.t;\napply meqReifyRaw_ok; repeat split; try assumption; try reflexivity.\n\n",
      "theorem": "Lemma SubList_app_7:\n    forall l1 l2 l3, SubList (l1 ++ l2) l3 -> SubList l1 l3 /\\ SubList l2 l3.",
      "ground_truth": "Proof.\n    intros; split.\n    - eapply SubList_app_4; eauto.\n    - eapply SubList_app_5; eauto.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 13,
      "prefix": "Require Import Bool String List Arith.Peano_dec Lia.\nRequire Import Lib.FMap Lib.Struct Lib.CommonTactics Lib.Indexer Lib.StringEq Lib.ListSupport.\nRequire Import Kami.Syntax Kami.Semantics Kami.SemFacts Kami.RefinementFacts Kami.Renaming Kami.Wf.\nRequire Import Kami.Specialize.\n\nRequire Import FunctionalExtensionality.\nRequire Import Compare_dec.\n\nSet Implicit Arguments.\nSet Asymmetric Patterns.\n\nSection Duplicate.\n  Variable m: nat -> Modules.\n\n  Fixpoint duplicate n :=\n    match n with\n    | O => specializeMod (m O) O\n    | S n' => ConcatMod (specializeMod (m n) n) (duplicate n')\n    end.\n\nEnd Duplicate.\n\nSection DuplicateFacts.\n  Variable m: nat -> Modules.\n\n  Lemma duplicate_ModEquiv:\n    forall ty1 ty2 n,\n      (forall iv, ModEquiv ty1 ty2 (m iv)) ->\n      ModEquiv ty1 ty2 (duplicate m n).\n  Proof.\n    induction n; simpl; intros;\n      [apply specializeMod_ModEquiv; auto|].\n    apply ModEquiv_modular; auto.\n    apply specializeMod_ModEquiv; auto.\n  Qed.\n\n  Lemma duplicate_validRegsModules:\n    forall n,\n      (forall iv, ValidRegsModules type (m iv)) ->\n      ValidRegsModules type (duplicate m n).\n  Proof.\n    induction n; simpl; intros.\n    - apply specializeMod_validRegsModules; auto.\n    - split; auto.\n      apply specializeMod_validRegsModules; auto.\n  Qed.\n\n  Lemma duplicate_dom_indexed:\n    (forall iv, Specializable (m iv)) ->\n    forall s n ,\n      In s (spDom (duplicate m n)) ->\n      exists t i, s = t __ i /\\ i < S n.\n  Proof.\n    induction n; simpl; intros.\n    - pose proof (specializeMod_dom_indexed (H 0) _ _ H0); dest; subst.\n      do 2 eexists; eauto.\n    - apply spDom_in in H0; destruct H0.\n      + pose proof (specializeMod_dom_indexed (H (S n)) _ _ H0); dest; subst.\n        do 2 eexists; eauto.\n      + specialize (IHn H0); dest; subst.\n        do 2 eexists; eauto.\n  Qed.\n\n  Lemma duplicate_specializeMod_disj_regs:\n    (forall iv, Specializable (m iv)) ->\n    forall n ln iv,\n      ln > n ->\n      DisjList (namesOf (getRegInits (specializeMod (m iv) ln)))\n               (namesOf (getRegInits (duplicate m n))).\n  Proof.\n    induction n; simpl; intros.\n    - apply specializeMod_disj_regs_different_indices; auto; lia.\n    - unfold namesOf in *.\n      rewrite map_app.\n      apply DisjList_comm, DisjList_app_4.\n      + apply specializeMod_disj_regs_different_indices; auto; lia.\n      + apply DisjList_comm, IHn; lia.\n  Qed.\n\n  Lemma duplicate_specializeMod_disj_defs:\n    (forall iv, Specializable (m iv)) ->\n    forall n ln iv,\n      ln > n ->\n      DisjList (getDefs (specializeMod (m iv) ln))\n               (getDefs (duplicate m n)).\n  Proof.\n    induction n; simpl; intros.\n    - apply specializeMod_disj_defs_different_indices; auto; lia.\n    - apply DisjList_comm.\n      apply DisjList_SubList with\n      (l1:= app (getDefs (specializeMod (m (S n)) (S n)))\n                (getDefs (duplicate m n))).\n      + unfold SubList; intros.\n        apply getDefs_in in H1; destruct H1;\n          apply in_or_app; auto.\n      + apply DisjList_app_4.\n        * apply specializeMod_disj_defs_different_indices; auto; lia.\n        * apply DisjList_comm, IHn; lia.\n  Qed.\n\n  Lemma duplicate_specializeMod_disj_calls:\n    (forall iv, Specializable (m iv)) ->\n    forall n ln iv,\n      ln > n ->\n      DisjList (getCalls (specializeMod (m iv) ln))\n               (getCalls (duplicate m n)).\n  Proof.\n    induction n; simpl; intros.\n    - apply specializeMod_disj_calls_different_indices; auto; lia.\n    - apply DisjList_comm.\n      apply DisjList_SubList with\n      (l1:= app (getCalls (specializeMod (m (S n)) (S n)))\n                (getCalls (duplicate m n))).\n      + unfold SubList; intros.\n        apply getCalls_in in H1; destruct H1;\n          apply in_or_app; auto.\n      + apply DisjList_app_4.\n        * apply specializeMod_disj_calls_different_indices; auto; lia.\n        * apply DisjList_comm, IHn; lia.\n  Qed.\n  \n  Lemma duplicate_disj_regs:\n    forall m1 m2,\n      (forall iv1, Specializable (m1 iv1)) ->\n      (forall iv2, Specializable (m2 iv2)) ->\n      (forall iv1 iv2, DisjList (namesOf (getRegInits (m1 iv1)))\n                                (namesOf (getRegInits (m2 iv2)))) ->\n      forall n,\n        DisjList (namesOf (getRegInits (duplicate m1 n)))\n                 (namesOf (getRegInits (duplicate m2 n))).\n  Proof.\n    induction n; simpl; intros.\n    - apply specializeMod_disj_regs_2; auto.\n    - unfold namesOf; do 2 rewrite map_app; apply DisjList_app_4.\n      + apply DisjList_comm, DisjList_app_4.\n        * apply DisjList_comm, specializeMod_disj_regs_2; auto.\n        * clear IHn.\n          assert (n < S n) by lia.\n          generalize dependent (S n); intros.\n          induction n; simpl; intros.\n          { apply DisjList_comm, specializeMod_disj_regs_2; auto. }\n          { rewrite map_app; apply DisjList_app_4.\n            { apply DisjList_comm, specializeMod_disj_regs_2; auto. }\n            { apply IHn; lia. }\n          }\n      + apply DisjList_comm, DisjList_app_4.\n        * clear IHn.\n          assert (n < S n) by lia.\n          generalize dependent (S n); intros.\n          induction n; simpl; intros.\n          { apply DisjList_comm, specializeMod_disj_regs_2; auto. }\n          { rewrite map_app; apply DisjList_comm, DisjList_app_4.\n            { apply specializeMod_disj_regs_2; auto. }\n            { apply DisjList_comm; auto.\n              apply IHn; lia.\n            }\n          }\n        * apply DisjList_comm, IHn.\n  Qed.\n\n  Lemma duplicate_noninteracting:\n    (forall iv, Specializable (m iv)) ->\n    forall n ln,\n      ln > n ->\n      forall iv,\n        NonInteracting (specializeMod (m iv) ln)\n                       (duplicate m n).\n  Proof.\n    induction n; simpl; intros.\n    - apply specializable_noninteracting_2; auto; lia.\n    - unfold NonInteracting in *.\n      assert (ln > n) by lia; specialize (IHn _ H1); clear H1; dest.\n      split.\n      + apply DisjList_comm.\n        apply DisjList_SubList with\n        (l1:= app (getCalls (specializeMod (m (S n)) (S n)))\n                  (getCalls (duplicate m n))).\n        * unfold SubList; intros.\n          apply getCalls_in in H1.\n          apply in_or_app; auto.\n        * apply DisjList_app_4.\n          { pose proof (specializable_noninteracting_2 (H (S n)) (H iv)).\n            apply H1; lia.\n          }\n          { specialize (IHn iv); dest.\n            apply DisjList_comm; auto.\n          }\n      + apply DisjList_comm.\n        apply DisjList_SubList with\n        (l1:= app (getDefs (specializeMod (m (S n)) (S n)))\n                  (getDefs (duplicate m n))).\n        * unfold SubList; intros.\n          apply getDefs_in in H1.\n          apply in_or_app; auto.\n        * apply DisjList_app_4.\n          { pose proof (specializable_noninteracting_2 (H (S n)) (H iv)).\n            apply H1; lia.\n          }\n          { specialize (IHn iv); dest.\n            apply DisjList_comm; auto.\n          }\n  Qed.\n\n  Lemma duplicate_regs_NoDup:\n    forall (Hsp: forall iv, Specializable (m iv)) n,\n      (forall iv, NoDup (namesOf (getRegInits (m iv)))) ->\n      NoDup (namesOf (getRegInits (duplicate m n))).\n  Proof.\n    induction n; simpl; intros; [apply specializeMod_regs_NoDup; auto|].\n    unfold namesOf in *; simpl in *.\n    rewrite map_app; apply NoDup_DisjList; auto.\n    - apply specializeMod_regs_NoDup, H; auto.\n    - apply duplicate_specializeMod_disj_regs; auto.\n  Qed.\n\n  Lemma getRegInits_duplicate_nil:\n    forall n,\n      (forall iv, Specializable (m iv)) ->\n      (forall iv, getRegInits (m iv) = nil) ->\n      getRegInits (duplicate m n) = nil.\n  Proof.\n    intros.\n    match goal with\n    | [ |- ?P ] => assert (namesOf (getRegInits (duplicate m n)) = nil -> P) as Hm\n    end.\n    { intros; unfold namesOf in H1; eapply map_eq_nil; eauto. }\n    apply Hm; clear Hm.\n    \n    induction n; simpl; intros.\n    - rewrite specializeMod_regs; auto.\n      rewrite H0; reflexivity.\n    - rewrite namesOf_app.\n      rewrite IHn; rewrite app_nil_r.\n      rewrite specializeMod_regs; auto.\n      rewrite H0; reflexivity.\n  Qed.\n\n  Lemma getDefs_duplicate_nil:\n    (forall iv, Specializable (m iv)) ->\n    (forall iv, getDefs (m iv) = nil) ->\n    forall n,\n      getDefs (duplicate m n) = nil.\n  Proof.\n    induction n; simpl; intros.\n    - rewrite specializeMod_defs; auto.\n      rewrite H0; reflexivity.\n    - rewrite getDefs_app.\n      rewrite IHn; rewrite app_nil_r.\n      rewrite specializeMod_defs; auto.\n      rewrite H0; reflexivity.\n  Qed.\n\n  Lemma getDefsBodies_duplicate_nil:\n    (forall iv, Specializable (m iv)) ->\n    (forall iv, getDefsBodies (m iv) = nil) ->\n    forall n,\n      getDefsBodies (duplicate m n) = nil.\n  Proof.\n    intros.\n    assert (forall iv, getDefs (m iv) = nil) by (intros; unfold getDefs; rewrite H0; reflexivity).\n    eapply getDefs_duplicate_nil with (n:= n) in H1; eauto.\n    eapply map_eq_nil with (f:= @attrName _); eauto.\n  Qed.\n\n  Lemma getRules_duplicate_in:\n    forall rn rb i,\n      (forall iv, Specializable (m iv)) ->\n      In (rn :: rb)%struct (getRules (m i)) ->\n      forall n,\n        i <= n ->\n        In ((rn __ i)\n              :: (fun ty => (Renaming.renameAction (specializer (m i) i) (rb ty))))%struct\n           (getRules (duplicate m n)).\n  Proof.\n    induction n; simpl; intros.\n    - inv H1; apply specializeMod_rules_in; auto.\n    - inv H1; [|apply in_or_app; right; auto].\n      apply in_or_app; left.\n      apply specializeMod_rules_in; auto.\n  Qed.\n\nEnd DuplicateFacts.\n\nSection TwoModules1.\n  Variables (m1 m2: Modules).\n  Hypotheses (Hsp1: Specializable m1)\n             (Hsp2: Specializable m2)\n             (Hequiv1: ModEquiv type typeUT m1)\n             (Hequiv2: ModEquiv type typeUT m2)\n             (Hvr1: ValidRegsModules type m1)\n             (Hvr2: ValidRegsModules type m2)\n             (Hexts: SubList (getExtMeths m1) (getExtMeths m2)).\n\n  Lemma specializer_equiv:\n    forall {A} (m: M.t A),\n      M.KeysSubset m (spDom m1) ->\n      M.KeysSubset m (spDom m2) ->\n      forall i,\n        renameMap (specializer m1 i) m = renameMap (specializer m2 i) m.",
      "suffix": "\n\n  Lemma specializeMod_defCallSub:\n    forall i,\n      DefCallSub m1 m2 ->\n      DefCallSub (specializeMod m1 i) (specializeMod m2 i).\n  Proof.\n    unfold DefCallSub; intros; dest; split.\n    - do 2 rewrite specializeMod_defs by assumption.\n      apply SubList_map; auto.\n    - do 2 rewrite specializeMod_calls by assumption.\n      apply SubList_map; auto.\n  Qed.\n\n  Lemma specializer_two_comm:\n    forall (m: MethsT),\n      M.KeysSubset m (getExtMeths m1) ->\n      forall i,\n        m = renameMap (specializer m2 i) (renameMap (specializer m1 i) m).\n  Proof.\n    intros.\n    replace (renameMap (specializer m1 i) m) with (renameMap (specializer m2 i) m).\n    - rewrite renameMapFInvG; auto.\n      + apply specializer_bijective.\n        apply specializable_disj_dom_img; auto.\n      + apply specializer_bijective.\n        apply specializable_disj_dom_img; auto.\n    - apply eq_sym, specializer_equiv.\n      + eapply M.KeysSubset_SubList; eauto.\n        pose proof (getExtMeths_meths m1).\n        apply SubList_trans with (l2:= app (getDefs m1) (getCalls m1)); auto.\n        apply SubList_app_3; [apply spDom_defs|apply spDom_calls].\n      + apply M.KeysSubset_SubList with (d2:= getExtMeths m2) in H; auto.\n        eapply M.KeysSubset_SubList; eauto.\n        pose proof (getExtMeths_meths m2).\n        apply SubList_trans with (l2:= app (getDefs m2) (getCalls m2)); auto.\n        apply SubList_app_3; [apply spDom_defs|apply spDom_calls].\n  Qed.\n\nEnd TwoModules1.\n\nSection DuplicateTwoModules1.\n  Variables (m1 m2: nat -> Modules).\n  Hypotheses (Hsp1: forall iv, Specializable (m1 iv))\n             (Hsp2: forall iv, Specializable (m2 iv))\n             (Hequiv1: forall iv, ModEquiv type typeUT (m1 iv))\n             (Hequiv2: forall iv, ModEquiv type typeUT (m2 iv))\n             (Hvr1: forall iv, ValidRegsModules type (m1 iv))\n             (Hvr2: forall iv, ValidRegsModules type (m2 iv))\n             (Hexts: forall iv1 iv2, SubList (getExtMeths (m1 iv1)) (getExtMeths (m2 iv2))).\n\n  Lemma duplicate_defCallSub:\n    forall n,\n      (forall i, DefCallSub (m1 i) (m2 i)) ->\n      DefCallSub (duplicate m1 n) (duplicate m2 n).\n  Proof.\n    induction n; simpl; intros.\n    - apply specializeMod_defCallSub; auto.\n    - apply DefCallSub_modular.\n      + apply specializeMod_defCallSub; auto.\n      + apply IHn; auto.\n  Qed.\n\n  Lemma duplicate_traceRefines:\n    forall n,\n      (forall i, traceRefines (liftToMap1 (@idElementwise _)) (m1 i) (m2 i)) ->\n      traceRefines (liftToMap1 (@idElementwise _))\n                   (duplicate m1 n)\n                   (duplicate m2 n).\n  Proof.\n    induction n; simpl; intros.\n    - apply specialized_2 with (i:= O); auto.\n      specialize (H 0).\n      eapply traceRefines_label_map; eauto using H.\n      clear - Hsp1 Hsp2 Hexts; unfold EquivalentLabelMap; intros.\n      rewrite idElementwiseId; unfold id; simpl.\n      unfold liftPRename; simpl.\n      apply specializer_two_comm; auto.\n\n    - apply traceRefines_modular_noninteracting; auto.\n      + apply specializeMod_ModEquiv; auto.\n      + apply specializeMod_ModEquiv; auto.\n      + apply duplicate_ModEquiv; auto.\n      + apply duplicate_ModEquiv; auto.\n      + apply duplicate_specializeMod_disj_regs; auto.\n      + apply duplicate_specializeMod_disj_regs; auto.\n      + pose proof (duplicate_validRegsModules m1 (S n) Hvr1); auto.\n      + pose proof (duplicate_validRegsModules m2 (S n) Hvr2); auto.\n      + apply duplicate_specializeMod_disj_defs; auto.\n      + eapply DisjList_comm, DisjList_SubList.\n        * apply getIntCalls_getCalls.\n        * apply DisjList_comm, duplicate_specializeMod_disj_calls; auto.\n      + eapply DisjList_SubList.\n        * apply getIntCalls_getCalls.\n        * apply duplicate_specializeMod_disj_calls; auto.\n      + apply duplicate_specializeMod_disj_defs; auto.\n      + eapply DisjList_comm, DisjList_SubList.\n        * apply getIntCalls_getCalls.\n        * apply DisjList_comm, duplicate_specializeMod_disj_calls; auto.\n      + eapply DisjList_SubList.\n        * apply getIntCalls_getCalls.\n        * apply duplicate_specializeMod_disj_calls; auto.\n      + apply duplicate_noninteracting; auto.\n      + apply duplicate_noninteracting; auto.\n      + apply specialized_2 with (i:= S n); auto.\n        specialize (H (S n)).\n        eapply traceRefines_label_map; eauto using H.\n        clear - Hsp1 Hsp2 Hexts; unfold EquivalentLabelMap; intros.\n        rewrite idElementwiseId; unfold id; simpl.\n        unfold liftPRename; simpl.\n        apply specializer_two_comm; auto.\n  Qed.\n\nEnd DuplicateTwoModules1.\n\nSection TwoModules2.\n  Variables (m1 m2: Modules).\n  Hypotheses (Hsp1: Specializable m1)\n             (Hsp2: Specializable m2)\n             (Hequiv1: ModEquiv type typeUT m1)\n             (Hequiv2: ModEquiv type typeUT m2)\n             (Hvr1: ValidRegsModules type m1)\n             (Hvr2: ValidRegsModules type m2).\n\n  Variable (ds: string). (* a single label to drop *)\n\n  Hypothesis (Hexts: SubList (filter (fun s => negb (string_eq s ds)) (getExtMeths m1))\n                             (getExtMeths m2)).\n\n  Lemma specializeMod_traceRefines_drop:\n    forall i,\n      (m1 <<=[dropP ds] m2) ->\n      (specializeMod m1 i <<=[dropI ds i] specializeMod m2 i).\n  Proof.\n    intros.\n    apply specialized_2; auto.\n    apply traceRefines_label_map with (p:= liftToMap1 (dropP ds)); auto.\n\n    clear -Hsp1 Hsp2 Hexts.\n    unfold EquivalentLabelMap; intros.\n\n    unfold liftPRename.\n\n    assert (renameMap (specializer m2 i) ((liftToMap1 (dropP ds)) m) =\n            liftToMap1 (dropI ds i) (renameMap (specializer m1 i) m)).\n    { rewrite specializer_map with (m:= m1); auto;\n        [|eapply M.KeysSubset_SubList; eauto; apply spDom_getExtMeths].\n      rewrite specializer_map with (m:= m2); auto;\n        [|apply M.KeysSubset_SubList with (d1:= getExtMeths m2); [|apply spDom_getExtMeths];\n          eapply M.KeysSubset_SubList; eauto;\n          apply dropP_KeysSubset; auto].\n\n      clear; M.ext y.\n      rewrite liftToMap1_find.\n      remember (M.find y (renameMap (spf i) m)) as yiv; destruct yiv.\n      - apply eq_sym, renameFind2' in Heqyiv; [|apply spf_onto].\n        dest; subst; rewrite <-renameMapFind; [|apply spf_onto].\n        rewrite liftToMap1_find, H0.\n        unfold dropP, dropI.\n        remember (string_eq x ds) as xds; destruct xds.\n        + apply string_eq_dec_eq in Heqxds; subst.\n          rewrite string_eq_true; reflexivity.\n        + apply string_eq_dec_neq in Heqxds.\n          remember (string_eq (spf i x) (ds __ i)) as xdsi; destruct xdsi; auto.\n          apply string_eq_dec_eq, spf_onto in Heqxdsi.\n          elim Heqxds; auto.\n      - remember (M.find y (renameMap (spf i) (liftToMap1 (dropP ds) m))) as ypv;\n          destruct ypv; auto.\n        exfalso; apply eq_sym, renameFind2' in Heqypv; [|apply spf_onto].\n        dest; subst.\n        rewrite <-renameMapFind in Heqyiv; [|apply spf_onto].\n        rewrite liftToMap1_find in H0.\n        rewrite <-Heqyiv in H0; inv H0.\n    }\n\n    rewrite <-H0.\n    rewrite <-specializer_two_comm with (m1:= m2) (m2:= m2) (i:= i); auto.\n    - apply SubList_refl.\n    - eapply M.KeysSubset_SubList; eauto.\n      apply dropP_KeysSubset; auto.\n  Qed.\n\n  Lemma equivalentLabelMapElem_dropI_dropN:\n    forall n t (Ht: t > n),\n      EquivalentLabelMapElem (dropI ds t) (compLabelMaps (dropI ds t) (dropN ds n))\n                             (getExtMeths (specializeMod m1 t)).\n  Proof.\n    unfold EquivalentLabelMapElem; intros.\n    induction n.\n    - simpl; unfold compLabelMaps, dropI.\n      destruct (string_eq _ (ds __ t)).\n      + destruct (string_eq _ (ds __ 0)); auto.\n      + remember (string_eq _ _) as sv; destruct sv; auto.\n        exfalso; apply string_eq_dec_eq in Heqsv; subst.\n        apply spDom_getExtMeths in H.\n        apply specializeMod_dom_indexed in H; auto; dest.\n        apply withIndex_index_eq in H; dest; lia.\n    - simpl; assert (t > n) by lia; specialize (IHn H0); clear H0.\n      rewrite IHn; clear IHn.\n      unfold dropI, compLabelMaps.\n      remember (dropN ds n s v) as nv; destruct nv; auto.\n      destruct (string_eq s (ds __ t)).\n      + destruct (string_eq _ _); auto.\n      + remember (string_eq _ _) as sn; destruct sn; auto.\n        exfalso; apply string_eq_dec_eq in Heqsn; subst.\n        apply spDom_getExtMeths in H.\n        apply specializeMod_dom_indexed in H; auto; dest.\n        apply withIndex_index_eq in H; dest; lia.\n  Qed.\n\nEnd TwoModules2.\n\nSection DuplicateTwoModules2.\n  Variables (m1 m2: nat -> Modules).\n  Hypotheses (Hsp1: forall iv, Specializable (m1 iv))\n             (Hsp2: forall iv, Specializable (m2 iv))\n             (Hequiv1: forall iv, ModEquiv type typeUT (m1 iv))\n             (Hequiv2: forall iv, ModEquiv type typeUT (m2 iv))\n             (Hvr1: forall iv, ValidRegsModules type (m1 iv))\n             (Hvr2: forall iv, ValidRegsModules type (m2 iv)).\n\n  Variable (ds: string). (* a single label to drop *)\n\n  Hypothesis (Hexts: forall iv1 iv2,\n                 SubList (filter (fun s => negb (string_eq s ds))\n                                 (getExtMeths (m1 iv1)))\n                         (getExtMeths (m2 iv2))).\n  \n  Lemma equivalentLabelMapElem_dropN_dropI:\n    forall n u (Ht: u > n),\n      EquivalentLabelMapElem (dropN ds n) (compLabelMaps (dropI ds u) (dropN ds n))\n                             (getExtMeths (duplicate m1 n)).\n  Proof.\n    induction n; unfold EquivalentLabelMapElem; intros.\n    - simpl; unfold compLabelMaps, dropI.\n      destruct (string_eq _ (ds __ 0)); auto.\n      remember (string_eq _ _) as st; destruct st; auto.\n      apply string_eq_dec_eq in Heqst; subst.\n      simpl in H.\n      apply spDom_getExtMeths in H.\n      apply specializeMod_dom_indexed in H; auto; dest.\n      apply withIndex_index_eq in H; dest; lia.\n    - simpl; assert (u > n) by lia; specialize (IHn _ H0); clear H0.\n      simpl in H.\n      apply getExtMeths_in in H; destruct H.\n      + clear IHn.\n        unfold dropI, compLabelMaps.\n        destruct (dropN ds n s v); auto.\n        destruct (string_eq _ (ds __ (S n))); auto.\n        remember (string_eq _ _) as st; destruct st; auto.\n        exfalso; apply string_eq_dec_eq in Heqst; subst.\n        apply spDom_getExtMeths in H.\n        apply specializeMod_dom_indexed in H; auto; dest.\n        apply withIndex_index_eq in H; dest; lia.\n      + unfold compLabelMaps.\n        rewrite IHn; clear IHn; auto.\n        unfold compLabelMaps.\n        destruct (dropN ds n s v); auto.\n        destruct (dropI ds u s s0); auto.\n        destruct (dropI ds (S n) s s1); auto.\n        unfold dropI; remember (string_eq _ _) as st; destruct st; auto.\n        exfalso; apply string_eq_dec_eq in Heqst; subst.\n        apply spDom_getExtMeths in H.\n        apply duplicate_dom_indexed in H; auto; dest.\n        apply withIndex_index_eq in H; dest; lia.\n  Qed.\n\n  Lemma duplicate_traceRefines_drop:\n    forall n,\n      (forall i, (m1 i) <<=[dropP ds] (m2 i)) ->\n      (duplicate m1 n <<=[dropN ds n] duplicate m2 n).\n  Proof.\n    induction n; simpl; intros.\n    - apply specializeMod_traceRefines_drop; auto.\n    - apply traceRefines_modular_noninteracting_p; auto.\n      + apply specializeMod_ModEquiv; auto.\n      + apply specializeMod_ModEquiv; auto.\n      + apply duplicate_ModEquiv; auto.\n      + apply duplicate_ModEquiv; auto.\n      + apply duplicate_specializeMod_disj_regs; auto.\n      + apply duplicate_specializeMod_disj_regs; auto.\n      + pose proof (duplicate_validRegsModules m1 (S n) Hvr1); auto.\n      + pose proof (duplicate_validRegsModules m2 (S n) Hvr2); auto.\n      + apply duplicate_specializeMod_disj_defs; auto.\n      + eapply DisjList_comm, DisjList_SubList.\n        * apply getIntCalls_getCalls.\n        * apply DisjList_comm, duplicate_specializeMod_disj_calls; auto.\n      + eapply DisjList_SubList.\n        * apply getIntCalls_getCalls.\n        * apply duplicate_specializeMod_disj_calls; auto.\n      + apply duplicate_specializeMod_disj_defs; auto.\n      + eapply DisjList_comm, DisjList_SubList.\n        * apply getIntCalls_getCalls.\n        * apply DisjList_comm, duplicate_specializeMod_disj_calls; auto.\n      + eapply DisjList_SubList.\n        * apply getIntCalls_getCalls.\n        * apply duplicate_specializeMod_disj_calls; auto.\n      + split.\n        * apply equivalentLabelMapElem_dropI_dropN; auto; lia.\n        * apply equivalentLabelMapElem_dropN_dropI; auto; lia.\n      + apply duplicate_noninteracting; auto.\n      + apply duplicate_noninteracting; auto.\n      + apply specializeMod_traceRefines_drop; auto.\n  Qed.\n\nEnd DuplicateTwoModules2.\n\nSection DuplicateTwoModules3.\n  Variables (m1 m2: nat -> Modules).\n  Hypotheses (Hequiv1: forall iv ty, ModEquiv ty typeUT (m1 iv))\n             (Hequiv2: forall iv ty, ModEquiv ty typeUT (m2 iv))\n             (Hvr1: forall iv ty, ValidRegsModules ty (m1 iv))\n             (Hvr2: forall iv ty, ValidRegsModules ty (m2 iv))\n             (Hsp1: forall iv, Specializable (m1 iv))\n             (Hsp2: forall iv, Specializable (m2 iv)).\n\n  Lemma duplicate_regs_ConcatMod_1:\n    forall n,\n      SubList (getRegInits (duplicate (fun i => (m1 i) ++ (m2 i))%kami n))\n              (getRegInits (duplicate m1 n ++ duplicate m2 n)%kami).\n  Proof.\n    Opaque specializeMod.\n    induction n; intros.\n    - unfold duplicate.\n      rewrite specializeMod_concatMod; auto.\n      apply SubList_refl.\n    - simpl in *; apply SubList_app_3.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * do 2 apply SubList_app_1; apply SubList_refl.\n        * apply SubList_app_2, SubList_app_1, SubList_refl.\n      + unfold SubList in *; intros.\n        specialize (IHn e H).\n        apply in_app_or in IHn; destruct IHn.\n        * apply in_or_app; left; apply in_or_app; auto.\n        * apply in_or_app; right; apply in_or_app; auto.\n          Transparent specializeMod.\n  Qed.\n\n  Lemma duplicate_regs_ConcatMod_2:\n    forall n,\n      SubList (getRegInits (duplicate m1 n ++ duplicate m2 n)%kami)\n              (getRegInits (duplicate (fun i => m1 i ++ m2 i)%kami n)).\n  Proof.\n    Opaque specializeMod.\n    induction n; intros.\n    - unfold duplicate.\n      rewrite specializeMod_concatMod; auto.\n      apply SubList_refl.\n    - simpl in *; apply SubList_app_3.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * do 2 apply SubList_app_1; apply SubList_refl.\n        * apply SubList_app_2; apply SubList_app_4 in IHn; auto.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * apply SubList_app_1, SubList_app_2, SubList_refl.\n        * apply SubList_app_2; apply SubList_app_5 in IHn; auto.\n          Transparent specializeMod.\n  Qed.\n\n  Corollary duplicate_regs_ConcatMod:\n    forall n,\n      EquivList (getRegInits (duplicate m1 n ++ duplicate m2 n)%kami)\n                (getRegInits (duplicate (fun i => m1 i ++ m2 i)%kami n)).\n  Proof.\n    intros; split.\n    - apply duplicate_regs_ConcatMod_2.\n    - apply duplicate_regs_ConcatMod_1.\n  Qed.\n\n  Lemma duplicate_regs_NoDup_2:\n    (forall i, NoDup (namesOf (getRegInits (m1 i ++ m2 i)%kami))) ->\n    forall n,\n      NoDup (namesOf (getRegInits (duplicate m1 n ++ duplicate m2 n)%kami)).\n  Proof.\n    Opaque specializeMod.\n    intros.\n    pose proof H; apply duplicate_regs_NoDup with (n:= n) in H0.\n    induction n; simpl; intros.\n    - simpl in *; rewrite specializeMod_concatMod in H0; auto.\n    - assert (NoDup (namesOf (getRegInits (duplicate (fun i => m1 i ++ m2 i)%kami n)))).\n      { apply duplicate_regs_NoDup; auto.\n        intros; apply specializable_concatMod; auto.\n      }\n      specialize (IHn H1); clear H1.\n      unfold namesOf; repeat rewrite map_app.\n      rewrite app_assoc.\n      rewrite <-app_assoc with (l:= map (@attrName _)\n                                        (getRegInits (specializeMod (m1 (S n)) (S n)))).\n      rewrite <-app_assoc with (l:= map (@attrName _)\n                                        (getRegInits (specializeMod (m1 (S n)) (S n)))).\n      apply NoDup_app_comm_ext.\n      rewrite app_assoc.\n      rewrite app_assoc.\n      rewrite <-app_assoc with (n:= map (@attrName _) (getRegInits (duplicate m2 n))).\n      apply NoDup_DisjList.\n      + specialize (H (S n)); apply specializeMod_regs_NoDup with (i:= S n) in H;\n          [|apply specializable_concatMod; auto].\n        rewrite specializeMod_concatMod in H; auto.\n        rewrite <-map_app; auto.\n      + rewrite <-map_app; auto.\n      + do 2 rewrite <-map_app.\n        pose proof (duplicate_regs_ConcatMod_2 n).\n        apply SubList_map with (f:= @attrName _) in H1.\n        eapply DisjList_comm, DisjList_SubList; eauto.\n        pose proof (specializeMod_concatMod (Hvr1 (S n)) (Hvr2 (S n))\n                                            (Hequiv1 (S n)) (Hequiv2 (S n)) (S n)\n                                            (Hsp1 (S n)) (Hsp2 (S n))).\n        change (getRegInits (specializeMod (m1 (S n)) (S n)) ++\n                            getRegInits (specializeMod (m2 (S n)) (S n)))\n        with (getRegInits (specializeMod (m1 (S n)) (S n) ++\n                                         (specializeMod (m2 (S n)) (S n)))%kami).\n        rewrite <-H2.\n        apply DisjList_comm.\n        change (m1 (S n) ++ m2 (S n))%kami with ((fun i => (m1 i ++ m2 i)%kami) (S n)).\n        apply duplicate_specializeMod_disj_regs; auto.\n        intros; apply specializable_concatMod; auto.\n    - intros; apply specializable_concatMod; auto.\n  Qed.\n\n  Lemma duplicate_rules_ConcatMod_1:\n    forall n,\n      SubList (getRules (duplicate (fun i => m1 i ++ m2 i)%kami n))\n              (getRules (duplicate m1 n ++ duplicate m2 n)%kami).\n  Proof.\n    Opaque specializeMod.\n    induction n; intros.\n    - unfold duplicate.\n      rewrite specializeMod_concatMod; auto.\n      apply SubList_refl.\n    - simpl in *; apply SubList_app_3.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * do 2 apply SubList_app_1; apply SubList_refl.\n        * apply SubList_app_2, SubList_app_1, SubList_refl.\n      + unfold SubList in *; intros.\n        specialize (IHn e H).\n        apply in_app_or in IHn; destruct IHn.\n        * apply in_or_app; left; apply in_or_app; auto.\n        * apply in_or_app; right; apply in_or_app; auto.\n          Transparent specializeMod.\n  Qed.\n\n  Lemma duplicate_rules_ConcatMod_2:\n    forall n,\n      SubList (getRules (duplicate m1 n ++ duplicate m2 n)%kami)\n              (getRules (duplicate (fun i => m1 i ++ m2 i)%kami n)).\n  Proof.\n    Opaque specializeMod.\n    induction n; intros.\n    - unfold duplicate.\n      rewrite specializeMod_concatMod; auto.\n      apply SubList_refl.\n    - simpl in *; apply SubList_app_3.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * do 2 apply SubList_app_1; apply SubList_refl.\n        * apply SubList_app_2; apply SubList_app_4 in IHn; auto.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * apply SubList_app_1, SubList_app_2, SubList_refl.\n        * apply SubList_app_2; apply SubList_app_5 in IHn; auto.\n          Transparent specializeMod.\n  Qed.\n\n  Corollary duplicate_rules_ConcatMod:\n    forall n,\n      EquivList (getRules (duplicate m1 n ++ duplicate m2 n)%kami)\n                (getRules (duplicate (fun i => m1 i ++ m2 i)%kami n)).\n  Proof.\n    intros; split.\n    - apply duplicate_rules_ConcatMod_2.\n    - apply duplicate_rules_ConcatMod_1.\n  Qed.\n\n  Lemma duplicate_defs_ConcatMod_1:\n    forall n,\n      SubList (getDefsBodies (duplicate (fun i => m1 i ++ m2 i)%kami n))\n              (getDefsBodies (duplicate m1 n ++ duplicate m2 n)%kami).\n  Proof.\n    Opaque specializeMod.\n    induction n; intros.\n    - unfold duplicate.\n      rewrite specializeMod_concatMod; auto.\n      apply SubList_refl.\n    - simpl in *; apply SubList_app_3.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * do 2 apply SubList_app_1; apply SubList_refl.\n        * apply SubList_app_2, SubList_app_1, SubList_refl.\n      + unfold SubList in *; intros.\n        specialize (IHn e H).\n        apply in_app_or in IHn; destruct IHn.\n        * apply in_or_app; left; apply in_or_app; auto.\n        * apply in_or_app; right; apply in_or_app; auto.\n          Transparent specializeMod.\n  Qed.\n\n  Lemma duplicate_defs_ConcatMod_2:\n    forall n,\n      SubList (getDefsBodies (duplicate m1 n ++ duplicate m2 n)%kami)\n              (getDefsBodies (duplicate (fun i => m1 i ++ m2 i)%kami n)).\n  Proof.\n    Opaque specializeMod.\n    induction n; intros.\n    - unfold duplicate.\n      rewrite specializeMod_concatMod; auto.\n      apply SubList_refl.\n    - simpl in *; apply SubList_app_3.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * do 2 apply SubList_app_1; apply SubList_refl.\n        * apply SubList_app_2; apply SubList_app_4 in IHn; auto.\n      + rewrite specializeMod_concatMod; auto.\n        simpl; apply SubList_app_3.\n        * apply SubList_app_1, SubList_app_2, SubList_refl.\n        * apply SubList_app_2; apply SubList_app_5 in IHn; auto.\n          Transparent specializeMod.\n  Qed.\n\n  Lemma duplicate_defs_ConcatMod:\n    forall n,\n      EquivList (getDefsBodies (duplicate m1 n ++ duplicate m2 n)%kami)\n                (getDefsBodies (duplicate (fun i => m1 i ++ m2 i)%kami n)).\n  Proof.\n    intros; split.\n    - apply duplicate_defs_ConcatMod_2.\n    - apply duplicate_defs_ConcatMod_1.\n  Qed.\n\nEnd DuplicateTwoModules3.\n\nSection DuplicateTwoModules4.\n  Variables (m1 m2: nat -> Modules).\n  Hypotheses (Hsp1: forall iv, Specializable (m1 iv))\n             (Hsp2: forall iv, Specializable (m2 iv))\n             (Hequiv1: forall iv ty, ModEquiv ty typeUT (m1 iv))\n             (Hequiv2: forall iv ty, ModEquiv ty typeUT (m2 iv))\n             (Hvr1: forall iv ty, ValidRegsModules ty (m1 iv))\n             (Hvr2: forall iv ty, ValidRegsModules ty (m2 iv))\n             (HnoDup: forall iv, NoDup (namesOf (getRegInits (m1 iv ++ m2 iv)%kami))).\n\n  Lemma duplicate_concatMod_comm_1:\n    forall n,\n      duplicate (fun i => m1 i ++ m2 i)%kami n <<== ((duplicate m1 n) ++ (duplicate m2 n))%kami.\n  Proof.\n    intros; rewrite idElementwiseId.\n    apply traceRefines_same_module_structure.\n    - apply duplicate_regs_NoDup; auto.\n      intros; apply specializable_concatMod; auto.\n    - apply duplicate_regs_NoDup_2; auto.\n    - split.\n      + apply duplicate_regs_ConcatMod_1; auto.\n      + apply duplicate_regs_ConcatMod_2; auto.\n    - split.\n      + apply duplicate_rules_ConcatMod_1; auto.\n      + apply duplicate_rules_ConcatMod_2; auto.\n    - split.\n      + apply duplicate_defs_ConcatMod_1; auto.\n      + apply duplicate_defs_ConcatMod_2; auto.\n  Qed.\n\n  Lemma duplicate_concatMod_comm_2:\n    forall n,\n      ((duplicate m1 n) ++ (duplicate m2 n))%kami <<== duplicate (fun i => m1 i ++ m2 i)%kami n.\n  Proof.\n    intros; rewrite idElementwiseId.\n    apply traceRefines_same_module_structure.\n    - apply duplicate_regs_NoDup_2; auto.\n    - apply duplicate_regs_NoDup; auto.\n      intros; apply specializable_concatMod; auto.\n    - split.\n      + apply duplicate_regs_ConcatMod_2; auto.\n      + apply duplicate_regs_ConcatMod_1; auto.\n    - split.\n      + apply duplicate_rules_ConcatMod_2; auto.\n      + apply duplicate_rules_ConcatMod_1; auto.\n    - split.\n      + apply duplicate_defs_ConcatMod_2; auto.\n      + apply duplicate_defs_ConcatMod_1; auto.\n  Qed.\n\nEnd DuplicateTwoModules4.\n\n#[global] Hint Unfold specializeMod duplicate: ModuleDefs.\n\n",
      "theorem": "Lemma specializer_equiv:\n    forall {A} (m: M.t A),\n      M.KeysSubset m (spDom m1) ->\n      M.KeysSubset m (spDom m2) ->\n      forall i,\n        renameMap (specializer m1 i) m = renameMap (specializer m2 i) m.",
      "ground_truth": "Proof. intros; do 2 (rewrite specializer_map; auto). Qed."
    },
    {
      "split": "train-sft",
      "index": 14,
      "prefix": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Export complexes.\nSet Implicit Arguments.\nUnset Strict Implicit.\nParameter partie_reelle : C -> R.\nParameter partie_imaginaire : C -> R.\n \nAxiom\n  partie_reelle_def :\n    forall (z : C) (a b : R), z = cons_cart a b -> a = partie_reelle z.\n \nAxiom\n  partie_imaginaire_def :\n    forall (z : C) (a b : R), z = cons_cart a b -> b = partie_imaginaire z.\n \nAxiom\n  forme_algebrique_def :\n    forall (z : C) (a b : R),\n    a = partie_reelle z -> b = partie_imaginaire z -> z = cons_cart a b.\n \nLemma car_image_forme_algebrique :\n forall (z : C) (M : PO),\n M = image z ->\n partie_reelle z = abscisse M /\\ partie_imaginaire z = ordonnee M.\nintros.\nelim existence_coordonnees with (O := O) (I := I) (J := J) (M := M);\n [ intros x H2; elim H2; intros y H3 | auto with geo ].\ncut (z = cons_cart x y); intros.\nrewrite <- (partie_reelle_def H0).\nrewrite <- (partie_imaginaire_def H0).\nsplit; eauto with geo.\neauto with geo.\nQed.\n \nLemma coordonnees_affixe :\n forall M : PO, cons_cart (abscisse M) (ordonnee M) = affixe M :>C.\nintros.\nelim existence_affixe_point with (M := M); intros z H;\n try clear existence_affixe_point; try exact H.\nelim car_image_forme_algebrique with (z := z) (M := M);\n [ intros; try exact H1 | eauto with geo ].\nrewrite <- H1; rewrite <- H0; rewrite <- H.\nsymmetry  in |- *; eauto with geo.\nQed.\n#[export] Hint Resolve coordonnees_affixe: geo.\n \nLemma absvec_ordvec_affixe :\n forall (a b : R) (A B : PO),\n a = absvec (vec A B) ->\n b = ordvec (vec A B) -> cons_cart a b = affixe_vec (vec A B).\nintros a b A B.\nelim existence_representant_vecteur with (A := O) (B := A) (C := B);\n intros D H1; try exact H1.\nrewrite <- H1; intros.\napply affixe_point_vecteur.\nrewrite H0; rewrite H; rewrite (ordvec_ordonnee (O:=O) (I:=I) (J:=J) D);\n auto with geo.\nrewrite (absvec_abscisse (O:=O) (I:=I) (J:=J) D); auto with geo.\nQed.\nParameter module : C -> R.\nParameter argument : C -> AV.\n \nAxiom\n  module_def :\n    forall (z : C) (M : PO), M = image z -> module z = distance O M.\n \nAxiom\n  argument_def :\n    forall (M : PO) (z : C),\n    O <> M -> M = image z -> argument z = cons_AV (vec O I) (vec O M).\n#[export] Hint Resolve module_def argument_def: geo.\n \nLemma module_def2 :\n forall (z : C) (M : PO), z = affixe M -> module z = distance O M.\nintros; eauto with geo.\nQed.\n \nLemma argument_def2 :\n forall (M : PO) (z : C),\n O <> M -> z = affixe M -> argument z = cons_AV (vec O I) (vec O M).\nintros; eauto with geo.\nQed.\n \nLemma existence_module : forall z : C, exists r : R, module z = r.\nintros.\nelim existence_image_complexe with (z := z); intros M H1;\n try clear existence_image_complexe; try exact H1.\nexists (distance O M); eauto with geo.\nQed.\n \nDefinition zeroC := cons_cart 0 0.\n \nLemma image_zeroC : image zeroC = O.\nelim existence_image_complexe with (z := zeroC); unfold zeroC in |- *;\n intros M H1; try exact H1.\ncut (vec O M = add_PP (mult_PP 0 (vec O I)) (mult_PP 0 (vec O J))); intros;\n eauto with geo.\nrewrite <- H1.\nsymmetry  in |- *.\napply vecteur_nul_conf.\nrewrite H.\nRingvec.\nQed.\n#[export] Hint Resolve image_zeroC: geo.\n \nLemma affixe_origine : zeroC = affixe O.\neauto with geo.\nQed.\n#[export] Hint Resolve affixe_origine: geo.\n \nLemma module_zeroC : module zeroC = 0.\nrewrite (module_def (z:=zeroC) (M:=O)); auto with geo.\nQed.\n \nLemma module_nul_zeroC : forall z : C, module z = 0 -> z = zeroC.\nintros.\nelim existence_image_complexe with (z := z); intros M H1;\n try clear existence_image_complexe; try exact H1.\ncut (O = M); intros.\nrewrite (affixe_image H1).\nrewrite <- H0; auto with geo.\napply distance_refl1.\nrewrite <- H; symmetry  in |- *; auto with geo.\nQed.\n#[export] Hint Resolve module_zeroC module_nul_zeroC: geo.\n \nLemma module_non_zero : forall z : C, z <> zeroC -> module z <> 0.\nred in |- *; intros.\napply H; auto with geo.\nQed.\n \nLemma nonzero_module : forall z : C, module z <> 0 -> z <> zeroC.\nred in |- *; intros.\napply H; rewrite H0; auto with geo.\nQed.\n#[export] Hint Resolve module_non_zero nonzero_module: geo.\n \nLemma image_nonzero_nonorigine :\n forall (M : PO) (z : C), z <> zeroC :>C -> M = image z -> O <> M.\nintros.\nred in |- *; intros; apply H.\nreplace z with (affixe M).\nrewrite <- H1; auto with geo.\nsymmetry  in |- *; auto with geo.\nQed.\n#[export] Hint Resolve image_nonzero_nonorigine: geo.\n \nLemma nonorigine_image_nonzero :\n forall (M : PO) (z : C), O <> M -> M = image z -> z <> zeroC :>C.\nintros.\nred in |- *; intros; apply H.\nrewrite H0; rewrite H1.\nsymmetry  in |- *; auto with geo.\nQed.\n#[export] Hint Resolve nonorigine_image_nonzero: geo.\n \nLemma existence_argument :\n forall z : C, z <> zeroC -> exists a : R, argument z = image_angle a.\nintros.\nelim existence_image_complexe with (z := z); intros M H1;\n try clear existence_image_complexe; try exact H1.\ncut (O <> M); intros; eauto with geo.\nmesure O I O M.\nexists x.\nrewrite H2; eauto with geo.\nQed.\n \nLemma existence_forme_polaire :\n forall z : C,\n z <> zeroC ->\n exists r : R, (exists a : R, module z = r /\\ argument z = image_angle a).\nintros.\nelim existence_module with (z := z); intros r H0; try clear existence_module;\n try exact H0.\nelim existence_argument with (z := z);\n [ intros a H1; try clear existence_argument; try exact H1 | auto ].\nexists r; exists a; auto.\nQed.\nParameter cons_pol : R -> R -> C.\n \nAxiom\n  forme_polaire_def :\n    forall (z : C) (r a : R),\n    z <> zeroC ->\n    module z = r -> argument z = image_angle a -> z = cons_pol r a.\n \nAxiom complexe_polaire_module : forall r a : R, module (cons_pol r a) = r.\n \nAxiom\n  complexe_polaire_argument :\n    forall r a : R, r <> 0 -> argument (cons_pol r a) = image_angle a.\n \nLemma polaire_non_nul : forall r a : R, r <> 0 -> cons_pol r a <> zeroC.\nintros.\napply nonzero_module.\nrewrite complexe_polaire_module; auto.\nQed.\n \nLemma complexe_pol_module :\n forall (z : C) (r a : R), z <> zeroC -> z = cons_pol r a -> module z = r.\nintros.\nrewrite H0; rewrite complexe_polaire_module; auto.\nQed.\n \nLemma complexe_pol_argument :\n forall (z : C) (r a : R),\n z <> zeroC -> z = cons_pol r a -> argument z = image_angle a.\nintros.\nrewrite H0; rewrite complexe_polaire_argument; auto.\nrewrite <- (complexe_pol_module (z:=z) (r:=r) (a:=a)); auto with geo.\nQed.\n#[export] Hint Resolve forme_polaire_def complexe_pol_module complexe_pol_argument\n  polaire_non_nul complexe_polaire_module complexe_polaire_module: geo.\n \nLemma pol_complexe_module :\n forall (z : C) (r a : R) (M : PO),\n z <> zeroC -> z = cons_pol r a -> M = image z -> distance O M = r.\nintros.\nrewrite <- (module_def H1); eauto with geo.\nQed.\n \nLemma pol_complexe_argument :\n forall (z : C) (r a : R) (M : PO),\n z <> zeroC ->\n z = cons_pol r a ->\n M = image z -> cons_AV (vec O I) (vec O M) = image_angle a.\nintros.\nrewrite <- (argument_def (M:=M) (z:=z)); eauto with geo.\nQed.\n#[export] Hint Resolve pol_complexe_argument pol_complexe_module: geo.\n \nLemma image_forme_polaire :\n forall (z : C) (M : PO),\n O <> M ->\n M = image z ->\n module z = distance O M /\\ argument z = cons_AV (vec O I) (vec O M).\nintros.\nsplit; eauto with geo.\nQed.\n \nLemma unicite_forme_polaire_nonzero :\n forall (z : C) (r a r' a' : R),\n z <> zeroC ->\n z = cons_pol r a ->\n z = cons_pol r' a' -> r = r' /\\ image_angle a = image_angle a'.\nintros.\nsplit.\nrewrite <- (complexe_pol_module (z:=z) (r:=r) (a:=a)); eauto with geo.\nrewrite <- (complexe_pol_argument (z:=z) (r:=r) (a:=a)); eauto with geo.\nQed.\n#[export] Hint Resolve unicite_forme_polaire_nonzero image_forme_polaire: geo.\n \nLemma passage_polaire_algebrique :\n forall (z : C) (r a x y : R),\n z <> zeroC ->\n z = cons_cart x y -> z = cons_pol r a -> x = r * cos a /\\ y = r * sin a.\nintros.\nelim existence_image_complexe with (z := z); intros M H2;\n try clear existence_image_complexe; try exact H2.\nelim\n coordonnees_polaires_cartesiennes\n  with\n    (x := x)\n    (y := y)\n    (a := a)\n    (r := r)\n    (O := O)\n    (I := I)\n    (J := J)\n    (M := M);\n [ intros; eauto with geo\n | eauto with geo\n | eauto with geo\n | eauto with geo\n | eauto with geo\n | eauto with geo ].\nsymmetry  in |- *; eauto with geo.\nsymmetry  in |- *; eauto with geo.\nQed.\n \nLemma passage_algebrique_module :\n forall (z : C) (x y : R),\n z = cons_cart x y -> module z = sqrt (Rsqr x + Rsqr y).\nintros.\nelim existence_image_complexe with (z := z); intros M H2;\n try clear existence_image_complexe; try exact H2.\nreplace (module z) with (distance O M); auto.\nrewrite (distance_coordonnees (O:=O) (I:=I) (J:=J) (M:=M) (x:=x) (y:=y));\n eauto with geo.\nsymmetry  in |- *; eauto with geo.\nQed.\n \nLemma passage_algebrique_argument :\n forall (z : C) (r x y a : R),\n z <> zeroC ->\n z = cons_cart x y -> z = cons_pol r a -> cos a = / r * x /\\ sin a = / r * y.\nintros.\nelim\n passage_polaire_algebrique with (z := z) (r := r) (a := a) (x := x) (y := y);\n [ intros | eauto with geo | eauto with geo | eauto with geo ].\ncut (r <> 0); intros.\nsplit; [ try assumption | idtac ].\nrewrite H2.\nfield; auto.\nrewrite H3.\nfield; auto.\nreplace r with (module z); eauto with geo.\nQed.\n \nLemma egalite_forme_polaire :\n forall z z' : C,\n z <> zeroC ->\n z' <> zeroC -> module z = module z' -> argument z = argument z' -> z = z'.\nintros.\nelim existence_forme_polaire with (z := z);\n [ intros r H3; elim H3; intros a H4; elim H4; intros H5 H6;\n    try clear H4 H3 existence_forme_polaire; try exact H6\n | auto ].\nelim existence_forme_polaire with (z := z');\n [ intros r0 H7; elim H7; intros a0 H8; elim H8; intros H9 H10;\n    try clear H8 H7 existence_forme_polaire; try exact H10\n | auto ].\nrewrite (forme_polaire_def (z:=z) (r:=r) (a:=a)); auto.\nrewrite (forme_polaire_def (z:=z') (r:=r) (a:=a)); auto.\nrewrite <- H5; auto.\nrewrite <- H6; auto.\nQed.\n#[export] Hint Resolve passage_algebrique_module passage_algebrique_argument\n  egalite_forme_polaire: geo.\n \nLemma algebrique_zeroC :\n forall a b : R, cons_cart a b = zeroC :>C -> a = 0 /\\ b = 0.\nintros.\napply unicite_parties_relles_imaginaires with zeroC; auto.\nQed.\n \nLemma polaire_calcul_algebrique :\n forall (z : C) (r a : R),\n z <> zeroC :>C ->\n z = cons_pol r a :>C -> z = cons_cart (r * cos a) (r * sin a) :>C.\nintros.\nelim existence_parties_relles_imaginaires with (z := z); intros a0 H1;\n elim H1; intros b H2; try clear H1 existence_parties_relles_imaginaires;\n try exact H2.\nelim\n passage_polaire_algebrique\n  with (z := z) (r := r) (a := a) (x := a0) (y := b);\n [ intros; try exact H4 | auto | auto | auto ].\nrewrite H2; rewrite H3; rewrite H4; auto.\nQed.\n#[export] Hint Resolve polaire_calcul_algebrique: geo.\n \nDefinition Rinj (x : R) := cons_cart x 0.\n \nDefinition oneC := cons_cart 1 0.\n#[export] Hint Unfold oneC zeroC Rinj: geo.\n \nLemma Rinj_zero : Rinj 0 = zeroC.\nunfold Rinj, zeroC in |- *; auto.\nQed.\n \nLemma Rinj_un : Rinj 1 = oneC.\nunfold Rinj, oneC in |- *; auto.\nQed.\n \nLemma module_oneC : module oneC = 1.\nintros.\nrewrite (passage_algebrique_module (z:=oneC) (x:=1) (y:=0)).\nreplace (Rsqr 1 + Rsqr 0) with 1 by (unfold Rsqr; ring).\nexact sqrt_1.\nunfold oneC in |- *; auto.\nQed.\n \nLemma oneC_nonzero : oneC <> zeroC.\napply nonzero_module.\nrewrite module_oneC; auto with real.\nQed.\n#[export] Hint Resolve module_oneC oneC_nonzero: geo.\n \nLemma argument_oneC : argument oneC = image_angle 0.\nelim existence_forme_polaire with (z := oneC);\n [ intros r H; elim H; intros a H0; elim H0; intros H1 H2;\n    try clear H0 H existence_forme_polaire; try exact H2\n | auto with geo ].\nrewrite module_oneC in H1.\nrewrite H2.\nelim\n passage_algebrique_argument\n  with (z := oneC) (r := 1) (x := 1) (y := 0) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\napply egalite_angle_trigo.\nrewrite sin_zero; rewrite H4; ring.\nrewrite H3; rewrite cos_zero; field.\nQed.\n#[export] Hint Resolve argument_oneC: geo.\n \nDefinition i := cons_cart 0 1.\n#[export] Hint Unfold i: geo.\n \nLemma module_i : module i = 1.\nintros.\nrewrite (passage_algebrique_module (z:=i) (x:=0) (y:=1)).\nreplace (Rsqr 0 + Rsqr 1) with 1 by (unfold Rsqr; ring).\nexact sqrt_1.\nunfold i in |- *; auto.\nQed.\n \nLemma i_nonzero : i <> zeroC.\napply nonzero_module.\nrewrite module_i; auto with real.\nQed.\n#[export] Hint Resolve module_i i_nonzero: geo.\n \nLemma argument_i : argument i = image_angle pisurdeux.\nelim existence_forme_polaire with (z := i);\n [ intros r H; elim H; intros a H0; elim H0; intros H1 H2;\n    try clear H0 H existence_forme_polaire; try exact H2\n | auto with geo ].\nelim\n passage_algebrique_argument\n  with (z := i) (r := 1) (x := 0) (y := 1) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\nrewrite module_i in H1.\nrewrite H2.\nelim\n passage_algebrique_argument\n  with (z := i) (r := 1) (x := 0) (y := 1) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\napply egalite_angle_trigo.\nrewrite sin_pisurdeux; rewrite H4; field.\nrewrite H3; rewrite cos_pisurdeux; ring.\nQed.\n#[export] Hint Resolve argument_i: geo.\n \nLemma forme_polaire_oneC : oneC = cons_pol 1 0.\napply forme_polaire_def; auto with geo.\nQed.\n \nLemma forme_polaire_i : i = cons_pol 1 pisurdeux.\napply forme_polaire_def; auto with geo.\nQed.\n#[export] Hint Resolve forme_polaire_oneC forme_polaire_i: geo.\n \nLemma egalite_cart_pol :\n forall x y r a : R,\n r <> 0 ->\n module (cons_cart x y) = r ->\n argument (cons_cart x y) = image_angle a :>AV ->\n cons_cart x y = cons_pol r a :>C.\nintros.\nrewrite <- (forme_polaire_def (z:=cons_cart x y) (r:=r) (a:=a));\n auto with geo.\napply nonzero_module.\nrewrite H0; auto.\nQed.\n \nLemma module_opp_un : module (Rinj (-1)) = 1.",
      "suffix": "\n \nLemma opp_un_nonzero : Rinj (-1) <> zeroC :>C.\napply nonzero_module.\nrewrite module_opp_un; auto with real.\nQed.\n#[export] Hint Resolve opp_un_nonzero module_opp_un: geo.\n \nLemma argument_opp_un : argument (Rinj (-1)) = image_angle pi.\nelim existence_forme_polaire with (z := Rinj (-1));\n [ intros r H1; elim H1; intros a H2; elim H2; intros H3 H4; try clear H2 H1;\n    try exact H4\n | auto with geo ].\nrewrite module_opp_un in H3.\nelim\n passage_algebrique_argument\n  with (z := Rinj (-1)) (r := 1) (x := -1) (y := 0) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\nrewrite H4.\napply egalite_angle_trigo.\nrewrite sin_pi; rewrite H0; ring.\nrewrite H; rewrite cos_pi; field.\nQed.\n#[export] Hint Resolve argument_opp_un: geo.\n \nLemma forme_polaire_opp_un : Rinj (-1) = cons_pol 1 pi.\napply forme_polaire_def; auto with geo.\nQed.\n \nLemma module_reel : forall x : R, module (Rinj x) = Rabs x.\nunfold Rinj in |- *; intros.\nrewrite (passage_algebrique_module (z:=cons_cart x 0) (x:=x) (y:=0));\n auto with geo.\nreplace (Rsqr x + Rsqr 0) with (Rsqr x) by (unfold Rsqr; ring).\nrewrite sqrt_Rsqr_abs; auto.\nQed.\n \nLemma module_reel_pos : forall x : R, 0 <= x -> module (Rinj x) = x.\nunfold Rinj in |- *; intros.\nrewrite (passage_algebrique_module (z:=cons_cart x 0) (x:=x) (y:=0));\n auto with geo.\nreplace (Rsqr x + Rsqr 0) with (Rsqr x) by (unfold Rsqr in |- *; ring).\nrewrite sqrt_Rsqr; auto.\nQed.\n \nLemma reel_non_nul : forall x : R, x <> 0 -> Rinj x <> zeroC.\nintros.\napply nonzero_module.\nrewrite module_reel.\napply Rabs_no_R0; auto.\nQed.\n#[export] Hint Resolve reel_non_nul module_reel_pos module_reel: geo.\n \nLemma argument_reel_pos :\n forall x : R, 0 < x -> argument (Rinj x) = image_angle 0.\nintros.\ncut (x <> 0); intros.\nelim existence_forme_polaire with (z := Rinj x);\n [ intros r H1; elim H1; intros a H2; elim H2; intros H3 H4; try clear H2 H1;\n    try exact H4\n | auto with geo ].\ncut (x = r); intros.\nelim\n passage_algebrique_argument\n  with (z := Rinj x) (r := r) (x := x) (y := 0) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\nrewrite H4.\napply egalite_angle_trigo.\nrewrite sin_zero; rewrite H5; ring.\nrewrite H2; rewrite <- H1; rewrite cos_zero; field; trivial.\nrewrite module_reel_pos in H3; auto.\nlra.\nauto with real.\nQed.\n#[export] Hint Resolve argument_reel_pos: geo.\n \nLemma forme_pol_reel_pos : forall x : R, 0 < x -> Rinj x = cons_pol x 0 :>C.\nintros.\napply forme_polaire_def; auto with geo.\napply reel_non_nul; auto with real.\napply module_reel_pos; auto with real.\nQed.\n \nLemma module_reel_neg : forall x : R, 0 > x -> module (Rinj x) = - x.\nintros.\nrewrite module_reel; auto.\napply Rabs_left1; auto with real.\nQed.\n#[export] Hint Resolve module_reel_neg: geo.\n \nLemma argument_reel_neg :\n forall x : R, 0 > x -> argument (Rinj x) = image_angle pi.\nintros.\ncut (x <> 0); intros.\nelim existence_forme_polaire with (z := Rinj x);\n [ intros r H1; elim H1; intros a H2; elim H2; intros H3 H4; try clear H2 H1;\n    try exact H4\n | auto with geo ].\nelim\n passage_algebrique_argument\n  with (z := Rinj x) (r := r) (x := x) (y := 0) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\nrewrite H4.\napply egalite_angle_trigo.\nrewrite sin_pi; rewrite H2; ring.\ncut (r = - x); intros.\nrewrite H1; rewrite H5; rewrite cos_pi;  field; trivial.\nrewrite <- H3.\nrewrite module_reel_neg in |- *; [  ring | auto with geo ].\nauto with real.\nQed.\n#[export] Hint Resolve argument_reel_neg: geo.\n \nLemma forme_pol_reel_neg :\n forall x : R, 0 > x -> Rinj x = cons_pol (- x) pi :>C.\nintros.\napply forme_polaire_def; auto with geo.\napply reel_non_nul; auto with real.\nQed.\n \nLemma module_pos : forall z : C, module z >= 0.\nintros.\nelim existence_image_complexe with (z := z); intros M H;\n try clear existence_image_complexe; try exact H.\nrewrite (module_def H); auto with geo.\nQed.\n#[export] Hint Resolve module_pos: geo.\n \nLemma module_stric_pos : forall z : C, z <> zeroC :>C -> module z > 0.\nintros.\ncut (module z >= 0); intros; auto with geo.\nelim H0; intros; auto.\nabsurd (module z = 0); auto with geo.\nQed.\n#[export] Hint Resolve module_stric_pos: geo.\n \nLemma abs_module : forall z : C, module z = Rabs (module z).\nintros.\ncut (module z >= 0); intros; auto with geo.\nrewrite Rabs_right; auto.\nQed.\n#[export] Hint Resolve abs_module: geo.\n",
      "theorem": "Lemma module_opp_un : module (Rinj (-1)) = 1.",
      "ground_truth": "unfold Rinj in |- *.\nrewrite (passage_algebrique_module (z:=cons_cart (-1) 0) (x:=-1) (y:=0));\n auto with geo.\nreplace (Rsqr (-1) + Rsqr 0) with 1 by (unfold Rsqr; ring).\nexact sqrt_1.\nQed."
    },
    {
      "split": "train-sft",
      "index": 15,
      "prefix": "(** Fixed precision machine words *)\n\nRequire Import Arith NArith ZArith Bool Lia.\nRequire Import Eqdep_dec EqdepFacts.\nRequire Import Program.Tactics Program.Equality.\nRequire Import Ring Ring_polynom.\nRequire Import Lia Nlia NatLib DepEq N_Z_nat_conversions.\n\nSet Implicit Arguments.\n\n(*! Definitions *)\n\n(** * [word] *)\n\nInductive word : nat -> Set :=\n| WO : word O\n| WS : bool -> forall n, word n -> word (S n).\n\nDeclare Scope word_scope.\nDelimit Scope word_scope with word.\nBind Scope word_scope with word.\n\nOpen Scope word_scope.\n\n(** * Conversion to and from [nat] (or [N]), zero and one *)\n\nFixpoint wordToNat sz (w : word sz) : nat :=\n  match w with\n    | WO => O\n    | WS false w' => (wordToNat w') * 2\n    | WS true w' => S (wordToNat w' * 2)\n  end.\n\nDefinition wordToNat' sz (w : word sz) : nat :=\n  match w with\n    | WO => O\n    | WS false w' => 2 * wordToNat w'\n    | WS true w' => S (2 * wordToNat w')\n  end.\n\nFixpoint natToWord (sz n : nat) : word sz :=\n  match sz with\n    | O => WO\n    | S sz' => WS (mod2 n) (natToWord sz' (Nat.div2 n))\n  end.\n\nFixpoint wordToN sz (w : word sz) : N :=\n  match w with\n    | WO => 0\n    | WS false w' => 2 * wordToN w'\n    | WS true w' => N.succ (2 * wordToN w')\n  end%N.\n\nDefinition wzero sz := natToWord sz 0.\n\nFixpoint wzero' (sz : nat) : word sz :=\n  match sz with\n    | O => WO\n    | S sz' => WS false (wzero' sz')\n  end.\n\nFixpoint posToWord (sz : nat) (p : positive) {struct p} : word sz :=\n  match sz with\n    | O => WO\n    | S sz' =>\n      match p with\n        | xI p' => WS true (posToWord sz' p')\n        | xO p' => WS false (posToWord sz' p')\n        | xH => WS true (wzero' sz')\n      end\n  end.\n\nDefinition NToWord (sz : nat) (n : N) : word sz :=\n  match n with\n    | N0 => wzero' sz\n    | Npos p => posToWord sz p\n  end.\n\nDefinition wone sz := natToWord sz 1.\n\nFixpoint wones (sz : nat) : word sz :=\n  match sz with\n    | O => WO\n    | S sz' => WS true (wones sz')\n  end.\n\n(** * MSB, LSB, head, and tail *)\n\nFixpoint wmsb sz (w : word sz) (a : bool) : bool :=\n  match w with\n    | WO => a\n    | WS b x => wmsb x b\n  end.\n\nDefinition wlsb sz (w: word (S sz)) :=\n  match w with\n  | WO => tt\n  | WS b _ => b\n  end.\n\nDefinition whd sz (w : word (S sz)) : bool :=\n  match w in word sz' return match sz' with\n                               | O => unit\n                               | S _ => bool\n                             end with\n    | WO => tt\n    | WS b _ => b\n  end.\n\nDefinition wtl sz (w : word (S sz)) : word sz :=\n  match w in word sz' return match sz' with\n                               | O => unit\n                               | S sz'' => word sz''\n                             end with\n    | WO => tt\n    | WS _ w' => w'\n  end.\n\nFixpoint rep_bit (n : nat) (b : word 1) : word n :=\n  match n as n0 return (word n0) with\n  | 0 => WO\n  | S n0 => WS (whd b) (rep_bit n0 b)\n  end.\n\n(** * Shattering (to define [weq]) and decidable equality **)\n\nLemma shatter_word : forall n (a : word n),\n  match n return word n -> Prop with\n    | O => fun a => a = WO\n    | S _ => fun a => a = WS (whd a) (wtl a)\n  end a.\n  destruct a; eauto.\nQed.\n\nLemma shatter_word_S : forall n (a : word (S n)),\n  exists b, exists c, a = WS b c.\nProof.\n  intros n a; repeat eexists; apply (shatter_word a).\nQed.\nLemma shatter_word_0 : forall a : word 0,\n  a = WO.\nProof.\n  intros a; apply (shatter_word a).\nQed.\n\n#[global] Hint Resolve shatter_word_0.\n\nDefinition weq : forall sz (x y : word sz), {x = y} + {x <> y}.\n  refine (fix weq sz (x : word sz) : forall y : word sz, {x = y} + {x <> y} :=\n    match x in word sz return forall y : word sz, {x = y} + {x <> y} with\n      | WO => fun _ => left _ _\n      | WS b x' => fun y => if bool_dec b (whd y)\n        then if weq _ x' (wtl y) then left _ _ else right _ _\n        else right _ _\n    end); clear weq.\n\n  abstract (symmetry; apply shatter_word_0).\n\n  abstract (subst; symmetry; apply (shatter_word (n:=S _) _)).\n\n  let y' := y in (* kludge around warning of mechanically generated names not playing well with [abstract] *)\n  abstract (rewrite (shatter_word y'); simpl; intro H; injection H; intros;\n    eauto using inj_pair2_eq_dec, Nat.eq_dec).\n\n  let y' := y in (* kludge around warning of mechanically generated names not playing well with [abstract] *)\n  abstract (rewrite (shatter_word y'); simpl; intro H; injection H; auto).\nDefined.\n\nFixpoint weqb sz (x : word sz) : word sz -> bool :=\n  match x in word sz return word sz -> bool with\n    | WO => fun _ => true\n    | WS b x' => fun y =>\n      if eqb b (whd y)\n      then if @weqb _ x' (wtl y) then true else false\n      else false\n  end.\n\n(** * Combining and splitting *)\n\nFixpoint combine (sz1 : nat) (w : word sz1) : forall sz2, word sz2 -> word (sz1 + sz2) :=\n  match w in word sz1 return forall sz2, word sz2 -> word (sz1 + sz2) with\n    | WO => fun _ w' => w'\n    | WS b w' => fun _ w'' => WS b (combine w' w'')\n  end.\n\nFixpoint split1 (sz1 sz2 : nat) : word (sz1 + sz2) -> word sz1 :=\n  match sz1 with\n    | O => fun _ => WO\n    | S sz1' => fun w => WS (whd w) (split1 sz1' sz2 (wtl w))\n  end.\n\nFixpoint split2 (sz1 sz2 : nat) : word (sz1 + sz2) -> word sz2 :=\n  match sz1 with\n    | O => fun w => w\n    | S sz1' => fun w => split2 sz1' sz2 (wtl w)\n  end.\n\n(** * Extension operators *)\n\nDefinition sext (sz : nat) (w : word sz) (sz' : nat) : word (sz + sz') :=\n  if wmsb w false then\n    combine w (wones sz')\n  else\n    combine w (wzero sz').\n\nDefinition zext (sz : nat) (w : word sz) (sz' : nat) : word (sz + sz') :=\n  combine w (wzero sz').\n\n(** * Arithmetic *)\n\nDefinition wneg sz (x : word sz) : word sz :=\n  NToWord sz (Npow2 sz - wordToN x).\n\nDefinition wordBin (f : N -> N -> N) sz (x y : word sz) : word sz :=\n  NToWord sz (f (wordToN x) (wordToN y)).\n\nDefinition wplus := wordBin Nplus.\nDefinition wmult := wordBin Nmult.\nDefinition wdiv := wordBin N.div.\nDefinition wmod := wordBin Nmod.\nDefinition wmult' sz (x y : word sz) : word sz :=\n  split2 sz sz (NToWord (sz + sz) (Nmult (wordToN x) (wordToN y))).\nDefinition wminus sz (x y : word sz) : word sz := wplus x (wneg y).\nDefinition wnegN sz (x : word sz) : word sz :=\n  natToWord sz (pow2 sz - wordToNat x).\nDefinition wordBinN (f : nat -> nat -> nat) sz (x y : word sz) : word sz :=\n  natToWord sz (f (wordToNat x) (wordToNat y)).\nDefinition wplusN := wordBinN plus.\n\nDefinition wmultN := wordBinN mult.\nDefinition wmultN' sz (x y : word sz) : word sz :=\n  split2 sz sz (natToWord (sz + sz) (mult (wordToNat x) (wordToNat y))).\nDefinition wdivN := wordBinN Nat.div.\nDefinition wremN := wordBinN Nat.modulo.\n\nDefinition wminusN sz (x y : word sz) : word sz := wplusN x (wnegN y).\n\nNotation \"w ~ 1\" := (WS true w)\n (at level 7, left associativity, format \"w '~' '1'\") : word_scope.\nNotation \"w ~ 0\" := (WS false w)\n (at level 7, left associativity, format \"w '~' '0'\") : word_scope.\n\nNotation \"^~\" := wneg.\nNotation \"l ^+ r\" := (@wplus _ l%word r%word) (at level 50, left associativity).\nNotation \"l ^* r\" := (@wmult _ l%word r%word) (at level 40, left associativity).\nNotation \"l ^- r\" := (@wminus _ l%word r%word) (at level 50, left associativity).\nNotation \"l ^/ r\" := (@wdiv _ l%word r%word) (at level 50, left associativity).\nNotation \"l ^% r\" := (@wmod _ l%word r%word) (at level 50, left associativity).\n\n(** * Bitwise operators *)\n\nFixpoint wnot sz (w : word sz) : word sz :=\n  match w with\n    | WO => WO\n    | WS b w' => WS (negb b) (wnot w')\n  end.\n\nFixpoint bitwp (f : bool -> bool -> bool) sz (w1 : word sz) : word sz -> word sz :=\n  match w1 with\n    | WO => fun _ => WO\n    | WS b w1' => fun w2 => WS (f b (whd w2)) (bitwp f w1' (wtl w2))\n  end.\n\nDefinition wnot' sz := bitwp xorb (wones sz).\n\nDefinition wor := bitwp orb.\nDefinition wand := bitwp andb.\nDefinition wxor := bitwp xorb.\n\nNotation \"l ^| r\" := (@wor _ l%word r%word) (at level 50, left associativity).\nNotation \"l ^& r\" := (@wand _ l%word r%word) (at level 40, left associativity).\n\n(** * Conversion to and from [Z] *)\n\nDefinition wordToZ sz (w : word sz) : Z :=\n  if wmsb w false then\n    (** Negative **)\n    match wordToN (wneg w) with\n    | N0 => 0%Z\n    | Npos x => Zneg x\n    end\n  else\n    (** Positive **)\n    match wordToN w with\n    | N0 => 0%Z\n    | Npos x => Zpos x\n    end.\n\nDefinition uwordToZ sz (w : word sz) : Z := Z.of_N (wordToN w).\n\nDefinition ZToWord (sz : nat) (z : Z) : word sz :=\n  match z with\n  | Z0 => wzero' sz\n  | Zpos x => posToWord sz x\n  | Zneg x => wneg (posToWord sz x)\n  end.\n\n(** * Arithmetic by [Z] *)\n\nDefinition wordBinZ (f : Z -> Z -> Z) sz (x y : word sz) : word sz :=\n  ZToWord sz (f (wordToZ x) (wordToZ y)).\n\nDefinition wplusZ := wordBinZ Z.add.\nDefinition wminusZ := wordBinZ Z.sub.\nDefinition wmultZ := wordBinZ Z.mul.\nDefinition wmultZsu sz (x y : word sz) :=\n  ZToWord sz (Z.mul (wordToZ x) (Z.of_N (wordToN y))).\nDefinition wdivZ := wordBinZ Z.quot.\nDefinition wdivZsu sz (x y : word sz) :=\n  ZToWord sz (Z.div (wordToZ x) (Z.of_N (wordToN y))).\nDefinition wremZ := wordBinZ Z.rem.\nDefinition wremZsu sz (x y : word sz) :=\n  ZToWord sz (Z.modulo (wordToZ x) (Z.of_N (wordToN y))).\n\n(** * Comparison predicates and deciders *)\n\nDefinition wlt sz (l r : word sz) : Prop :=\n  N.lt (wordToN l) (wordToN r).\nDefinition wslt sz (l r : word sz) : Prop :=\n  Z.lt (wordToZ l) (wordToZ r).\n\nNotation \"w1 > w2\" := (@wlt _ w2%word w1%word) : word_scope.\nNotation \"w1 >= w2\" := (~(@wlt _ w1%word w2%word)) : word_scope.\nNotation \"w1 < w2\" := (@wlt _ w1%word w2%word) : word_scope.\nNotation \"w1 <= w2\" := (~(@wlt _ w2%word w1%word)) : word_scope.\n\nNotation \"w1 '>s' w2\" := (@wslt _ w2%word w1%word) (at level 70, w2 at next level) : word_scope.\nNotation \"w1 '>s=' w2\" := (~(@wslt _ w1%word w2%word)) (at level 70, w2 at next level) : word_scope.\nNotation \"w1 '<s' w2\" := (@wslt _ w1%word w2%word) (at level 70, w2 at next level) : word_scope.\nNotation \"w1 '<s=' w2\" := (~(@wslt _ w2%word w1%word)) (at level 70, w2 at next level) : word_scope.\n\nDefinition wlt_dec : forall sz (l r : word sz), {l < r} + {l >= r}.\n  refine (fun sz l r =>\n    match N.compare (wordToN l) (wordToN r) as k return N.compare (wordToN l) (wordToN r) = k -> _ with\n      | Lt => fun pf => left _ _\n      | _ => fun pf => right _ _\n    end (refl_equal _));\n  abstract congruence.\nDefined.\n\nDefinition wslt_dec : forall sz (l r : word sz), {l <s r} + {l >s= r}.\n  refine (fun sz l r =>\n    match Z.compare (wordToZ l) (wordToZ r) as c return Z.compare (wordToZ l) (wordToZ r) = c -> _ with\n      | Lt => fun pf => left _ _\n      | _ => fun pf => right _ _\n    end (refl_equal _));\n  abstract congruence.\nDefined.\n\nNotation \"$ n\" := (natToWord _ n) (at level 5, format \"$ n\").\nNotation \"# n\" := (wordToNat n) (at level 5, format \"# n\").\n\n(** * Bit shifting *)\n\nFact sz_minus_nshift : forall sz nshift, (nshift < sz)%nat -> sz = sz - nshift + nshift.\nProof.\n  intros; lia.\nQed.\n\nFact nshift_plus_nkeep : forall sz nshift, (nshift < sz)%nat -> nshift + (sz - nshift) = sz.\nProof.\n  intros; lia.\nQed.\n\nDefinition wlshift (sz : nat) (w : word sz) (n : nat) : word sz.\n  refine (split1 sz n _).\n  rewrite Nat.add_comm.\n  exact (combine (wzero n) w).\nDefined.\n\nDefinition wrshift (sz : nat) (w : word sz) (n : nat) : word sz.\n  refine (split2 n sz _).\n  rewrite Nat.add_comm.\n  exact (combine w (wzero n)).\nDefined.\n\nDefinition wrshifta (sz : nat) (w : word sz) (n : nat) : word sz.\n  refine (split2 n sz _).\n  rewrite Nat.add_comm.\n  exact (sext w _).\nDefined.\n\nDefinition extz {sz} (w: word sz) (n: nat) := combine (wzero n) w.\n\nFixpoint wpow2 sz: word (S sz) :=\n  match sz with\n  | O => WO~1\n  | S sz' => (wpow2 sz')~0\n  end.\n\nNotation \"l ^<< r\" := (@wlshift _ _ l%word r%word) (at level 35).\nNotation \"l ^>> r\" := (@wrshift _ _ l%word r%word) (at level 35).\n\n(** * Setting an individual bit *)\n\nDefinition wbit sz sz' (n : word sz') := natToWord sz (pow2 (wordToNat n)).\n\n\n(*! Facts *)\n\n#[global] Hint Rewrite div2_double div2_S_double: div2.\nLocal Hint Resolve mod2_S_double mod2_double.\n\nTheorem eq_rect_word_offset : forall n n' offset w Heq,\n  eq_rect n (fun n => word (offset + n)) w n' Heq =\n  eq_rect (offset + n) (fun n => word n) w (offset + n') (eq_rect_word_offset_helper _ _ _ Heq).\nProof.\n  intros.\n  destruct Heq.\n  rewrite (UIP_dec Nat.eq_dec (eq_rect_word_offset_helper _ _ offset eq_refl) eq_refl).\n  reflexivity.\nQed.\n\nTheorem eq_rect_word_mult : forall n n' scale w Heq,\n  eq_rect n (fun n => word (n * scale)) w n' Heq =\n  eq_rect (n * scale) (fun n => word n) w (n' * scale) (eq_rect_word_mult_helper _ _ _ Heq).\nProof.\n  intros.\n  destruct Heq.\n  rewrite (UIP_dec Nat.eq_dec (eq_rect_word_mult_helper _ _ scale eq_refl) eq_refl).\n  reflexivity.\nQed.\n\nTheorem eq_rect_word_match : forall n n' (w : word n) (H : n = n'),\n  match H in (_ = N) return (word N) with\n  | eq_refl => w\n  end = eq_rect n (fun n => word n) w n' H.\nProof.\n  intros.\n  destruct H.\n  rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nTheorem whd_match : forall n n' (w : word (S n)) (Heq : S n = S n'),\n  whd w = whd (match Heq in (_ = N) return (word N) with\n               | eq_refl => w\n               end).\nProof.\n  intros.\n  rewrite eq_rect_word_match.\n  generalize dependent w.\n  remember Heq as Heq'. clear HeqHeq'.\n  generalize dependent Heq'.\n  replace (n') with (n) by lia.\n  intros. rewrite <- (eq_rect_eq_dec Nat.eq_dec). reflexivity.\nQed.\n\nTheorem wtl_match : forall n n' (w : word (S n)) (Heq : S n = S n') (Heq' : n = n'),\n  (match Heq' in (_ = N) return (word N) with\n   | eq_refl => wtl w\n   end) = wtl (match Heq in (_ = N) return (word N) with\n               | eq_refl => w\n               end).\nProof.\n  intros.\n  repeat match goal with\n           | [ |- context[match ?pf with refl_equal => _ end] ] => generalize pf\n         end.\n  generalize dependent w; clear.\n  intros.\n  generalize Heq Heq'.\n  subst.\n  intros.\n  rewrite (UIP_dec Nat.eq_dec Heq' (refl_equal _)).\n  rewrite (UIP_dec Nat.eq_dec Heq0 (refl_equal _)).\n  reflexivity.\nQed.\n\nTheorem word0: forall (w : word 0), w = WO.\nProof.\n  firstorder.\nQed.\n\nTheorem wordToNat_wordToNat' : forall sz (w : word sz),\n  wordToNat w = wordToNat' w.\nProof.\n  induction w. auto. unfold wordToNat. simpl. rewrite Nat.mul_comm. reflexivity.\nQed.\n\nTheorem natToWord_wordToNat : forall sz w, natToWord sz (wordToNat w) = w.\n  induction w as [|b]; rewrite wordToNat_wordToNat'; intuition; f_equal; unfold natToWord, wordToNat'; fold natToWord; fold wordToNat';\n    destruct b; f_equal; autorewrite with div2; intuition.\nQed.\n\nTheorem roundTrip_0 : forall sz, wordToNat (natToWord sz 0) = 0.\n  induction sz; simpl; intuition lia.\nQed.\n\n#[global] Hint Rewrite roundTrip_0 : wordToNat.\n\nLemma wordToNat_natToWord' : forall sz w, exists k, wordToNat (natToWord sz w) + k * pow2 sz = w.\n  induction sz as [|sz IHsz]; simpl; intro w; intuition; repeat rewrite untimes2.\n\n  exists w; intuition lia.\n\n  case_eq (mod2 w); intro Hmw.\n\n  specialize (IHsz (Nat.div2 w)); firstorder.\n  rewrite wordToNat_wordToNat' in *.\n  let x' := match goal with H : _ + ?x * _ = _ |- _ => x end in\n  rename x' into x. (* force non-auto-generated name *)\n  exists x; intuition.\n  rewrite Nat.mul_assoc.\n  rewrite (Nat.mul_comm x 2).\n  rewrite Nat.mul_comm. simpl mult at 1.\n  rewrite (plus_Sn_m (2 * wordToNat' (natToWord sz (Nat.div2 w)))).\n  rewrite <- Nat.mul_assoc.\n  rewrite <- Nat.mul_add_distr_l.\n  rewrite H; clear H.\n  symmetry; apply div2_odd; auto.\n\n  specialize (IHsz (Nat.div2 w)); firstorder.\n  let x' := match goal with H : _ + ?x * _ = _ |- _ => x end in\n  rename x' into x. (* force non-auto-generated name *)\n  exists x; intuition.\n  rewrite Nat.mul_assoc.\n  rewrite (Nat.mul_comm x 2).\n  rewrite <- Nat.mul_assoc.\n  rewrite Nat.mul_comm.\n  rewrite <- Nat.mul_add_distr_l.\n  match goal with H : _ |- _ => rewrite H; clear H end.\n  symmetry; apply div2_even; auto.\nQed.\n\nTheorem wordToNat_natToWord:\n  forall sz w, exists k, wordToNat (natToWord sz w) = w - k * pow2 sz /\\ (k * pow2 sz <= w)%nat.\nProof.\n  intros sz w; destruct (wordToNat_natToWord' sz w) as [k]; exists k; intuition lia.\nQed.\n\nLemma wordToNat_natToWord_2: forall sz w : nat,\n    (w < pow2 sz)%nat -> wordToNat (natToWord sz w) = w.\nProof.\n  intros.\n  pose proof (wordToNat_natToWord sz w).\n  destruct H0; destruct H0.\n  rewrite H0 in *; clear H0.\n  destruct x; lia.\nQed.\n\nLemma natToWord_times2: forall sz x,\n  ((natToWord sz x)~0)%word = natToWord (S sz) (2 * x).\nProof.\n  intros. unfold natToWord. fold natToWord. f_equal.\n  - symmetry. apply mod2_double.\n  - rewrite div2_double. reflexivity.\nQed.\n\nTheorem WS_neq : forall b1 b2 sz (w1 w2 : word sz),\n  (b1 <> b2 \\/ w1 <> w2)\n  -> WS b1 w1 <> WS b2 w2.\n  intros b1 b2 sz w1 w2 ? H0; intuition.\n  apply (f_equal (@whd _)) in H0; tauto.\n  apply (f_equal (@wtl _)) in H0; tauto.\nQed.\n\nTheorem weqb_true_iff : forall sz x y,\n  @weqb sz x y = true <-> x = y.\nProof.\n  induction x as [|b ? x IHx]; simpl; intros y.\n  { split; auto. }\n  { rewrite (shatter_word y) in *. simpl in *.\n    case_eq (eqb b (whd y)); intros H.\n    case_eq (weqb x (wtl y)); intros H0.\n    split; auto; intros. rewrite eqb_true_iff in H. f_equal; eauto. eapply IHx; eauto.\n    split; intros H1; try congruence. inversion H1; clear H1; subst.\n    eapply inj_pair2_eq_dec in H4. eapply IHx in H4. congruence.\n    eapply Nat.eq_dec.\n    split; intros; try congruence.\n    inversion H0. apply eqb_false_iff in H. congruence. }\nQed.\n\nLtac shatterer := simpl; intuition;\n  match goal with\n    | [ w : _ |- _ ] => rewrite (shatter_word w); simpl\n  end; f_equal; auto.\n\nTheorem combine_split : forall sz1 sz2 (w : word (sz1 + sz2)),\n  combine (split1 sz1 sz2 w) (split2 sz1 sz2 w) = w.\n  induction sz1; shatterer.\nQed.\n\nTheorem split1_combine : forall sz1 sz2 (w : word sz1) (z : word sz2),\n  split1 sz1 sz2 (combine w z) = w.\n  induction sz1; shatterer.\nQed.\n\nTheorem split2_combine : forall sz1 sz2 (w : word sz1) (z : word sz2),\n  split2 sz1 sz2 (combine w z) = z.\n  induction sz1; shatterer.\nQed.\n\n#[global] Hint Rewrite combine_split.\n#[global] Hint Rewrite split1_combine.\n#[global] Hint Rewrite split2_combine.\n\nTheorem combine_assoc : forall n1 (w1 : word n1) n2 n3 (w2 : word n2) (w3 : word n3) Heq,\n  combine (combine w1 w2) w3\n  = match Heq in _ = N return word N with\n      | refl_equal => combine w1 (combine w2 w3)\n    end.\n  induction w1 as [|?? w1 IHw1]; simpl; intros n2 n3 w2 w3 Heq; intuition.\n\n  rewrite (UIP_dec Nat.eq_dec Heq (refl_equal _)); reflexivity.\n\n  rewrite (IHw1 _ _ _ _ (Nat.add_assoc _ _ _)); clear IHw1.\n  repeat match goal with\n           | [ |- context[match ?pf with refl_equal => _ end] ] => generalize pf\n         end.\n  generalize dependent (combine w1 (combine w2 w3)).\n  rewrite Nat.add_assoc; intros w Heq0 e.\n  rewrite (UIP_dec Nat.eq_dec e (refl_equal _)).\n  rewrite (UIP_dec Nat.eq_dec Heq0 (refl_equal _)).\n  reflexivity.\nQed.\n\nTheorem split1_iter : forall n1 n2 n3 Heq w,\n  split1 n1 n2 (split1 (n1 + n2) n3 w)\n  = split1 n1 (n2 + n3) (match Heq in _ = N return word N with\n                           | refl_equal => w\n                         end).\nProof.\n  induction n1; simpl; intuition.\n\n  f_equal.\n  apply whd_match.\n  assert (n1 + n2 + n3 = n1 + (n2 + n3)) as Heq' by lia.\n  rewrite IHn1 with (Heq:=Heq').\n  f_equal.\n  apply wtl_match.\nQed.\n\nTheorem split2_iter : forall n1 n2 n3 Heq w,\n  split2 n2 n3 (split2 n1 (n2 + n3) w)\n  = split2 (n1 + n2) n3 (match Heq in _ = N return word N with\n                           | refl_equal => w\n                         end).\n  induction n1 as [|n1 IHn1]; simpl; intros n2 n3 Heq w; intuition.\n\n  rewrite (UIP_dec Nat.eq_dec Heq (refl_equal _)); reflexivity.\n\n  rewrite (IHn1 _ _ (Nat.add_assoc _ _ _)).\n  f_equal.\n  apply wtl_match.\nQed.\n\nTheorem split1_split2 : forall n1 n2 n3 Heq w,\n  split1 n2 n3 (split2 n1 (n2 + n3) w) =\n  split2 n1 n2 (split1 (n1 + n2) n3 (match Heq in _ = N return word N with\n                                     | refl_equal => w\n                                     end)).\nProof.\n  induction n1; simpl; intros.\n\n  rewrite (UIP_dec Nat.eq_dec Heq (refl_equal _)).\n  reflexivity.\n\n  rewrite (shatter_word w).\n  simpl.\n  assert (n1 + (n2 + n3) = n1 + n2 + n3) as Heq' by lia.\n  rewrite <- wtl_match with (Heq':=Heq').\n  rewrite <- IHn1.\n  f_equal.\nQed.\n\nTheorem split2_split1 : forall n1 n2 n3 Heq w,\n  split2 n1 n2 (split1 (n1+n2) n3 w) =\n  split1 n2 n3 (split2 n1 (n2+n3) (match Heq in _ = N return word N with\n                                     | refl_equal => w\n                                     end)).\nProof.\n  induction n1; simpl; intros.\n\n  rewrite (UIP_dec Nat.eq_dec Heq (refl_equal _)).\n  reflexivity.\n\n  rewrite (shatter_word w).\n  simpl.\n  assert (n1 + n2 + n3 = n1 + (n2 + n3)) as Heq' by lia.\n  rewrite <- wtl_match with (Heq':=Heq').\n  rewrite <- IHn1.\n  f_equal.\nQed.\n\nTheorem combine_0_n : forall sz2 (w: word 0) (v: word sz2),\n  combine w v = v.\nProof.\n  intros.\n  replace w with WO.\n  auto.\n  rewrite word0; auto.\nQed.\n\nLemma WS_eq_rect : forall b n (w: word n) n' H H',\n  eq_rect _ word (@WS b n w) _ H = @WS b n' (eq_rect _ word w _ H').\nProof.\n  destruct n; intros; subst;\n    eq_rect_simpl; auto.\nQed.\n\nTheorem combine_eq_rect2 : forall sz n n'\n  (H: n = n') H'\n  (a: word sz) (b: word n),\n  combine a b =\n    eq_rect _ word (combine a (eq_rect _ word b _ H)) _ H'.\nProof.\n  induction a; simpl; intros.\n  eq_rect_simpl; auto.\n  erewrite WS_eq_rect.\n  erewrite IHa.\n  auto.\n\n  Unshelve.\n  lia.\nQed.\n\nTheorem combine_n_0 : forall sz1 (w : word sz1) (v : word 0),\n  combine w v = eq_rect _ word w _ (plus_n_O sz1).\nProof.\n  induction w; intros.\n  - replace v with WO; auto.\n  - simpl; rewrite IHw.\n    erewrite WS_eq_rect.\n    reflexivity.\nQed.\n\nLemma whd_eq_rect : forall n w Heq,\n  whd (eq_rect (S n) word w (S (n + 0)) Heq) =\n  whd w.\nProof.\n  intros.\n  generalize Heq.\n  replace (n + 0) with n by lia.\n  intros.\n  f_equal.\n  eq_rect_simpl.\n  reflexivity.\nQed.\n\nLemma wtl_eq_rect : forall n w Heq Heq',\n  wtl (eq_rect (S n) word w (S (n + 0)) Heq) =\n  eq_rect n word (wtl w) (n + 0) Heq'.\nProof.\n  intros.\n  generalize dependent Heq.\n  rewrite <- Heq'; simpl; intros.\n  rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nLemma whd_eq_rect_mul : forall n w Heq,\n  whd (eq_rect (S n) word w (S (n * 1)) Heq) =\n  whd w.\nProof.\n  intros.\n  generalize Heq.\n  replace (n * 1) with n by auto.\n  intros.\n  eq_rect_simpl.\n  reflexivity.\nQed.\n\nLemma wtl_eq_rect_mul : forall n w b Heq Heq',\n  wtl (eq_rect (S n) word (WS b w) (S (n * 1)) Heq) =\n  eq_rect _ word w _ Heq'.\nProof.\n  intros.\n  generalize Heq.\n  rewrite <- Heq'.\n  intros. eq_rect_simpl.\n  reflexivity.\nQed.\n\nTheorem split1_0 : forall n w Heq,\n  split1 n 0 (eq_rect _ word w _ Heq) = w.\nProof.\n  intros.\n  induction n; intros.\n  shatterer.\n  simpl.\n  erewrite wtl_eq_rect.\n  rewrite IHn.\n  rewrite whd_eq_rect.\n  simpl.\n  shatterer.\n\n  Unshelve.\n  lia.\nQed.\n\nTheorem split2_0 : forall n w Heq,\n  split2 0 n (eq_rect _ word w _ Heq) = w.\nProof.\n  intros.\n  simpl.\n  eq_rect_simpl.\n  reflexivity.\nQed.\n\nTheorem combine_end : forall n1 n2 n3 Heq w,\n  combine (split1 n2 n3 (split2 n1 (n2 + n3) w))\n  (split2 (n1 + n2) n3 (match Heq in _ = N return word N with\n                          | refl_equal => w\n                        end))\n  = split2 n1 (n2 + n3) w.\n  induction n1 as [|n1 IHn1]; simpl; intros n2 n3 Heq w.\n\n  rewrite (UIP_dec Nat.eq_dec Heq (refl_equal _)).\n  apply combine_split.\n\n  rewrite (shatter_word w) in *.\n  simpl.\n  eapply trans_eq; [ | apply IHn1 with (Heq := Nat.add_assoc _ _ _) ]; clear IHn1.\n  repeat f_equal.\n  repeat match goal with\n           | [ |- context[match ?pf with refl_equal => _ end] ] => generalize pf\n         end.\n  simpl.\n  generalize dependent w.\n  rewrite Nat.add_assoc.\n  intros.\n  rewrite (UIP_dec Nat.eq_dec e (refl_equal _)).\n  rewrite (UIP_dec Nat.eq_dec Heq0 (refl_equal _)).\n  reflexivity.\nQed.\n\nLemma Private_plus_reg_l : forall n m p, p + n = p + m -> n = m.\nProof. intros n m p H. now apply ->Nat.add_cancel_l in H. Qed.\n\nTheorem eq_rect_combine : forall n1 n2 n2' (w1 : word n1) (w2 : word n2') Heq,\n  eq_rect (n1 + n2') (fun n => word n)\n    (combine w1 w2) (n1 + n2) Heq =\n  combine w1 (eq_rect n2' (fun n => word n) w2 n2 (Private_plus_reg_l _ _ _ Heq)).\nProof.\n  intros.\n  generalize (Private_plus_reg_l n2' n2 n1 Heq); intros.\n  generalize dependent Heq.\n  generalize dependent w2.\n  rewrite e; intros.\n  repeat rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nLemma eq_rect_combine_assoc' : forall a b c H wa wb wc,\n  eq_rect (a + (b + c)) word (combine wa (combine wb wc)) _ H = combine (combine wa wb) wc.\nProof.\n  intros.\n  erewrite combine_assoc, eq_rect_word_match.\n  reflexivity.\nQed.\n\nLemma eq_rect_split2_helper : forall a b c,\n  a = b -> c + a = c + b.\nProof.\n  intros; lia.\nQed.\n\nTheorem eq_rect_split2 : forall n1 n2 n2' (w : word (n1 + n2')) Heq,\n  eq_rect n2' (fun n => word n)\n    (split2 n1 n2' w) n2 Heq =\n  split2 n1 n2 (eq_rect (n1+n2') (fun n => word n) w (n1+n2) (eq_rect_split2_helper _ Heq)).\nProof.\n  intros.\n  generalize (eq_rect_split2_helper n1 Heq); intros.\n  generalize dependent Heq.\n  generalize dependent w.\n  assert (n2' = n2) as H' by lia.\n  generalize dependent e.\n  rewrite H'; intros.\n  repeat rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nTheorem eq_rect_split2_eq2 : forall n1 n2 n2' (w : word (n1 + n2)) Heq Heq2,\n  eq_rect n2 (fun n => word n)\n    (split2 n1 n2 w) n2' Heq =\n  split2 n1 n2' (eq_rect (n1+n2) (fun n => word n) w (n1+n2') Heq2).\nProof.\n  intros.\n  assert (H' := Heq).\n  generalize dependent w.\n  generalize dependent Heq.\n  generalize dependent Heq2.\n  rewrite H'; intros.\n  repeat rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nTheorem eq_rect_split2_eq1 : forall n1 n1' n2 (w: word (n1 + n2)) Heq,\n     split2 n1 n2 w = split2 n1' n2\n        (eq_rect (n1 + n2) (fun y : nat => word y) w\n     (n1' + n2) Heq).\nProof.\n  intros.\n  assert (n1 = n1') as H' by lia.\n  generalize dependent w.\n  generalize dependent Heq.\n  rewrite H'; intros.\n  rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nTheorem combine_split_eq_rect2 : forall n1 n2 n2' (w : word (n1 + n2)) Heq,\n  combine (split1 n1 n2 w)\n          (eq_rect n2 (fun n => word n) (split2 n1 n2 w)\n                   n2' Heq) =\n  eq_rect (n1 + n2) (fun n => word n) w\n          (n1 + n2') (eq_rect_split2_helper _ Heq).\nProof.\n  intros.\n  assert (n2 = n2') by lia.\n  generalize dependent Heq.\n  generalize dependent w.\n  rewrite <- H; intros.\n  repeat rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  apply combine_split.\nQed.\n\nLemma eq_rect_split1_helper : forall a b c,\n  a = b -> a + c = b + c.\nProof.\n  intros; lia.\nQed.\n\nLemma eq_rect_split1_eq2_helper : forall a b c,\n  a = b -> c + a = c + b.\nProof.\n  intros; lia.\nQed.\n\nTheorem eq_rect_split1 : forall n1 n1' n2 (w : word (n1' + n2)) Heq,\n  eq_rect n1' (fun n => word n)\n    (split1 n1' n2 w) n1 Heq =\n  split1 n1 n2 (eq_rect (n1'+n2) (fun n => word n) w (n1+n2) (eq_rect_split1_helper _ Heq)).\nProof.\n  intros.\n  generalize (eq_rect_split1_helper n2 Heq); intros.\n  generalize dependent Heq.\n  generalize dependent w.\n  assert (n1' = n1) as H' by lia.\n  generalize dependent e.\n  rewrite H'; intros.\n  repeat rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nTheorem eq_rect_split1_eq1 : forall n1 n1' n2 (w : word (n1 + n2)) Heq Heq1,\n  eq_rect n1 (fun n => word n)\n    (split1 n1 n2 w) n1' Heq =\n  split1 n1' n2 (eq_rect (n1+n2) (fun n => word n) w (n1'+n2) Heq1).\nProof.\n  intros.\n  generalize dependent w.\n  generalize dependent Heq1.\n  rewrite Heq; intros.\n  repeat rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nLemma split1_eq_rect_eq1_helper : forall a b c, b = a -> a + c = b + c.\nProof. intros. subst. reflexivity. Qed.\n\nTheorem split1_eq_rect_eq1 : forall a a' b H w,\n  split1 a b w = eq_rect _ word (split1 a' b\n    (eq_rect _ word w _ (split1_eq_rect_eq1_helper b H))) _ H.\nProof.\n  intros a a' b H.\n  subst a'; intros; eq_rect_simpl; auto.\nQed.\n\nTheorem eq_rect_split1_eq2 : forall n1 n2 n2' (w: word (n1 + n2)) Heq,\n     split1 n1 n2 w = split1 n1 n2'\n        (eq_rect (n1 + n2) (fun y : nat => word y) w\n     (n1 + n2') Heq).\nProof.\n  intros.\n  assert (n2 = n2') as H' by lia.\n  generalize dependent w.\n  generalize dependent Heq.\n  rewrite H'; intros.\n  rewrite <- (eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nFact eq_rect_combine_dist_helper1 : forall a b c d, b * c = d -> (a + b) * c = a * c + d.\nProof. intros; subst. apply Nat.mul_add_distr_r. Qed.\n\nFact eq_rect_combine_dist_helper2 : forall a b c d, b * c = d -> a * c + d = (a + b) * c.\nProof. intros; subst. symmetry; apply Nat.mul_add_distr_r. Qed.\n\nTheorem eq_rect_combine_dist : forall a b c d (w : word ((a + b) * c)) (H : b * c = d),\n  b * c = d ->\n  let H1 := (eq_rect_combine_dist_helper1 a b c H) in\n  let H2 := (eq_rect_combine_dist_helper2 a b c H) in\n  let w' := eq_rec ((a + b) * c) word w _ H1 in\n  w = eq_rec _ word (combine (split1 (a * c) d w') (split2 (a * c) d w')) _ H2.\nProof.\n  intros.\n  subst d.\n  rewrite combine_split.\n  eq_rect_simpl.\n  generalize dependent w.\n  generalize dependent H2.\n  rewrite H1.\n  intros.\n  eq_rect_simpl; auto.\nQed.\n\nLemma wzero_dist : forall a b c H,\n  wzero ((a + b) * c) = eq_rect _ word (wzero (a * c + b * c)) _ H.\nProof.\n  intros a b c H.\n  rewrite H.\n  reflexivity.\nQed.\n\nLemma wzero_rev : forall (a b : nat) H,\n   wzero (a + b) = eq_rect _ word (wzero (b + a)) _ H.\nProof. intros a b H. rewrite H. auto. Qed.\n\nLemma split1_zero : forall sz1 sz2, split1 sz1 sz2 (natToWord _ O) = natToWord _ O.\nProof.\n  induction sz1; auto; simpl; intros.\n  f_equal. eauto.\nQed.\n\nLemma split2_zero : forall sz1 sz2, split2 sz1 sz2 (natToWord _ O) = natToWord _ O.\nProof.\n  induction sz1; auto.\nQed.\n\nTheorem combine_inj : forall sz1 sz2 a b c d,\n  @combine sz1 a sz2 b = @combine sz1 c sz2 d -> a = c /\\ b = d.\nProof.\n  induction sz1; simpl; intros.\n  - rewrite (word0 a) in *.\n    rewrite (word0 c) in *.\n    simpl in *.\n    intuition.\n  - rewrite (shatter_word a) in *.\n    rewrite (shatter_word c) in *.\n    simpl in *.\n    inversion H.\n    apply (inj_pair2_eq_dec _ Nat.eq_dec) in H2.\n    destruct (IHsz1 _ _ _ _ _ H2).\n    intuition.\n    f_equal; auto.\nQed.\n\nTheorem combine_wzero : forall sz1 sz2, combine (wzero sz1) (wzero sz2) = wzero (sz1 + sz2).\nProof.\n  induction sz1; auto.\n  unfold wzero in *.\n  intros; simpl; f_equal; auto.\nQed.\n\nTheorem combine_wones : forall sz1 sz2, combine (wones sz1) (wones sz2) = wones (sz1 + sz2).\nProof.\n  induction sz1; auto.\n  intros; simpl; f_equal; auto.\nQed.\n\nTheorem wordToN_nat : forall sz (w : word sz), wordToN w = N_of_nat (wordToNat w).\nProof.\n  induction w; intuition.\n  destruct b; unfold wordToN, wordToNat; fold wordToN; fold wordToNat.\n\n  rewrite N_of_S.\n  rewrite N_of_mult.\n  rewrite <- IHw. \n  rewrite Nmult_comm.\n  reflexivity.\n\n  rewrite N_of_mult.\n  rewrite <- IHw.\n  rewrite Nmult_comm.\n  reflexivity.\nQed.\n\nLemma wordToN_to_nat sz: forall (w: word sz), BinNat.N.to_nat (wordToN w) = wordToNat w.\nProof.\n  intros.\n  rewrite wordToN_nat.\n  rewrite Nnat.Nat2N.id.\n  reflexivity.\nQed.\n\nLocal Hint Extern 1 (@eq nat _ _) => lia.\n\nTheorem mod2_S : forall n k,\n  2 * k = S n\n  -> mod2 n = true.\n  induction n as [n] using strong; intros.\n  destruct n; simpl in *.\n  exfalso; lia.\n  destruct n; simpl in *; auto.\n  destruct k as [|k]; simpl in *.\n  discriminate.\n  apply H with k; auto.\nQed.\n\nTheorem wzero'_def : forall sz, wzero' sz = wzero sz.\n  unfold wzero; induction sz; simpl; intuition.\n  congruence.\nQed.\n\nTheorem posToWord_nat : forall p sz, posToWord sz p = natToWord sz (nat_of_P p).\n  induction p as [ p IHp | p IHp | ]; destruct sz; simpl; intuition; f_equal; try rewrite wzero'_def in *.\n\n  rewrite ZL6.\n  destruct (ZL4 p) as [x Heq]; rewrite Heq; simpl.\n  replace (x + S x) with (S (2 * x)) by lia.\n  symmetry; apply mod2_S_double.\n\n  rewrite IHp.\n  rewrite ZL6.\n  destruct (nat_of_P p); simpl; intuition.\n  replace (n + S n) with (S (2 * n)) by lia.\n  rewrite div2_S_double; auto.\n\n  unfold nat_of_P; simpl.\n  rewrite ZL6.\n  replace (nat_of_P p + nat_of_P p) with (2 * nat_of_P p) by lia.\n  symmetry; apply mod2_double.\n\n  rewrite IHp.\n  unfold nat_of_P; simpl.\n  rewrite ZL6.\n  replace (nat_of_P p + nat_of_P p) with (2 * nat_of_P p) by lia.\n  rewrite div2_double.\n  auto.\n  auto.\nQed.\n\nLemma posToWord_sz0: forall p, posToWord 0 p = $0.\nProof.\n  intros. unfold posToWord. destruct p; reflexivity.\nQed.\n\nTheorem NToWord_nat : forall sz n, NToWord sz n = natToWord sz (nat_of_N n).\n  destruct n; simpl; intuition; try rewrite wzero'_def in *.\n  auto.\n  apply posToWord_nat.\nQed.\n\nTheorem wplus_alt : forall sz (x y : word sz), wplus x y = wplusN x y.\n  unfold wplusN, wplus, wordBinN, wordBin; intros.\n\n  repeat rewrite wordToN_nat; repeat rewrite NToWord_nat.\n  rewrite nat_of_Nplus.\n  repeat rewrite nat_of_N_of_nat.\n  reflexivity.\nQed.\n\nTheorem wmult_alt : forall sz (x y : word sz), wmult x y = wmultN x y.\n  unfold wmultN, wmult, wordBinN, wordBin; intros.\n\n  repeat rewrite wordToN_nat; repeat rewrite NToWord_nat.\n  rewrite nat_of_Nmult.\n  repeat rewrite nat_of_N_of_nat.\n  reflexivity.\nQed.\n\nTheorem wneg_alt : forall sz (x : word sz), wneg x = wnegN x.\n  unfold wnegN, wneg; intros.\n  repeat rewrite wordToN_nat; repeat rewrite NToWord_nat.\n  rewrite nat_of_Nminus.\n  do 2 f_equal.\n  apply Npow2_nat.\n  apply nat_of_N_of_nat.\nQed.\n\nTheorem wminus_Alt : forall sz (x y : word sz), wminus x y = wminusN x y.\n  intros; unfold wminusN, wminus; rewrite wneg_alt; apply wplus_alt.\nQed.\n\nTheorem wplus_unit : forall sz (x : word sz), natToWord sz 0 ^+ x = x.\n  intros; rewrite wplus_alt; unfold wplusN, wordBinN; intros.\n  rewrite roundTrip_0; apply natToWord_wordToNat.\nQed.\n\nTheorem wplus_comm : forall sz (x y : word sz), x ^+ y = y ^+ x.\n  intros; repeat rewrite wplus_alt; unfold wplusN, wordBinN; f_equal; auto.\nQed.\n\nTheorem drop_sub :\n  forall sz n k,\n    (k * pow2 sz <= n)%nat ->\n    natToWord sz (n - k * pow2 sz) = natToWord sz n.\nProof.\n  induction sz as [|sz IHsz]; simpl; intros n k *; intuition; repeat rewrite untimes2 in *; f_equal.\n\n  rewrite Nat.mul_assoc.\n  rewrite (Nat.mul_comm k).\n  rewrite <- Nat.mul_assoc.\n  apply drop_mod2.\n  rewrite Nat.mul_assoc.\n  rewrite (Nat.mul_comm 2).\n  rewrite <- Nat.mul_assoc.\n  auto.\n\n  rewrite <- (IHsz (Nat.div2 n) k).\n  rewrite Nat.mul_assoc.\n  rewrite (Nat.mul_comm k).\n  rewrite <- Nat.mul_assoc.\n  rewrite div2_minus_2.\n  reflexivity.\n  rewrite Nat.mul_assoc.\n  rewrite (Nat.mul_comm 2).\n  rewrite <- Nat.mul_assoc.\n  auto.\n\n  apply div2_bound.\n  rewrite Nat.mul_assoc.\n  rewrite (Nat.mul_comm 2).\n  rewrite <- Nat.mul_assoc.\n  auto.\nQed.\n\nLocal Hint Extern 1 (_ <= _)%nat => lia.\n\nTheorem wplus_assoc : forall sz (x y z : word sz), x ^+ (y ^+ z) = x ^+ y ^+ z.\n  intros sz x y z *; repeat rewrite wplus_alt; unfold wplusN, wordBinN; intros.\n\n  repeat match goal with\n           | [ |- context[wordToNat (natToWord ?sz ?w)] ] =>\n             let Heq := fresh \"Heq\" in\n               destruct (wordToNat_natToWord sz w) as [? [Heq ?]]; rewrite Heq\n         end.\n\n  match goal with\n  | [ |- context[wordToNat ?x + wordToNat ?y - ?x1 * pow2 ?sz + wordToNat ?z] ]\n    => replace (wordToNat x + wordToNat y - x1 * pow2 sz + wordToNat z)\n      with (wordToNat x + wordToNat y + wordToNat z - x1 * pow2 sz) by auto\n  end.\n  match goal with\n  | [ |- context[wordToNat ?x + (wordToNat ?y + wordToNat ?z - ?x0 * pow2 ?sz)] ]\n    => replace (wordToNat x + (wordToNat y + wordToNat z - x0 * pow2 sz))\n      with (wordToNat x + wordToNat y + wordToNat z - x0 * pow2 sz) by auto\n  end.\n  repeat rewrite drop_sub; auto.\nQed.\n\nTheorem roundTrip_1 : forall sz, wordToNat (natToWord (S sz) 1) = 1.\n  induction sz; simpl in *; intuition.\nQed.\n\nTheorem roundTrip_1': forall sz, sz <> 0 -> wordToNat (natToWord sz 1) = 1.\nProof.\n  intros.\n  destruct sz.\n  - tauto.\n  - apply roundTrip_1.\nQed.\n\n\nTheorem mod2_WS : forall sz (x : word sz) b, mod2 (wordToNat (WS b x)) = b.\n  intros sz x b. rewrite wordToNat_wordToNat'.\n  destruct b; simpl.\n\n  rewrite untimes2.\n  case_eq (2 * wordToNat x); intuition.\n  eapply mod2_S; eauto.\n  rewrite <- (mod2_double (wordToNat x)); f_equal; lia.\nQed.\n\nTheorem div2_WS : forall sz (x : word sz) b, Nat.div2 (wordToNat (WS b x)) = wordToNat x.\n  destruct b; rewrite wordToNat_wordToNat'; unfold wordToNat'; fold wordToNat'.\n  apply div2_S_double.\n  apply div2_double.\nQed.\n\nTheorem wmult_unit : forall sz (x : word sz), natToWord sz 1 ^* x = x.\n  intros sz x; rewrite wmult_alt; unfold wmultN, wordBinN; intros.\n  destruct sz; simpl.\n  rewrite (shatter_word x); reflexivity.\n  rewrite roundTrip_0; simpl.\n  rewrite Nat.add_0_r.\n  rewrite (shatter_word x).\n  f_equal.\n\n  apply mod2_WS.\n\n  rewrite div2_WS.\n  apply natToWord_wordToNat.\nQed.\n\nTheorem wmult_comm : forall sz (x y : word sz), x ^* y = y ^* x.\n  intros; repeat rewrite wmult_alt; unfold wmultN, wordBinN; auto with arith.\nQed.\n\nTheorem wmult_unit_r : forall sz (x : word sz), x ^* natToWord sz 1 = x.\nProof.\n  intros.\n  rewrite wmult_comm.\n  apply wmult_unit.\nQed.\n\nLemma wmult_neut_l: forall (sz : nat) (x : word sz), $0 ^* x = $0.\nProof.\n  intros. unfold wmult. unfold wordBin. do 2 rewrite wordToN_nat.\n  rewrite <- Nnat.Nat2N.inj_mul. rewrite roundTrip_0.\n  rewrite Nat.mul_0_l. simpl. rewrite wzero'_def. reflexivity.\nQed.\n\nLemma wmult_neut_r: forall (sz : nat) (x : word sz), x ^* $0 = $0.\nProof.\n  intros. unfold wmult. unfold wordBin. do 2 rewrite wordToN_nat.\n  rewrite <- Nnat.Nat2N.inj_mul. rewrite roundTrip_0.\n  rewrite Nat.mul_0_r. simpl. rewrite wzero'_def. reflexivity.\nQed.\n\nTheorem wmult_assoc : forall sz (x y z : word sz), x ^* (y ^* z) = x ^* y ^* z.\n  intros sz x y z; repeat rewrite wmult_alt; unfold wmultN, wordBinN; intros.\n\n  repeat match goal with\n           | [ |- context[wordToNat (natToWord ?sz ?w)] ] =>\n             let Heq := fresh \"Heq\" in\n               destruct (wordToNat_natToWord sz w) as [? [Heq ?]]; rewrite Heq\n         end.\n\n  rewrite Nat.mul_sub_distr_l.\n  rewrite Nat.mul_sub_distr_r.\n  match goal with\n  | [ |- natToWord _ (_ - _ * (?x0' * _)) = natToWord _ (_ - ?x1' * _ * _) ]\n    => rename x0' into x0, x1' into x1 (* force the names to not be autogenerated *)\n  end.\n  rewrite (Nat.mul_assoc (wordToNat x) x0).\n  rewrite <- (Nat.mul_assoc x1).\n  rewrite (Nat.mul_comm (pow2 sz)).\n  rewrite (Nat.mul_assoc x1).\n  repeat rewrite drop_sub; auto with arith.\n  rewrite (Nat.mul_comm x1).\n  rewrite <- (Nat.mul_assoc (wordToNat x)).\n  rewrite (Nat.mul_comm (wordToNat y)).\n  rewrite Nat.mul_assoc.\n  rewrite (Nat.mul_comm (wordToNat x)).\n  repeat rewrite <- Nat.mul_assoc.\n  auto with arith.\n  repeat rewrite <- Nat.mul_assoc.\n  auto with arith.\nQed.\n\nTheorem wmult_plus_distr : forall sz (x y z : word sz), (x ^+ y) ^* z = (x ^* z) ^+ (y ^* z).\n  intros sz x y z; repeat rewrite wmult_alt; repeat rewrite wplus_alt; unfold wmultN, wplusN, wordBinN; intros.\n\n  repeat match goal with\n           | [ |- context[wordToNat (natToWord ?sz ?w)] ] =>\n             let Heq := fresh \"Heq\" in\n               destruct (wordToNat_natToWord sz w) as [? [Heq ?]]; rewrite Heq\n         end.\n\n  rewrite Nat.mul_sub_distr_r.\n  match goal with\n  | [ |- natToWord _ (_ - ?x0' * _ * _) = natToWord _ (_ - ?x1' * _ + (_ - ?x2' * _)) ]\n    => rename x0' into x0, x1' into x1, x2' into x2 (* force the names to not be autogenerated *)\n  end.\n  rewrite <- (Nat.mul_assoc x0).\n  rewrite (Nat.mul_comm (pow2 sz)).\n  rewrite (Nat.mul_assoc x0).\n\n  replace (wordToNat x * wordToNat z - x1 * pow2 sz +\n    (wordToNat y * wordToNat z - x2 * pow2 sz))\n    with (wordToNat x * wordToNat z + wordToNat y * wordToNat z - x1 * pow2 sz - x2 * pow2 sz).\n  repeat rewrite drop_sub; auto with arith.\n  rewrite (Nat.mul_comm x0).\n  rewrite (Nat.mul_comm (wordToNat x + wordToNat y)).\n  rewrite <- (Nat.mul_assoc (wordToNat z)).\n  auto with arith.\n  generalize dependent (wordToNat x * wordToNat z).\n  generalize dependent (wordToNat y * wordToNat z).\n  intros.\n  lia.\nQed.\n\nTheorem wminus_def : forall sz (x y : word sz), x ^- y = x ^+ ^~ y.\n  reflexivity.\nQed.\n\nTheorem wordToNat_bound : forall sz (w : word sz), (wordToNat w < pow2 sz)%nat.\n  induction w as [|b]; simpl; intuition.\n  destruct b; simpl; lia.\nQed.\n\nTheorem natToWord_pow2 : forall sz, natToWord sz (pow2 sz) = natToWord sz 0.\n  induction sz as [|sz]; simpl; intuition.\n\n  generalize (div2_double (pow2 sz)); simpl; intro Hr; rewrite Hr; clear Hr.\n  f_equal.\n  generalize (mod2_double (pow2 sz)); auto.\n  auto.\nQed.\n\nTheorem wminus_inv : forall sz (x : word sz), x ^+ ^~ x = wzero sz.\n  intros sz x; rewrite wneg_alt; rewrite wplus_alt; unfold wnegN, wplusN, wzero, wordBinN; intros.\n\n  repeat match goal with\n           | [ |- context[wordToNat (natToWord ?sz ?w)] ] =>\n             let Heq := fresh \"Heq\" in\n               destruct (wordToNat_natToWord sz w) as [? [Heq ?]]; rewrite Heq\n         end.\n\n  match goal with\n  | [ |- context[wordToNat ?x + (pow2 ?sz - wordToNat ?x - ?x0 * pow2 ?sz)] ]\n    => replace (wordToNat x + (pow2 sz - wordToNat x - x0 * pow2 sz))\n      with (pow2 sz - x0 * pow2 sz)\n  end.\n  rewrite drop_sub; auto with arith.\n  apply natToWord_pow2.\n  generalize (wordToNat_bound x).\n  lia.\nQed.\n\nLemma wminus_diag: forall sz (w: word sz),\n    w ^- w = $0.\nProof.\n  intros. unfold wminus. apply wminus_inv.\nQed.\n\nLemma wneg_0_wminus: forall {sz: nat} (x: word sz),\n    ^~ x = $0 ^- x.\nProof.\n  intros.\n  rewrite <- wplus_unit at 1.\n  reflexivity.\nQed.\n\nDefinition wring (sz : nat) : ring_theory (wzero sz) (wone sz) (@wplus sz) (@wmult sz) (@wminus sz) (@wneg sz) (@eq _) :=\n  mk_rt _ _ _ _ _ _ _\n  (@wplus_unit _) (@wplus_comm _) (@wplus_assoc _)\n  (@wmult_unit _) (@wmult_comm _) (@wmult_assoc _)\n  (@wmult_plus_distr _) (@wminus_def _) (@wminus_inv _).\n\nTheorem weqb_sound : forall sz (x y : word sz), weqb x y = true -> x = y.\nProof.\n  eapply weqb_true_iff.\nQed.\n\nArguments weqb_sound : clear implicits.\n\nLemma weqb_eq: forall sz (a b: word sz), a = b -> weqb a b = true.\nProof. intros. rewrite weqb_true_iff. assumption. Qed.\n\nLemma weqb_ne: forall sz (a b: word sz), a <> b -> weqb a b = false.\nProof.\n  intros. destruct (weqb a b) eqn: E.\n  - rewrite weqb_true_iff in E. contradiction.\n  - reflexivity.\nQed.\n\nLemma weqb_false: forall sz (a b: word sz), weqb a b = false -> a <> b.\nProof.\n  intros. destruct (weqb a b) eqn: E.\n  - discriminate.\n  - intro C. subst. rewrite weqb_eq in E; congruence.\nQed.\n\nLtac is_nat_cst n :=\n  match eval hnf in n with\n    | O => constr:(true)\n    | S ?n' => is_nat_cst n'\n    | _ => constr:(false)\n  end.\n\nLtac isWcst w :=\n  match eval hnf in w with\n    | WO => constr:(true)\n    | WS ?b ?w' =>\n      match eval hnf in b with\n        | true => isWcst w'\n        | false => isWcst w'\n        | _ => constr:(false)\n      end\n    | natToWord _ ?n => is_nat_cst n\n    | _ => constr:(false)\n  end.\n\nLtac wcst w :=\n  let b := isWcst w in\n    match b with\n      | true => w\n      | _ => constr:(NotConstant)\n    end.\n\n(* Here's how you can add a ring for a specific bit-width.\n   There doesn't seem to be a polymorphic method, so this code really does need to be copied. *)\n\n(*\nDefinition wring8 := wring 8.\nAdd Ring wring8 : wring8 (decidable (weqb_sound 8), constants [wcst]).\n*)\n\nLtac noptac x := idtac.\n\nLtac PackWring sz F :=\n  let RNG := (fun proj => proj\n    inv_morph_nothing inv_morph_nothing noptac noptac\n    (word sz) (@eq (word sz)) (wzero sz) (wone sz)\n    (@wplus sz) (@wmult sz) (@wminus sz) (@wneg sz)\n    (BinNums.Z) (BinNums.N) (id_phi_N)\n    (pow_N (wone sz) (@wmult sz))\n    (ring_correct (@Eqsth (word sz))\n                  (Eq_ext _ _ _)\n                  (Rth_ARth (@Eqsth (word sz)) (Eq_ext _ _ _) (wring sz))\n                  (gen_phiZ_morph (@Eqsth (word sz)) (Eq_ext _ _ _) (wring sz))\n                  (pow_N_th _ _ (@Eqsth (word sz)))\n                  (triv_div_th (@Eqsth (word sz))\n                               (Eq_ext _ _ _)\n                               (Rth_ARth (@Eqsth (word sz)) (Eq_ext _ _ _) (wring sz))\n                               (gen_phiZ_morph (@Eqsth (word sz)) (Eq_ext _ _ _) (wring sz)))\n    )\n    tt) in\n  F RNG (@nil (word sz)) (@nil (word sz)).\n\nLtac ring_sz sz := PackWring sz Ring_gen.\n\nFact bitwp_wtl : forall sz (w w' : word (S sz)) op, bitwp op (wtl w) (wtl w') = wtl (bitwp op w w').\nProof.\n  intros.\n  rewrite (shatter_word w), (shatter_word w').\n  auto.\nQed.\n\nLemma split1_bitwp_dist : forall sz1 sz2 w w' op,\n  split1 sz1 sz2 (bitwp op w w') = bitwp op (split1 sz1 sz2 w) (split1 sz1 sz2 w').\nProof.\n  induction sz1; intros; auto.\n  simpl.\n  f_equal.\n  rewrite (shatter_word w), (shatter_word w'); auto.\n  rewrite <- IHsz1, bitwp_wtl.\n  reflexivity.\nQed.\n\nLemma split2_bitwp_dist : forall sz1 sz2 w w' op,\n  split2 sz1 sz2 (bitwp op w w') = bitwp op (split2 sz1 sz2 w) (split2 sz1 sz2 w').\nProof.\n  induction sz1; intros; auto.\n  simpl; rewrite <- IHsz1, bitwp_wtl.\n  reflexivity.\nQed.\n\nLemma combine_bitwp : forall sz1 sz2 (wa wa' : word sz1) (wb wb' : word sz2) op,\n  combine (bitwp op wa wa') (bitwp op wb wb') = bitwp op (combine wa wb) (combine wa' wb').\nProof.\n  induction sz1; intros; rewrite (shatter_word wa), (shatter_word wa'); simpl; f_equal; auto.\nQed.\n\nLemma eq_rect_bitwp : forall a b Heq f w1 w2,\n  bitwp f w1 w2 = eq_rect a word (\n    bitwp f (eq_rect b word w1 a Heq) (eq_rect b word w2 a Heq)) b (eq_sym Heq).\nProof.\n  intros a b H; subst a.\n  intros; eq_rect_simpl; reflexivity.\nQed.\n\nFact eq_rect_bitwp' : forall a b Heq f w1 w2,\n  eq_rect b word (bitwp f w1 w2) a Heq = bitwp f (eq_rect b word w1 a Heq) (eq_rect b word w2 a Heq).\nProof.\n  intros a b H1; subst a.\n  intros; eq_rect_simpl; reflexivity.\nQed.\n\nFact eq_rect_bitwp_1 : forall a b Heq f w1 w2,\n  bitwp f (eq_rect a word w1 b Heq) w2 = eq_rect a word (bitwp f w1 (eq_rect b word w2 a (eq_sym Heq))) b Heq.\nProof.\n  intros a b H.\n  subst a; intros; eq_rect_simpl; auto.\nQed.\n\nTheorem wnot_wnot'_equiv : forall sz (w : word sz), wnot w = wnot' w.\nProof.\n  unfold wnot'.\n  induction sz; intros w; shatterer.\nQed.\n\nTheorem wnot_split1 : forall sz1 sz2 w, wnot (split1 sz1 sz2 w) = split1 sz1 sz2 (wnot w).\nProof.\n  intros.\n  repeat rewrite wnot_wnot'_equiv.\n  unfold wnot'.\n  erewrite <- split1_combine with (w := wones _).\n  rewrite <- split1_bitwp_dist, combine_wones.\n  reflexivity.\nQed.\n\nTheorem wnot_split2 : forall sz1 sz2 w, wnot (split2 sz1 sz2 w) = split2 sz1 sz2 (wnot w).\nProof.\n  intros.\n  repeat rewrite wnot_wnot'_equiv.\n  unfold wnot'.\n  erewrite <- split2_combine with (z := wones _).\n  rewrite <- split2_bitwp_dist, combine_wones.\n  reflexivity.\nQed.\n\nTheorem wnot_combine : forall sz1 sz2 (w1 : word sz1) (w2 : word sz2),\n  wnot (combine w1 w2) = combine (wnot w1) (wnot w2).\nProof.\n  intros.\n  repeat rewrite wnot_wnot'_equiv.\n  unfold wnot'.\n  rewrite <- combine_wones, combine_bitwp.\n  reflexivity.\nQed.\n\nTheorem wnot_zero: forall sz, wnot (wzero sz) = wones sz.\nProof.\n  induction sz; simpl; f_equal; eauto.\nQed.\n\nTheorem wnot_ones : forall sz, wnot (wones sz) = wzero sz.\nProof.\n  induction sz; simpl; f_equal; try rewrite IHsz; eauto.\nQed.\n\nTheorem wnot_eq_rect : forall a b H (w : word a), wnot (eq_rect a word w b H) = eq_rect a word (wnot w) b H.\nProof.\n  intros.\n  subst b; eq_rect_simpl; auto.\nQed.\n\nTheorem wor_unit : forall sz (x : word sz), wzero sz ^| x = x.\nProof.\n  unfold wzero, wor; induction x; simpl; intuition congruence.\nQed.\n\nTheorem wor_comm : forall sz (x y : word sz), x ^| y = y ^| x.\nProof.\n  unfold wor; induction x; intro y; rewrite (shatter_word y); simpl; intuition; f_equal; auto with bool.\nQed.\n\nTheorem wor_assoc : forall sz (x y z : word sz), x ^| (y ^| z) = x ^| y ^| z.\nProof.\n  unfold wor; induction x; intro y; rewrite (shatter_word y); simpl; intuition; f_equal; auto with bool.\nQed.\n\nTheorem wand_unit : forall sz (x : word sz), wones sz ^& x = x.\nProof.\n  unfold wand; induction x; simpl; intuition congruence.\nQed.\n\nTheorem wand_kill : forall sz (x : word sz), wzero sz ^& x = wzero sz.\nProof.\n  unfold wzero, wand; induction x; simpl; intuition congruence.\nQed.\n\nTheorem wand_comm : forall sz (x y : word sz), x ^& y = y ^& x.\nProof.\n  unfold wand; induction x; intro y; rewrite (shatter_word y); simpl; intuition; f_equal; auto with bool.\nQed.\n\nTheorem wand_assoc : forall sz (x y z : word sz), x ^& (y ^& z) = x ^& y ^& z.\nProof.\n  unfold wand; induction x; intro y; rewrite (shatter_word y); simpl; intuition; f_equal; auto with bool.\nQed.\n\nTheorem wand_or_distr : forall sz (x y z : word sz), (x ^| y) ^& z = (x ^& z) ^| (y ^& z).\nProof.\n  unfold wand, wor; induction x; intro y; rewrite (shatter_word y); intro z; rewrite (shatter_word z); simpl; intuition; f_equal; auto with bool.\n  destruct (whd y); destruct (whd z); destruct b; reflexivity.\nQed.\n\nLemma wor_wones : forall sz w, wones sz ^| w = wones sz.\nProof.\n  unfold wor; induction sz; intros; simpl; auto.\n  rewrite IHsz; auto.\nQed.\n\nLemma wor_wzero : forall sz w, wzero sz ^| w = w.\nProof.\n  unfold wor; induction sz; shatterer.\nQed.\n\nLemma wand_wones : forall sz w, wones sz ^& w = w.\nProof.\n  unfold wand; induction sz; shatterer.\nQed.\n\nLemma wand_wzero : forall sz w, wzero sz ^& w = wzero sz.\nProof.\n  intros. rewrite <- wzero'_def.\n  unfold wand; induction sz; shatterer.\nQed.\n\nLemma wxor_wones : forall sz w, wxor (wones sz) w = wnot w.\nProof.\n  unfold wxor; induction sz; shatterer.\nQed.\n\nLemma wxor_wzero : forall sz w, wxor (wzero sz) w = w.\nProof.\n  unfold wxor; induction sz; shatterer; destruct (whd w); auto.\nQed.\n\nLemma wxor_comm : forall sz (w1 w2 : word sz), wxor w1 w2 = wxor w2 w1.\nProof.\n  unfold wxor; induction sz. shatterer.\n  intros. rewrite (shatter_word w1), (shatter_word w2).\n  simpl.\n  rewrite xorb_comm, IHsz.\n  reflexivity.\nQed.\n\nLemma wxor_assoc : forall sz (w1 w2 w3 : word sz), wxor w1 (wxor w2 w3) = wxor (wxor w1 w2) w3.\nProof.\n  unfold wxor.\n  induction sz; intros; rewrite (shatter_word w1), (shatter_word w2), (shatter_word w3); auto.\n  simpl; f_equal.\n  rewrite xorb_assoc_reverse; auto.\n  rewrite IHsz.\n  reflexivity.\nQed.\n\nLemma wor_wone : forall sz (w : word sz) b,\n  WS b w ^| wone _ = WS true w.\nProof.\n  intros.\n  compute [wone natToWord wor]. simpl.\n  fold natToWord.\n  change (natToWord sz 0) with (wzero sz).\n  rewrite orb_true_r.\n  rewrite wor_comm, wor_wzero.\n  reflexivity.\nQed.\n\nLemma wand_wone : forall sz (w : word sz) b,\n  WS b w ^& wone _ = WS b (wzero _).\nProof.\n  intros.\n  compute [wone natToWord wand]. simpl.\n  fold natToWord.\n  change (natToWord sz 0) with (wzero sz).\n  rewrite andb_true_r.\n  rewrite wand_comm, wand_wzero.\n  reflexivity.\nQed.\n\nLemma wxor_wone : forall sz (w : word sz) b,\n  wxor (WS b w) (wone _) = WS (negb b) w.\nProof.\n  intros.\n  compute [wone natToWord wxor]. simpl.\n  fold natToWord.\n  change (natToWord sz 0) with (wzero sz).\n  rewrite xorb_true_r.\n  rewrite wxor_comm, wxor_wzero.\n  reflexivity.\nQed.\n\nDefinition wbring (sz : nat) : semi_ring_theory (wzero sz) (wones sz) (@wor sz) (@wand sz) (@eq _) :=\n  mk_srt _ _ _ _ _\n  (@wor_unit _) (@wor_comm _) (@wor_assoc _)\n  (@wand_unit _) (@wand_kill _) (@wand_comm _) (@wand_assoc _)\n  (@wand_or_distr _).\n\n(** * Inequality proofs *)\n\nLtac word_simpl := unfold sext, zext, wzero in *; simpl in *.\n\nLtac word_eq := ring.\n\nLtac word_eq1 := match goal with\n                   | _ => ring\n                   | [ H : _ = _ |- _ ] => ring [H]\n                 end.\n\nTheorem word_neq : forall sz (w1 w2 : word sz),\n  w1 ^- w2 <> wzero sz\n  -> w1 <> w2.\n  intros; intro; subst.\n  unfold wminus in H.\n  rewrite wminus_inv in H.\n  tauto.\nQed.\n\nLtac word_neq := apply word_neq; let H := fresh \"H\" in intro H; simpl in H; ring_simplify in H; try discriminate.\n\nLtac word_contra := match goal with\n                      | [ H : _ <> _ |- False ] => apply H; ring\n                    end.\n\nLtac word_contra1 := match goal with\n                       | [ H : _ <> _ |- False ] => apply H;\n                         match goal with\n                           | _ => ring\n                           | [ H' : _ = _ |- _ ] => ring [H']\n                         end\n                     end.\n\nLemma not_wlt_ge : forall sz (l r : word sz),\n  ((l < r) -> False) -> (r <= l).\nProof.\n  intros.\n  case_eq (wlt_dec l r); intros;\n    try contradiction;\n    auto.\nQed.\n\nLemma not_wle_gt : forall sz (l r : word sz),\n  ((l <= r) -> False) -> (r < l).\nProof.\n  intros.\n  case_eq (wlt_dec r l); intros;\n    try contradiction;\n    auto.\nQed.\n\nLemma lt_le : forall sz (a b : word sz),\n  a < b -> a <= b.\nProof.\n  unfold wlt, N.lt. intros sz a b H H0. rewrite N.compare_antisym in H0. rewrite H in H0. simpl in *. congruence.\nQed.\n\nLemma eq_le : forall sz (a b : word sz),\n  a = b -> a <= b.\nProof.\n  intros; subst. unfold wlt, N.lt. rewrite N.compare_refl. congruence.\nQed.\n\nLemma wordToN_inj : forall sz (a b : word sz),\n  wordToN a = wordToN b -> a = b.\nProof.\n  induction a; intro b0; rewrite (shatter_word b0); intuition.\n  simpl in H.\n  destruct b; destruct (whd b0); intros.\n  f_equal. eapply IHa. eapply N.succ_inj in H.\n  destruct (wordToN a); destruct (wordToN (wtl b0)); try congruence.\n  destruct (wordToN (wtl b0)); destruct (wordToN a); inversion H.\n  destruct (wordToN (wtl b0)); destruct (wordToN a); inversion H.\n  f_equal. eapply IHa.\n  destruct (wordToN a); destruct (wordToN (wtl b0)); try congruence.\nQed.\n\nLemma wordToNat_inj : forall sz (a b : word sz),\n  wordToNat a = wordToNat b -> a = b.\nProof.\n  intros; apply wordToN_inj.\n  repeat rewrite wordToN_nat.\n  apply Nat2N.inj_iff; auto.\nQed.\n\nLemma unique_inverse : forall sz (a b1 b2 : word sz),\n  a ^+ b1 = wzero _ ->\n  a ^+ b2 = wzero _ ->\n  b1 = b2.\nProof.\n  intros sz a b1 b2 H *.\n  transitivity (b1 ^+ wzero _).\n  rewrite wplus_comm. rewrite wplus_unit. auto.\n  transitivity (b1 ^+ (a ^+ b2)). congruence.\n  rewrite wplus_assoc.\n  rewrite (wplus_comm b1). rewrite H. rewrite wplus_unit. auto.\nQed.\n\nLemma sub_0_eq : forall sz (a b : word sz),\n  a ^- b = wzero _ -> a = b.\nProof.\n  intros sz a b H. destruct (weq (wneg b) (wneg a)) as [e|n].\n  transitivity (a ^+ (^~ b ^+ b)).\n  rewrite (wplus_comm (^~ b)). rewrite wminus_inv.\n  rewrite wplus_comm. rewrite wplus_unit. auto.\n  rewrite e. rewrite wplus_assoc. rewrite wminus_inv. rewrite wplus_unit. auto.\n  unfold wminus in H.\n  generalize (unique_inverse a (wneg a) (^~ b)).\n  intro H0. exfalso. apply n. symmetry; apply H0.\n  apply wminus_inv.\n  auto.\nQed.\n\nLemma le_neq_lt : forall sz (a b : word sz),\n  b <= a -> a <> b -> b < a.\nProof.\n  intros sz a b H H0; destruct (wlt_dec b a) as [?|n]; auto.\n  exfalso. apply H0. unfold wlt, N.lt in *.\n  eapply wordToN_inj. eapply Ncompare_eq_correct.\n  case_eq ((wordToN a ?= wordToN b)%N); auto; try congruence.\n  intros H1. rewrite N.compare_antisym in n. rewrite H1 in n. simpl in *. congruence.\nQed.\n\n\n#[global] Hint Resolve word_neq lt_le eq_le sub_0_eq le_neq_lt : worder.\n\nLtac shatter_word x :=\n  match type of x with\n    | word 0 => try rewrite (shatter_word_0 x) in *\n    | word (S ?N) =>\n      let x' := fresh in\n      let H := fresh in\n      destruct (@shatter_word_S N x) as [ ? [ x' H ] ];\n      rewrite H in *; clear H; shatter_word x'\n  end.\n\n\n(** Uniqueness of equality proofs **)\nLemma rewrite_weq : forall sz (a b : word sz)\n  (pf : a = b),\n  weq a b = left _ pf.\nProof.\n  intros sz a b *; destruct (weq a b); try solve [ exfalso; auto ].\n  f_equal.\n  eapply UIP_dec. eapply weq.\nQed.\n\n\n(** * Some more useful derived facts *)\n\nLemma natToWord_plus : forall sz n m, natToWord sz (n + m) = natToWord _ n ^+ natToWord _ m.\n  destruct sz as [|sz]; intros n m; intuition.\n  rewrite wplus_alt.\n  unfold wplusN, wordBinN.\n  destruct (wordToNat_natToWord (S sz) n); intuition.\n  destruct (wordToNat_natToWord (S sz) m); intuition.\n  do 2 match goal with H : _ |- _ => rewrite H; clear H end.\n  match goal with\n  | [ |- context[?n - ?x * pow2 (S ?sz) + (?m - ?x0 * pow2 (S ?sz))] ]\n    => replace (n - x * pow2 (S sz) + (m - x0 * pow2 (S sz))) with (n + m - x * pow2 (S sz) - x0 * pow2 (S sz))\n      by lia\n  end.\n  repeat rewrite drop_sub; auto; lia.\nQed.\n\nLemma natToWord_S : forall sz n, natToWord sz (S n) = natToWord _ 1 ^+ natToWord _ n.\n  intros sz n; change (S n) with (1 + n); apply natToWord_plus.\nQed.\n\nTheorem natToWord_inj : forall sz n m, natToWord sz n = natToWord sz m\n  -> (n < pow2 sz)%nat\n  -> (m < pow2 sz)%nat\n  -> n = m.\n  intros sz n m H H0 H1.\n  apply (f_equal (@wordToNat _)) in H.\n  destruct (wordToNat_natToWord sz n) as [x H2].\n  destruct (wordToNat_natToWord sz m) as [x0 H3].\n  intuition.\n  match goal with\n  | [ H : wordToNat ?x = wordToNat ?y, H' : wordToNat ?x = ?a, H'' : wordToNat ?y = ?b |- _ ]\n    => let H0 := fresh in assert (H0 : a = b) by congruence; clear H H' H''; rename H0 into H\n  end.\n  assert (x = 0) by (destruct x; lia).\n  assert (x0 = 0) by (destruct x0; lia).\n  subst; simpl in *; lia.\nQed.\n\nLemma wordToNat_natToWord_idempotent : forall sz n,\n  (N.of_nat n < Npow2 sz)%N\n  -> wordToNat (natToWord sz n) = n.\n  intros sz n H.\n  destruct (wordToNat_natToWord sz n) as [x]; intuition.\n  destruct x as [|x].\n  simpl in *; lia.\n  simpl in *.\n  apply Nlt_out in H.\n  autorewrite with N in *.\n  rewrite Npow2_nat in *.\n  generalize dependent (x * pow2 sz).\n  intros; lia.\nQed.\n\nLemma wplus_cancel : forall sz (a b c : word sz),\n  a ^+ c = b ^+ c\n  -> a = b.\n  intros sz a b c H.\n  apply (f_equal (fun x => x ^+ ^~ c)) in H.\n  repeat rewrite <- wplus_assoc in H.\n  rewrite wminus_inv in H.\n  repeat rewrite (wplus_comm _ (wzero sz)) in H.\n  repeat rewrite wplus_unit in H.\n  assumption.\nQed.\n\nLemma wminus_plus_distr:\n  forall {sz} (x y z: word sz), x ^- (y ^+ z) = x ^- y ^- z.\nProof.\n  intros.\n  apply wplus_cancel with (c:= y ^+ z).\n  rewrite wminus_def, <-wplus_assoc.\n  rewrite wplus_comm with (y:= y ^+ z), wminus_inv.\n  rewrite wplus_comm with (x:= x), wplus_unit.\n  rewrite !wminus_def, <-wplus_assoc.\n  rewrite wplus_assoc with (x:= ^~ z).\n  rewrite wplus_comm with (x:= ^~ z).\n  rewrite <-wplus_assoc with (x:= y).\n  rewrite wplus_comm with (x:= ^~ z), wminus_inv.\n  rewrite wplus_comm with (x:= y), wplus_unit.\n  rewrite <-wplus_assoc.\n  rewrite wplus_comm with (x:= ^~ y), wminus_inv.\n  rewrite wplus_comm, wplus_unit.\n  reflexivity.\nQed.\n\nLemma wminus_wplus_undo: forall sz (a b: word sz),\n    a ^- b ^+ b = a.\nProof.\n  intros.\n  rewrite wminus_def.\n  rewrite <- wplus_assoc.\n  rewrite (wplus_comm (^~ b)).\n  rewrite wminus_inv.\n  rewrite wplus_comm.\n  rewrite wplus_unit.\n  reflexivity.\nQed.\n\nLemma wneg_zero:\n  forall {sz} (w: word sz), ^~ w = (natToWord sz 0) -> w = natToWord sz 0.\nProof.\n  intros.\n  apply wplus_cancel with (c:= ^~ w).\n  rewrite wminus_inv, wplus_unit; auto.\nQed.\n\nLemma wneg_idempotent:\n  forall {sz} (w: word sz), ^~ (^~ w) = w.\nProof.\n  intros.\n  apply sub_0_eq.\n  rewrite wminus_def.\n  rewrite wplus_comm.\n  apply wminus_inv.\nQed.\n\nLemma wneg_zero': forall sz,\n  wneg (natToWord sz 0) = natToWord sz 0.\nProof.\n  intros. apply wneg_zero. apply wneg_idempotent.\nQed.\n\nLemma wplus_one_neq: forall {sz} (w: word (S sz)), w ^+ (natToWord (S sz) 1) <> w.\nProof.\n  intros; intro Hx.\n  rewrite wplus_comm in Hx.\n  assert ((natToWord (S sz) 1) ^+ w ^- w = w ^- w) by (rewrite Hx; reflexivity).\n  clear Hx.\n  do 2 rewrite wminus_def in H.\n  rewrite <-wplus_assoc in H.\n  rewrite wminus_inv in H.\n  rewrite wplus_comm, wplus_unit in H.\n  inversion H.\nQed.\n\nLemma wneg_one_pow2_minus_one: forall {sz}, wordToNat (^~ (natToWord sz 1)) = pow2 sz - 1.\nProof.\n  destruct sz; auto.\n  unfold wneg; intros.\n  rewrite wordToN_nat, roundTrip_1.\n  simpl BinNat.N.of_nat.\n  rewrite NToWord_nat, Nnat.N2Nat.inj_sub, Npow2_nat.\n  apply wordToNat_natToWord_2.\n  pose (pow2_zero (S sz)).\n  lia.\nQed.\n\nLemma wones_pow2_minus_one: forall {sz}, wordToNat (wones sz) = pow2 sz - 1.\nProof.\n  induction sz; simpl; auto.\n  rewrite IHsz; pose (pow2_zero sz).\n  lia.\nQed.\n\nLemma pow2_minus_one_wones: forall {sz} (w: word sz),\n    wordToNat w = pow2 sz - 1 -> w = wones sz.\nProof.\n  intros; rewrite <-wones_pow2_minus_one in H.\n  apply wordToNat_inj; auto.\nQed.\n\nLemma wones_natToWord: forall sz,\n  wones sz = $ (pow2 sz - 1).\nProof.\n  induction sz.\n  - reflexivity.\n  - unfold wones. fold wones. rewrite IHsz.\n    unfold natToWord at 2. fold natToWord. f_equal.\n    + rewrite mod2sub.\n      * simpl. rewrite mod2_pow2_twice. reflexivity.\n      * pose proof (zero_lt_pow2 (S sz)). lia.\n    + f_equal. unfold pow2 at 2. fold pow2.\n      rewrite <- (div2_S_double (pow2 sz - 1)). f_equal.\n      pose proof (zero_lt_pow2 sz). lia.\nQed.\n\nLemma wones_wneg_one: forall {sz}, wones sz = ^~ (natToWord sz 1).\nProof.\n  intros; apply wordToNat_inj.\n  rewrite wneg_one_pow2_minus_one.\n  rewrite wones_pow2_minus_one.\n  reflexivity.\nQed.\n\nLemma wordToNat_natToWord_pred:\n  forall {sz} (w: word sz), w <> wzero sz ->\n                            pred (wordToNat w) =\n                            wordToNat (w ^- (natToWord sz 1)).\nProof.\n  intros; remember (wordToNat w) as wn; destruct wn; simpl in *.\n  - elim H.\n    apply wordToNat_inj.\n    rewrite roundTrip_0; auto.\n  - apply natToWord_inj with (sz:= sz).\n    + rewrite natToWord_wordToNat.\n      apply wplus_cancel with (c:= (natToWord sz 1)).\n      rewrite wminus_def, <-wplus_assoc.\n      rewrite wplus_comm with (x:= ^~ (natToWord sz 1)).\n      rewrite wminus_inv.\n      rewrite wplus_comm with (x:= w).\n      rewrite wplus_unit.\n      rewrite wplus_comm, <-natToWord_S.\n      apply wordToNat_inj.\n      rewrite wordToNat_natToWord_2; auto.\n      rewrite Heqwn.\n      apply wordToNat_bound.\n    + pose proof (wordToNat_bound w); lia.\n    + apply wordToNat_bound.\nQed.\n\nLemma natToWord_mult : forall sz n m, natToWord sz (n * m) = natToWord _ n ^* natToWord _ m.\nProof.\n  destruct sz; intuition.\n  rewrite wmult_alt.\n  unfold wmultN, wordBinN.\n  destruct (wordToNat_natToWord (S sz) n); intuition.\n  destruct (wordToNat_natToWord (S sz) m); intuition.\n  rewrite H0; rewrite H2; clear H0 H2.\n  replace ((n - x * pow2 (S sz)) * (m - x0 * pow2 (S sz)))\n    with ((n - x * pow2 (S sz)) * m - (n - x * pow2 (S sz)) * (x0 * pow2 (S sz)))\n    by (rewrite Nat.mul_sub_distr_l; auto).\n  rewrite Nat.mul_assoc; rewrite drop_sub.\n  repeat rewrite Nat.mul_comm with (m:=m).\n  replace (m * (n - x * pow2 (S sz)))\n    with (m * n - m * (x * pow2 (S sz)))\n    by (rewrite Nat.mul_sub_distr_l; auto).\n  rewrite Nat.mul_assoc; rewrite drop_sub.\n  auto.\n  rewrite <- Nat.mul_assoc; apply Nat.mul_le_mono_l; auto.\n  rewrite <- Nat.mul_assoc; apply Nat.mul_le_mono_l; auto.\nQed.\n\nLemma wlt_lt: forall sz (a b : word sz), a < b ->\n  (wordToNat a < wordToNat b)%nat.\nProof.\n  intros.\n  unfold wlt in H.\n  repeat rewrite wordToN_nat in *.\n  apply Nlt_out in H.\n  repeat rewrite Nat2N.id in *.\n  auto.\nQed.\n\nLemma wle_le: forall sz (a b : word sz), (a <= b)%word ->\n  (wordToNat a <= wordToNat b)%nat.\nProof.\n  intros.\n  unfold wlt in H.\n  repeat rewrite wordToN_nat in *.\n  apply Nge_out in H.\n  repeat rewrite Nat2N.id in *.\n  auto.\nQed.\n\nLemma wlt_lt': forall sz a b, (a < pow2 sz)%nat\n  -> natToWord sz a < b\n  -> (wordToNat (natToWord sz a) < wordToNat b)%nat.\nProof.\n  intros.\n  apply wlt_lt.\n  auto.\nQed.\n\nLemma lt_word_lt_nat : forall (sz:nat) (n:word sz) (m:nat),\n  (n < (natToWord sz m))%word ->\n  (wordToNat n < m)%nat.\nProof.\n  intros.\n  apply wlt_lt in H.\n  destruct (wordToNat_natToWord' sz m).\n  rewrite <- H0.\n  apply Nat.lt_le_trans with (1 := H).\n  now apply Nat.le_add_r.\nQed.\n\nLemma le_word_le_nat : forall (sz:nat) (n:word sz) (m:nat),\n  (n <= (natToWord sz m))%word ->\n  (wordToNat n <= m)%nat.\nProof.\n  intros.\n  apply wle_le in H.\n  destruct (wordToNat_natToWord' sz m).\n  rewrite <- H0.\n  apply Nat.le_trans with (1 := H).\n  now apply Nat.le_add_r.\nQed.\n\n(* Chain [lt_word_lt_nat] and [Nat.lt_le_incl]\n    Avoids using [Hint Resolve Nat.lt_le_incl] for this specific lemma,\n    though this may be a premature optimization. *)\nLemma lt_word_le_nat : forall (sz:nat) (n:word sz) (m:nat),\n  (n < (natToWord sz m))%word ->\n  (wordToNat n <= m)%nat.\nProof.\n  intros.\n  apply lt_word_lt_nat in H.\n  apply Nat.lt_le_incl.\n  assumption.\nQed.\n\n#[global] Hint Resolve lt_word_le_nat.\n\nLemma wordToNat_natToWord_idempotent' : forall sz n,\n  (n < pow2 sz)%nat\n  -> wordToNat (natToWord sz n) = n.\nProof.\n  intros.\n  destruct (wordToNat_natToWord sz n); intuition.\n  destruct x.\n  simpl in *; lia.\n  simpl in *.\n  generalize dependent (x * pow2 sz).\n  intros; lia.\nQed.\n\nLemma le_word_le_nat': forall (sz:nat) n m,\n  (n < pow2 sz)%nat ->\n  (natToWord sz n <= m)%word ->\n  (n <= wordToNat m)%nat.\nProof.\n  intros.\n  apply wle_le in H0.\n  rewrite wordToNat_natToWord_idempotent' in H0; auto.\nQed.\n\nLemma wordToNat_natToWord_bound : forall sz n (bound : word sz),\n  (n <= wordToNat bound)%nat\n  -> wordToNat (natToWord sz n) = n.\nProof.\n  intros.\n  apply wordToNat_natToWord_idempotent'.\n  eapply Nat.le_lt_trans; eauto.\n  apply wordToNat_bound.\nQed.\n\nLemma wordToNat_natToWord_le : forall sz n,\n  (wordToNat (natToWord sz n) <= n)%nat.\nProof.\n  intros.\n  case_eq (lt_dec n (pow2 sz)); intros.\n  rewrite wordToNat_natToWord_idempotent'; auto.\n  eapply Nat.le_trans.\n  apply Nat.lt_le_incl.\n  apply wordToNat_bound.\n  lia.\nQed.\n\nLemma wordToNat_natToWord_lt : forall sz n b,\n  (n < b -> wordToNat (natToWord sz n) < b)%nat.\nProof.\n  intros.\n  eapply Nat.le_lt_trans.\n  apply wordToNat_natToWord_le.\n  auto.\nQed.\n\nLemma wordToNat_eq_natToWord : forall sz (w : word sz) n,\n  wordToNat w = n\n  -> w = natToWord sz n.\nProof.\n  intros. rewrite <- H. rewrite natToWord_wordToNat. auto.\nQed.\n\nLemma wlt_lt_bound: forall sz (a : word sz) (b bound : nat),\n  (a < natToWord sz b)%word\n  -> (b <= wordToNat (natToWord sz bound))%nat\n  -> (wordToNat a < b)%nat.\nProof.\n  intros.\n  apply wlt_lt in H.\n  erewrite wordToNat_natToWord_bound in H; eauto.\nQed.\n\nLemma natplus1_wordplus1_eq:\n  forall sz (a bound : word sz),\n    (0 < sz)%nat ->\n    (a < bound)%word ->\n    (wordToNat a) + 1 = wordToNat (a ^+ (natToWord sz 1)).\nProof.\n  intros.\n  rewrite wplus_alt. unfold wplusN, wordBinN. simpl.\n  assert ((1 < pow2 sz)%nat).\n  inversion H.\n  simpl; auto.\n  apply one_lt_pow2.\n  erewrite wordToNat_natToWord_bound.\n  rewrite wordToNat_natToWord_idempotent' by auto.\n  reflexivity.\n  apply wlt_lt in H0.\n  rewrite wordToNat_natToWord_idempotent' by auto.\n  instantiate (1:=bound). lia.\nQed.\n\nLemma lt_wlt: forall sz (n : word sz) m, (wordToNat n < wordToNat m)%nat ->\n  n < m.\nProof.\n  intros.\n  unfold wlt.\n  repeat rewrite wordToN_nat.\n  apply Nlt_in.\n  repeat rewrite Nat2N.id.\n  auto.\nQed.\n\nLemma le_wle: forall sz (n : word sz) m, (wordToNat n <= wordToNat m)%nat ->\n  n <= m.\nProof.\n  intros.\n  unfold wlt.\n  repeat rewrite wordToN_nat.\n  apply N.le_ngt.\n  apply N.ge_le.\n  apply Nge_in.\n  repeat rewrite Nat2N.id.\n  auto.\nQed.\n\nLemma wlt_wle_incl : forall sz (a b : word sz),\n  (a < b)%word -> (a <= b)%word.\nProof.\n  intros.\n  apply wlt_lt in H.\n  apply le_wle.\n  lia.\nQed.\n\nLemma wminus_Alt2: forall sz x y, y <= x ->\n  @wminusN sz x y = wordBinN minus x y.\nProof.\n  intros.\n  unfold wminusN, wplusN, wnegN, wordBinN.\n  destruct (weq y (natToWord sz 0)); subst.\n\n  rewrite roundTrip_0.\n  repeat rewrite Nat.sub_0_r.\n  rewrite <- drop_sub with (k:=1) (n:=pow2 sz); try lia.\n  replace (pow2 sz - 1 * pow2 sz) with (0) by lia.\n  rewrite roundTrip_0.\n  rewrite <- plus_n_O.\n  reflexivity.\n\n  rewrite wordToNat_natToWord_idempotent' with (n:=pow2 sz - wordToNat y).\n  rewrite <- drop_sub with (k:=1).\n  simpl.\n  rewrite <- plus_n_O.\n  replace (wordToNat x + (pow2 sz - wordToNat y) - pow2 sz) with (wordToNat x - wordToNat y).\n  auto.\n  rewrite Nat.add_sub_assoc.\n  lia.\n\n  remember (wordToNat_bound y); lia.\n\n  simpl. rewrite <- plus_n_O.\n  rewrite Nat.add_sub_assoc; [| remember (wordToNat_bound y); lia ].\n  rewrite Nat.add_comm.\n  rewrite <- Nat.add_sub_assoc.\n  lia.\n\n  apply Nat.nlt_ge.\n  unfold not in *; intros.\n  apply H.\n  apply lt_wlt; auto.\n\n  apply Nat.sub_lt.\n  remember (wordToNat_bound y); lia.\n\n  assert (wordToNat y <> 0); try lia.\n\n  assert (wordToN y <> wordToN (natToWord sz 0)).\n  unfold not in *. intros. apply n.\n  apply wordToN_inj.\n  auto.\n\n  repeat rewrite wordToN_nat in H0.\n  unfold not in *. intros. apply H0.\n  apply N2Nat.inj.\n  repeat rewrite Nat2N.id.\n  rewrite roundTrip_0.\n  auto.\nQed.\n\nTheorem wlt_wf:\n  forall sz, well_founded (@wlt sz).\nProof.\n  intros.\n  eapply well_founded_lt_compat with (f:=@wordToNat sz).\n  apply wlt_lt.\nQed.\n\nLtac wlt_ind :=\n  match goal with\n  | [ |- forall (n: word ?len), ?P ] =>\n    refine (well_founded_ind (@wlt_wf len) (fun n => P) _)\n  end.\n\nTheorem wordToNat_plusone: forall sz w w', w < w' ->\n  wordToNat (w ^+ natToWord sz 1) = S (wordToNat w).\nProof.\n  intros.\n\n  destruct sz.\n  exfalso.\n  rewrite word0 with (w:=w') in H.\n  rewrite word0 with (w:=w) in H.\n  apply wlt_lt in H.\n  lia.\n\n  rewrite wplus_alt.\n  unfold wplusN, wordBinN.\n  rewrite wordToNat_natToWord_idempotent'.\n\n  rewrite roundTrip_1.\n  lia.\n\n  eapply Nat.le_lt_trans; [| apply wordToNat_bound ].\n  rewrite wordToNat_natToWord_idempotent';\n    [| erewrite <- roundTrip_1 at 1; apply wordToNat_bound ].\n  apply wlt_lt in H.\n  instantiate (1:=w').\n  lia.\nQed.\n\n\nTheorem wordToNat_minus_one': forall sz n, n <> natToWord sz 0 ->\n  S (wordToNat (n ^- natToWord sz 1)) = wordToNat n.\nProof.\n  intros.\n  destruct sz.\n  rewrite word0 with (w:=n) in H.\n  rewrite word0 with (w:=natToWord 0 0) in H.\n  exfalso; auto.\n\n  destruct (weq n (natToWord (S sz) 0)); intuition.\n  rewrite wminus_Alt.\n  rewrite wminus_Alt2.\n  unfold wordBinN.\n  rewrite roundTrip_1.\n  erewrite wordToNat_natToWord_bound with (bound:=n); try lia.\n  assert (wordToNat n <> 0); try lia.\n  unfold not; intros; apply n0; clear n0.\n  rewrite <- H0; rewrite natToWord_wordToNat; auto.\n  unfold not; intros; apply n0; clear n0.\n  apply wlt_lt in H0.\n  replace n with (natToWord (S sz) (wordToNat n)) by (rewrite natToWord_wordToNat; auto).\n  f_equal; rewrite roundTrip_1 in *.\n  lia.\nQed.\n\nTheorem wordToNat_minus_one: forall sz n, n <> natToWord sz 0 ->\n  wordToNat (n ^- natToWord sz 1) = wordToNat n - 1.\nProof.\n  intros.\n  erewrite Nat.succ_inj with (n2 := wordToNat (n ^- (natToWord sz 1))); auto.\n  rewrite wordToNat_minus_one'; auto.\n  assert (wordToNat n <> 0).\n  intuition.\n  erewrite <- roundTrip_0 with (sz := sz) in H0.\n  apply wordToNat_inj in H0; tauto.\n  lia.\nQed.\n\nLemma lt_minus : forall a b c,\n  (b <= a -> b < c -> a < c -> a - b < c)%nat.\nProof.\n  intros; lia.\nQed.\n\nLemma wminus_minus : forall sz (a b : word sz),\n  b <= a\n  -> wordToNat (a ^- b) = wordToNat a - wordToNat b.\nProof.\n  intros.\n  rewrite wminus_Alt.\n  rewrite wminus_Alt2; auto.\n  unfold wordBinN.\n  eapply wordToNat_natToWord_idempotent'.\n  apply lt_minus.\n  apply wle_le; auto.\n  apply wordToNat_bound.\n  apply wordToNat_bound.\nQed.\n\nLemma wminus_minus': forall (sz : nat) (a b : word sz),\n    (#b <= #a)%nat ->\n    #(a ^- b) = #a - #b.\nProof.\n  intros. apply wminus_minus.\n  unfold wlt. intro C.\n  apply Nlt_out in C.\n  rewrite! wordToN_to_nat in *.\n  lia.\nQed.\n\nLemma wordToNat_neq_inj: forall sz (a b : word sz),\n  a <> b <-> wordToNat a <> wordToNat b.\nProof.\n  split; intuition.\n  apply wordToNat_inj in H0; auto.\n  subst; auto.\nQed.\n\nLemma natToWord_discriminate: forall sz, (sz > 0)%nat -> natToWord sz 0 <> natToWord sz 1.\nProof.\n  unfold not.\n  intros.\n  induction sz.\n  lia.\n  unfold natToWord in H0; fold natToWord in H0.\n  discriminate H0.\nQed.\n\nDefinition bit_dec : forall (a : word 1), {a = $0} + {a = $1}.\n  intro.\n  rewrite (shatter_word a).\n  replace (wtl a) with WO by auto.\n  destruct (whd a).\n  right; apply eq_refl.\n  left; apply eq_refl.\nDefined.\n\nLemma neq0_wneq0: forall sz (n : word sz),\n  wordToNat n <> 0  <-> n <> $0.\nProof.\n  split; intros.\n  apply wordToNat_neq_inj.\n  rewrite roundTrip_0; auto.\n  apply wordToNat_neq_inj in H.\n  rewrite roundTrip_0 in H; auto.\nQed.\n\nLemma gt0_wneq0: forall sz (n : word sz),\n  (wordToNat n > 0)%nat <-> n <> $0.\nProof.\n  split; intros.\n  apply neq0_wneq0; lia.\n  apply wordToNat_neq_inj in H.\n  rewrite roundTrip_0 in H; lia.\nQed.\n\nLemma weq_minus1_wlt: forall sz (a b : word sz),\n  (a <> $0 -> a ^- $1 = b -> a > b)%word.\nProof.\n  intros.\n  apply lt_wlt; subst.\n  rewrite wordToNat_minus_one; auto.\n  apply gt0_wneq0 in H.\n  lia.\nQed.\n\nLemma wordnat_minus1_eq : forall sz n (w : word sz),\n  (n > 0)%nat\n  -> n = wordToNat w\n  -> n - 1 = wordToNat (w ^- $1).\nProof.\n  intros; rewrite wordToNat_minus_one; auto.\n  apply gt0_wneq0; subst; auto.\nQed.\n\nTheorem wlshift_0 : forall sz (w : word sz), @wlshift sz w 0 = w.\nProof.\n  intros.\n  unfold wlshift.\n  eapply split1_0.\nQed.\n\nTheorem wrshift_0 : forall sz (w : word sz), @wrshift sz w 0 = w.\nProof.\n  intros.\n  unfold wrshift.\n  simpl.\n  rewrite combine_n_0.\n  eq_rect_simpl. reflexivity.\nQed.\n\nTheorem wlshift_gt : forall sz n (w : word sz), (n > sz)%nat ->\n  wlshift w n = wzero sz.\nProof.\n  intros sz n w H.\n  generalize dependent w.\n  remember (n - sz) as e.\n  assert (n = sz + e) by lia; subst n.\n  intros w.\n  unfold wlshift.\n  rewrite <- combine_wzero.\n  erewrite combine_assoc, eq_rect_word_match.\n  eq_rect_simpl.\n  rewrite eq_rect_combine.\n  apply split1_combine.\n  Unshelve. lia.\nQed.\n\nTheorem wrshift_gt : forall sz n (w : word sz), (n > sz)%nat ->\n  wrshift w n = wzero sz.\nProof.\n  intros sz n w H.\n  generalize dependent w.\n  remember (n - sz) as e.\n  assert (n = sz + e) by lia; subst n.\n  intros w.\n  unfold wrshift.\n  erewrite wzero_rev, <- combine_wzero.\n  eq_rect_simpl.\n  rewrite <- eq_rect_word_match, <- eq_rect_combine, eq_rect_word_match.\n  eq_rect_simpl.\n  rewrite eq_rect_combine_assoc', split2_combine.\n  reflexivity.\n  Unshelve. lia.\nQed.\n\nTheorem wlshift_bitwp : forall sz (w1 w2 : word sz) f n,\n  wlshift (bitwp f w1 w2) n = split1 sz n (\n    eq_rec _ word (combine (wzero n) (bitwp f w1 w2)) _ (eq_sym (Nat.add_comm sz n))).\nProof.\n  intros.\n  unfold wlshift.\n  eq_rect_simpl.\n  reflexivity.\nQed.\n\nTheorem wrshift_bitwp : forall sz (w1 w2 : word sz) f n,\n  wrshift (bitwp f w1 w2) n = split2 n sz (\n    eq_rect _ word (combine (bitwp f w1 w2) (wzero n)) _ (eq_sym (Nat.add_comm n sz))).\nProof.\n  intros.\n  unfold wrshift.\n  eq_rect_simpl.\n  reflexivity.\nQed.\n\nTheorem wnot_wlshift : forall sz (w : word sz) n,\n  wnot (wlshift w n) = split1 sz n (eq_rect _ word (combine (wones n) (wnot w)) _ (eq_sym (Nat.add_comm sz n))).\nProof.\n  intros.\n  unfold wlshift.\n  rewrite wnot_split1.\n  eq_rect_simpl.\n  rewrite wnot_eq_rect.\n  rewrite wnot_combine.\n  rewrite wnot_zero.\n  reflexivity.\nQed.\n\nTheorem wnot_wrshift : forall sz (w : word sz) n,\n  wnot (wrshift w n) = split2 n sz (eq_rect _ word (combine (wnot w) (wones n)) _ (eq_sym (Nat.add_comm n sz))).\nProof.\n  intros.\n  unfold wrshift.\n  rewrite wnot_split2.\n  eq_rect_simpl.\n  rewrite wnot_eq_rect.\n  rewrite wnot_combine.\n  rewrite wnot_zero.\n  reflexivity.\nQed.\n\nTheorem div2_pow2_twice: forall n,\n  Nat.div2 (pow2 n + (pow2 n + 0)) = pow2 n.\nProof.\n  intros.\n  replace (pow2 n + (pow2 n + 0)) with (2 * pow2 n) by lia.\n  rewrite Nat.div2_double.\n  auto.\nQed.\n\nTheorem zero_or_wordToNat_S: forall sz (n : word sz),\n  n = $0 \\/\n  exists nn, wordToNat n = S nn /\\ wordToNat (n ^- $1) = nn.\nProof.\n  intros.\n  destruct sz.\n  left. rewrite (word0 n). auto.\n  destruct (weq n $0); intuition.\n  right.\n  exists (wordToNat (n ^- $1)); intuition.\n  rewrite wminus_Alt.\n  rewrite wminus_Alt2.\n  unfold wordBinN.\n  rewrite roundTrip_1.\n  erewrite wordToNat_natToWord_bound with (bound:=n); try lia.\n  assert (wordToNat n <> 0); try lia.\n  unfold not; intros; apply n0; clear n0.\n  rewrite <- H. rewrite natToWord_wordToNat; auto.\n  unfold not; intros; apply n0; clear n0.\n  apply wlt_lt in H.\n  replace n with (natToWord (S sz) (wordToNat n)) by (rewrite natToWord_wordToNat; auto).\n  f_equal.\n  rewrite roundTrip_1 in *.\n  lia.\nQed.\n\nTheorem wbit_or_same : forall sz sz' (n : word sz'), (wordToNat n < sz)%nat\n  -> (wbit sz n) ^| (wbit sz n) <> wzero sz.\nProof.\n  unfold not.\n  induction sz; intros; try lia.\n  unfold wbit, wzero, wor in *.\n  simpl in *.\n  destruct (zero_or_wordToNat_S n).\n  subst; rewrite roundTrip_0 in *. discriminate.\n  destruct H1. destruct H1.\n  rewrite H1 in *.\n  inversion H0.\n  apply (inj_pair2_eq_dec _ Nat.eq_dec) in H5.\n  rewrite div2_pow2_twice in H5.\n  repeat rewrite <- H2 in H5.\n  eapply IHsz; eauto.\n  lia.\nQed.\n\nTheorem wbit_or_other : forall sz sz' (n1 n2 : word sz'), (wordToNat n1 < sz)%nat\n  -> (wordToNat n2 < sz)%nat\n  -> (n1 <> n2)\n  -> (wbit sz n1) ^& (wbit sz n2) = wzero sz.\nProof.\n  induction sz; intros; try lia.\n  unfold wbit, wzero, wand.\n  simpl.\n  destruct (zero_or_wordToNat_S n1); destruct (zero_or_wordToNat_S n2);\n    try congruence; destruct_conjs; subst; try rewrite roundTrip_0.\n\n  repeat rewrite H4; simpl; repeat rewrite mod2_pow2_twice; f_equal.\n  rewrite wand_kill; auto.\n\n  repeat rewrite H4; simpl; repeat rewrite mod2_pow2_twice; f_equal.\n  rewrite wand_comm; rewrite wand_kill; auto.\n\n  repeat rewrite H4; repeat rewrite H6; simpl.\n  repeat rewrite mod2_pow2_twice; f_equal.\n  repeat rewrite div2_pow2_twice.\n  eapply IHsz; try lia.\n\n  apply word_neq.\n  unfold not in *; intros; apply H1; clear H1.\n  apply sub_0_eq; rewrite <- H2.\n  ring_sz sz'.\nQed.\n\nTheorem wbit_and_not: forall sz sz' (n : word sz'), (wordToNat n < sz)%nat\n  -> (wbit sz n) ^& wnot (wbit sz n) = wzero sz.\nProof.\n  induction sz; intros; try lia.\n  unfold wbit, wzero, wand, wnot.\n  simpl.\n  f_equal.\n  apply andb_negb_r.\n\n  destruct (zero_or_wordToNat_S n); subst.\n  rewrite roundTrip_0; simpl.\n  apply wand_kill.\n\n  do 2 destruct H0.\n  rewrite H0; simpl.\n  rewrite div2_pow2_twice.\n  fold wnot.\n  rewrite <- H1.\n  eapply IHsz.\n  lia.\nQed.\n\nTheorem wbit_and_not_other: forall sz sz' (n1 n2 : word sz'), (wordToNat n1 < sz)%nat\n  -> (wordToNat n2 < sz)%nat\n  -> n1 <> n2\n  -> (wbit sz n1) ^& wnot (wbit sz n2) = wbit sz n1.\nProof.\n  induction sz; intros; try lia.\n  unfold wbit, wzero, wand, wnot.\n  simpl.\n  destruct (zero_or_wordToNat_S n1); destruct (zero_or_wordToNat_S n2);\n    try congruence; destruct_conjs; subst; fold wnot; try rewrite roundTrip_0; simpl;\n    f_equal.\n\n  rewrite H4; simpl; rewrite mod2_pow2_twice; auto.\n  rewrite H4; simpl; rewrite div2_pow2_twice; apply wand_kill.\n\n  rewrite H4; simpl; rewrite mod2_pow2_twice; auto.\n  rewrite H4; simpl; rewrite div2_pow2_twice.\n  rewrite wnot_zero. rewrite wand_comm. apply wand_unit.\n\n  rewrite H4; simpl; rewrite mod2_pow2_twice; simpl; apply andb_true_r.\n  rewrite H4; rewrite H6; simpl.\n  repeat rewrite div2_pow2_twice.\n  apply IHsz; try lia.\n\n  apply word_neq.\n  unfold not in *; intros; apply H1.\n  apply sub_0_eq.\n  rewrite <- H2.\n  ring_sz sz'.\nQed.\n\nLemma wordToNat_wzero:\n  forall sz, wordToNat (wzero sz) = 0.\nProof.\n  unfold wzero; intros.\n  apply roundTrip_0.\nQed.\n\nLemma wordToN_wzero:\n  forall sz, wordToN (wzero sz) = 0%N.\nProof.\n  intros; rewrite wordToN_nat.\n  rewrite wordToNat_wzero.\n  reflexivity.\nQed.\n\nLemma combine_zero:\n  forall n m, combine (natToWord n 0) (natToWord m 0) = natToWord _ 0.\nProof.\n  induction n; simpl; intros; [reflexivity|].\n  rewrite IHn; reflexivity.\nQed.\n\nLemma combine_one:\n  forall n m, combine (natToWord (S n) 1) (natToWord m 0) = natToWord _ 1.\nProof.\n  cbn; intros.\n  rewrite combine_zero; reflexivity.\nQed.\n\nLemma wmsb_wzero':\n  forall sz, wmsb (wzero' sz) false = false.\nProof. induction sz; auto. Qed.\n\nLemma wmsb_wzero:\n  forall sz, wmsb (wzero sz) false = false.\nProof.\n  intros.\n  rewrite <-wzero'_def.\n  apply wmsb_wzero'.\nQed.\n\nLemma wmsb_wones:\n  forall sz, wmsb (wones (S sz)) false = true.\nProof.\n  induction sz; cbn; auto.\nQed.\n\nLemma wmsb_0: forall sz (m: word (S sz)) default,\n  (# m < pow2 sz)%nat ->\n  @wmsb (S sz) m default = false.\nProof.\n  induction sz; intros.\n  - simpl in *. assert (#m = 0) as N by lia.\n    rewrite <- (roundTrip_0 1) in N.\n    apply wordToNat_inj in N. subst m.\n    simpl. reflexivity.\n  - pose proof (shatter_word_S m) as P.\n    destruct P as [b [m0 E]]. subst.\n    unfold wmsb. fold wmsb.\n    apply IHsz.\n    simpl in H. destruct b; lia.\nQed.\n\nLemma wmsb_1: forall sz (m: word (S sz)) default,\n  pow2 sz <= # m < 2 * pow2 sz ->\n  @wmsb (S sz) m default = true.\nProof.\n  induction sz; intros.\n  - simpl in *. assert (#m = 1) as N by lia.\n    rewrite <- (roundTrip_1 1) in N.\n    apply (wordToNat_inj m ($ 1)) in N. subst m.\n    simpl. reflexivity.\n  - pose proof (shatter_word_S m) as P.\n    destruct P as [b [m0 E]]. subst.\n    unfold wmsb. fold wmsb.\n    apply IHsz.\n    simpl in H. destruct b; lia.\nQed.\n\nLemma wmsb_0_natToWord: forall sz n default,\n  (2 * n < pow2 (S sz))%nat ->\n  @wmsb (S sz) (natToWord (S sz) n) default = false.\nProof.\n  intros. apply wmsb_0.\n  pose proof (wordToNat_natToWord_le (S sz) n). unfold pow2 in H. fold pow2 in H. lia.\nQed.\n\nLemma wmsb_1_natToWord: forall sz n default,\n  pow2 sz <= n < 2 * pow2 sz ->\n  @wmsb (S sz) (natToWord (S sz) n) default = true.\nProof.\n  intros. apply wmsb_1.\n  rewrite wordToNat_natToWord_idempotent'; simpl; lia.\nQed.\n\nLemma wordToN_wzero':\n  forall sz, wordToN (wzero' sz) = 0%N.\nProof.\n  induction sz; simpl; auto.\n  rewrite IHsz; auto.\nQed.\n\nLemma wordToZ_wzero':\n  forall sz, wordToZ (wzero' sz) = 0%Z.\nProof.\n  unfold wordToZ; intros.\n  rewrite wmsb_wzero'.\n  rewrite wordToN_wzero'.\n  reflexivity.\nQed.\n\nLemma wordToZ_wzero:\n  forall sz, wordToZ (wzero sz) = 0%Z.\nProof.\n  unfold wordToZ; intros.\n  rewrite wmsb_wzero.\n  rewrite wordToN_wzero.\n  reflexivity.\nQed.\n\nLemma wmsb_existT: (* Note: not axiom free *)\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2),\n    existT word _ w1 = existT word _ w2 ->\n    forall b, wmsb w1 b = wmsb w2 b.\nProof.\n  intros.\n  assert (sz1 = sz2) by (apply eq_sigT_fst in H; auto); subst.\n  destruct_existT; reflexivity.\nQed.\n\nLemma destruct_word_S: forall sz (w: word (S sz)),\n    exists v b, w = WS b v.\nProof.\n  intros.\n  refine (match w with\n          | WO => _\n          | WS b v => _\n          end); unfold IDProp; eauto.\nQed.\n\nLemma induct_word_S: forall (P : forall n : nat, word (S n) -> Prop),\n    (forall b, P 0 (WS b WO)) ->\n    (forall b b0 n (w : word n), P n (WS b0 w) -> P (S n) (WS b (WS b0 w))) ->\n    forall (n : nat) (w : word (S n)), P n w.\nProof.\n  induction n; intros.\n  - destruct (destruct_word_S w) as [v [b E]]. subst w.\n    rewrite (word0 v).\n    apply H.\n  - destruct (destruct_word_S w) as [v [b E]]. subst w.\n    destruct (destruct_word_S v) as [w [b0 E]]. subst v.\n    apply H0.\n    apply IHn.\nQed.\n\nLemma wmsb_eq_rect:\n  forall sz1 (w: word sz1) sz2 (Hsz: sz1 = sz2) b,\n    wmsb w b = wmsb (eq_rect _ word w _ Hsz) b.\nProof.\n  intros.\n  apply wmsb_existT.\n  apply eq_sym, existT_eq_rect.\nQed.\n\nLemma wmsb_ws:\n  forall sz (w: word (S sz)) b a, wmsb (WS b w) a = wmsb w a.\nProof.\n  intros; cbn.\n  dependent destruction w.\n  reflexivity.\nQed.\n\nLemma wmsb_extz:\n  forall sz (w: word sz) n,\n    wmsb (extz w n) false = wmsb w false.\nProof.\n  induction n; intros; auto.\nQed.\n\nLemma wmsb_default:\n  forall sz (w: word sz) b1 b2,\n    sz <> 0 -> wmsb w b1 = wmsb w b2.\nProof.\n  dependent induction w; intros; intuition.\nQed.\n\nLemma wmsb_split2:\n  forall sz (w: word (sz + 1)) b,\n    wmsb w b = if weq (split2 _ 1 w) (natToWord _ 0) then false else true.\nProof.\n  dependent destruction w; intros; [lia|].\n  assert (sz = n) by lia; subst; clear x0.\n\n  move w at top.\n  dependent induction w.\n  - cbn in *.\n    do 2 dependent destruction w0.\n    destruct b0; cbn; reflexivity.\n  - simpl in w0.\n    dependent destruction w0.\n    specialize (IHw b w0).\n\n    cbn; cbn in IHw.\n    apply IHw; clear -x.\n    remember (WS b w) as ww; clear Heqww.\n    generalize dependent w0.\n    simpl; replace (n + 1) with (S n) by lia.\n    intros.\n    inversion x; subst; destruct_existT.\n    inversion H0; subst; destruct_existT.\n    reflexivity.\nQed.\n\nLemma wmsb_true_split2_wones:\n  forall sz (w: word (sz + 1)) b,\n    wmsb w b = true ->\n    wones 1 = split2 sz 1 w.\nProof.\n  intros.\n  pose proof (wmsb_split2 _ w b).\n  destruct (weq _ _).\n  - rewrite H in H0; discriminate.\n  - clear -n.\n    remember (split2 sz 1 w) as ww; clear Heqww w.\n    do 2 dependent destruction ww.\n    destruct b; intuition.\nQed.\n\nLemma wmsb_false_split2_wzero:\n  forall sz (w: word (sz + 1)) b,\n    wmsb w b = false ->\n    wzero 1 = split2 sz 1 w.\nProof.\n  intros.\n  pose proof (wmsb_split2 _ w b).\n  destruct (weq _ _); auto.\n  rewrite H in H0; discriminate.\nQed.\n\nLemma wmsb_split1_sext:\n  forall sz (w: word (sz + 1)),\n    wmsb w false = wmsb (split1 _ 1 w) false ->\n    exists sw, sext sw 1 = w.\nProof.\n  unfold sext; intros.\n  pose proof (combine_split _ _ w) as Hw.\n  rewrite <-Hw; rewrite <-Hw in H at 2; clear Hw.\n  rewrite split1_combine in H.\n  exists (split1 sz 1 w).\n  destruct (wmsb (split1 sz 1 w) false).\n  - rewrite <-wmsb_true_split2_wones with (b:= false) by assumption.\n    reflexivity.\n  - rewrite <-wmsb_false_split2_wzero with (b:= false) by assumption.\n    reflexivity.\nQed.\n\nLemma wmsb_combine_WO:\n  forall sz (w: word sz) b,\n    wmsb (combine w WO) b = wmsb w b.\nProof.\n  dependent induction w; cbn; intros; auto.\nQed.\n\nLemma wmsb_combine:\n  forall sz1 sz2 (w1: word sz1) (w2: word sz2) b1 b2,\n    sz2 <> 0 ->\n    wmsb (combine w1 w2) b1 = wmsb w2 b2.\nProof.\n  dependent induction w1; cbn; intros.\n  - auto using wmsb_default.\n  - auto using IHw1.\nQed.\n\nLemma wmsb_combine_existT:\n  forall sz (w: word sz) sz1 (w1: word sz1) sz2 (w2: word sz2) b1 b2,\n    sz2 <> 0 ->\n    existT word _ w = existT word _ (combine w1 w2) ->\n    wmsb w b1 = wmsb w2 b2.\nProof.\n  intros.\n  pose proof (eq_sigT_fst H0); subst.\n  destruct_existT.\n  auto using wmsb_combine.\nQed.\n\nLemma wmsb_zext:\n  forall sz (w: word sz) b n, n <> 0 -> wmsb (zext w n) b = false.\nProof.\n  destruct n; cbn; intros; [elim H; reflexivity|].\n  unfold zext.\n  erewrite wmsb_combine with (b2:= false) by discriminate.\n  apply wmsb_wzero.\nQed.\n\nLemma wordToN_zext:\n  forall sz (w: word sz) n,\n    wordToN (zext w n) = wordToN w.\nProof.\n  dependent induction w; cbn; intros.\n  - induction n; cbn; intros; [reflexivity|].\n    unfold wzero in IHn; rewrite IHn; reflexivity.\n  - rewrite IHw; reflexivity.\nQed.\n\nLemma wordToNat_zext:\n  forall sz (w: word sz) n,\n    wordToNat (zext w n) = wordToNat w.\nProof.\n  dependent induction w; cbn; intros.\n  - induction n; cbn; intros; [reflexivity|].\n    unfold wzero in IHn; rewrite IHn; reflexivity.\n  - rewrite IHw; reflexivity.\nQed.\n\nLemma zext_wordToNat_equal_Z:\n  forall sz (w: word sz) n,\n    n <> 0 -> wordToZ (zext w n) = Z.of_nat (wordToNat w).\nProof.\n  unfold wordToZ, zext; intros.\n  rewrite wmsb_combine with (b2:= false) by assumption.\n  rewrite wmsb_wzero.\n  replace (combine w (wzero n)) with (zext w n) by reflexivity.\n  rewrite wordToN_zext.\n  rewrite wordToN_nat.\n  rewrite <-nat_N_Z.\n  unfold Z.of_N; reflexivity.\nQed.\n\nLemma wordToN_WS_0:\n  forall sz (w: word sz), wordToN w~0 = (2 * wordToN w)%N.\nProof. reflexivity. Qed.\n\nLemma wordToN_WS_1:\n  forall sz (w: word sz), wordToN w~1 = (2 * wordToN w + 1)%N.\nProof.\n  intros; cbn.\n  unfold N.succ_double.\n  destruct (wordToN w); reflexivity.\nQed.\n\nLemma NToWord_WS_0:\n  forall sz n, NToWord (S sz) (2 * n) = (NToWord sz n)~0.\nProof.\n  destruct n; intros; [reflexivity|].\n  replace (2 * N.pos p)%N with (N.pos (p~0)) by reflexivity.\n  reflexivity.\nQed.\n\nLemma NToWord_WS_1:\n  forall sz n, NToWord (S sz) (2 * n + 1) = (NToWord sz n)~1.\nProof.\n  destruct n; intros; [reflexivity|].\n  replace (2 * N.pos p)%N with (N.pos (p~0)) by reflexivity.\n  reflexivity.\nQed.\n\nLemma wneg_WS_0:\n  forall sz (w: word sz), wneg w~0 = (wneg w)~0.\nProof.\n  unfold wneg; intros.\n  rewrite wordToN_WS_0.\n  replace (Npow2 (S sz)) with (2 * Npow2 sz)%N by reflexivity.\n  rewrite <-N.mul_sub_distr_l.\n  apply NToWord_WS_0.\nQed.\n\nLemma NToWord_wordToN:\n  forall sz (w: word sz), NToWord sz (wordToN w) = w.\nProof.\n  intros.\n  rewrite wordToN_nat, NToWord_nat.\n  rewrite Nat2N.id.\n  apply natToWord_wordToNat.\nQed.\n  \nLemma roundTripN_0:\n  forall sz, wordToN (NToWord sz 0) = 0%N.\nProof.\n  intros.\n  rewrite wordToN_nat, NToWord_nat.\n  rewrite roundTrip_0; reflexivity.\nQed.\n\nLemma wordToN_NToWord:\n  forall sz n,\n  exists k, wordToN (NToWord sz n) = (n - k * Npow2 sz)%N /\\ (k * Npow2 sz <= n)%N.\nProof.\n  intros.\n  rewrite wordToN_nat, NToWord_nat.\n  pose proof (wordToNat_natToWord sz (N.to_nat n)).\n  destruct H as [k [? ?]].\n  exists (N.of_nat k).\n  split.\n  - apply N2Nat.inj.\n    rewrite Nat2N.id, N2Nat.inj_sub, N2Nat.inj_mul.\n    rewrite Nat2N.id.\n    rewrite Npow2_nat.\n    assumption.\n  - rewrite nat_compare_le, Nat2N.inj_compare in H0.\n    rewrite Nat2N.inj_mul, <-Npow2_nat in H0.\n    do 2 rewrite N2Nat.id in H0.\n    assumption.\nQed.\n\nLemma wordToN_NToWord_2:\n  forall sz n, (n < Npow2 sz)%N -> wordToN (NToWord sz n) = n.\nProof.\n  intros.\n  rewrite wordToN_nat, NToWord_nat.\n  rewrite wordToNat_natToWord_2.\n  - apply N2Nat.id.\n  - rewrite <-Npow2_nat.\n    apply Nlt_out; auto.\nQed.\n\nLemma wordToN_bound:\n  forall sz (w: word sz), (wordToN w < Npow2 sz)%N.\nProof.\n  intros.\n  rewrite wordToN_nat.\n  apply Nlt_in.\n  rewrite Npow2_nat, Nat2N.id.\n  apply wordToNat_bound.\nQed.\n\nLemma wordToN_plus: forall sz (a b: word sz),\n    (wordToN a + wordToN b < Npow2 sz)%N ->\n    wordToN (a ^+ b) = (wordToN a + wordToN b)%N.\nProof.\n  intros. unfold wplus, wordBin.\n  rewrite wordToN_NToWord_2 by assumption.\n  reflexivity.\nQed.\n\nLemma wordToN_mult: forall sz (a b: word sz),\n    (wordToN a * wordToN b < Npow2 sz)%N ->\n    wordToN (a ^* b) = (wordToN a * wordToN b)%N.\nProof.\n  intros. unfold wmult, wordBin.\n  rewrite wordToN_NToWord_2 by assumption.\n  reflexivity.\nQed.\n\nLemma wnot_def:\n  forall sz (w: word sz), wnot w = NToWord sz (Npow2 sz - wordToN w - 1).\nProof.\n  dependent induction w; cbn; [reflexivity|].\n  destruct b; cbn.\n  - rewrite IHw; clear IHw.\n    rewrite <-NToWord_WS_0.\n    f_equal.\n    destruct (Npow2 n); [reflexivity|].\n    destruct (wordToN w).\n    + change (N.pos p~0) with (2 * N.pos p)%N.\n      do 2 rewrite N.mul_sub_distr_l.\n      do 2 rewrite <-N.sub_add_distr.\n      reflexivity.\n    + change (N.pos p~0) with (2 * N.pos p)%N.\n      change (N.pos p0~0) with (2 * N.pos p0)%N.\n      rewrite <-N.add_1_l.\n      do 2 rewrite N.mul_sub_distr_l.\n      do 2 rewrite <-N.sub_add_distr.\n      rewrite N.add_comm with (n:= 1%N).\n      rewrite <-N.add_assoc.\n      reflexivity.\n  - rewrite IHw; clear IHw.\n    rewrite <-NToWord_WS_1.\n    f_equal.\n    pose proof (wordToN_bound w).\n    remember (Npow2 n) as pn; destruct pn;\n      [exfalso; eapply Npow2_not_zero; eauto|clear Heqpn].\n    destruct (wordToN w).\n    + change (N.pos p~0) with (2 * N.pos p)%N.\n      do 2 rewrite N.mul_sub_distr_l.\n      do 2 rewrite <-N.sub_add_distr.\n      destruct p; cbn; reflexivity.\n    + change (N.pos p~0) with (2 * N.pos p)%N.\n      change (N.pos p0~0) with (2 * N.pos p0)%N.\n      rewrite N.mul_sub_distr_l.\n      rewrite <-N.mul_sub_distr_l with (n:= N.pos p).\n      assert (exists pp, N.pos p - N.pos p0 = N.pos pp)%N.\n      { apply N.sub_gt in H.\n        destruct (N.pos p - N.pos p0)%N; [intuition idtac|].\n        eexists; reflexivity.\n      }\n      destruct H0; rewrite H0.\n      destruct x; cbn; reflexivity.\nQed.\n\nLemma wneg_wnot:\n  forall sz (w: word sz), wnot w = wneg w ^- (natToWord _ 1).\nProof.\n  unfold wneg; intros.\n  rewrite wnot_def.\n\n  destruct (weq w (wzero _)); subst.\n\n  - rewrite wordToN_nat.\n    unfold wzero; rewrite roundTrip_0; cbn.\n    rewrite N.sub_0_r.\n    do 2 rewrite NToWord_nat.\n    rewrite Npow2_nat, natToWord_pow2, N2Nat.inj_sub.\n    change (N.to_nat 1%N) with 1.\n    rewrite Npow2_nat.\n    apply wordToNat_inj.\n    rewrite wordToNat_natToWord_2 by (pose proof (zero_lt_pow2 sz); lia).\n    unfold wminus.\n    rewrite wplus_unit, <-wones_wneg_one.\n    apply eq_sym, wones_pow2_minus_one.\n\n  - pose proof (wordToN_bound w).\n    assert (Npow2 sz - wordToN w < Npow2 sz)%N.\n    { apply N.sub_lt.\n      { apply N.lt_le_incl; auto. }\n      { assert (wordToN w <> 0)%N.\n        { replace 0%N with (wordToN (wzero sz)).\n          { intro Hx; elim n.\n            apply wordToN_inj; auto.\n          }\n          { rewrite wordToN_nat.\n            unfold wzero; rewrite roundTrip_0; reflexivity.\n          }\n        }\n        nlia.\n      }\n    }\n    apply N.sub_gt in H.\n    remember (Npow2 sz - wordToN w)%N as p; clear Heqp.\n    do 2 rewrite NToWord_nat.\n    rewrite N2Nat.inj_sub.\n    change (N.to_nat 1%N) with 1.\n    assert (N.to_nat p < pow2 sz)%nat\n      by (rewrite <-Npow2_nat; apply Nlt_out; auto); clear H0.\n    assert (N.to_nat p <> 0)\n      by (change 0 with (N.to_nat 0%N); intro Hx; elim H; apply N2Nat.inj; auto); clear H.\n    apply wordToNat_inj.\n    rewrite <-wordToNat_natToWord_pred.\n    + do 2 rewrite wordToNat_natToWord_2 by lia.\n      lia.\n    + intro Hx; elim H0.\n      apply natToWord_inj with (sz:= sz); try lia.\n      assumption.\nQed.\n\nLemma wzero_wneg:\n  forall n, wneg (wzero n) = wzero n.\nProof.\n  intros.\n  pose proof (wminus_inv (wzero n)).\n  rewrite wplus_unit in H; auto.\nQed.\n\nLemma pow2_wneg:\n  forall sz, wneg (natToWord (S sz) (pow2 sz)) = natToWord (S sz) (pow2 sz).\nProof.\n  unfold wneg; intros.\n  rewrite <-Npow2_nat, <-NToWord_nat.\n  rewrite wordToN_NToWord_2\n    by (apply Nlt_in; do 2 rewrite Npow2_nat;\n        pose proof (zero_lt_pow2 sz); simpl; lia).\n  rewrite Npow2_S.\n  f_equal; nlia.\nQed.\n\nLemma wneg_WS_1:\n  forall sz (w: word sz), wneg w~1 = (wnot w)~1.\nProof.\n  intros.\n  apply wordToN_inj.\n  simpl; rewrite wnot_def.\n  unfold wneg.\n  rewrite wordToN_NToWord_2\n    by (apply N.sub_lt; [apply N.lt_le_incl, wordToN_bound|nlia]).\n  rewrite wordToN_NToWord_2.\n  - rewrite wordToN_WS_1.\n    change (Npow2 (S sz)) with (2 * Npow2 sz)%N.\n    rewrite N.sub_add_distr.\n    rewrite <-N.mul_sub_distr_l.\n    assert (Npow2 sz - wordToN w <> 0)%N\n      by (pose proof (wordToN_bound w); nlia).\n    remember (Npow2 sz - wordToN w)%N as n; clear Heqn.\n    destruct n; [intuition idtac|].\n    remember (N.pos p - 1)%N as pp; destruct pp.\n    + apply eq_sym, N.sub_0_le in Heqpp.\n      apply N.le_1_r in Heqpp; destruct Heqpp; [discriminate|].\n      rewrite H0; reflexivity.\n    + change (N.pos p0~0) with (2 * N.pos p0)%N.\n      rewrite Heqpp.\n      rewrite <-N.add_1_r.\n      rewrite N.mul_sub_distr_l.\n      clear; destruct p; cbn; reflexivity.\n  - rewrite <-N.sub_add_distr.\n    apply N.sub_lt; [|nlia].\n    pose proof (wordToN_bound w).\n    apply N.le_succ_l in H.\n    rewrite N.add_1_r; assumption.\nQed.\n\nLemma wordToZ_WS_0:\n  forall sz (w: word sz), wordToZ w~0 = (2 * wordToZ w)%Z.\nProof.\n  dependent destruction w; [reflexivity|].\n  unfold wordToZ.\n  rewrite wmsb_ws.\n  destruct (wmsb (WS b w) false).\n  - rewrite wneg_WS_0.\n    rewrite wordToN_WS_0.\n    destruct (wordToN (wneg (WS b w))); cbn; lia.\n  - rewrite wordToN_WS_0.\n    destruct (wordToN (WS b w)); cbn; lia.\nQed.\n\nLemma wordToZ_WS_1:\n  forall sz (w: word (S sz)), wordToZ w~1 = (2 * wordToZ w + 1)%Z.\nProof.\n  dependent destruction w.\n  unfold wordToZ.\n  rewrite wmsb_ws.\n  remember (wmsb (WS b w) false) as msb.\n  destruct msb.\n  - rewrite wneg_WS_1.\n    rewrite wordToN_WS_1.\n    rewrite wnot_def.\n    unfold wneg.\n\n    assert (Npow2 (S sz) - wordToN (WS b w) <> 0)%N.\n    { pose proof (wordToN_bound (WS b w)); nlia. }\n    assert (Npow2 (S sz) - wordToN (WS b w) < Npow2 (S sz))%N.\n    { apply N.sub_lt.\n      { apply N.lt_le_incl, wordToN_bound. }\n      { assert (wordToN (WS b w) <> 0)%N.\n        { replace 0%N with (wordToN (wzero (S sz))).\n          { intro Hx.\n            apply wordToN_inj in Hx.\n            rewrite Hx in Heqmsb.\n            rewrite wmsb_wzero in Heqmsb; discriminate.\n          }\n          { rewrite wordToN_nat.\n            unfold wzero; rewrite roundTrip_0; reflexivity.\n          }\n        }\n        nlia.\n      }\n    }\n    remember (Npow2 (S sz) - wordToN (WS b w))%N as n; clear Heqn.\n\n    rewrite wordToN_NToWord_2 by nlia.\n    rewrite wordToN_NToWord_2 by nlia.\n    destruct n; [intuition idtac|].\n    destruct p; cbn; reflexivity.\n\n  - rewrite wordToN_WS_1.\n    destruct (wordToN (WS b w)); cbn; lia.\nQed.\n\nLemma wordToZ_WS_1':\n  forall sz (w: word (sz + 1)), wordToZ w~1 = (2 * wordToZ w + 1)%Z.\nProof.\n  intro sz.\n  replace (sz + 1) with (S sz) by lia.\n  intros.\n  apply wordToZ_WS_1.\nQed.\n\nLemma wordToZ_inj:\n  forall sz (w1 w2: word sz),\n    wordToZ w1 = wordToZ w2 -> w1 = w2.\nProof.\n  unfold wordToZ; intros.\n  remember (wmsb w1 false) as msb1.\n  remember (wmsb w2 false) as msb2.\n  destruct msb1, msb2.\n  - remember (wordToN (wneg w1)) as wn1.\n    remember (wordToN (wneg w2)) as wn2.\n    destruct wn1, wn2; try discriminate.\n    + assert (wneg w1 = wneg w2).\n      { apply wordToN_inj.\n        rewrite <-Heqwn1, <-Heqwn2; reflexivity.\n      }\n      rewrite <-wneg_idempotent with (w:= w1).\n      rewrite <-wneg_idempotent with (w:= w2).\n      rewrite H0; reflexivity.\n    + inversion H; subst; clear H.\n      assert (wneg w1 = wneg w2).\n      { apply wordToN_inj.\n        rewrite <-Heqwn1, <-Heqwn2; reflexivity.\n      }\n      rewrite <-wneg_idempotent with (w:= w1).\n      rewrite <-wneg_idempotent with (w:= w2).\n      rewrite H; reflexivity.\n  - remember (wordToN (wneg w1)) as wn1.\n    remember (wordToN w2) as wn2.\n    destruct wn1, wn2; try discriminate.\n    rewrite <-wordToN_wzero with (sz:= sz) in Heqwn1, Heqwn2.\n    apply wordToN_inj in Heqwn1.\n    apply wordToN_inj in Heqwn2.\n    assert (w1 = wzero sz).\n    { rewrite <-wneg_idempotent with (w:= w1), <-Heqwn1.\n      apply wzero_wneg.\n    }\n    subst; reflexivity.\n  - remember (wordToN w1) as wn1.\n    remember (wordToN (wneg w2)) as wn2.\n    destruct wn1, wn2; try discriminate.\n    rewrite <-wordToN_wzero with (sz:= sz) in Heqwn1, Heqwn2.\n    apply wordToN_inj in Heqwn1.\n    apply wordToN_inj in Heqwn2.\n    assert (w2 = wzero sz).\n    { rewrite <-wneg_idempotent with (w:= w2), <-Heqwn2.\n      apply wzero_wneg.\n    }\n    subst; reflexivity.\n  - remember (wordToN w1) as wn1.\n    remember (wordToN w2) as wn2.\n    destruct wn1, wn2; try discriminate.\n    + rewrite <-wordToN_wzero with (sz:= sz) in Heqwn1, Heqwn2.\n      rewrite Heqwn1 in Heqwn2.\n      apply wordToN_inj in Heqwn2; auto.\n    + inversion H; subst; clear H.\n      rewrite Heqwn1 in Heqwn2.\n      apply wordToN_inj in Heqwn2; auto.\nQed.\n\nLemma wordToZ_wones:\n  forall sz, sz <> 0 -> wordToZ (wones sz) = (-1)%Z.\nProof.\n  induction sz; intros; [elim H; reflexivity|].\n  simpl; destruct sz; [reflexivity|].\n  rewrite wordToZ_WS_1.\n  rewrite IHsz by discriminate.\n  reflexivity.\nQed.\n\nLemma wordToNat_eq_rect:\n  forall sz (w: word sz) nsz Hsz,\n    wordToNat (eq_rect _ word w nsz Hsz) = wordToNat w.\nProof.\n  intros; subst; simpl; reflexivity.\nQed.\n\nLemma wordToNat_existT:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2) (Hsz: sz1 = sz2),\n    wordToNat w1 = wordToNat w2 ->\n    existT word _ w1 = existT word _ w2.\nProof.\n  intros; subst.\n  apply wordToNat_inj in H; subst.\n  reflexivity.\nQed.\n\nLemma existT_wordToNat:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2),\n    existT word _ w1 = existT word _ w2 ->\n    wordToNat w1 = wordToNat w2.\nProof.\n  intros.\n  pose proof (eq_sigT_fst H); subst.\n  destruct_existT; reflexivity.\nQed.\n\nLemma wordToZ_eq_rect:\n  forall sz (w: word sz) nsz Hsz,\n    wordToZ (eq_rect _ word w nsz Hsz) = wordToZ w.\nProof.\n  intros; subst; simpl; reflexivity.\nQed.\n\nLemma wordToZ_existT:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2) (Hsz: sz1 = sz2),\n    wordToZ w1 = wordToZ w2 ->\n    existT word _ w1 = existT word _ w2.\nProof.\n  intros; subst.\n  apply wordToZ_inj in H; subst.\n  reflexivity.\nQed.\n\nLemma existT_wordToZ:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2),\n    existT word _ w1 = existT word _ w2 ->\n    wordToZ w1 = wordToZ w2.\nProof.\n  intros.\n  pose proof (eq_sigT_fst H); subst.\n  destruct_existT.\n  reflexivity.\nQed.\n\nLemma wplus_WS_0:\n  forall sz (w1 w2: word sz) b, WS b (w1 ^+ w2) = WS b w1 ^+ w2~0.\nProof.\n  intros.\n  unfold wplus, wordBin; intros.\n  rewrite wordToN_WS_0.\n  destruct b.\n  - rewrite wordToN_WS_1.\n    rewrite <-N.add_assoc.\n    rewrite N.add_comm with (n:= 1%N).\n    rewrite N.add_assoc.\n    rewrite <-N.mul_add_distr_l.\n    apply eq_sym, NToWord_WS_1.\n  - rewrite wordToN_WS_0.\n    rewrite <-N.mul_add_distr_l.\n    apply eq_sym, NToWord_WS_0.\nQed.\n\nCorollary wplus_WS_0':\n  forall sz (w1 w2: word sz) b, WS b (w1 ^+ w2) = w1~0 ^+ WS b w2.\nProof.\n  intros.\n  rewrite wplus_comm with (x:= w1).\n  rewrite wplus_comm with (x:= w1~0).\n  apply wplus_WS_0.\nQed.\n\nLemma wpow2_pow2:\n  forall sz, wordToNat (wpow2 sz) = pow2 sz.\nProof.\n  induction sz; simpl; intros; [reflexivity|].\n  rewrite IHsz.\n  lia.\nQed.\n\nLemma wpow2_Npow2:\n  forall sz, wordToN (wpow2 sz) = Npow2 sz.\nProof.\n  induction sz; simpl; intros; [reflexivity|].\n  rewrite IHsz; reflexivity.\nQed.\n\nLemma wpow2_wneg:\n  forall sz, wneg (wpow2 sz) = wpow2 sz.\nProof.\n  induction sz; simpl; intros; [reflexivity|].\n  rewrite wneg_WS_0.\n  rewrite IHsz; reflexivity.\nQed.\n\nLemma wpow2_wmsb:\n  forall sz, wmsb (wpow2 sz) false = true.\nProof.\n  induction sz; simpl; intros; auto.\nQed.\n\nLemma wmsb_wnot:\n  forall sz (w: word (S sz)) b1 b2,\n    wmsb (wnot w) b1 = negb (wmsb w b2).\nProof.\n  dependent destruction w; intros.\n  simpl; move w at bottom; move b at bottom.\n  dependent induction w; simpl; auto.\nQed.\n\nLemma wmsb_wneg_true:\n  forall sz (w: word (S sz)),\n    w <> wpow2 sz ->\n    forall b1 b2,\n      wmsb w b1 = true ->\n      wmsb (wneg w) b2 = false.\nProof.\n  dependent destruction w.\n  dependent induction w; intros;\n    [simpl in *; subst; elim H; reflexivity|].\n\n  destruct b.\n  - rewrite wneg_WS_1.\n    rewrite wmsb_ws.\n    rewrite wmsb_wnot with (b2:= false).\n    simpl; apply negb_false_iff; assumption.\n  - rewrite wneg_WS_0.\n    destruct b0; simpl.\n    + rewrite wneg_WS_1; simpl.\n      dependent destruction w.\n      * elim H; reflexivity.\n      * simpl in H0.\n        rewrite wmsb_wnot with (b2:= false).\n        simpl; apply negb_false_iff; assumption.\n    + eapply IHw with (b1:= false); eauto.\n      intro Hx; elim H.\n      clear -Hx.\n      simpl; rewrite Hx; reflexivity.\nQed.\n\nLemma wmsb_wneg_false:\n  forall sz (w: word (S sz)),\n    wordToNat w <> 0 ->\n    forall b1 b2,\n      wmsb w b1 = false ->\n      wmsb (wneg w) b2 = true.\nProof.\n  dependent destruction w.\n  dependent induction w; intros;\n    [simpl in *; subst; elim H; reflexivity|].\n\n  destruct b.\n  - rewrite wneg_WS_1.\n    rewrite wmsb_ws.\n    rewrite wmsb_ws in H0.\n    rewrite wmsb_wnot with (b2:= false).\n    apply negb_true_iff; assumption.\n  - rewrite wneg_WS_0.\n    destruct b0; simpl.\n    + rewrite wneg_WS_1; simpl.\n      dependent destruction w.\n      * discriminate.\n      * simpl in H0.\n        rewrite wmsb_wnot with (b2:= false).\n        simpl; apply negb_true_iff; assumption.\n    + eapply IHw with (b1:= false); eauto.\n      intro Hx; elim H.\n      clear -Hx.\n      simpl in *; lia.\nQed.\n\nLemma zext_WO_wzero:\n  forall n, zext WO n = wzero n.\nProof.\n  reflexivity.\nQed.\n\nLemma wmsb_wneg_zext:\n  forall sz (w: word sz) b n,\n    n <> 0 -> wordToNat w <> 0 ->\n    wmsb (wneg (zext w n)) b = true.\nProof.\n  intros.\n  dependent destruction w; [elim H0; reflexivity|].\n  apply wmsb_wneg_false with (b1:= false).\n  - rewrite <-wordToNat_zext with (n:= n0) in H0.\n    assumption.\n  - apply wmsb_zext; assumption.\nQed.\n\nLemma wminus_WS_pos:\n  forall sz (w1 w2: word (S sz)),\n    wordToZ (WS true w1 ^- WS false w2) =\n    (2 * wordToZ (w1 ^- w2) + 1)%Z.\nProof.\n  unfold wminus; intros.\n  cbn.\n  rewrite wneg_WS_0.\n  rewrite <-wplus_WS_0.\n  rewrite wordToZ_WS_1.\n  reflexivity.\nQed.\n\nLemma wminus_WS_pos':\n  forall sz (w1 w2: word (sz + 1)),\n    wordToZ (WS true w1 ^- WS false w2) =\n    (2 * wordToZ (w1 ^- w2) + 1)%Z.\nProof.\n  intro sz.\n  replace (sz + 1) with (S sz) by lia.\n  intros.\n  apply wminus_WS_pos.\nQed.\n\nLemma wtl_combine:\n  forall (x: word 1) sz (y: word sz),\n    wtl (combine x y) = y.\nProof.\n  intros.\n  do 2 dependent destruction x.\n  reflexivity.\nQed.\n\nLemma extz_combine:\n  forall sz (w: word sz) n, extz w n = combine (natToWord n 0) w.\nProof.\n  reflexivity.\nQed.\n\nLemma combine_assoc_existT:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2) sz3 (w3: word sz3),\n    existT word (sz1 + (sz2 + sz3)) (combine w1 (combine w2 w3)) =\n    existT word (sz1 + sz2 + sz3) (combine (combine w1 w2) w3).\nProof.\n  intros; apply EqdepFacts.eq_sigT_sig_eq.\n  assert (Hsz: sz1 + (sz2 + sz3) = sz1 + sz2 + sz3) by lia.\n  exists Hsz.\n  rewrite (combine_assoc w1 w2 w3 Hsz).\n  reflexivity.\nQed.\n\nLemma sext_combine:\n  forall sz n (w: word (sz + n)) sz1 (w1: word sz1)\n         sz2 (Hsz2: sz2 <> 0) (w2: word sz2),\n    existT word _ w = existT word _ (combine w1 (sext w2 n)) ->\n    exists sw, w = sext sw n /\\ existT word _ sw = existT word _ (combine w1 w2).\nProof.\n  intros; unfold sext in H.\n  remember (wmsb w2 false) as msb2; destruct msb2.\n  - rewrite combine_assoc_existT in H.\n    assert (sz = sz1 + sz2) by (apply eq_sigT_fst in H; lia); subst.\n    destruct_existT.\n    exists (combine w1 w2).\n    split; [|reflexivity].\n    unfold sext.\n    dependent destruction w2; [discriminate|].\n    rewrite wmsb_combine with (b2:= false) by discriminate.\n    rewrite <-Heqmsb2.\n    reflexivity.\n  - rewrite combine_assoc_existT in H.\n    assert (sz = sz1 + sz2) by (apply eq_sigT_fst in H; lia); subst.\n    destruct_existT.\n    exists (combine w1 w2).\n    split; [|reflexivity].\n    unfold sext.\n    dependent destruction w2; [intuition idtac|].\n    rewrite wmsb_combine with (b2:= false) by discriminate.\n    rewrite <-Heqmsb2.\n    reflexivity.\nQed.\n\nLemma wplus_wzero_1:\n  forall sz (w: word sz), w ^+ (wzero _) = w.\nProof.\n  unfold wplus, wordBin; intros.\n  rewrite wordToN_wzero.\n  rewrite N.add_0_r.\n  apply NToWord_wordToN.\nQed.\n\nLemma wplus_wzero_2:\n  forall sz (w: word sz), (wzero _) ^+ w = w.\nProof.\n  unfold wplus, wordBin; intros.\n  rewrite wordToN_wzero.\n  rewrite N.add_0_l.\n  apply NToWord_wordToN.\nQed.\n\nLemma combine_wplus_1:\n  forall sl (w1: word sl) su (w2 w3: word su),\n    combine w1 (w2 ^+ w3) = combine w1 w2 ^+ extz w3 sl.\nProof.\n  dependent induction w1; intros; [reflexivity|].\n  cbn; rewrite IHw1.\n  rewrite <-wplus_WS_0.\n  rewrite extz_combine; reflexivity.\nQed.\n\nLemma combine_wplus_2:\n  forall sl (w1: word sl) su (w2 w3: word su),\n    combine w1 (w2 ^+ w3) = extz w2 sl ^+ combine w1 w3.\nProof.\n  intros.\n  rewrite wplus_comm.\n  rewrite combine_wplus_1.\n  apply wplus_comm.\nQed.\n\nLemma existT_wplus:\n  forall sz (w1 w2: word sz) sz' (w3 w4: word sz'),\n    existT word _ w1 = existT word _ w3 ->\n    existT word _ w2 = existT word _ w4 ->\n    existT word _ (w1 ^+ w2) = existT word _ (w3 ^+ w4).\nProof.\n  intros.\n  rewrite eq_sigT_sig_eq in H; destruct H as [Hsz1 ?].\n  rewrite eq_sigT_sig_eq in H0; destruct H0 as [Hsz2 ?].\n  subst; do 2 rewrite <-(eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nLemma existT_wminus:\n  forall sz (w1 w2: word sz) sz' (w3 w4: word sz'),\n    existT word _ w1 = existT word _ w3 ->\n    existT word _ w2 = existT word _ w4 ->\n    existT word _ (w1 ^- w2) = existT word _ (w3 ^- w4).\nProof.\n  intros.\n  rewrite eq_sigT_sig_eq in H; destruct H as [Hsz1 ?].\n  rewrite eq_sigT_sig_eq in H0; destruct H0 as [Hsz2 ?].\n  subst; do 2 rewrite <-(eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\n\nLemma existT_sext:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2) n,\n    existT word _ w1 = existT word _ w2 ->\n    existT word _ (sext w1 n) = existT word _ (sext w2 n).\nProof.\n  intros; inversion H; reflexivity.\nQed.\n\nLemma existT_extz:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2) n,\n    existT word _ w1 = existT word _ w2 ->\n    existT word _ (extz w1 n) = existT word _ (extz w2 n).\nProof.\n  intros; inversion H; reflexivity.\nQed.\n\nLemma existT_wrshifta:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2) n,\n    existT word _ w1 = existT word _ w2 ->\n    existT word _ (wrshifta w1 n) = existT word _ (wrshifta w2 n).\nProof.\n  intros; inversion H; reflexivity.\nQed.\n\nLemma existT_wlshift:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2) n,\n    existT word _ w1 = existT word _ w2 ->\n    existT word _ (wlshift w1 n) = existT word _ (wlshift w2 n).\nProof.\n  intros; inversion H; reflexivity.\nQed.\n\nLemma eq_rect_wplus:\n  forall sz (w1 w2: word sz) sz' Hsz,\n    eq_rect sz word (w1 ^+ w2) sz' Hsz =\n    (eq_rect sz word w1 sz' Hsz) ^+ (eq_rect sz word w2 sz' Hsz).\nProof.\n  intros; subst.\n  eq_rect_simpl; reflexivity.\nQed.\n\nLemma eq_rect_2:\n  forall sz (pa: word sz) sz' Heq1 Heq2,\n    eq_rect sz' word (eq_rect sz word pa sz' Heq1) sz Heq2 = pa.\nProof.\n  intros; subst.\n  do 2 rewrite <-(eq_rect_eq_dec Nat.eq_dec).\n  reflexivity.\nQed.\n\nLemma wzero_eq_rect:\n  forall sz1 sz2 Heq,\n    eq_rect sz1 word (wzero sz1) sz2 Heq = wzero sz2.\nProof.\n  intros; subst.\n  apply eq_sym, (eq_rect_eq_dec Nat.eq_dec).\nQed.\n\nLemma wrshifta_0:\n  forall sz (w: word sz), wrshifta w 0 = w.\nProof.\n  unfold wrshifta; intros; simpl.\n  unfold eq_rec_r, eq_rec.\n  unfold sext.\n  destruct (wmsb w false).\n  - cbn; rewrite combine_n_0.\n    rewrite eq_rect_2; reflexivity.\n  - cbn; rewrite combine_n_0.\n    rewrite eq_rect_2; reflexivity.\nQed.\n\nLemma wrshifta_WO:\n  forall n, wrshifta WO n = WO.\nProof.\n  unfold wrshifta; cbn; intros.\n  unfold eq_rec_r, eq_rec.\n  rewrite wzero_eq_rect.\n  rewrite <-combine_wzero.\n  rewrite split2_combine.\n  reflexivity.\nQed.\n\nLemma split2_WO:\n  forall n w, split2 n 0 w = WO.\nProof.\n  induction n; cbn; intros; auto.\nQed.\n\nLemma sext_wzero:\n  forall sz n, sext (wzero sz) n = wzero (sz + n).\nProof.\n  unfold sext; intros.\n  rewrite wmsb_wzero.\n  apply combine_wzero.\nQed.\n\nLemma wrshifta_wzero:\n  forall sz n, wrshifta (wzero sz) n = wzero _.\nProof.\n  intros.\n  unfold wrshifta; cbn.\n  rewrite sext_wzero.\n  unfold eq_rec_r, eq_rec.\n  rewrite wzero_eq_rect.\n  rewrite <-combine_wzero.\n  rewrite split2_combine.\n  reflexivity.\nQed.\n\nLemma extz_sext:\n  forall sz (w: word sz) n1 n2,\n    existT word _ (extz (sext w n1) n2) =\n    existT word _ (sext (extz w n2) n1).\nProof.\n  dependent destruction w; cbn; intros.\n  - unfold wzero, extz, sext.\n    rewrite combine_wzero.\n    rewrite combine_wzero.\n    rewrite wmsb_wzero.\n    rewrite combine_wzero.\n    replace (n2 + 0 + n1) with (n2 + n1) by lia.\n    reflexivity.\n  - unfold wzero, extz, sext.\n    rewrite wmsb_combine with (b2:= false) by discriminate.\n    destruct (wmsb (WS b w) false);\n      try (rewrite <-combine_assoc_existT; reflexivity).\nQed.\n\nLemma sext_WS:\n  forall sz (w: word (S sz)) b n,\n    sext (WS b w) n = WS b (sext w n).\nProof.\n  unfold sext; intros.\n  rewrite wmsb_ws.\n  destruct (wmsb w false); reflexivity.\nQed.\n\nLemma sext_wordToZ:\n  forall sz n (w: word sz),\n    wordToZ (sext w n) = wordToZ w.\nProof.\n  dependent induction w; cbn; intros; [apply wordToZ_wzero|].\n  dependent destruction w.\n  - unfold sext; simpl.\n    destruct b; cbn.\n    + rewrite wordToZ_wones by discriminate.\n      reflexivity.\n    + rewrite wordToZ_wzero; reflexivity.\n  - remember (WS b0 w) as ww; clear Heqww.\n    rewrite sext_WS.\n    destruct b.\n    + change (S n0 + n) with (S (n0 + n)) in *.\n      repeat rewrite wordToZ_WS_1.\n      rewrite IHw.\n      reflexivity.\n    + change (S n0 + n) with (S (n0 + n)) in *.\n      repeat rewrite wordToZ_WS_0.\n      rewrite IHw.\n      reflexivity.\nQed.\n\nLemma sext_natToWord': forall sz1 sz2 n,\n  (2 * n < pow2 sz1)%nat ->\n  sext (natToWord sz1 n) sz2 = natToWord (sz1 + sz2) n.\nProof.\n  induction sz1; intros.\n  - simpl. unfold sext. simpl. unfold wzero. unfold pow2 in *.\n    assert (n=0) by lia. subst n. reflexivity.\n  - unfold sext in *.\n    assert (@wmsb (S sz1) (natToWord (S sz1) n) false = false) as E by\n      (apply wmsb_0_natToWord; assumption).\n    rewrite E. clear E.\n    simpl. unfold natToWord. f_equal. fold natToWord.\n    specialize (IHsz1 sz2 (Nat.div2 n)).\n    rewrite <- IHsz1.\n    + assert (@wmsb sz1 (natToWord sz1 (Nat.div2 n)) false = false) as E. {\n        destruct sz1.\n        - reflexivity.\n        - apply wmsb_0_natToWord. unfold pow2 in *. fold pow2 in *.\n          assert ((2 * Nat.div2 n <= n)%nat) by apply two_times_div2_bound. lia.\n      }\n      rewrite E. clear E. reflexivity.\n    + replace (pow2 (S sz1)) with (2 * (pow2 sz1)) in H.\n      * assert ((2 * Nat.div2 n <= n)%nat) by apply two_times_div2_bound. lia.\n      * reflexivity.\nQed.\n\nLemma sext_natToWord: forall sz2 sz1 sz n (e: sz1 + sz2 = sz),\n  (2 * n < pow2 sz1)%nat ->\n  eq_rect (sz1 + sz2) word (sext (natToWord sz1 n) sz2) sz e = natToWord sz n.\nProof.\n  intros. rewrite sext_natToWord' by assumption. rewrite e. reflexivity.\nQed.\n\nLemma sext_wneg_natToWord'': forall sz1 sz2 n,\n  pow2 sz1 <= 2 * n < pow2 (S sz1) ->\n  sext (natToWord sz1 n) sz2 = natToWord (sz1 + sz2) (pow2 (sz1+sz2) - (pow2 sz1 - n)).\nProof.\n  induction sz1; intros.\n  - unfold pow2 in H. lia. (* contradiction *)\n  - unfold sext in *.\n    assert (@wmsb (S sz1) (natToWord (S sz1) n) false = true) as E. {\n      apply wmsb_1.\n      rewrite wordToNat_natToWord_idempotent';\n      (unfold pow2 in *; fold pow2 in *; lia).\n    }\n    rewrite E.\n    match goal with\n    | |- _ = $ ?a => remember a as b\n    end.\n    simpl. unfold natToWord. f_equal.\n    + subst b. rewrite mod2sub.\n      * rewrite mod2sub.\n        { replace (S sz1 + sz2) with (S (sz1 + sz2)) by lia.\n          simpl.\n          do 2 rewrite mod2_pow2_twice.\n          do 2 rewrite Bool.xorb_false_l.\n          reflexivity.\n        }\n        simpl in *. lia.\n      * rewrite pow2_add_mul in *. unfold pow2 in *. fold pow2 in *.\n        apply Nat.le_trans with (m := 2 * pow2 sz1); [lia|].\n        rewrite <- Nat.mul_assoc.\n        apply Nat.mul_le_mono_l.\n        rewrite <- Nat.mul_1_r at 1.\n        apply Nat.mul_le_mono_l.\n        apply one_le_pow2.\n    + fold natToWord.\n      specialize (IHsz1 sz2 (Nat.div2 n)).\n      assert (Nat.div2 b = pow2 (sz1 + sz2) - (pow2 sz1 - (Nat.div2 n))) as D2. {\n        rewrite minus_minus.\n        - subst b. replace (S sz1 + sz2) with (S (sz1 + sz2)) by lia.\n          unfold pow2. fold pow2.\n          rewrite minus_minus.\n          * rewrite <- Nat.mul_sub_distr_l. \n            rewrite <- (Nat.add_comm n).\n            rewrite div2_plus_2.\n            apply Nat.add_comm.\n          * rewrite pow2_add_mul. clear IHsz1. unfold pow2 in *. fold pow2 in *.\n            split; [lia|].\n            apply Nat.mul_le_mono_l.\n            rewrite <- Nat.mul_1_r at 1.\n            apply Nat.mul_le_mono_l.\n            apply one_le_pow2.\n        - unfold pow2 in H. fold pow2 in H.\n          split.\n          * pose proof (@div2_compat_lt_l (pow2 sz1) n) as P. lia.\n          * rewrite pow2_add_mul. clear IHsz1.\n            rewrite <- Nat.mul_1_r at 1.\n            apply Nat.mul_le_mono_l.\n            apply one_le_pow2.\n      }\n      rewrite D2.\n      destruct sz1 as [|sz1'].\n      * simpl in H. assert (n=1) by lia. subst n. simpl in D2. simpl.\n        apply wones_natToWord.\n      * assert (n <= S (2 * Nat.div2 n))%nat. {\n          destruct (even_odd_destruct n) as [[m C]|[m C]]; subst n.\n          - rewrite Nat.div2_double. constructor. constructor.\n          - replace (2 * m + 1) with (S (2 * m)) by lia. rewrite Nat.div2_succ_double.\n            constructor.\n        }\n       rewrite <- IHsz1.\n        { assert (@wmsb (S sz1') (natToWord (S sz1') (Nat.div2 n)) false = true) as F. {\n          apply wmsb_1_natToWord.\n          unfold pow2 in *. fold pow2 in *.\n          assert (2 * Nat.div2 n <= n)%nat by apply two_times_div2_bound.\n          clear -H H0 H1.\n          lia. }\n          { rewrite F. reflexivity. }\n        }\n        { assert (2 * Nat.div2 n <= n)%nat by apply two_times_div2_bound.\n          clear -H H0 H1.\n          unfold pow2 in *. fold pow2 in *.\n          lia. }\nQed.\n\nLemma sext_wneg_natToWord': forall sz1 sz2 n,\n  (2 * n < pow2 sz1)%nat ->\n  sext (wneg (natToWord sz1 n)) sz2 = wneg (natToWord (sz1 + sz2) n).\nProof.\n  intros. rewrite wneg_alt. unfold wnegN.\n  destruct n as [|n].\n  - rewrite roundTrip_0. rewrite Nat.sub_0_r. rewrite natToWord_pow2.\n    unfold sext.\n    assert (wmsb (natToWord sz1 0) false = false) as W. {\n      destruct sz1.\n      + simpl. reflexivity.\n      + apply wmsb_0_natToWord. assumption.\n    }\n    rewrite W.\n    rewrite combine_wzero.\n    symmetry.\n    apply wneg_zero'.\n  - rewrite sext_wneg_natToWord''.\n    + rewrite wneg_alt. unfold wnegN.\n      rewrite wordToNat_natToWord_idempotent' by lia.\n      rewrite wordToNat_natToWord_idempotent'.\n      * replace (pow2 sz1 - (pow2 sz1 - S n)) with (S n) by lia.\n        reflexivity.\n      * rewrite pow2_add_mul.\n        apply Nat.le_trans with (m := pow2 sz1); [lia|].\n        rewrite <- Nat.mul_1_r at 1.\n        apply Nat.mul_le_mono_l.\n        apply one_le_pow2.\n    + rewrite wordToNat_natToWord_idempotent' by lia.\n      simpl. lia.\nQed.\n\nLemma sext_wneg_natToWord: forall sz2 sz1 sz n (e: sz1 + sz2 = sz),\n  (2 * n < pow2 sz1)%nat ->\n  eq_rect (sz1 + sz2) word (sext (wneg (natToWord sz1 n)) sz2) sz e = wneg (natToWord sz n).\nProof.\n  intros. rewrite sext_wneg_natToWord' by assumption. rewrite e. reflexivity.\nQed.\n\nLemma wordToNat_split1:\n  forall sz1 sz2 (w: word (sz1 + sz2)),\n    wordToNat (split1 _ _ w) =\n    Nat.modulo (wordToNat w) (pow2 sz1).\nProof.\n  induction sz1; intros; [reflexivity|].\n  dependent destruction w.\n  simpl; rewrite IHsz1.\n  pose proof (zero_lt_pow2 sz1).\n  destruct b.\n  - change (pow2 sz1 + (pow2 sz1 + 0)) with (2 * pow2 sz1).\n    replace (S (wordToNat w * 2)) with (1 + 2 * wordToNat w) by lia.\n    rewrite Nat.add_mod by lia.\n    rewrite Nat.mul_mod_distr_l; [|lia|discriminate].\n    rewrite Nat.mod_1_l by lia.\n    rewrite Nat.mul_comm with (n:= 2).\n    change (1 + wordToNat w mod pow2 sz1 * 2) with (S (wordToNat w mod pow2 sz1 * 2)).\n    apply eq_sym, Nat.mod_small.\n    assert (pow2 sz1 <> 0) by lia.\n    pose proof (Nat.mod_upper_bound (wordToNat w) (pow2 sz1) H0).\n    lia.\n  - change (pow2 sz1 + (pow2 sz1 + 0)) with (2 * pow2 sz1).\n    rewrite Nat.mul_comm with (n:= 2).\n    rewrite Nat.mul_mod_distr_r; [|lia|discriminate].\n    reflexivity.\nQed.\n\nLemma wordToNat_split2:\n  forall sz1 sz2 (w: word (sz1 + sz2)),\n    wordToNat (split2 _ _ w) =\n    Nat.div (wordToNat w) (pow2 sz1).\nProof.\n  induction sz1; intros;\n    [rewrite Nat.div_1_r; reflexivity|].\n  dependent destruction w.\n  change (split2 (S sz1) sz2 (WS b w))\n    with (split2 sz1 sz2 w).\n  rewrite IHsz1.\n  destruct b.\n  - unfold pow2; fold pow2.\n    replace (@wordToNat (S sz1 + sz2) w~1)\n      with (1 + 2 * wordToNat w) by (simpl; lia).\n    rewrite <-Nat.div_div;\n      [|discriminate|pose proof (zero_lt_pow2 sz1); lia].\n    rewrite Nat.mul_comm, Nat.div_add by discriminate.\n    rewrite Nat.div_small with (b := 2) by lia.\n    reflexivity.\n  - unfold pow2; fold pow2.\n    replace (@wordToNat (S sz1 + sz2) w~0)\n      with (2 * wordToNat w) by (simpl; lia).\n    rewrite Nat.div_mul_cancel_l;\n      [|pose proof (zero_lt_pow2 sz1); lia|discriminate].\n    reflexivity.\nQed.\n\nLemma wordToNat_wrshifta:\n  forall sz (w: word sz) n,\n    wordToNat (wrshifta w n) =\n    Nat.div (wordToNat (sext w n)) (pow2 n).\nProof.\n  unfold wrshifta; intros.\n  rewrite wordToNat_split2.\n  unfold eq_rec_r, eq_rec.\n  rewrite wordToNat_eq_rect.\n  reflexivity.\nQed.\n\nLemma wordToNat_combine:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2),\n    wordToNat (combine w1 w2) =\n    wordToNat w1 + pow2 sz1 * wordToNat w2.\nProof.\n  dependent induction w1; intros; [simpl; lia|].\n  unfold pow2; fold pow2.\n  rewrite Nat.mul_comm with (n:= 2). (* to avoid [simpl] *)\n  simpl; destruct b.\n  - rewrite IHw1; simpl.\n    rewrite Nat.mul_comm with (n:= pow2 n * 2).\n    rewrite Nat.mul_assoc.\n    rewrite <-Nat.mul_add_distr_r.\n    rewrite Nat.mul_comm with (n:= pow2 n).\n    reflexivity.\n  - rewrite IHw1.\n    rewrite Nat.mul_comm with (n:= pow2 n * 2).\n    rewrite Nat.mul_assoc.\n    rewrite <-Nat.mul_add_distr_r.\n    rewrite Nat.mul_comm with (n:= pow2 n).\n    reflexivity.\nQed.\n\nLemma wordToNat_wlshift:\n  forall sz (w: word sz) n,\n    wordToNat (wlshift w n) =\n    Nat.mul (Nat.modulo (wordToNat w) (pow2 (sz - n))) (pow2 n).\nProof.\n  intros; destruct (le_dec n sz).\n  \n  - unfold wlshift; intros.\n    rewrite wordToNat_split1.\n    unfold eq_rec_r, eq_rec.\n    rewrite wordToNat_eq_rect.\n    rewrite wordToNat_combine.\n    rewrite wordToNat_wzero; simpl.\n    replace (pow2 sz) with (pow2 (sz - n + n)) by (f_equal; lia).\n    rewrite pow2_add_mul.\n    rewrite Nat.mul_comm with (n:= pow2 (sz - n)).\n    rewrite Nat.mul_mod_distr_l;\n      [|pose proof (zero_lt_pow2 (sz - n)); lia\n       |pose proof (zero_lt_pow2 n); lia].\n    apply Nat.mul_comm.\n\n  - assert (n > sz)%nat by lia.\n    rewrite wlshift_gt by assumption.\n    replace (sz - n) with 0 by lia.\n    rewrite wordToNat_wzero; simpl; reflexivity.\nQed.\n\nLemma wordToNat_extz:\n  forall sz (w: word sz) n,\n    wordToNat (extz w n) = pow2 n * wordToNat w.\nProof.\n  unfold extz; intros.\n  rewrite wordToNat_combine.\n  rewrite wordToNat_wzero.\n  reflexivity.\nQed.\n\nLemma extz_is_mult_pow2: forall sz n d,\n  extz (natToWord sz n) d = natToWord (d + sz) (pow2 d * n).\nProof.\n  intros. induction d.\n  - unfold extz.\n    rewrite combine_0_n.\n    simpl.\n    f_equal.\n    lia.\n  - unfold extz in *.\n    change (pow2 (S d) * n) with (2 * pow2 d * n).\n    rewrite <- Nat.mul_assoc.\n    change ((S d) + sz) with (S (d + sz)) in *.\n    rewrite <- natToWord_times2.\n    simpl.\n    fold natToWord.\n    f_equal.\n    exact IHd.\nQed.\n\nLemma extz_is_mult_pow2_neg: forall sz n d,\n  extz (wneg (natToWord sz n)) d = wneg (natToWord (d + sz) (pow2 d * n)).\nProof.\n  intros. induction d.\n  - unfold extz.\n    rewrite combine_0_n.\n    simpl.\n    f_equal. f_equal.\n    lia.\n  - unfold extz in *.\n    change (pow2 (S d) * n) with (2 * pow2 d * n).\n    rewrite <- Nat.mul_assoc.\n    change ((S d) + sz) with (S (d + sz)) in *.\n    rewrite <- natToWord_times2.\n    simpl.\n    fold natToWord.\n    f_equal.\n    rewrite wneg_WS_0.\n    f_equal.\n    exact IHd.\nQed.\n\nLemma wordToNat_sext_bypass:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2) (Hsz: sz1 = sz2) n,\n    wordToNat w1 = wordToNat w2 ->\n    wordToNat (sext w1 n) = wordToNat (sext w2 n).\nProof.\n  intros; subst.\n  apply wordToNat_inj in H; subst.\n  reflexivity.\nQed.\n  \nLemma combine_sext:\n  forall sz1 (w1: word sz1) sz2 (w2: word (S sz2)) n,\n    existT word _ (combine w1 (sext w2 n)) =\n    existT word _ (sext (combine w1 w2) n).\nProof.\n  unfold sext; intros.\n  rewrite wmsb_combine with (b2:= false) by discriminate.\n  destruct (wmsb w2 false); apply combine_assoc_existT.\nQed.\n\nLemma extz_extz:\n  forall sz (w: word sz) n1 n2,\n    existT word _ (extz (extz w n1) n2) =\n    existT word _ (extz w (n2 + n1)).\nProof.\n  unfold extz; cbn; intros.\n  rewrite combine_assoc_existT.\n  rewrite combine_wzero.\n  reflexivity.\nQed.\n\nLemma wrshifta_extz_sext:\n  forall sz (w: word sz) n1 n2,\n    existT word _ (wrshifta (extz w (n1 + n2)) n1) =\n    existT word _ (sext (extz w n2) n1).\nProof.\n  intros.\n  rewrite <-extz_sext.\n  apply wordToNat_existT; [lia|].\n  rewrite wordToNat_wrshifta.\n\n  replace (wordToNat (sext (extz w (n1 + n2)) n1))\n    with (wordToNat (sext (extz (extz w n2) n1) n1)).\n  - replace (wordToNat (sext (extz (extz w n2) n1) n1))\n      with (wordToNat (extz (sext (extz w n2) n1) n1))\n      by apply existT_wordToNat, extz_sext.\n    do 2 rewrite wordToNat_extz.\n    rewrite Nat.mul_comm, Nat.div_mul\n      by (pose proof (zero_lt_pow2 n1); lia).\n    replace (wordToNat (sext (extz w n2) n1))\n      with (wordToNat (extz (sext w n1) n2))\n      by apply existT_wordToNat, extz_sext.\n    rewrite wordToNat_extz.\n    reflexivity.\n  - apply wordToNat_sext_bypass; [lia|].\n    apply existT_wordToNat.\n    apply extz_extz.\nQed.\n\nLemma wordToNat_sext_modulo:\n  forall sz (w: word sz) n,\n    Nat.modulo (wordToNat (sext w n)) (pow2 sz) = wordToNat w.\nProof.\n  unfold sext; intros.\n  pose proof (zero_lt_pow2 sz).\n  destruct (wmsb w false).\n  - rewrite wordToNat_combine.\n    rewrite Nat.mul_comm, Nat.mod_add by lia.\n    apply Nat.mod_small.\n    apply wordToNat_bound.\n  - rewrite wordToNat_combine.\n    rewrite Nat.mul_comm, Nat.mod_add by lia.\n    apply Nat.mod_small.\n    apply wordToNat_bound.\nQed.\n\nLemma wlshift_sext_extz:\n  forall sz (w: word sz) n,\n    existT word _ (wlshift (sext w n) n) =\n    existT word _ (extz w n).\nProof.\n  intros; apply wordToNat_existT; [lia|].\n  rewrite wordToNat_wlshift.\n  rewrite wordToNat_extz.\n  replace (sz + n - n) with sz by lia.\n  rewrite wordToNat_sext_modulo.\n  apply Nat.mul_comm.\nQed.\n\nLemma wlshift_combine_extz:\n  forall sn sl (wl: word sl) ssu (wu: word (ssu + sn)),\n    existT word (sl + (ssu + sn)) (wlshift (combine wl wu) sn) =\n    existT word (sn + (sl + ssu)) (extz (combine wl (split1 ssu _ wu)) sn).\nProof.\n  intros; apply wordToNat_existT; [lia|].\n  rewrite wordToNat_wlshift.\n  rewrite wordToNat_combine.\n  rewrite wordToNat_extz.\n  rewrite wordToNat_combine.\n  rewrite wordToNat_split1.\n\n  replace (sl + (ssu + sn) - sn) with (sl + ssu) by lia.\n  rewrite Nat.mul_comm; f_equal.\n  rewrite pow2_add_mul.\n  pose proof (zero_lt_pow2 sl).\n  pose proof (zero_lt_pow2 ssu).\n  rewrite Nat.mod_mul_r; try lia.\n  rewrite Nat.mul_comm with (n:= pow2 sl) at 1.\n  rewrite Nat.mod_add; [|lia].\n  rewrite Nat.mod_small by apply wordToNat_bound.\n  do 3 f_equal.\n  rewrite Nat.mul_comm, Nat.div_add; [|lia].\n  rewrite Nat.div_small by apply wordToNat_bound.\n  reflexivity.\nQed.\n\nLemma extz_sext_eq_rect:\n  forall sz (w: word sz) n1 n2 nsz Hnsz1,\n  exists Hnsz2,\n    eq_rect (n2 + (sz + n1)) word (extz (sext w n1) n2) nsz Hnsz1 =\n    eq_rect (n2 + sz + n1) word (sext (extz w n2) n1) nsz Hnsz2.\nProof.\n  intros; subst; simpl.\n  assert (Hsz: n2 + sz + n1 = n2 + (sz + n1)) by lia.\n  exists Hsz.\n  pose proof (extz_sext w n1 n2).\n  pose proof (eq_sigT_snd H).\n  rewrite <-H0.\n  eq_rect_simpl.\n  reflexivity.\nQed.\n\nLemma sext_zero:\n  forall n m, sext (natToWord n 0) m = natToWord _ 0.\nProof.\n  unfold sext; intros.\n  rewrite wmsb_wzero.\n  rewrite combine_wzero.\n  reflexivity.\nQed.\n\nLemma sext_split1:\n  forall sz (w: word sz) n,\n    split1 sz _ (sext w n) = w.\nProof.\n  unfold sext; intros.\n  destruct (wmsb w false); apply split1_combine.\nQed.\n\nLemma sext_sext:\n  forall sz (w: word sz) n1 n2,\n    existT word _ (sext w (n1 + n2)) = existT word _ (sext (sext w n1) n2).\nProof.\n  unfold sext; intros.\n  remember (wmsb w false) as wmsb; destruct wmsb.\n  - destruct n1 as [|n1].\n    + cbn; rewrite wmsb_combine_WO, <-Heqwmsb.\n      rewrite <-combine_assoc_existT.\n      reflexivity.\n    + rewrite wmsb_combine with (b2:= false) by discriminate.\n      rewrite wmsb_wones.\n      rewrite <-combine_assoc_existT.\n      rewrite combine_wones.\n      reflexivity.\n  - destruct n1 as [|n1].\n    + cbn; rewrite wmsb_combine_WO, <-Heqwmsb.\n      rewrite <-combine_assoc_existT.\n      reflexivity.\n    + rewrite wmsb_combine with (b2:= false) by discriminate.\n      rewrite wmsb_wzero.\n      rewrite <-combine_assoc_existT.\n      rewrite combine_wzero.\n      reflexivity.\nQed.\n\nLemma wneg_wordToN:\n  forall sz (w: word sz),\n    wordToN w <> 0%N ->\n    wordToN (wneg w) = (Npow2 sz - wordToN w)%N.\nProof.\n  unfold wneg; intros.\n  rewrite wordToN_NToWord_2.\n  - reflexivity.\n  - pose proof (wordToN_bound w).\n    nlia.\nQed.\n\nLemma Nmul_two:\n  forall n, (n + n = 2 * n)%N.\nProof.\n  intros.\n  destruct n; simpl; auto.\n  rewrite Pos.add_diag.\n  reflexivity.\nQed.\n\nLemma wmsb_false_bound:\n  forall sz (w: word (S sz)),\n    wmsb w false = false -> (wordToN w < Npow2 sz)%N.\nProof.\n  dependent destruction w.\n  dependent induction w;\n    [simpl; intros; subst; nlia|].\n  intros; rewrite Npow2_S, Nmul_two.\n  destruct b.\n  - destruct b0.\n    + specialize (IHw H).\n      rewrite wordToN_WS_1.\n      rewrite N.add_comm.\n      apply N.mul_2_mono_l; auto.\n    + dependent destruction w.\n      * simpl; clear; nlia.\n      * specialize (IHw H).\n        rewrite wordToN_WS_1, wordToN_WS_0.\n        rewrite wordToN_WS_1 in IHw.\n        rewrite N.add_comm.\n        apply N.mul_2_mono_l.\n        nlia.\n  - destruct b0.\n    + dependent destruction w.\n      * simpl in H; discriminate.\n      * specialize (IHw H).\n        rewrite wordToN_WS_0, wordToN_WS_1.\n        rewrite wordToN_WS_0 in IHw.\n        apply N.mul_lt_mono_pos_l; [nlia|].\n        rewrite Npow2_S, Nmul_two in IHw.\n        apply N.mul_lt_mono_pos_l in IHw; [|nlia].\n        rewrite Npow2_S, Nmul_two.\n        rewrite N.add_comm.\n        apply N.mul_2_mono_l.\n        assumption.\n    + specialize (IHw H).\n      rewrite wordToN_WS_0.\n      apply N.mul_lt_mono_pos_l; [nlia|].\n      assumption.\nQed.\n\nLemma wmsb_true_bound:\n  forall sz (w: word (S sz)),\n    wmsb w false = true -> (Npow2 sz <= wordToN w)%N.\nProof.\n  dependent destruction w.\n  dependent induction w;\n    [simpl; intros; subst; reflexivity|].\n  intros; rewrite Npow2_S, Nmul_two.\n  destruct b.\n  - destruct b0.\n    + specialize (IHw H).\n      rewrite wordToN_WS_1.\n      apply N.mul_le_mono_nonneg_l with (p:= 2%N) in IHw; [|compute; discriminate].\n      rewrite N.add_1_r.\n      apply N.le_le_succ_r.\n      assumption.\n    + dependent destruction w.\n      * simpl in H; discriminate.\n      * specialize (IHw H).\n        rewrite wordToN_WS_1, wordToN_WS_0.\n        rewrite wordToN_WS_1 in IHw.\n        apply N.lt_eq_cases in IHw; destruct IHw.\n        { apply N.lt_succ_r.\n          rewrite <-N.add_1_r.\n          replace (2 * (2 * wordToN (WS b w)) + 1 + 1)%N\n            with (2 * (2 * wordToN (WS b w)) + 2 * 1)%N by nlia.\n          rewrite <-N.mul_add_distr_l.\n          apply N.mul_lt_mono_pos_l; [nlia|].\n          assumption.\n        }\n        { exfalso.\n          rewrite Npow2_S, Nmul_two in H0.\n          assert (N.even (2 * Npow2 n) = N.even (2 * wordToN (WS b w) + 1))\n            by (rewrite H0; reflexivity).\n          rewrite N.even_mul, N.even_2 in H1.\n          rewrite N.add_comm, N.even_add_mul_2, N.even_1 in H1.\n          discriminate.\n        }\n  - destruct b0.\n    + dependent destruction w.\n      * simpl in H; discriminate.\n      * specialize (IHw H).\n        rewrite wordToN_WS_0, wordToN_WS_1.\n        rewrite wordToN_WS_0 in IHw.\n        apply N.mul_le_mono_nonneg_l; [compute; discriminate|].\n        rewrite N.add_1_r.\n        apply N.le_le_succ_r.\n        assumption.\n    + specialize (IHw H).\n      rewrite wordToN_WS_0.\n      apply N.mul_le_mono_nonneg_l; [compute; discriminate|].\n      assumption.\nQed.\n\nLemma ZToWord_wordToZ:\n  forall sz (w: word sz), ZToWord sz (wordToZ w) = w.\nProof.\n  unfold ZToWord, wordToZ; intros.\n  remember (wmsb w false) as msb; destruct msb.\n  - remember (wordToN (wneg w)) as ww.\n    destruct ww.\n    + assert (wneg w = wzero _).\n      { apply wordToN_inj; rewrite <-Heqww.\n        rewrite wordToN_nat.\n        rewrite roundTrip_0.\n        reflexivity.\n      }\n      rewrite wzero'_def.\n      rewrite <-wneg_idempotent, H.\n      apply eq_sym, wzero_wneg.\n    + assert (wneg w = NToWord _ (N.pos p)).\n      { apply wordToN_inj; rewrite Heqww.\n        rewrite NToWord_wordToN.\n        reflexivity.\n      }\n      rewrite <-wneg_idempotent, H.\n      reflexivity.\n  - remember (wordToN w) as ww.\n    destruct ww.\n    + assert (w = wzero _); subst.\n      { apply wordToN_inj; rewrite <-Heqww.\n        rewrite wordToN_nat.\n        rewrite roundTrip_0.\n        reflexivity.\n      }\n      apply wzero'_def.\n    + assert (w = NToWord _ (N.pos p)); subst.\n      { apply wordToN_inj; rewrite Heqww.\n        rewrite NToWord_wordToN.\n        reflexivity.\n      }\n      reflexivity.\nQed.\n\nLemma wordToZ_ZToWord:\n  forall z sz,\n    (- Z.of_nat (pow2 sz) <= z < Z.of_nat (pow2 sz))%Z ->\n    wordToZ (ZToWord (S sz) z) = z.\nProof.\n  unfold wordToZ, ZToWord; intros.\n  destruct z.\n  - rewrite wmsb_wzero'.\n    rewrite wordToN_wzero'.\n    reflexivity.\n\n  - rewrite posToWord_nat.\n    remember (wmsb (natToWord (S sz) (Pos.to_nat p)) false) as msb.\n    destruct msb.\n    + exfalso.\n      simpl in H; destruct H.\n      apply eq_sym, wmsb_true_bound in Heqmsb.\n      rewrite <-positive_N_nat, <-NToWord_nat in Heqmsb.\n      rewrite <-positive_nat_Z in H0.\n      apply Nat2Z.inj_lt in H0.\n      rewrite <-positive_N_nat, <-Npow2_nat in H0.\n      apply Nlt_in in H0.\n      pose proof (wordToN_NToWord (S sz) (N.pos p)).\n      destruct H1 as [k [? ?]].\n      rewrite H1 in Heqmsb.\n      assert (N.pos p - k * Npow2 (S sz) <= N.pos p)%N by apply N.le_sub_l.\n      assert (Npow2 sz <= N.pos p)%N by (etransitivity; eassumption).\n      apply N.le_ngt in H4; auto.\n    + rewrite wordToN_nat, wordToNat_natToWord_2.\n      * rewrite positive_nat_N; reflexivity.\n      * rewrite <-Npow2_nat, <-positive_N_nat.\n        apply Nlt_out.\n        destruct H.\n        rewrite <-N2Z.inj_pos, <-N_nat_Z in H0.\n        apply Nat2Z.inj_lt in H0.\n        rewrite <-Npow2_nat in H0.\n        apply Nlt_in.\n        rewrite Npow2_S, N2Nat.inj_add.\n        lia.\n                                  \n  - rewrite wneg_idempotent.\n    rewrite posToWord_nat.\n    remember (wmsb (wneg (natToWord (S sz) (Pos.to_nat p))) false) as msb.\n    destruct msb.\n    + rewrite wordToN_nat, wordToNat_natToWord_2.\n      * rewrite positive_nat_N; reflexivity.\n      * rewrite <-Npow2_nat, <-positive_N_nat.\n        apply Nlt_out.\n        destruct H.\n        apply Z.opp_le_mono in H.\n        rewrite Pos2Z.opp_neg, Z.opp_involutive in H.\n        rewrite <-N2Z.inj_pos, <-N_nat_Z in H.\n        apply Nat2Z.inj_le in H.\n        rewrite <-Npow2_nat in H.\n        apply Nlt_in.\n        rewrite Npow2_S, N2Nat.inj_add.\n        assert (N.to_nat (Npow2 sz) > 0)%nat by (rewrite Npow2_nat; apply pow2_zero).\n        lia.\n    + exfalso.\n      simpl in H.\n      apply eq_sym, wmsb_false_bound in Heqmsb.\n      rewrite wneg_wordToN in Heqmsb.\n      * rewrite Npow2_S in Heqmsb.\n        rewrite <-N.add_0_r in Heqmsb.\n        rewrite <-N.add_sub_assoc in Heqmsb.\n        { apply N.add_lt_mono_l in Heqmsb.\n          exfalso; eapply N.nlt_0_r; eauto.\n        }\n        { destruct H.\n          apply Z.opp_le_mono in H.\n          rewrite Pos2Z.opp_neg, Z.opp_involutive in H.\n          rewrite <-N2Z.inj_pos, <-N_nat_Z in H.\n          apply Nat2Z.inj_le in H.\n          rewrite positive_N_nat in H.\n          rewrite <-positive_N_nat, <-NToWord_nat.\n          pose proof (wordToN_NToWord (S sz) (N.pos p)).\n          destruct H1 as [k [? ?]]; rewrite H1.\n          etransitivity; [apply N.le_sub_l|].\n          rewrite <-Npow2_nat in H.\n          rewrite <-positive_N_nat in H.\n          unfold N.le; rewrite N2Nat.inj_compare.\n          apply nat_compare_le; auto.\n        }\n      * intro Hx.\n        replace 0%N with (wordToN (wzero (S sz))) in Hx by apply wordToN_wzero.\n        apply wordToN_inj in Hx.\n        assert (wordToNat (natToWord (S sz) (Pos.to_nat p)) = 0)\n          by (rewrite Hx; apply wordToNat_wzero).\n        rewrite wordToNat_natToWord_2 in H0.\n        { clear -H0.\n          induction p; simpl in H0; try discriminate.\n          elim IHp; rewrite Pos2Nat.inj_xO in H0; lia.\n        }\n        { destruct H.\n          apply Z.opp_le_mono in H.\n          rewrite Pos2Z.opp_neg, Z.opp_involutive in H.\n          rewrite <-N2Z.inj_pos, <-N_nat_Z in H.\n          apply Nat2Z.inj_le in H.\n          rewrite positive_N_nat in H.\n          simpl.\n          pose proof (pow2_zero sz).\n          lia.\n        }\nQed.\n\nLemma wordToZ_ZToWord'': forall (sz: nat),\n    (0 < sz)%nat ->\n    forall n: Z,\n      (- 2 ^ (Z.of_nat sz - 1) <= n < 2 ^ (Z.of_nat sz - 1))%Z ->\n      wordToZ (ZToWord sz n) = n.\nProof.\n  intros.\n  destruct sz; [lia|].\n  apply wordToZ_ZToWord.\n  replace (Z.of_nat (S sz) - 1)%Z with (Z.of_nat sz) in * by lia.\n  rewrite Nat2Z.inj_pow.\n  assumption.\nQed.\n\nLemma wordToZ_wordToN:\n  forall sz (w: word sz),\n    wordToZ w = (Z.of_N (wordToN w) - Z.of_N (if wmsb w false then Npow2 sz else 0))%Z.\nProof.\n  unfold wordToZ; intros.\n  remember (wmsb w false) as msb; destruct msb;\n    [|simpl; rewrite Z.sub_0_r; reflexivity].\n  destruct (weq w (wzero _)); subst;\n    [rewrite wmsb_wzero in Heqmsb; discriminate|].\n  rewrite wneg_wordToN.\n  - pose proof (wordToN_bound w).\n    replace (Z.of_N (wordToN w) - Z.of_N (Npow2 sz))%Z\n      with (- (Z.of_N (Npow2 sz) - Z.of_N (wordToN w)))%Z by lia.\n    rewrite <-N2Z.inj_sub by (apply N.lt_le_incl; assumption).\n    clear; destruct (Npow2 sz - wordToN w)%N; reflexivity.\n  - intro Hx; elim n.\n    rewrite <-wordToN_wzero with (sz:= sz) in Hx.\n    apply wordToN_inj in Hx; auto.\nQed.\n\nLemma ZToWord_Z_of_N:\n  forall sz n,\n    ZToWord sz (Z.of_N n) = NToWord sz n.\nProof.\n  unfold ZToWord, NToWord; intros.\n  destruct n; reflexivity.\nQed.\n\nLemma ZToWord_Z_of_nat: forall sz x, ZToWord sz (Z.of_nat x) = natToWord sz x.\nProof.\n  intros.\n  rewrite <- nat_N_Z.\n  rewrite ZToWord_Z_of_N.\n  rewrite NToWord_nat.\n  rewrite Nnat.Nat2N.id.\n  reflexivity.\nQed.\n\nLemma natToWord_Z_to_nat: forall sz n,\n    (0 <= n)%Z ->\n    natToWord sz (Z.to_nat n) = ZToWord sz n.\nProof.\n  intros. rewrite <- ZToWord_Z_of_nat.\n  rewrite Z2Nat.id by assumption.\n  reflexivity.\nQed.\n\nLemma ZToWord_sz0: forall z, ZToWord 0 z = $0.\nProof.\n  intros. unfold ZToWord. destruct z; try rewrite posToWord_sz0; reflexivity.\nQed.\n\nLemma ZToWord_0: forall sz, ZToWord sz 0 = wzero sz.\nProof.\n  intros. unfold ZToWord. apply wzero'_def.\nQed.\n\nLemma ZToWord_1{sz : nat}: ZToWord sz 1 = wone sz.\nProof.\n  intros.\n  rewrite <- natToWord_Z_to_nat by (cbv; discriminate).\n  reflexivity.\nQed.\n\nLemma natToWord_pow2_add:\n  forall sz n,\n    natToWord sz (n + pow2 sz) = natToWord sz n.\nProof.\n  induction sz; intros; [reflexivity|].\n  unfold natToWord, pow2; fold natToWord pow2.\n  rewrite drop_mod2_add, div2_plus_2, IHsz.\n  reflexivity.\nQed.\n\nLemma nat_add_pow2_wzero:\n  forall sz n1 n2,\n    n1 + n2 = pow2 sz ->\n    natToWord sz n1 ^+ natToWord sz n2 = wzero sz.\nProof.\n  intros.\n  rewrite <-natToWord_plus, H.\n  rewrite natToWord_pow2.\n  reflexivity.\nQed.\n\nLemma Npos_Npow2_wzero:\n  forall sz p1 p2,\n    N.pos (p1 + p2) = Npow2 sz ->\n    posToWord sz p1 ^+ posToWord sz p2 = wzero sz.\nProof.\n  intros.\n  do 2 rewrite posToWord_nat.\n  assert (Pos.to_nat p1 + Pos.to_nat p2 = pow2 sz).\n  { rewrite <-Pos2Nat.inj_add, <-Npow2_nat.\n    rewrite <-positive_N_nat.\n    rewrite H; reflexivity.\n  }\n  apply nat_add_pow2_wzero; auto.\nQed.\n\nLemma ZToWord_Npow2_sub:\n  forall sz z,\n    ZToWord sz (z - Z.of_N (Npow2 sz)) = ZToWord sz z.\nProof.\n  unfold ZToWord; intros.\n  remember (z - Z.of_N (Npow2 sz))%Z as zz.\n  destruct z.\n  - destruct zz.\n    + assert (Z.of_N (Npow2 sz) = 0)%Z by lia.\n      change 0%Z with (Z.of_N 0%N) in H.\n      apply N2Z.inj in H.\n      exfalso; eapply Npow2_not_zero; eauto.\n    + pose proof (N2Z.is_nonneg (Npow2 sz)).\n      destruct (Z.of_N (Npow2 sz)); simpl in Heqzz, H;\n        try discriminate.\n      pose proof (Pos2Z.neg_is_neg p0); lia.\n    + assert (Z.of_N (Npow2 sz) = Z.pos p).\n      { rewrite Z.sub_0_l, <-Pos2Z.opp_pos in Heqzz.\n        apply Z.opp_inj in Heqzz; auto.\n      }\n      rewrite <-N2Z.inj_pos in H.\n      apply N2Z.inj in H.\n      rewrite posToWord_nat, <-positive_N_nat, <-H.\n      rewrite Npow2_nat, natToWord_pow2.\n      rewrite wzero_wneg.\n      apply eq_sym, wzero'_def.\n\n  - destruct zz.\n    + assert (Z.of_N (Npow2 sz) = Z.pos p) by lia.\n      rewrite <-N2Z.inj_pos in H.\n      apply N2Z.inj in H.\n      rewrite posToWord_nat, <-positive_N_nat, <-H.\n      rewrite Npow2_nat, natToWord_pow2.\n      apply wzero'_def.\n    + assert (Z.pos p = Z.pos p0 + Z.of_N (Npow2 sz))%Z by lia.\n      do 2 rewrite <-N2Z.inj_pos in H.\n      rewrite <-N2Z.inj_add in H.\n      apply N2Z.inj in H.\n      apply eq_sym.\n      do 2 rewrite posToWord_nat, <-positive_N_nat.\n      rewrite H, N2Nat.inj_add, Npow2_nat.\n      apply natToWord_pow2_add.\n    + assert (Z.pos p - Z.neg p0 = Z.of_N (Npow2 sz))%Z by lia.\n      simpl in H.\n      remember (Npow2 sz) as n; destruct n;\n        [exfalso; eapply Npow2_not_zero; eauto|].\n      rewrite N2Z.inj_pos in H; inversion H; subst; clear H.\n      apply eq_sym, sub_0_eq.\n      rewrite wminus_def, wneg_idempotent.\n      apply Npos_Npow2_wzero; auto.\n      \n  - destruct zz.\n    + assert (Z.neg p = Z.of_N (Npow2 sz))%Z by lia.\n      pose proof (N2Z.is_nonneg (Npow2 sz)).\n      rewrite <-H in H0.\n      pose proof (Pos2Z.neg_is_neg p); lia.\n    + assert (Z.neg p = Z.pos p0 + Z.of_N (Npow2 sz))%Z by lia.\n      pose proof (N2Z.is_nonneg (Npow2 sz)).\n      destruct (Z.of_N (Npow2 sz)); simpl in H;\n        try discriminate.\n      pose proof (Pos2Z.neg_is_neg p1); lia.\n    + assert (Pos.to_nat p0 = Pos.to_nat p + pow2 sz).\n      { rewrite <-Npow2_nat.\n        do 2 rewrite <-positive_N_nat.\n        rewrite <-N2Nat.inj_add.\n        f_equal.\n        pose proof (N2Z.is_nonneg (Npow2 sz)).\n        remember (Z.of_N (Npow2 sz)) as z; destruct z.\n        { change 0%Z with (Z.of_N 0) in Heqz.\n          apply N2Z.inj in Heqz.\n          exfalso; eapply Npow2_not_zero; eauto.\n        }\n        { simpl in Heqzz; inversion Heqzz; subst.\n          rewrite <-N2Z.inj_pos in Heqz.\n          apply N2Z.inj in Heqz.\n          rewrite <-Heqz.\n          reflexivity.\n        }\n        { pose proof (Zlt_neg_0 p1); lia. }\n      }\n      f_equal.\n      do 2 rewrite posToWord_nat.\n      rewrite H.\n      apply natToWord_pow2_add.\nQed.\n\nLemma wplus_wplusZ:\n  forall sz (w1 w2: word sz),\n    w1 ^+ w2 = wplusZ w1 w2.\nProof.\n  unfold wplus, wplusZ, wordBin, wordBinZ; intros.\n  do 2 rewrite wordToZ_wordToN.\n  match goal with\n  | [ |- context[(?z1 - ?z2 + (?z3 - ?z4))%Z] ] =>\n    replace (z1 - z2 + (z3 - z4))%Z with (z1 + z3 - z2 - z4)%Z by lia\n  end.\n  rewrite <-N2Z.inj_add.\n  destruct (wmsb w1 false); destruct (wmsb w2 false).\n  - simpl; do 2 rewrite ZToWord_Npow2_sub.\n    apply eq_sym, ZToWord_Z_of_N.\n  - simpl; rewrite Z.sub_0_r, ZToWord_Npow2_sub.\n    apply eq_sym, ZToWord_Z_of_N.\n  - simpl; rewrite Z.sub_0_r, ZToWord_Npow2_sub.\n    apply eq_sym, ZToWord_Z_of_N.\n  - simpl; do 2 rewrite Z.sub_0_r.\n    apply eq_sym, ZToWord_Z_of_N.\nQed.\n\nLemma ZToWord_Npow2_sub_k : forall (sz : nat) (z : Z) (k: nat),\n    ZToWord sz (z - Z.of_nat k * Z.of_N (Npow2 sz)) = ZToWord sz z.\nProof.\n  intros. induction k.\n  - simpl. f_equal. lia.\n  - rewrite <- IHk.\n    replace (z - Z.of_nat (S k) * Z.of_N (Npow2 sz))%Z\n       with ((z - Z.of_nat k * Z.of_N (Npow2 sz)) - Z.of_N (Npow2 sz))%Z by nia.\n    apply ZToWord_Npow2_sub.\nQed.\n\nLemma ZToWord_Npow2_add_k : forall (sz : nat) (z : Z) (k: nat),\n    ZToWord sz (z + Z.of_nat k * Z.of_N (Npow2 sz)) = ZToWord sz z.\nProof.\n  intros.\n  replace z with (z + Z.of_nat k * Z.of_N (Npow2 sz) - Z.of_nat k * Z.of_N (Npow2 sz))%Z at 2\n    by lia.\n  symmetry.\n  apply ZToWord_Npow2_sub_k.\nQed.\n\nLemma ZToWord_Npow2_sub_z : forall (sz : nat) (z : Z) (k: Z),\n    ZToWord sz (z - k * Z.of_N (Npow2 sz)) = ZToWord sz z.\nProof.\n  intros. destruct k.\n  - simpl. f_equal. lia.\n  - rewrite <- positive_nat_Z. apply ZToWord_Npow2_sub_k.\n  - rewrite <- Pos2Z.opp_pos.\n    replace (z - - Z.pos p * Z.of_N (Npow2 sz))%Z\n       with (z +   Z.pos p * Z.of_N (Npow2 sz))%Z by nia.\n    rewrite <- positive_nat_Z. apply ZToWord_Npow2_add_k.\nQed.\n\nLemma ZToWord_Npow2_add_k':  forall sz z k,\n    ZToWord sz (z + k * Z.of_N (Npow2 sz)) = ZToWord sz z.\nProof.\n  intros. assert (0 <= k \\/ k < 0)%Z as C by lia. destruct C as [C | C].\n  - pose proof (ZToWord_Npow2_add_k sz z (Z.to_nat k)) as Q.\n    rewrite Znat.Z2Nat.id in Q; assumption.\n  - pose proof (ZToWord_Npow2_sub_k sz z (Z.to_nat (- k))) as Q.\n    rewrite Znat.Z2Nat.id in Q by lia.\n    rewrite <- Q.\n    f_equal.\n    lia.\nQed.\n\nLemma wordToZ_ZToWord': forall sz w,\n    exists k, wordToZ (ZToWord sz w) = (w - k * Z.of_N (Npow2 sz))%Z.\nProof.\n  intros.\n  destruct sz.\n  - simpl. exists w%Z. rewrite ZToWord_sz0. rewrite wordToZ_wzero. lia.\n  - exists ((w + Z.of_nat (pow2 sz)) / Z.of_N (Npow2 (S sz)))%Z.\n    erewrite <- ZToWord_Npow2_sub_z.\n    rewrite wordToZ_ZToWord.\n    + reflexivity.\n    + replace w with ((- Z.of_nat (pow2 sz)) + (w + Z.of_nat (pow2 sz)))%Z at 1 3 by lia.\n      rewrite <- Z.add_sub_assoc.\n      replace (Z.of_N (Npow2 (S sz))) with (2 * Z.of_nat (pow2 sz))%Z.\n      * remember (Z.of_nat (pow2 sz)) as M.\n        assert (M > 0)%Z. {\n          subst. destruct (pow2 sz) eqn: E.\n          - exfalso. eapply pow2_ne_zero. exact E.\n          - simpl. constructor.\n        }\n        rewrite <- Zdiv.Zmod_eq_full by lia.\n        pose proof (Zdiv.Z_mod_lt (w + M) (2 * M)). lia.\n      * rewrite <- Npow2_nat. rewrite N_nat_Z.\n        rewrite Npow2_S. rewrite N2Z.inj_add. lia.\nQed.\n\nLemma ZToWord_plus: forall sz a b, ZToWord sz (a + b) = ZToWord sz a ^+ ZToWord sz b.\nProof.\n  destruct sz as [|sz]; intros n m; intuition auto with worder.\n  rewrite wplus_wplusZ.\n  unfold wplusZ, wordBinZ.\n  destruct (wordToZ_ZToWord' (S sz) n) as [k1 D1].\n  destruct (wordToZ_ZToWord' (S sz) m) as [k2 D2].\n  rewrite D1.\n  rewrite D2.\n  replace (n - k1 * Z.of_N (Npow2 (S sz)) + (m - k2 * Z.of_N (Npow2 (S sz))))%Z\n     with (n + m - (k1 + k2) * Z.of_N (Npow2 (S sz)))%Z by nia.\n  symmetry.\n  apply ZToWord_Npow2_sub_z.\nQed.\n\nLemma wplus_Z:  forall sz (a b : word sz),\n    a ^+ b = ZToWord sz (wordToZ a + wordToZ b).\nProof.\n  intros. rewrite ZToWord_plus. rewrite! ZToWord_wordToZ. reflexivity.\nQed.\n\nLemma else_0_to_ex_N: forall (b: bool) (a: N),\n    exists k, (if b then a else 0%N) = (k * a)%N.\nProof.\n  intros. destruct b.\n  - exists 1%N. nia.\n  - exists 0%N. reflexivity.\nQed.\n\nLocal Lemma wmultZ_helper: forall a b k1 k2 p,\n    ((a - k1 * p) * (b - k2 * p) = a * b - (k1 * b + k2 * a - k1 * k2 * p) * p)%Z.\nProof. intros. nia. Qed.\n\nLemma wmult_wmultZ: forall (sz : nat) (w1 w2 : word sz), w1 ^* w2 = wmultZ w1 w2.\nProof.\n  unfold wmultZ, wmult, wordBinZ, wordBin. intros.\n  do 2 rewrite wordToZ_wordToN.\n  destruct (else_0_to_ex_N (wmsb w1 false) (Npow2 sz)) as [k1 E1]. rewrite E1. clear E1.\n  destruct (else_0_to_ex_N (wmsb w2 false) (Npow2 sz)) as [k2 E2]. rewrite E2. clear E2.\n  do 2 rewrite N2Z.inj_mul.\n  rewrite wmultZ_helper.\n  rewrite <- N2Z.inj_mul.\n  rewrite ZToWord_Npow2_sub_z.\n  rewrite ZToWord_Z_of_N.\n  reflexivity.\nQed.\n\nLemma ZToWord_mult: forall sz a b, ZToWord sz (a * b) = ZToWord sz a ^* ZToWord sz b.\nProof.\n  intros. rewrite wmult_wmultZ. unfold wmultZ, wordBinZ.\n  destruct (wordToZ_ZToWord' sz a) as [k1 D1]. rewrite D1. clear D1.\n  destruct (wordToZ_ZToWord' sz b) as [k2 D2]. rewrite D2. clear D2.\n  rewrite wmultZ_helper.\n  symmetry.\n  apply ZToWord_Npow2_sub_z.\nQed.\n\nLemma wmult_Z:  forall sz (a b : word sz),\n    a ^* b = ZToWord sz (wordToZ a * wordToZ b).\nProof.\n  intros. rewrite ZToWord_mult. rewrite! ZToWord_wordToZ. reflexivity.\nQed.\n\nLemma wordToZ_wplus_bound:\n  forall sz (w1 w2: word (S sz)),\n    (- Z.of_nat (pow2 sz) <= wordToZ w1 + wordToZ w2 < Z.of_nat (pow2 sz))%Z ->\n    (wordToZ w1 + wordToZ w2 = wordToZ (w1 ^+ w2))%Z.\nProof.\n  intros.\n  rewrite wplus_wplusZ.\n  unfold wplusZ, wordBinZ.\n  remember (wordToZ w1 + wordToZ w2)%Z as z; clear Heqz.\n  apply eq_sym, wordToZ_ZToWord; assumption.\nQed.\n\nLemma wordToZ_wplus_bound':\n  forall sz (w1 w2: word sz),\n    sz <> 0 ->\n    (- Z.of_nat (pow2 (pred sz)) <= wordToZ w1 + wordToZ w2 < Z.of_nat (pow2 (pred sz)))%Z ->\n    (wordToZ w1 + wordToZ w2 = wordToZ (w1 ^+ w2))%Z.\nProof.\n  intros.\n  destruct sz; [exfalso; auto|clear H].\n  apply wordToZ_wplus_bound; auto.\nQed.\n\nLemma wordToZ_size':\n  forall sz (w: word (S sz)),\n    (- Z.of_nat (pow2 sz) <= wordToZ w < Z.of_nat (pow2 sz))%Z.\nProof.\n  unfold wordToZ; intros.\n  remember (wmsb w false) as msb; destruct msb.\n  - destruct (weq w (wpow2 _)).\n    + subst; rewrite wpow2_wneg.\n      rewrite wpow2_Npow2.\n      remember (Npow2 sz) as np.\n      destruct np; [exfalso; eapply Npow2_not_zero; eauto|].\n      split.\n      * rewrite <-Pos2Z.opp_pos, <-N2Z.inj_pos.\n        rewrite Heqnp.\n        rewrite <-Npow2_nat.\n        rewrite N_nat_Z.\n        reflexivity.\n      * etransitivity.\n        { apply Pos2Z.neg_is_neg. }\n        { change 0%Z with (Z.of_nat 0).\n          apply Nat2Z.inj_lt.\n          apply zero_lt_pow2.\n        }\n    + assert (wordToN (wneg w) < Npow2 sz)%N.\n      { apply wmsb_false_bound.\n        eapply wmsb_wneg_true; eauto.\n      }\n      remember (wordToN (wneg w)) as ww; clear Heqww.\n      destruct ww; simpl.\n      * split; try lia.\n        change 0%Z with (Z.of_nat 0).\n        apply Nat2Z.inj_lt.\n        apply zero_lt_pow2.\n      * split.\n        { rewrite <-Pos2Z.opp_pos, <-N2Z.inj_pos.\n          rewrite <-Npow2_nat.\n          rewrite N_nat_Z.\n          rewrite <-Z.opp_le_mono.\n          apply N2Z.inj_le.\n          apply N.lt_le_incl.\n          assumption.\n        }\n        { etransitivity.\n          { apply Pos2Z.neg_is_neg. }\n          { change 0%Z with (Z.of_nat 0).\n            apply Nat2Z.inj_lt.\n            apply zero_lt_pow2.\n          }\n        }\n  - apply eq_sym, wmsb_false_bound in Heqmsb.\n    destruct (wordToN w); simpl.\n    * split; try lia.\n      change 0%Z with (Z.of_nat 0).\n      apply Nat2Z.inj_lt.\n      apply zero_lt_pow2.\n    * split.\n      { etransitivity.\n        { apply Z.opp_nonpos_nonneg.\n          change 0%Z with (Z.of_nat 0).\n          apply Nat2Z.inj_le.\n          pose proof (zero_lt_pow2 sz); lia.\n        }\n        { pose proof (Pos2Z.is_pos p); lia. }\n      }\n      { rewrite <-N2Z.inj_pos.\n        rewrite <-Npow2_nat.\n        rewrite N_nat_Z.\n        apply N2Z.inj_lt.\n        assumption.\n      }\nQed.\n\nLemma wordToZ_size:\n  forall sz (w: word (S sz)),\n    (Z.abs (wordToZ w) <= Z.of_nat (pow2 sz))%Z.\nProof.\n  intros.\n  pose proof (wordToZ_size' w).\n  destruct H.\n  apply Z.abs_le.\n  split; lia.\nQed.\n\nLemma wordToZ_size'': forall (sz : nat),\n    (0 < sz)%nat ->\n    forall  w : word sz,\n      (- 2 ^ (Z.of_nat sz - 1) <= wordToZ w < 2 ^ (Z.of_nat sz - 1))%Z.\nProof.\n  intros.\n  destruct sz; [lia|].\n  pose proof (@wordToZ_size' sz w) as P.\n  replace (Z.of_nat (S sz) - 1)%Z with (Z.of_nat sz) by lia.\n  rewrite Nat2Z.inj_pow in P.\n  exact P.\nQed.\n\nLemma wneg_wzero:\n  forall sz (w: word sz), wneg w = wzero sz -> w = wzero sz.\nProof.\n  intros.\n  pose proof (wminus_inv w).\n  rewrite H in H0.\n  rewrite wplus_comm, wplus_unit in H0; subst.\n  reflexivity.\nQed.\n\nLemma wmsb_false_pos:\n  forall sz (w: word sz),\n    wmsb w false = false <-> (wordToZ w >= 0)%Z.\nProof.\n  unfold wordToZ; split; intros.\n  - rewrite H.\n    destruct (wordToN w).\n    + lia.\n    + pose proof (Zgt_pos_0 p); lia.\n  - remember (wmsb w false) as b; destruct b; auto.\n    remember (wordToN (wneg w)) as n; destruct n.\n    + replace 0%N with (wordToN (wzero sz)) in Heqn.\n      * apply wordToN_inj in Heqn.\n        apply eq_sym, wneg_wzero in Heqn; subst.\n        rewrite wmsb_wzero in Heqb; discriminate.\n      * rewrite <-wzero'_def.\n        apply wordToN_wzero'.\n    + exfalso; pose proof (Zlt_neg_0 p); lia.\nQed.\n\nLemma wmsb_true_neg:\n  forall sz (w: word sz),\n    wmsb w false = true <-> (wordToZ w < 0)%Z.\nProof.\n  unfold wordToZ; split; intros.\n  - rewrite H.\n    remember (wordToN (wneg w)) as n; destruct n.\n    + replace 0%N with (wordToN (wzero sz)) in Heqn.\n      * apply wordToN_inj in Heqn.\n        apply eq_sym, wneg_wzero in Heqn; subst.\n        rewrite wmsb_wzero in H; discriminate.\n      * rewrite <-wzero'_def.\n        apply wordToN_wzero'.\n    + pose proof (Zlt_neg_0 p); lia.\n  - remember (wmsb w false) as b; destruct b; auto.\n    remember (wordToN w) as n; destruct n.\n    + lia.\n    + pose proof (Zgt_pos_0 p); lia.\nQed.\n\nLemma wordToZ_distr_diff_wmsb:\n  forall sz (w1 w2: word sz),\n    wmsb w1 false = negb (wmsb w2 false) ->\n    wordToZ (w1 ^+ w2) = (wordToZ w1 + wordToZ w2)%Z.\nProof.\n  intros.\n  destruct sz;\n    [rewrite (shatter_word w1), (shatter_word w2); reflexivity|].\n  eapply eq_sym, wordToZ_wplus_bound.\n  pose proof (wordToZ_size' w1).\n  pose proof (wordToZ_size' w2).\n  remember (wmsb w1 false) as msb1; destruct msb1.\n  - apply eq_sym, wmsb_true_neg in Heqmsb1.\n    apply eq_sym, negb_true_iff, wmsb_false_pos in H.\n    destruct H0, H1.\n    split; lia.\n  - apply eq_sym, wmsb_false_pos in Heqmsb1.\n    apply eq_sym, negb_false_iff, wmsb_true_neg in H.\n    destruct H0, H1.\n    split; lia.\nQed.\n\nLemma sext_wplus_wordToZ_distr:\n  forall sz (w1 w2: word sz) n,\n    n <> 0 -> wordToZ (sext w1 n ^+ sext w2 n) =\n              (wordToZ (sext w1 n) + wordToZ (sext w2 n))%Z.\nProof.\n  intros.\n  destruct n; [exfalso; auto|clear H].\n  apply eq_sym, wordToZ_wplus_bound'; [lia|].\n\n  do 2 rewrite sext_wordToZ.\n  destruct sz.\n  - rewrite (shatter_word w1), (shatter_word w2).\n    cbn; split; try (pose proof (pow2_zero n); lia).\n  - replace (pred (S sz + S n)) with (S (sz + n)) by lia.\n    pose proof (wordToZ_size' w1); destruct H.\n    pose proof (wordToZ_size' w2); destruct H1.\n    split.\n    + rewrite pow2_S_z.\n      etransitivity; [|apply Z.add_le_mono; eassumption].\n      rewrite <-Z.add_diag, Z.opp_add_distr.\n      apply Z.add_le_mono;\n        rewrite <-Z.opp_le_mono; apply Nat2Z.inj_le, pow2_le; lia.\n    + rewrite pow2_S_z.\n      eapply Z.lt_le_trans; [apply Z.add_lt_mono; eassumption|].\n      rewrite <-Z.add_diag.\n      apply Z.add_le_mono; apply Nat2Z.inj_le, pow2_le; lia.\nQed.\n\nLemma sext_wplus_wordToZ_distr_existT:\n  forall sz (w1 w2: word sz) ssz (sw1 sw2: word ssz) n,\n    existT word _ w1 = existT word _ (sext sw1 n) ->\n    existT word _ w2 = existT word _ (sext sw2 n) ->\n    n <> 0 -> wordToZ (w1 ^+ w2) = (wordToZ w1 + wordToZ w2)%Z.\nProof.\n  intros.\n  assert (sz = ssz + n) by (apply eq_sigT_fst in H; auto); subst.\n  destruct_existT.\n  apply sext_wplus_wordToZ_distr; auto.\nQed.\n\nLemma split1_existT:\n  forall n sz1 (w1: word (n + sz1)) sz2 (w2: word (n + sz2)),\n    existT word _ w1 = existT word _ w2 ->\n    split1 n _ w1 = split1 n _ w2.\nProof.\n  intros.\n  assert (sz1 = sz2) by (apply eq_sigT_fst in H; lia); subst.\n  destruct_existT.\n  reflexivity.\nQed.\n\nLemma word_combinable:\n  forall sz1 sz2 (w: word (sz1 + sz2)),\n  exists w1 w2, w = combine w1 w2.\nProof.\n  intros.\n  exists (split1 _ _ w), (split2 _ _ w).\n  apply eq_sym, combine_split.\nQed.\n\nLemma split1_combine_existT:\n  forall sz n (w: word (n + sz)) sl (wl: word (n + sl)) su (wu: word su),\n    existT word _ w = existT word _ (combine wl wu) ->\n    split1 n _ w = split1 n _ wl.\nProof.\n  intros.\n  pose proof (word_combinable _ _ w).\n  destruct H0 as [? [? ?]]; subst.\n  pose proof (word_combinable _ _ wl).\n  destruct H0 as [? [? ?]]; subst.\n  assert (sz = sl + su) by (apply eq_sigT_fst in H; lia); subst.\n  pose proof (word_combinable _ _ x0).\n  destruct H0 as [? [? ?]]; subst.\n  do 2 rewrite split1_combine.\n  rewrite combine_assoc_existT in H.\n  destruct_existT.\n  assert (split1 _ _ (split1 _ _ (combine (combine x x3) x4)) =\n          split1 _ _ (split1 _ _ (combine (combine x1 x2) wu)))\n    by (rewrite H; reflexivity).\n  repeat rewrite split1_combine in H0.\n  assumption.\nQed.\n\nLemma extz_pow2_wordToZ:\n  forall sz (w: word sz) n,\n    wordToZ (extz w n) = (wordToZ w * Z.of_nat (pow2 n))%Z.\nProof.\n  induction n; [cbn; lia|].\n  rewrite pow2_S_z.\n  change (wordToZ (extz w (S n))) with (wordToZ (combine (natToWord n 0) w)~0).\n  rewrite wordToZ_WS_0.\n  unfold extz, wzero in IHn.\n  rewrite IHn.\n  rewrite Z.mul_assoc.\n  rewrite Z.mul_comm with (n:= 2%Z).\n  apply eq_sym, Z.mul_assoc.\nQed.\n\nLemma extz_wneg:\n  forall sz (w: word sz) n,\n    extz (wneg w) n = wneg (extz w n).\nProof.\n  induction n; intros; [reflexivity|].\n  cbn; rewrite wneg_WS_0.\n  unfold extz, wzero in IHn.\n  rewrite IHn.\n  reflexivity.\nQed.\n\nLemma wneg_wordToZ:\n  forall sz (w: word (S sz)),\n    w <> wpow2 sz ->\n    wordToZ (wneg w) = (- wordToZ w)%Z.\nProof.\n  intros.\n  assert (wordToZ (wneg w) + wordToZ w = 0)%Z.\n  { destruct (weq w (wzero _)).\n    { subst; rewrite wzero_wneg, wordToZ_wzero.\n      reflexivity.\n    }\n    { rewrite <-wordToZ_distr_diff_wmsb.\n      { rewrite wplus_comm, wminus_inv.\n        apply wordToZ_wzero.\n      }\n      { remember (wmsb w false) as msb; destruct msb.\n        { eapply wmsb_wneg_true; eauto. }\n        { eapply wmsb_wneg_false; eauto.\n          intro Hx; elim n.\n          apply wordToNat_inj.\n          rewrite wordToNat_wzero, Hx; reflexivity.\n        }\n      }\n    }\n  }\n  lia.\nQed.\n\nLemma wneg_wordToZ':\n  forall sz (w: word (S sz)) z,\n    w <> wpow2 sz ->\n    (z + wordToZ (wneg w))%Z = (z - wordToZ w)%Z.\nProof.\n  intros.\n  rewrite wneg_wordToZ by assumption.\n  lia.\nQed.\n\nLemma wneg_wplus_distr:\n  forall sz (w1 w2: word sz),\n    wneg (w1 ^+ w2) = wneg w1 ^+ wneg w2.\nProof.\n  intros.\n  apply wplus_cancel with (c:= w1 ^+ w2).\n  rewrite wplus_comm, wminus_inv.\n  rewrite wplus_comm, wplus_assoc.\n  rewrite <-wplus_assoc with (x:= w1).\n  rewrite wplus_comm with (x:= w2).\n  rewrite wplus_assoc.\n  rewrite wminus_inv.\n  rewrite wplus_wzero_2.\n  rewrite wminus_inv.\n  reflexivity.\nQed.\n\nLemma wminus_wneg:\n  forall sz (w1 w2: word sz),\n    wneg (w1 ^- w2) = w2 ^- w1.\nProof.\n  unfold wminus; intros.\n  rewrite wneg_wplus_distr.\n  rewrite wneg_idempotent.\n  apply wplus_comm.\nQed.\n\nLemma wminus_wordToZ:\n  forall sz (w1 w2: word (S sz)),\n    w2 ^- w1 <> wpow2 sz ->\n    wordToZ (w1 ^- w2) = (- wordToZ (w2 ^- w1))%Z.\nProof.\n  intros.\n  rewrite <-wneg_idempotent with (w:= w1 ^- w2).\n  rewrite wminus_wneg.\n  rewrite wneg_wordToZ by assumption.\n  reflexivity.\nQed.\n\nLemma wminus_wordToZ':\n  forall sz (w1 w2: word (sz + 1)),\n    existT word _ (w2 ^- w1) <> existT word _ (wpow2 sz) ->\n    wordToZ (w1 ^- w2) = (- wordToZ (w2 ^- w1))%Z.\nProof.\n  intro sz.\n  replace (sz + 1) with (S sz) by lia.\n  intros.\n  apply wminus_wordToZ.\n  intro Hx; elim H.\n  rewrite Hx; reflexivity.\nQed.\n\nLemma wminus_wminusZ: forall (sz : nat) (w1 w2 : word sz), w1 ^- w2 = wminusZ w1 w2.\nProof.\n  unfold wminusZ, wminus, wordBinZ. intros. rewrite <- Z.add_opp_r.\n  rewrite wplus_wplusZ. unfold wplusZ, wordBinZ.\n  destruct sz.\n  - do 2 rewrite ZToWord_sz0. reflexivity.\n  - destruct (weq w2 (wpow2 sz)).\n    + subst. rewrite wpow2_wneg.\n      replace (wordToZ w1 + - wordToZ (wpow2 sz))%Z\n         with (wordToZ w1 + wordToZ (wpow2 sz) - 2 * wordToZ (wpow2 sz))%Z by lia.\n      replace (2 * wordToZ (wpow2 sz))%Z with (- 1 * Z.of_N (Npow2 (S sz)))%Z.\n      * symmetry. apply ZToWord_Npow2_sub_z.\n      * rewrite wordToZ_wordToN.\n        rewrite wpow2_wmsb.\n        rewrite wpow2_Npow2.\n        rewrite Npow2_S.\n        rewrite N2Z.inj_add.\n        lia.\n    + rewrite wneg_wordToZ by assumption. reflexivity.\nQed.\n\nLocal Lemma wminusZ_helper: forall a b k1 k2 p,\n    ((a - k1 * p) - (b - k2 * p) = a - b - (k1 - k2) * p)%Z.\nProof. intros. nia. Qed.\n\nLemma ZToWord_minus: forall sz a b, ZToWord sz (a - b) = ZToWord sz a ^- ZToWord sz b.\nProof.\n  intros. rewrite wminus_wminusZ. unfold wminusZ, wordBinZ.\n  destruct (wordToZ_ZToWord' sz a) as [k1 D1]. rewrite D1. clear D1.\n  destruct (wordToZ_ZToWord' sz b) as [k2 D2]. rewrite D2. clear D2.\n  rewrite wminusZ_helper.\n  symmetry.\n  apply ZToWord_Npow2_sub_z.\nQed.\n\nLemma wminus_Z: forall sz (a b : word sz),\n    a ^- b = ZToWord sz (wordToZ a - wordToZ b).\nProof.\n  intros. rewrite ZToWord_minus. rewrite! ZToWord_wordToZ. reflexivity.\nQed.\n\nLemma ZToWord_opp_wneg{sz: nat}: forall (x: Z),\n    ZToWord sz (- x) = ^~ (ZToWord sz x).\nProof.\n  intros.\n  rewrite wneg_0_wminus.\n  rewrite wminus_wminusZ.\n  unfold wminusZ, wordBinZ.\n  rewrite wordToZ_wzero.\n  rewrite (Z.sub_0_l (wordToZ (ZToWord sz x))).\n  destruct (wordToZ_ZToWord' sz x) as [k E].\n  rewrite E.\n  rewrite Z.opp_sub_distr.\n  rewrite ZToWord_Npow2_add_k'.\n  reflexivity.\nQed.\n\nLemma Zeqb_true_ZToWord: forall {sz: nat} (x y: Z),\n    (x =? y)%Z = true ->\n    ZToWord sz x = ZToWord sz y.\nProof.\n  intros. apply Z.eqb_eq in H. congruence.\nQed.\n\nLemma word_ring_theory_Z: forall (sz: nat),\n    ring_theory (ZToWord sz 0) (ZToWord sz 1)\n                (@wplus sz) (@wmult sz) (@wminus sz) (@wneg sz) eq.\nProof.\n  intros.\n  rewrite ZToWord_0.\n  rewrite ZToWord_1.\n  apply wring.\nQed.\n\nLemma word_ring_morph_Z: forall (sz: nat),\n    ring_morph (ZToWord sz 0) (ZToWord sz 1) (@wplus sz) (@wmult sz) (@wminus sz) (@wneg sz)\n               eq 0%Z 1%Z Z.add Z.mul Z.sub Z.opp Z.eqb\n               (ZToWord sz).\nProof.\n  constructor.\n  + reflexivity.\n  + reflexivity.\n  + exact (@ZToWord_plus sz).\n  + exact (@ZToWord_minus sz).\n  + exact (@ZToWord_mult sz).\n  + exact (@ZToWord_opp_wneg sz).\n  + exact (@Zeqb_true_ZToWord sz).\nQed.\n\nLemma extz_zero:\n  forall sz n, extz (natToWord sz 0) n = wzero _.\nProof.\n  unfold wzero; intros.\n  rewrite extz_combine.\n  apply combine_zero.\nQed.\n\nLemma sext_eq_rect:\n  forall sz (w: word sz) n nsz Hsz1,\n  exists Hsz2,\n    eq_rect (sz + n) word (sext w n) (nsz + n) Hsz1 =\n    sext (eq_rect sz word w nsz Hsz2) n.\nProof.\n  intros.\n  assert (Hsz: sz = nsz) by lia.\n  exists Hsz.\n  subst; simpl.\n  eq_rect_simpl.\n  reflexivity.\nQed.\n\nLemma wmsb_sext:\n  forall sz (w: word sz) n,\n    wmsb (sext w n) false = wmsb w false.\nProof.\n  unfold sext; intros.\n  remember (wmsb w false) as ww; destruct ww.\n  - destruct n; cbn.\n    + rewrite wmsb_combine_WO; auto.\n    + rewrite wmsb_combine with (b2:= false) by discriminate; cbn.\n      clear; induction n; cbn; auto.\n  - destruct n; cbn.\n    + rewrite wmsb_combine_WO; auto.\n    + rewrite wmsb_combine with (b2:= false) by discriminate; cbn.\n      clear; induction n; cbn; auto.\nQed.\n\nLemma wmsb_wlshift_sext:\n  forall sz (w: word sz) n,\n    wmsb (sext w n) false = wmsb (wlshift (sext w n) n) false.",
      "suffix": "\n\nLemma wordToZ_wordToNat_pos:\n  forall sz (w: word sz),\n    wmsb w false = false ->\n    Z.of_nat (wordToNat w) = wordToZ w.\nProof.\n  unfold wordToZ; intros.\n  rewrite H.\n  rewrite <-wordToN_to_nat.\n  destruct (wordToN w).\n  - reflexivity.\n  - simpl; apply positive_nat_Z.\nQed.\n\nCorollary wmsb_Zabs_pos:\n  forall sz (w: word sz),\n    wmsb w false = false -> Z.abs (wordToZ w) = wordToZ w.\nProof.\n  intros.\n  apply wmsb_false_pos in H.\n  unfold Z.abs.\n  destruct (wordToZ w); auto.\n  pose proof (Zlt_neg_0 p); lia.\nQed.\n\nCorollary wmsb_Zabs_neg:\n  forall sz (w: word sz),\n    wmsb w false = true -> (Z.abs (wordToZ w) = - wordToZ w)%Z.\nProof.\n  intros.\n  apply wmsb_true_neg in H.\n  unfold Z.abs.\n  destruct (wordToZ w); auto.\n  pose proof (Zgt_pos_0 p); lia.\nQed.\n\nLemma wordToN_combine:\n  forall sz1 (w1: word sz1) sz2 (w2: word sz2),\n    wordToN (combine w1 w2) = (wordToN w1 + Npow2 sz1 * wordToN w2)%N.\nProof.\n  intros.\n  repeat rewrite wordToN_nat.\n  rewrite pow2_N.\n  rewrite <-Nat2N.inj_mul, <-Nat2N.inj_add.\n  rewrite wordToNat_combine; reflexivity.\nQed.\n\nLemma word_exists_bound:\n  forall sz z,\n    (- Z.of_nat (pow2 sz) <= z < Z.of_nat (pow2 sz))%Z ->\n    exists w: word (S sz), wordToZ w = z.\nProof.\n  intros.\n  exists (ZToWord (S sz) z).\n  apply wordToZ_ZToWord; assumption.\nQed.\n\nLemma sext_size:\n  forall sz n (w: word (sz + n)),\n    sz <> 0 ->\n    (- Z.of_nat (pow2 (sz - 1)) <= wordToZ w < Z.of_nat (pow2 (sz - 1)))%Z ->\n    exists sw, w = sext sw n.\nProof.\n  intros.\n  destruct sz; [exfalso; auto|clear H].\n  simpl in *.\n  replace (sz - 0) with sz in H0 by lia.\n  apply word_exists_bound in H0.\n  destruct H0 as [sw ?].\n  exists sw.\n  apply wordToZ_inj.\n  change (S (sz + n)) with (S sz + n).\n  rewrite sext_wordToZ.\n  auto.\nQed.\n\nLemma wordToZ_combine_WO:\n  forall sz (w: word sz),\n    wordToZ (combine w WO) = wordToZ w.\nProof.\n  dependent induction w; [reflexivity|].\n  simpl; destruct b.\n  - destruct n; [rewrite (shatter_word w); reflexivity|].\n    change (S n + 0) with (S (n + 0)) in *.\n    do 2 rewrite wordToZ_WS_1.\n    rewrite IHw; reflexivity.\n  - do 2 rewrite wordToZ_WS_0.\n    rewrite IHw; reflexivity.\nQed.\n\nLemma combine_WO:\n  forall sz (w: word sz),\n    combine w WO = eq_rect _ word w _ (Nat.add_comm 0 sz).\nProof.\n  intros.\n  apply wordToZ_inj.\n  rewrite wordToZ_eq_rect.\n  apply wordToZ_combine_WO.\nQed.\n  \nLemma zext_zero:\n  forall sz (w: word sz),\n    zext w 0 = eq_rect _ word w _ (Nat.add_comm 0 sz).\nProof.\n  unfold zext; intros.\n  apply combine_WO.\nQed.\n\nLemma wmsb_false_wordToNat_eq:\n  forall sz (w: word (S sz)),\n    wmsb w false = false ->\n    wordToNat w = wordToNat (split1 sz _ (eq_rect _ word w _ (Nat.add_comm 1 sz))).\nProof.\n  intros.\n  remember (eq_rect _ word w _ (Nat.add_comm 1 sz)) as ww.\n  assert (wmsb ww false = false) by (subst; rewrite <-wmsb_eq_rect; assumption).\n  replace (wordToNat w) with (wordToNat ww) by (subst; rewrite wordToNat_eq_rect; reflexivity).\n  clear Heqww H w.\n  apply wmsb_false_split2_wzero in H0.\n  rewrite <-combine_split with (w:= ww) at 1.\n  rewrite wordToNat_combine.\n  rewrite <-H0.\n  cbn; lia.\nQed.\n\nLemma wordToZ_bound_weakened:\n  forall z n, (Z.abs z < n)%Z -> (- n <= z < n)%Z.\nProof.\n  intros.\n  apply Z.abs_lt in H.\n  lia.\nQed.\n\nLemma zext_size:\n  forall sz n (w: word (sz + n)),\n    (- Z.of_nat (pow2 sz) <= wordToZ w < Z.of_nat (pow2 sz))%Z ->\n    wmsb w false = false ->\n    exists sw, w = zext sw n.\nProof.\n  intros.\n  destruct n.\n  - exists (eq_rect _ word w _ (Nat.add_comm _ _)).\n    rewrite zext_zero.\n    apply eq_sym, eq_rect_2.\n  - apply word_exists_bound in H.\n    destruct H as [ssw ?].\n    assert (wmsb ssw false = false).\n    { apply wmsb_false_pos; apply wmsb_false_pos in H0.\n      rewrite H; assumption.\n    }\n    eexists.\n    apply wordToZ_inj.\n    rewrite zext_wordToNat_equal_Z by discriminate.\n    rewrite <-H.\n    rewrite <-wordToZ_wordToNat_pos by assumption.\n    rewrite wmsb_false_wordToNat_eq by assumption.\n    reflexivity.\nQed.\n\nLemma zext_size_1:\n  forall sz (w: word (sz + 1)),\n    wmsb w false = false ->\n    exists sw, w = zext sw 1.\nProof.\n  intros.\n  apply zext_size; auto.\n  generalize dependent w.\n  replace (sz + 1) with (S sz) by lia.\n  intros.\n  unfold wordToZ.\n  rewrite H.\n  apply wmsb_false_bound in H.\n  remember (wordToN w) as n; destruct n; simpl.\n  - split.\n    + lia.\n    + pose proof (pow2_zero sz); lia.\n  - rewrite <-N2Z.inj_pos.\n    rewrite <-N_nat_Z.\n    split; [lia|].\n    apply inj_lt.\n    rewrite <-Npow2_nat.\n    apply Nlt_out; auto.\nQed.\n\nLemma sext_wplus_exist:\n  forall sz (w1 w2: word sz) n,\n  exists w: word (S sz),\n    existT word _ (sext w1 (S n) ^+ sext w2 (S n)) =\n    existT word _ (sext w n).\nProof.\n  intros; eexists.\n  apply wordToZ_existT; [lia|].\n  rewrite sext_wplus_wordToZ_distr by discriminate.\n  do 3 rewrite sext_wordToZ.\n  assert (- Z.of_nat (pow2 sz) <= wordToZ w1 + wordToZ w2 < Z.of_nat (pow2 sz))%Z.\n  { clear n.\n    dependent destruction w1.\n    { rewrite (shatter_word w2); cbn; lia. }\n    { remember (WS b w1) as ww1; clear Heqww1 w1 b.\n      pose proof (wordToZ_size' ww1).\n      pose proof (wordToZ_size' w2).\n      destruct H, H0.\n      split.\n      { simpl; do 2 rewrite Nat2Z.inj_add; lia. }\n      { simpl; do 2 rewrite Nat2Z.inj_add; lia. }\n    }\n  }\n  apply wordToZ_ZToWord in H.\n  rewrite <-H.\n  reflexivity.\nQed.\n\n(* Making wlt_dec opaque is necessary to prevent the [exact H] in the\n * example below from blowing up..\n *)\nGlobal Opaque wlt_dec.\nDefinition test_wlt_f (a : nat) (b : nat) : nat :=\n  if wlt_dec (natToWord 64 a) $0 then 0 else 0.\nTheorem test_wlt_f_example: forall x y z, test_wlt_f x y = 0 -> test_wlt_f x z = 0.\nProof.\n  intros.\n  exact H.\nQed.\n\nLemma wordToNat_eq1: forall sz (a b: word sz), a = b -> wordToNat a = wordToNat b.\nProof.\n  intros; subst; reflexivity.\nQed.\n\nLemma wordToNat_eq2: forall sz (a b: word sz), wordToNat a = wordToNat b -> a = b.\nProof.\n  intros.\n  rewrite <- natToWord_wordToNat with (w := a).\n  rewrite <- natToWord_wordToNat with (w := b).\n  rewrite H.\n  reflexivity.\nQed.\n\nLemma wordToNat_lt1: forall sz (a b: word sz), a < b -> (wordToNat a < wordToNat b)%nat.\nProof.\n  intros.\n  pre_nlia.\n  repeat rewrite wordToN_to_nat in H.\n  assumption.\nQed.\n\nLemma wordToNat_lt2: forall sz (a b: word sz), (wordToNat a < wordToNat b)%nat -> a < b.\nProof.\n  intros.\n  pre_nlia.\n  repeat rewrite wordToN_to_nat.\n  assumption.\nQed.\n\nLemma wordToNat_gt1: forall sz (a b: word sz), a > b -> (wordToNat a > wordToNat b)%nat.\nProof.\n  intros.\n  pre_nlia.\n  repeat rewrite wordToN_to_nat in H.\n  assumption.\nQed.\n\nLemma wordToNat_gt2: forall sz (a b: word sz), (wordToNat a > wordToNat b)%nat -> a > b.\nProof.\n  intros.\n  pre_nlia.\n  repeat rewrite wordToN_to_nat.\n  assumption.\nQed.\n\nLemma wordToNat_le1: forall sz (a b: word sz), a <= b -> (wordToNat a <= wordToNat b)%nat.\nProof.\n  intros.\n  pre_nlia.\n  repeat rewrite wordToN_to_nat in H.\n  assumption.\nQed.\n\nLemma wordToNat_le2: forall sz (a b: word sz), (wordToNat a <= wordToNat b)%nat -> a <= b.\nProof.\n  intros.\n  pre_nlia.\n  repeat rewrite wordToN_to_nat.\n  assumption.\nQed.\n\nLemma wordToNat_ge1: forall sz (a b: word sz), a >= b -> (wordToNat a >= wordToNat b)%nat.\nProof.\n  intros.\n  pre_nlia.\n  repeat rewrite wordToN_to_nat in H.\n  assumption.\nQed.\n\nLemma wordToNat_ge2: forall sz (a b: word sz), (wordToNat a >= wordToNat b)%nat -> a >= b.\nProof.\n  intros.\n  pre_nlia.\n  repeat rewrite wordToN_to_nat.\n  assumption.\nQed.\n\nLemma wordToNat_neq1: forall sz (a b: word sz), a <> b -> wordToNat a <> wordToNat b.\nProof.\n  unfold not.\n  intros.\n  apply wordToNat_eq2 in H0.\n  tauto.\nQed.\n\nLemma wordToNat_neq2: forall sz (a b: word sz), wordToNat a <> wordToNat b -> a <> b.\nProof.\n  unfold not.\n  intros.\n  subst.\n  tauto.\nQed.\n\nLemma wordToNat_wplus': forall sz (a b: word sz),\n    (#a + #b < pow2 sz)%nat ->\n    #(a ^+ b) = #a + #b.\nProof.\n  intros.\n  rewrite <-? wordToN_to_nat in *.\n  rewrite <-? Nnat.N2Nat.inj_add in *.\n  rewrite <- Npow2_nat in *.\n  apply Nlt_in in H.\n  rewrite wordToN_plus by assumption.\n  reflexivity.\nQed.\n\nLemma wordToNat_wplus'': forall sz (a: word sz) (b: nat),\n    (#a + b < pow2 sz)%nat -> #(a ^+ $b) = #a + b.\nProof.\n  intros. rewrite wordToNat_wplus';\n  rewrite wordToNat_natToWord_2; lia.\nQed.\n\nLemma wordToNat_wmult': forall sz (a b: word sz),\n    (#a * #b < pow2 sz)%nat ->\n    #(a ^* b) = #a * #b.\nProof.\n  intros.\n  rewrite <-? wordToN_to_nat in *.\n  rewrite <-? Nnat.N2Nat.inj_mul in *.\n  rewrite <- Npow2_nat in *.\n  apply Nlt_in in H.\n  rewrite wordToN_mult by assumption.\n  reflexivity.\nQed.\n\nLemma wordNotNot: forall sz (a b: word sz), (a <> b -> False) -> a = b.\nProof.\n  intros.\n  destruct (weq a b); subst; tauto.\nQed.\n\nLtac pre_word_lia :=\n  unfold wzero, wone in *;\n  repeat match goal with\n           | H: @eq ?T ?a ?b |- _ =>\n             match T with\n               | word ?sz =>\n                 apply (@wordToNat_eq1 sz a b) in H;\n                   rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one in H;\n                   simpl in H\n             end\n           | |- @eq ?T ?a ?b =>\n             match T with\n               | word ?sz =>\n                 apply (@wordToNat_eq2 sz a b);\n                   rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one;\n                   simpl\n             end\n           | H: ?a < ?b |- _ =>\n             apply wordToNat_lt1 in H;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one in H;\n               simpl in H\n           | |- ?a < ?b =>\n             apply wordToNat_lt2;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one;\n               simpl\n           | H: ?a > ?b |- _ =>\n             apply wordToNat_gt1 in H;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one in H;\n               simpl in H\n           | |- ?a > ?b =>\n             apply wordToNat_gt2;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one;\n               simpl\n           | H: ?a <= ?b |- _ =>\n             apply wordToNat_le1 in H;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one in H;\n               simpl in H\n           | |- ?a <= ?b =>\n             apply wordToNat_le2;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one;\n               simpl\n           | H: ?a > ?b -> False |- _ =>\n             apply wordToNat_le1 in H;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one in H;\n               simpl in H\n           | |- ?a > ?b -> False =>\n             apply wordToNat_le2;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one;\n               simpl\n           | H: ?a < ?b -> False |- _ =>\n             apply wordToNat_ge1 in H;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one in H;\n               simpl in H\n           | |- ?a < ?b -> False =>\n             apply wordToNat_ge2;\n               rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one;\n               simpl\n           | H: not (@eq ?T ?a ?b) |- _ =>\n             match T with\n               | word ?sz =>\n                 apply (@wordToNat_neq1 sz a b) in H;\n                   rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one in H;\n                   simpl in H\n             end\n           | |- not (@eq ?T ?a ?b) =>\n             match T with\n               | word ?sz =>\n                 apply (@wordToNat_neq2 sz a b);\n                   rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one;\n                   simpl\n             end\n           | H: @eq ?T ?a ?b -> False |- _ =>\n             match T with\n               | word ?sz =>\n                 apply (@wordToNat_neq1 sz a b) in H;\n                   rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one in H;\n                   simpl in H\n             end\n           | |- @eq ?T ?a ?b -> False =>\n             match T with\n               | word ?sz =>\n                 apply (@wordToNat_neq2 sz a b);\n                   rewrite ?roundTrip_0, ?roundTrip_1, ?wones_pow2_minus_one;\n                   simpl\n             end\n           | H: (@eq ?T ?a ?b -> False) -> False |- _ =>\n             match T with\n               | word ?sz =>\n                 apply (@wordNotNot sz a b) in H\n             end\n           | H: (not (@eq ?T ?a ?b)) -> False |- _ =>\n             match T with\n               | word ?sz =>\n                 apply (@wordNotNot sz a b) in H\n             end\n           | H: not (@eq ?T ?a ?b -> False) |- _ =>\n             match T with\n               | word ?sz =>\n                 apply (@wordNotNot sz a b) in H\n             end\n           | H: not (not (@eq ?T ?a ?b)) |- _ =>\n             match T with\n               | word ?sz =>\n                 apply (@wordNotNot sz a b) in H\n             end\n         end.\n\n\nLtac word_lia := pre_word_lia; lia.\n\n\n\nLemma word_le_ge_eq sz (w1 w2: word sz): w1 <= w2 -> w1 >= w2 -> w1 = w2.\nProof.\n  intros; word_lia.\nQed.\n\nLemma word_le_zero sz (w: word sz): w <= wzero sz -> w = wzero sz.\nProof.\n  intros; word_lia.\nQed.\n\nClose Scope word_scope.\n\nOpen Scope word_scope.\nLocal Open Scope nat.\n\nLemma wzero_wones: forall sz, sz >= 1 ->\n                              natToWord sz 0 <> wones sz.\nProof.\n  intros.\n  unfold not.\n  intros.\n  pose proof (f_equal (@wordToNat sz) H0) as sth.\n  unfold wzero in *.\n  rewrite roundTrip_0 in *.\n  rewrite wones_pow2_minus_one in sth.\n  destruct sz; [lia | ].\n  pose proof (NatLib.one_lt_pow2 sz).\n  lia.\nQed.\n\nLemma wzero_wplus: forall sz w, wzero sz ^+ w = w.\nProof.\n  intros.\n  unfold wzero.\n  apply wplus_unit.\nQed.\n\nLemma wordToNat_nonZero sz (w: word sz):\n  w <> wzero sz -> wordToNat w > 0.\nProof.\n  induction w; simpl; unfold wzero; simpl; intros.\n  - tauto.\n  - destruct b.\n    + lia.\n    + assert (sth: w <> (natToWord n 0)).\n      { intro.\n        subst.\n        tauto.\n      }\n      assert (sth2: wordToNat w <> 0).\n      { intro sth3.\n        specialize (IHw sth).\n        lia.\n      }\n      lia.\nQed.\n\nLemma split2_pow2: forall sz n,\n    2 ^ sz <= n < 2 ^ S sz ->\n    wordToNat (split2 sz 1 (natToWord (sz + 1) n)) = 1.\nProof.\n  intros.\n  rewrite wordToNat_split2.\n  simpl in *.\n  rewrite Nat.add_0_r in *.\n  rewrite wordToNat_natToWord_bound with (bound := wones _).\n  - destruct H. \n    assert (sth: pow2 sz <> 0) by lia.\n    pose proof (Nat.div_le_mono _ _ (pow2 sz) sth H) as sth2.\n    rewrite Nat.div_same in sth2 by auto.\n    apply Nat.lt_le_pred in H0.\n    pose proof (Nat.div_le_mono _ _ (pow2 sz) sth H0) as sth3.\n    rewrite <- Nat.sub_1_r in sth3.\n    assert (sth4: pow2 sz = 1 * pow2 sz) by lia.\n    rewrite sth4 in sth3 at 2.\n    assert (sth5: 1 * pow2 sz + pow2 sz - 1 = 1 * pow2 sz + (pow2 sz - 1)) by lia.\n    rewrite sth5 in sth3.\n    rewrite Nat.div_add_l in sth3 by lia.\n    rewrite Nat.div_small with (a := pow2 sz - 1) in sth3 by lia.\n    lia.\n  - rewrite wones_pow2_minus_one.\n    assert (sth: sz + 1 = S sz) by lia.\n    rewrite sth.\n    simpl.\n    lia.\nQed.\n\nLemma combine_wones_WO sz:\n  forall w, w <> wzero sz -> split2 sz 1 (combine (wones sz) ($ 0) ^+ combine w ($ 0)) = WO~1.\nProof.\n  intros.\n  match goal with\n  | |- split2 _ _ (?a ^+ ?b) = _ =>\n    rewrite <- (@natToWord_wordToNat _ a);\n      rewrite <- (@natToWord_wordToNat _ b)\n  end.\n  rewrite <- natToWord_plus.\n  rewrite ?wordToNat_combine.\n  simpl.\n  rewrite wones_pow2_minus_one.\n  pose proof (wordToNat_bound w) as sth.\n  pose proof (wordToNat_nonZero H).\n  assert (sth2: 2^sz <= 2 ^ sz - 1 + wordToNat w < 2 ^ (S sz)). {\n    pose proof (pow2_zero sz) as sth3. \n    split; simpl; lia.\n  }\n  apply split2_pow2 in sth2.\n  rewrite Nat.mul_0_r.\n  rewrite ?Nat.add_0_r.\n  apply (f_equal (natToWord 1)) in sth2.\n  rewrite natToWord_wordToNat in sth2.\n  assumption.\nQed.\n\nLemma wordToNat_plus sz (w1 w2: word sz):\n  natToWord sz (wordToNat w1 + wordToNat w2) = w1 ^+ w2.\nProof.\n  rewrite natToWord_plus.\n  rewrite ?natToWord_wordToNat.\n  auto.\nQed.\n\nLemma wordToNat_natToWord_eqn sz:\n  forall n,\n    wordToNat (natToWord sz n) = n mod (pow2 sz).\nProof.\n  intros.\n  pose proof (wordToNat_natToWord sz n).\n  destruct H as [? [? ?]].\n  rewrite H.\n  assert (sth: pow2 sz * x = x * pow2 sz) by (apply Nat.mul_comm).\n  rewrite <- sth in *.\n  clear sth.\n  pose proof (wordToNat_bound (natToWord sz n)).\n  apply (Nat.mod_unique n (pow2 sz) x (n - pow2 sz * x)); try lia.\nQed.\n\nLemma mod_factor a b c:\n  b <> 0 ->\n  c <> 0 ->\n  (a mod (b * c)) mod b = a mod b.\nProof.\n  intros.\n  pose proof (Nat.mod_mul_r a _ _ H H0).\n  rewrite H1.\n  rewrite Nat.add_mod_idemp_l by auto.\n  rewrite Nat.add_mod by auto.\n  assert (sth: b * ((a/b) mod c) = (a/b) mod c * b) by (apply Nat.mul_comm).\n  rewrite sth.\n  rewrite Nat.mod_mul by auto.\n  rewrite Nat.add_0_r.\n  rewrite Nat.mod_mod by auto.\n  auto.\nQed.\n\nLemma split1_combine_wplus sz1 sz2 (w11 w21: word sz1) (w12 w22: word sz2):\n  split1 _ _ (combine w11 w12 ^+ combine w21 w22) = w11 ^+ w21.\nProof.\n  rewrite <- natToWord_wordToNat at 1.\n  rewrite wordToNat_split1.\n  rewrite <- wordToNat_plus.\n  rewrite ?wordToNat_combine.\n  assert (sth: #w11 + pow2 sz1 * #w12 + (#w21 + pow2 sz1 * #w22) = #w11 + #w21 + pow2 sz1 * (#w12 + #w22)) by ring.\n  rewrite wordToNat_natToWord_eqn.\n  rewrite sth.\n  rewrite Nat.pow_add_r.\n  assert (pow2 sz1 <> 0) by (pose proof (pow2_zero sz1); intro; lia).\n  assert (pow2 sz2 <> 0) by (pose proof (pow2_zero sz2); intro; lia).\n  rewrite mod_factor by auto.\n  rewrite Nat.add_mod by auto.\n  assert (sth2: pow2 sz1 * (# w12 + #w22) = (#w12 + #w22) * pow2 sz1) by ring.\n  rewrite sth2.\n  rewrite Nat.mod_mul by auto.\n  rewrite Nat.add_0_r.\n  rewrite Nat.mod_mod by auto.\n  rewrite <- wordToNat_natToWord_eqn.\n  rewrite natToWord_wordToNat.\n  rewrite natToWord_plus.\n  rewrite ?natToWord_wordToNat.\n  auto.\nQed.\n\nLemma div_2 a b:\n  b <> 0 ->\n  a < b * 2 ->\n  a >= b ->\n  a / b = 1.\nProof.\n  intros.\n  assert (sth: b * 1 <= a) by lia.\n  pose proof (Nat.div_le_lower_bound a b 1 H sth).\n  pose proof (Nat.div_lt_upper_bound a b 2 H H0).\n  lia.\nQed.\n\nLemma mod_sub a b:\n  b <> 0 ->\n  a < b * 2 ->\n  a >= b ->\n  a mod b = a - b.\nProof.\n  intros.\n  rewrite Nat.mod_eq; auto.\n  repeat f_equal.\n  rewrite div_2 by auto.\n  rewrite Nat.mul_1_r; auto.\nQed.\n\nLemma wordToNat_wneg_non_0 sz: forall (a: word sz),\n    a <> natToWord _ 0 ->\n    # (wneg a) = pow2 sz - #a.\nProof.\n  intros.\n  unfold wneg.\n  rewrite pow2_N.\n  rewrite NToWord_nat.\n  rewrite Nnat.N2Nat.inj_sub.\n  rewrite wordToN_to_nat.\n  rewrite Nnat.Nat2N.id.\n  simpl.\n  rewrite wordToNat_natToWord_idempotent'; auto.\n  assert (#a <> 0) by word_lia.\n  pose proof (pow2_zero sz).\n  lia.\nQed.\n\nLemma wordToNat_wnot sz: forall (a: word sz),\n    # (wnot a) = pow2 sz - #a - 1.\nProof.\n  intros.\n  rewrite wnot_def.\n  rewrite pow2_N.\n  rewrite NToWord_nat.\n  rewrite Nnat.N2Nat.inj_sub.\n  rewrite Nnat.N2Nat.inj_sub.\n  rewrite wordToN_to_nat.\n  rewrite Nnat.Nat2N.id.\n  simpl.\n  rewrite wordToNat_natToWord_idempotent'; auto.\n  pose proof (pow2_zero sz).\n  unfold Pos.to_nat; simpl.\n  lia.\nQed.\n\nLemma wzero_wor: forall sz w, w ^| wzero sz = w.\nProof.\n  intros.\n  rewrite wor_comm.\n  rewrite wor_wzero.\n  auto.\nQed.\n\nLemma bool_prop1: forall a b, a && negb (a && b) = a && negb b.\nProof.\n  destruct a, b; simpl; auto.\nQed.\n\nLemma wordToNat_wplus sz (w1 w2: word sz):\n  #(w1 ^+ w2) = (#w1 + #w2) mod (pow2 sz).\nProof.\n  rewrite <- (natToWord_wordToNat w1) at 1.\n  rewrite <- (natToWord_wordToNat w2) at 1.\n  rewrite <- natToWord_plus.\n  rewrite wordToNat_natToWord_eqn.\n  auto.\nQed.\n\nLemma wordToNat_wmult : forall (sz : nat) (w1 w2 : word sz),\n    #(w1 ^* w2) = (#w1 * #w2) mod pow2 sz.\nProof using .\n  clear. intros.\n  rewrite <- (natToWord_wordToNat w1) at 1.\n  rewrite <- (natToWord_wordToNat w2) at 1.\n  rewrite <- natToWord_mult.\n  rewrite wordToNat_natToWord_eqn.\n  reflexivity.\nQed.\n\nLocal Arguments natToWord : simpl never.\nLocal Arguments weq : simpl never.\n\nLemma wor_r_wzero_1 sz: (* Note: not axiom free *)\n  forall w1 w2,\n    w1 ^| w2 = natToWord sz 0 ->\n    w2 = natToWord sz 0.\nProof.\n  induction w1; simpl; auto; intros.\n  pose proof (shatter_word w2) as sth.\n  simpl in sth.\n  rewrite sth in *.\n  unfold wor in H.\n  simpl in H.\n  unfold natToWord in H.\n  unfold natToWord.\n  fold (natToWord n (Nat.div2 0)) in *.\n  unfold Nat.div2, mod2 in *.\n  inversion H.\n  destruct_existT.\n  rewrite (IHw1 _ H2).\n  f_equal.\n  destruct b, (whd w2); auto.\nQed.\n\nLemma wor_r_wzero_2 sz: (* Note: not axiom free *)\n  forall w1 w2,\n    w1 ^| w2 = natToWord sz 0 ->\n    w1 = natToWord sz 0.\nProof.\n  induction w1; simpl; auto; intros.\n  pose proof (shatter_word w2) as sth.\n  simpl in sth.\n  rewrite sth in *.\n  unfold wor in H.\n  simpl in H.\n  unfold natToWord in H.\n  unfold natToWord.\n  fold (natToWord n (Nat.div2 0)) in *.\n  unfold Nat.div2, mod2 in *.\n  inversion H.\n  destruct_existT.\n  rewrite (IHw1 _ H2).\n  f_equal.\n  destruct b, (whd w2); auto.\nQed.\n\nLemma wordToNat_zero sz: forall (w: word sz), #w = 0 -> w = natToWord _ 0.\nProof.\n  intros.\n  apply (f_equal (natToWord sz)) in H.\n  rewrite natToWord_wordToNat in H.\n  auto.\nQed.\n\nLemma wordToNat_notZero sz: forall (w: word sz), #w <> 0 -> w <> natToWord _ 0.\nProof.\n  intros.\n  intro.\n  subst.\n  pose proof (wordToNat_wzero sz); unfold wzero in *.\n  tauto.\nQed.\n\n\nLemma natToWord_nzero sz x:\n  0 < x ->\n  x < pow2 sz ->\n  natToWord sz x <> natToWord sz 0.\nProof.\n  intros.\n  pre_word_lia.\n  rewrite wordToNat_natToWord_idempotent'; lia.\nQed.\n\nLemma pow2_lt_pow2_S:\n  forall n, pow2 n < pow2 (n+1).\nProof.\n  induction n; simpl; lia.\nQed.\n\nLemma combine_shiftl_plus_n n x:\n  x < pow2 n ->\n  (combine (natToWord n x) WO~1) = (natToWord (n + 1) (pow2 n)) ^+ natToWord (n + 1) x.\nProof.\n  intros.\n  apply wordToNat_eq2.\n  rewrite ?wordToNat_combine.\n  rewrite ?wordToNat_natToWord_idempotent'; simpl; auto.\n  rewrite <- wordToNat_plus.\n  pose proof (pow2_lt_pow2_S n) as sth.\n  rewrite ?wordToNat_natToWord_idempotent'; simpl; try lia.\n  rewrite ?wordToNat_natToWord_idempotent'; simpl; try lia.\n  apply Nat.lt_add_lt_sub_l.\n  rewrite Nat.add_1_r.\n  simpl.\n  lia.\nQed.\n\nLemma combine_natToWord_wzero n:\n  forall x,\n    x < pow2 n ->\n    combine (natToWord n x) (natToWord 1 0) = natToWord (n+1) x.\nProof.\n  intros.\n  apply wordToNat_eq2.\n  rewrite ?wordToNat_combine.\n  simpl.\n  rewrite Nat.mul_0_r.\n  rewrite Nat.add_0_r.\n  pose proof (pow2_lt_pow2_S n) as sth2.\n  rewrite ?wordToNat_natToWord_idempotent' by lia.\n  reflexivity.\nQed.\n\nLemma word_cancel_l sz (a b c: word sz):\n  a = b -> c ^+ a = c ^+ b.\nProof.\n  intro H; rewrite H; reflexivity.\nQed.\n\n\nLemma word_cancel_r sz (a b c: word sz):\n  a = b -> a ^+ c = b ^+ c.\nProof.\n  intro H; rewrite H; reflexivity.\nQed.\n\nLemma word_cancel_m sz (a b c a' b': word sz):\n  a ^+ a' = b ^+ b'-> a ^+ c ^+ a' = b ^+ c ^+ b'.\nProof.\n  intros.\n  assert (sth: a ^+ c ^+ a' = a ^+ a'^+ c ).\n  rewrite <- wplus_assoc.\n  rewrite wplus_comm with (y := a').\n  rewrite wplus_assoc.\n  reflexivity.\n  rewrite sth.\n  rewrite H.\n  rewrite <- wplus_assoc.\n  rewrite wplus_comm with (x := b').\n  rewrite wplus_assoc.\n  reflexivity.\nQed.\n\nLemma move_wplus_wminus sz (a b c: word sz):\n  a ^+ b = c <-> a = c ^- b.\nProof.\n  split; intro.\n  + rewrite <- H.\n    rewrite wminus_def.\n    rewrite <- wplus_assoc.\n    rewrite wminus_inv.\n    rewrite wplus_wzero_1.\n    reflexivity.\n  + rewrite H.\n    rewrite wminus_def.\n    rewrite <- wplus_assoc.\n    rewrite wplus_comm with (x:= ^~b).\n    rewrite wminus_inv.\n    rewrite wplus_wzero_1.\n    reflexivity.\nQed.\n\nLemma move_wplus_pow2 sz (w1 w2: word (S sz)):\n  w1 = w2 ^+ $(pow2 sz) <->\n  w1 ^+ $(pow2 sz) = w2.\nProof.\n  split.\n  + intro.\n    apply move_wplus_wminus.\n    rewrite wminus_def.\n    rewrite pow2_wneg.\n    assumption.\n  + intro.\n    apply move_wplus_wminus in H.\n    rewrite <- pow2_wneg.\n    assumption.\nQed.\n\nLemma move_wminus_pow2 sz (w1 w2: word (S sz)):\n  w1 = w2 ^- $(pow2 sz) <->\n  w1 ^- $(pow2 sz) = w2.\nProof.\n  split.\n  + intro.\n    apply <- move_wplus_wminus.\n    rewrite pow2_wneg.\n    assumption.\n  + intro.\n    apply move_wplus_wminus.\n    rewrite <- pow2_wneg.\n    rewrite <- wminus_def.\n    assumption.\nQed.\n\nLemma pow2_wzero sz :\n  $(pow2 sz) = wzero sz.\nProof.\n  apply wordToNat_eq2.\n  rewrite wordToNat_natToWord_eqn.\n  rewrite Nat.mod_same.\n  rewrite wordToNat_wzero; auto.\n  pose proof (zero_lt_pow2 sz) as sth.\n  lia.\nQed.\n\nLemma pow2_wplus_wzero sz:\n  $(pow2 sz) ^+ $(pow2 sz) = wzero (sz + 1).\nProof.\n  apply wordToNat_eq2.\n  rewrite <- natToWord_plus.\n  rewrite <- mul2_add.\n  assert (pow2_1_mul: pow2 1 = 2) by auto.\n  rewrite <- pow2_1_mul at 2.\n  rewrite <- pow2_add_mul.\n  rewrite pow2_wzero; auto.\nQed.\n\nLemma wplus_wplus_pow2 sz (x1 x2 y1 y2: word (sz + 1)):\n  x1 = y1 ^+ $(pow2 sz) ->\n  x2 = y2 ^+ $(pow2 sz) ->\n  x1 ^+ x2 = y1 ^+ y2.\nProof.\n  intros.\n  rewrite H.\n  rewrite <- wplus_assoc.\n  rewrite wplus_comm.\n  rewrite wplus_comm in H0.\n  rewrite H0.\n  rewrite wplus_assoc.\n  rewrite pow2_wplus_wzero.\n  rewrite wzero_wplus.\n  rewrite wplus_comm.\n  reflexivity.\nQed.\n\n\n\nLemma wlt_meaning sz (w1 w2: word sz):\n  (w1 < w2)%word <-> #w1 < #w2.\nProof.\n  pose proof (@wordToNat_gt1 sz w2 w1).\n  pose proof (@wordToNat_gt2 sz w2 w1).\n  tauto.\nQed.\n\nLemma word1_neq (w: word 1):\n  w <> WO~0 ->\n  w <> WO~1 ->\n  False.\nProof.\n  shatter_word w; intros.\n  destruct x; tauto.\nQed.\n\nLemma combine_1 sz:\n  sz > 1 ->\n  natToWord (sz + 1) 1 = combine ($ 1) WO~0.\nProof.\n  intros.\n  rewrite <- natToWord_wordToNat.\n  f_equal.\n  rewrite wordToNat_combine; simpl.\n  rewrite Nat.mul_0_r, Nat.add_0_r.\n  rewrite wordToNat_natToWord_idempotent'; auto.\n  destruct sz; simpl; try lia.\n  pose proof (pow2_zero sz).\n  lia.\nQed.\n\nLemma wordToNat_cast ni no (pf: ni = no):\n  forall w,\n    #w = #(match pf in _ = Y return _ Y with\n           | eq_refl => w\n           end).\nProof.\n  destruct pf; intros; auto.\nQed.\n\n(* Usually this kind of lemmas would need a guarantee that \"(wordToN a mod wordToN b)%N\"\n   does not overflow, but fortunately this can never overflow.\n   And also, we don't need to prevent b from being 0. *)\nLemma wordToN_mod: forall sz (a b: word sz),\n    wordToN (a ^% b) = (wordToN a mod wordToN b)%N.\nProof.\n  intros. unfold wmod, wordBin.\n  rewrite wordToN_NToWord_2; [ reflexivity | ].\n  destruct (wordToN b) eqn: E.\n  - unfold N.modulo, N.div_eucl. destruct (wordToN a) eqn: F; simpl.\n    + apply Npow2_pos.\n    + rewrite <- F. apply wordToN_bound.\n  - eapply N.lt_trans.\n    + apply N.mod_upper_bound. congruence.\n    + rewrite <- E. apply wordToN_bound.\nQed.\n\nLemma wordToNat_mod: forall sz (a b: word sz),\n    b <> $0 ->\n    #(a ^% b) = #a mod #b.\nProof.\n  intros.\n  rewrite <-? wordToN_to_nat in *.\n  rewrite <-? N2Nat.inj_mod in *.\n  - rewrite wordToN_mod by assumption.\n    reflexivity.\n  - intro. apply H. replace 0%N with (wordToN (natToWord sz 0)) in H0.\n    + apply wordToN_inj. exact H0.\n    + erewrite <- wordToN_wzero. reflexivity.\nQed.\n\nLemma wlshift_mul_pow2: forall sz n (a: word sz),\n    wlshift a n = a ^* $ (pow2 n).\nProof.\n  intros.\n  apply wordToNat_inj.\n  unfold wlshift.\n  rewrite? wordToNat_split1.\n  unfold eq_rec_r, eq_rec.\n  rewrite? wordToNat_eq_rect.\n  rewrite? wordToNat_combine.\n  rewrite? wordToNat_wzero.\n  rewrite wordToNat_wmult.\n  rewrite wordToNat_natToWord_eqn.\n  rewrite Nat.add_0_l.\n  rewrite Nat.mul_mod_idemp_r by (apply pow2_ne_zero).\n  rewrite Nat.mul_comm.\n  reflexivity.\nQed.\n\nLemma wlshift_mul_Zpow2: forall sz n (a: word sz),\n    (0 <= n)%Z ->\n    wlshift a (Z.to_nat n) = a ^* ZToWord sz (2 ^ n).\nProof.\n  intros. rewrite wlshift_mul_pow2. f_equal.\n  change 2 with (Z.to_nat 2).\n  rewrite <- Z2Nat.inj_pow by lia.\n  apply natToWord_Z_to_nat.\n  apply Z.pow_nonneg.\n  lia.\nQed.\n\nLemma wlshift_distr_plus: forall sz n (a b: word sz),\n    wlshift (a ^+ b) n = wlshift a n ^+ wlshift b n.\nProof.\n  intros.\n  rewrite? wlshift_mul_pow2.\n  apply wmult_plus_distr.\nQed.\n\nLemma wlshift_iter: forall sz n1 n2 (a: word sz),\n    wlshift (wlshift a n1) n2 = wlshift a (n1 + n2).\nProof.\n  intros. rewrite? wlshift_mul_pow2.\n  rewrite <- wmult_assoc.\n  rewrite <- natToWord_mult.\n  do 2 f_equal.\n  symmetry.\n  apply Nat.pow_add_r.\nQed.\n\nLemma wlshift_zero: forall sz n, wlshift $0 n = natToWord sz 0.\nProof.\n  intros.\n  apply wordToNat_inj.\n  unfold wlshift.\n  rewrite? wordToNat_split1.\n  unfold eq_rec_r, eq_rec.\n  rewrite? wordToNat_eq_rect.\n  rewrite? wordToNat_combine.\n  rewrite? wordToNat_wzero.\n  rewrite Nat.mul_0_r.\n  change (0 + 0) with 0.\n  rewrite Nat.mod_0_l by (apply pow2_ne_zero).\n  reflexivity.\nQed.\n\nLemma wordToN_wordToZ: forall (sz : nat) (w : word sz),\n    wordToN w = Z.to_N (wordToZ w + Z.of_N (if wmsb w false then Npow2 sz else 0%N)).\nProof.\n  intros.\n  rewrite (wordToZ_wordToN w).\n  remember (if wmsb w false then Npow2 sz else 0%N) as c; clear Heqc.\n  rewrite Z.sub_add.\n  symmetry.\n  apply N2Z.id.\nQed.\n\nLemma uwordToZ_ZToWord_0: forall (sz : nat) (z : Z),\n    (0 <= z < Z.of_N (Npow2 sz))%Z ->\n    uwordToZ (ZToWord sz z) = z.\nProof.\n  intros.\n  unfold uwordToZ.\n  pose proof (Z2N.id _ (proj1 H)).\n  remember (Z.to_N z) as n; clear Heqn. subst z.\n  apply proj2 in H.\n  f_equal.\n  rewrite ZToWord_Z_of_N.\n  apply wordToN_NToWord_2.\n  apply N2Z.inj_lt.\n  assumption.\nQed.\n\nLemma uwordToZ_ZToWord: forall (sz : nat) (z : Z),\n    (0 <= z < 2 ^ (Z.of_nat sz))%Z ->\n    uwordToZ (ZToWord sz z) = z.\nProof.\n  intros. apply uwordToZ_ZToWord_0.\n  intuition idtac.\n  change 2%Z with (Z.of_nat 2) in H1.\n  rewrite <- Nat2Z.inj_pow in H1.\n  rewrite <- N_nat_Z.\n  rewrite Npow2_nat.\n  assumption.\nQed.\n\nLemma NToWord_Z_to_N: forall sz n,\n    (0 <= n)%Z ->\n    NToWord sz (Z.to_N n) = ZToWord sz n.\nProof.\n  intros.\n  rewrite <- ZToWord_Z_of_N.\n  rewrite Z2N.id by assumption.\n  reflexivity.\nQed.\n\nLemma uwordToZ_ZToWord_k: forall (sz : nat) (n : Z),\n    (0 <= n)%Z ->\n    exists k, uwordToZ (ZToWord sz n) = (n - k * 2 ^ Z.of_nat sz)%Z /\\ (k * 2 ^ Z.of_nat sz <= n)%Z.\nProof.\n  intros *. intro C.\n  unfold uwordToZ.\n  pose proof (wordToN_NToWord sz (Z.to_N n)) as P.\n  destruct P as [k [P Q]].\n  exists (Z.of_N k).\n  rewrite NToWord_Z_to_N in P by assumption.\n  rewrite P. clear P.\n  rewrite <- Z_of_N_Npow2 in *.\n  rewrite <- N2Z.inj_mul.\n  rewrite N2Z.inj_sub by assumption.\n  apply N2Z.inj_le in Q.\n  rewrite Z2N.id in * by assumption.\n  auto.\nQed.\n\nLemma Zpow2_pos: forall n, (2 ^ Z.of_nat n > 0)%Z.\nProof.\n  intros. pose proof (Z.pow_pos_nonneg 2 (Z.of_nat n)). lia.\nQed.\n\nLemma uwordToZ_bound: forall sz (a: word sz),\n    (0 <= uwordToZ a < 2 ^ Z.of_nat sz)%Z.\nProof.\n  intros.\n  unfold uwordToZ.\n  split.\n  + apply N2Z.is_nonneg.\n  + pose proof (wordToN_bound a) as P.\n    apply N2Z.inj_lt in P.\n    rewrite Z_of_N_Npow2 in P.\n    assumption.\nQed.\n\nLemma uwordToZ_ZToWord_mod: forall (sz : nat) (z : Z),\n    (0 <= z)%Z ->\n    uwordToZ (ZToWord sz z) = (z mod 2 ^ (Z.of_nat sz))%Z.\nProof.\n  intros.\n  pose proof (uwordToZ_ZToWord_k sz H) as P.\n  destruct P as [k [P Q]].\n  pose proof (uwordToZ_bound (ZToWord sz z)) as B.\n  rewrite P in *. clear P.\n  rewrite Zdiv.Zmod_eq by (apply Zpow2_pos).\n  pose proof (Z.div_unique_pos z (2 ^ Z.of_nat sz) k (z - k * 2 ^ Z.of_nat sz)) as U.\n  rewrite U.\n  - reflexivity.\n  - lia.\n  - rewrite Z.mul_comm. lia.\nQed.\n\nSection ZScope.\n  Import Zdiv.\n  Local Open Scope Z_scope.\n  Lemma uwordToZ_ZToWord_full\n    (sz : nat) (width_nonneg : (0 < sz)%nat) (z : Z)\n    : uwordToZ (ZToWord sz z)\n      = z mod 2 ^ Z.of_nat sz.\n  Proof.\n    rewrite <-(ZToWord_Npow2_sub_z sz z (-Z.abs z)).\n    rewrite Z_of_N_Npow2.\n    rewrite uwordToZ_ZToWord_mod, <-Zdiv.Zminus_mod_idemp_r, Zdiv.Z_mod_mult, Z.sub_0_r; trivial.\n    eapply Zle_minus_le_0.\n    rewrite Z.mul_opp_l.\n    replace z with (-(-z)) at 2 by Lia.lia.\n    rewrite <-Z.opp_le_mono.\n    etransitivity; cycle 1.\n    { eapply Z.mul_le_mono_nonneg_l; [Lia.lia|].\n      eapply Z.pow_le_mono_r; [Lia.lia|].\n      instantiate (1:= 1); Lia.lia. }\n    change (2^1) with 2.\n    Lia.lia.\n  Qed.\n\n  Lemma pow2_times2: forall i,\n      0 < i ->\n      2 ^ i = 2 * 2 ^ (i - 1).\n  Proof.\n    intros.\n    rewrite <- Z.pow_succ_r by lia.\n    f_equal.\n    lia.\n  Qed.\n\n  Lemma wordToZ_ZToWord_full sz (H: (0 < sz)%nat) (z:Z) :\n    wordToZ (ZToWord sz z) =\n    ( z\n      + 2 ^ (Z.of_nat sz - 1)\n    ) mod (2 ^ Z.of_nat sz)\n    - 2 ^ (Z.of_nat sz - 1).\n  Proof.\n    pose proof @wordToZ_size'' sz ltac:(trivial) (ZToWord _ z).\n    assert ( wordToZ (ZToWord sz z) =\n      (wordToZ (ZToWord sz z) +\n      2 ^ (Z.of_nat sz - 1))\n      mod (2*2 ^ (Z.of_nat sz - 1))\n      - 2 ^ (Z.of_nat sz - 1))\n    by (rewrite Z.mod_small; Lia.lia).\n    assert (2^Z.of_nat sz = 2 * 2 ^ (Z.of_nat sz - 1)) by\n      (rewrite pow2_times2; Lia.lia).\n    rewrite <-H2 in H1; rewrite H1.\n    f_equal.\n    case (wordToZ_ZToWord' sz z) as [y Hy]; rewrite Hy.\n    replace (z - y * Z.of_N (Npow2 sz) + 2 ^ (Z.of_nat sz - 1))\n    with ((z + 2 ^ (Z.of_nat sz - 1)) - y * Z.of_N (Npow2 sz)) by Lia.lia.\n    rewrite <-Zminus_mod_idemp_r.\n    enough (y * (Z.of_N (Npow2 sz)) mod 2 ^ Z.of_nat sz = 0) by\n      (f_equal; Lia.lia).\n      rewrite <-Zmult_mod_idemp_r.\n    enough ((Z.of_N (Npow2 sz)) mod 2 ^ Z.of_nat sz = 0) by\n      (rewrite H3, Z.mul_0_r, Zmod_0_l; trivial).\n    rewrite pow2_N, nat_N_Z, Nat2Z.inj_pow; apply Z_mod_same_full.\n  Qed.\n\n  Lemma wordToZ_ZToWord_full_post sz (H: (0 < sz)%nat) (z:Z) :\n    wordToZ (ZToWord sz z) =\n    ( wordToZ (ZToWord sz z)\n      + 2 ^ (Z.of_nat sz - 1)\n    ) mod (2 ^ Z.of_nat sz)\n    - 2 ^ (Z.of_nat sz - 1).\n  Proof.\n    pose proof @wordToZ_size'' sz ltac:(trivial) (ZToWord _ z).\n    case (wordToZ_ZToWord' sz z) as [y Hy].\n    assert ( wordToZ (ZToWord sz z) =\n      (wordToZ (ZToWord sz z) +\n      2 ^ (Z.of_nat sz - 1))\n      mod (2*2 ^ (Z.of_nat sz - 1))\n      - 2 ^ (Z.of_nat sz - 1))\n    by (rewrite Z.mod_small; Lia.lia).\n    enough (2^Z.of_nat sz = 2 * 2 ^ (Z.of_nat sz - 1))\n      by congruence; clear -H.\n    rewrite pow2_times2; Lia.lia.\n  Qed.\nEnd ZScope.\n\nLemma ZToWord_uwordToZ: forall sz (a: word sz),\n    ZToWord sz (uwordToZ a) = a.\nProof.\n  intros.\n  unfold uwordToZ.\n  rewrite ZToWord_Z_of_N.\n  apply NToWord_wordToN.\nQed.\n\nLemma wordToN_neq_0: forall sz (b : word sz),\n    b <> $0 ->\n    wordToN b <> 0%N.\nProof.\n  intros.\n  intro C.\n  apply H.\n  apply wordToN_inj.\n  erewrite <- wordToN_wzero in C.\n  unfold wzero in C.\n  exact C.\nQed.\n\n(* These counterexamples will hopefully be found by users who use commands\n   such as \"Search ((_ ^+ _) ^% _)\" *)\nLemma wmod_plus_distr_does_not_hold: ~ forall sz (a b m: word sz),\n    m <> $0 ->\n    (a ^+ b) ^% m = ((a ^% m) ^+ (b ^% m)) ^% m.\nProof.\n  intro C.\n  specialize (C 4 $9 $11 $7). cbv in C.\n  match type of C with (?A -> _) => assert A by (intro; discriminate) end.\n  specialize (C H). discriminate.\nQed.\n\nLemma wmul_mod_distr_does_not_hold: ~ forall sz (a b n: word sz),\n    n <> $0 ->\n    (a ^* b) ^% n = ((a ^% n) ^* (b ^% n)) ^% n.\nProof.\n  intro C.\n  specialize (C 4 $9 $11 $7). cbv in C.\n  match type of C with (?A -> _) => assert A by (intro; discriminate) end.\n  specialize (C H). discriminate.\nQed.\n\nLemma Nmod_0_r: forall a : N, (a mod 0)%N = a.\nProof.\n  intros. destruct a; reflexivity.\nQed.\n\nLemma wordToN_0: forall sz,\n    wordToN (natToWord sz 0) = 0%N.\nProof.\n  intros. change (natToWord sz 0) with (wzero sz).\n  apply wordToN_wzero.\nQed.\n\nLemma NToWord_0: forall sz,\n    NToWord sz 0 = $ (0).\nProof.\n  intros. change 0%nat with (N.to_nat 0).\n  apply NToWord_nat.\nQed.\n\nLemma wmod_0_r: forall sz (a: word sz), a ^% $0 = a.\nProof.\n  intros. unfold wmod, wordBin.\n  rewrite wordToN_0.\n  rewrite Nmod_0_r.\n  apply NToWord_wordToN.\nQed.\n\nLemma wordToN_NToWord_eqn: forall sz (n : N),\n    wordToN (NToWord sz n) = (n mod Npow2 sz)%N.\nProof.\n  intros.\n  pose proof (Npow2_not_zero sz).\n  apply Nnat.N2Nat.inj.\n  rewrite wordToN_to_nat.\n  rewrite N2Nat.inj_mod by assumption.\n  rewrite Npow2_nat.\n  rewrite <- wordToNat_natToWord_eqn.\n  rewrite <- NToWord_nat.\n  reflexivity.\nQed.\n\nLemma Nminus_mod_idemp_r: forall a b n : N,\n    (n <> 0)%N ->\n    (b <= a)%N ->\n    ((a - b mod n) mod n)%N = ((a - b) mod n)%N.\nProof.\n  intros.\n  apply N2Z.inj.\n  rewrite? N2Z.inj_mod by assumption.\n  pose proof (N.mod_le b n H).\n  rewrite N2Z.inj_sub by (eapply N.le_trans; eassumption).\n  rewrite N2Z.inj_sub by assumption.\n  rewrite? N2Z.inj_mod by assumption.\n  apply Zdiv.Zminus_mod_idemp_r.\nQed.\n\nLemma drop_sub_N: forall sz (n k : N),\n    (k * Npow2 sz <= n)%N ->\n    NToWord sz (n - k * Npow2 sz) = NToWord sz n.\nProof.\n  intros.\n  apply wordToN_inj.\n  pose proof (Npow2_not_zero sz).\n  do 2 rewrite wordToN_NToWord_eqn.\n  rewrite <- Nminus_mod_idemp_r by assumption.\n  rewrite N.mod_mul by assumption.\n  rewrite N.sub_0_r.\n  reflexivity.\nQed.\n\nLemma wmod_divides: forall sz (a b: word sz),\n    a ^% b = $0 ->\n    exists k, a = b ^* k.\nProof.\n  intros. destruct (weq b $0).\n  - subst b. rewrite wmod_0_r in *. subst a. exists (natToWord sz 0).\n    symmetry. apply wmult_neut_r.\n  - unfold wmod, wmult, wordBin in *.\n    pose proof (N.mod_divides (wordToN a) (wordToN b)) as P.\n    apply wordToN_neq_0 in n.\n    specialize (P n).\n    destruct P as [ [k P] _].\n    + apply (f_equal (@wordToN sz)) in H.\n      rewrite wordToN_NToWord_2 in H.\n      * rewrite H. apply wordToN_0.\n      * pose proof (wordToN_bound a). remember (wordToN a) as c. clear Heqc a.\n        pose proof (wordToN_bound b). remember (wordToN b) as d. clear Heqd b.\n        pose proof (N.mod_upper_bound c d n).\n        nlia.\n    + exists (NToWord sz (k - k / (Npow2 sz) * Npow2 sz)).\n      rewrite wordToN_NToWord_2.\n      { rewrite N.mul_sub_distr_l.\n        rewrite N.mul_assoc.\n        rewrite drop_sub_N.\n        - rewrite <- P. symmetry. apply NToWord_wordToN.\n        - rewrite <- N.mul_assoc.\n          rewrite <- (N.mul_comm (Npow2 sz)).\n          apply N.mul_le_mono_l.\n          apply (N.mul_div_le k (Npow2 sz)).\n          apply Npow2_not_zero.\n      }\n      { rewrite <- N.mul_comm. rewrite <- N.mod_eq by (apply Npow2_not_zero).\n        apply N.mod_upper_bound. apply Npow2_not_zero. }\nQed.\n\nLemma wmod_divides_other_direction_does_not_hold: ~ forall sz (a b: word sz),\n    b <> $0 ->\n    (exists k, a = b ^* k) ->\n    a ^% b = $0.\nProof.\n  intro C. specialize (C 4 $14 $5).\n  match type of C with (?A -> _) => assert A by (intro; discriminate) end.\n  specialize (C H).\n  match type of C with (?A -> _) => assert A as B end.\n  - exists (natToWord 4 6). reflexivity.\n  - specialize (C B). cbv in C. discriminate.\nQed.\n\nLemma wmod_mul_does_not_hold: ~ forall sz (a b: word sz),\n    b <> $0 ->\n    (a ^* b) ^% b = $0.\nProof.\n  intro C.\n  specialize (C 4 $6 $5).\n  match type of C with (?A -> _) => assert A by (intro; discriminate) end.\n  specialize (C H).\n  cbv in C.\n  discriminate.\nQed.\n\nLemma wmult_plus_distr_l: forall (sz : nat) (x y z : word sz),\n    z ^* (x ^+ y) = z ^* x ^+ z ^* y.\nProof.\n  intros. rewrite! (wmult_comm z).\n  apply wmult_plus_distr.\nQed.\n\nLemma wmod_same: forall sz (a: word sz), a ^% a = $0.\nProof.\n  intros. destruct (weq a $0).\n  - subst a. rewrite wmod_0_r in *. reflexivity.\n  - unfold wmod, wordBin. apply wordToN_neq_0 in n. rewrite N.mod_same by assumption.\n    apply NToWord_0.\nQed.\n\nLemma wmod_0_l: forall sz (m: word sz),\n    $0 ^% m = $0.\nProof.\n  intros. unfold wmod, wordBin.\n  rewrite wordToN_0.\n  destruct (N.eq_dec (wordToN m) 0%N).\n  - rewrite e. change (0 mod 0)%N with 0%N. apply NToWord_0.\n  - rewrite N.mod_0_l by assumption. apply NToWord_0.\nQed.\n\nLemma wmod_plus_distr: forall sz (a b m: word sz),\n    (exists k, (wordToN m * k)%N = Npow2 sz) ->\n    (a ^+ b) ^% m = ((a ^% m) ^+ (b ^% m)) ^% m.\nProof.\n  intros. destruct H as [k E].\n  assert (wordToN m <> 0%N) as H. {\n    intro C. rewrite C in E. simpl in E. symmetry in E.\n    apply Npow2_not_zero in E.\n    assumption.\n  }\n  unfold wplus, wmod, wordBin.\n  pose proof (wordToN_bound a). remember (wordToN a) as c. clear Heqc a.\n  pose proof (wordToN_bound b). remember (wordToN b) as d. clear Heqd b.\n  pose proof (wordToN_bound m). remember (wordToN m) as n. clear Heqn m.\n  pose proof (N.mod_upper_bound c n H).\n  pose proof (N.mod_upper_bound d n H).\n  rewrite (@wordToN_NToWord_2 sz (c mod n)) by nlia.\n  rewrite (@wordToN_NToWord_2 sz (d mod n)) by nlia.\n  repeat match goal with\n  | |- context [wordToN (NToWord ?sz ?n)] =>\n    let k := fresh \"k\" in\n    let E := fresh \"E\" in\n    let B := fresh \"B\" in\n    destruct (wordToN_NToWord sz n) as [ k [E B] ];\n    rewrite E in *; clear E\n  end.\n  rewrite <- E in *.\n  rewrite <- Nminus_mod_idemp_r by assumption.\n  rewrite <- (@Nminus_mod_idemp_r (c mod n + d mod n)) by assumption.\n  rewrite (N.mul_comm n k).\n  do 2 rewrite N.mul_assoc.\n  do 2 rewrite N.mod_mul by assumption.\n  do 2 rewrite N.sub_0_r.\n  f_equal.\n  apply N.add_mod.\n  assumption.\nQed.\n\nLemma wmod_mul: forall sz (a b: word sz),\n    (exists k, (wordToN b * k)%N = Npow2 sz) ->\n    (a ^* b) ^% b = $0.\nProof.\n  intros. destruct H as [k E].\n  assert (wordToN b <> 0%N) as H. {\n    intro C. rewrite C in E. simpl in E. symmetry in E.\n    apply Npow2_not_zero in E.\n    assumption.\n  }\n  unfold wmult, wmod, wordBin.\n  pose proof (wordToN_bound a). remember (wordToN a) as c. clear Heqc a.\n  pose proof (wordToN_bound b). remember (wordToN b) as d. clear Heqd b.\n  pose proof (N.mod_upper_bound c d H).\n  repeat match goal with\n  | |- context [wordToN (NToWord ?sz ?n)] =>\n    let k := fresh \"k\" in\n    let E := fresh \"E\" in\n    let B := fresh \"B\" in\n    destruct (wordToN_NToWord sz n) as [ k [E B] ];\n    rewrite E in *; clear E\n  end.\n  rewrite <- E in *.\n  rewrite <- Nminus_mod_idemp_r by assumption.\n  rewrite (N.mul_comm d k).\n  rewrite N.mul_assoc.\n  rewrite N.mod_mul by assumption.\n  rewrite N.sub_0_r.\n  rewrite N.mul_mod by assumption.\n  rewrite N.mod_same by assumption.\n  rewrite N.mul_0_r.\n  rewrite N.mod_0_l by assumption.\n  apply NToWord_0.\nQed.\n\nLemma combine_zero_general sz1 sz2:\n  forall (w: word sz1) (b: word sz2), (combine w b = $ 0 -> w = $ 0 /\\ b = $ 0)%word.\nProof.\n  intros.\n  pre_word_lia.\n  rewrite wordToNat_combine in *.\n  assert (sth1: wordToNat w = 0) by lia.\n  pose proof (pow2_zero sz1) as sth2.\n  assert (sth3: wordToNat b = 0) by nia.\n  split; eapply wordToNat_zero; eauto.\nQed.\n\nLemma combine_lt sz1 sz2:\n  forall (w1 w2: word sz1) (b1 b2: word sz2), (combine w1 b1 < combine w2 b2 ->\n                                               b1 <= b2)%word.\nProof.\n  intros.\n  pre_word_lia.\n  rewrite ?wordToNat_combine in *.\n  pose proof (pow2_zero sz1).\n  pose proof (wordToNat_bound w1).\n  pose proof (wordToNat_bound w2).\n  nia.\nQed.\n\nLemma split2_le sz1 sz2:\n  forall (w1 w2: word (sz1 + sz2)), (w1 <= w2 ->\n                                     split2 _ _ w1 <= split2 _ _ w2)%word.\nProof.\n  intros.\n  pre_word_lia.\n  rewrite ?wordToNat_split2.\n  pose proof (pow2_zero sz1).\n  apply Nat.div_le_mono; auto.\n  lia.\nQed.\n\nLemma word1_neq': forall w : word 1, w <> WO~1 -> w = WO~0.\nProof.\n  intros.\n  shatter_word w.\n  destruct x; auto; tauto.\nQed.\n\nLemma combine_ge sz1 sz2 (x1 y1: word sz1) (x2 y2: word sz2):\n  (combine x1 x2 <= combine y1 y2 ->\n   x2 < y2 \\/ (x2 = y2 /\\ x1 <= y1))%word.\nProof.\n  intros.\n  pre_word_lia.\n  rewrite ?wordToNat_combine in *.\n  pose proof (pow2_zero sz1).\n  pose proof (pow2_zero sz2).\n  destruct (weq x2 y2); subst.\n  - right; split; auto.\n    word_lia.\n  - left.\n    pose proof (wordToNat_bound x1).\n    pose proof (wordToNat_bound y1).\n    pre_word_lia.\n    nia.\nQed.\n",
      "theorem": "Lemma wmsb_wlshift_sext:\n  forall sz (w: word sz) n,\n    wmsb (sext w n) false = wmsb (wlshift (sext w n) n) false.",
      "ground_truth": "Proof.\n  intros.\n  pose proof (wlshift_sext_extz w n).\n  apply wmsb_existT with (b:= false) in H.\n  rewrite H.\n  rewrite wmsb_sext.\n  rewrite wmsb_extz.\n  reflexivity.\nQed."
    },
    {
      "split": "train-sft",
      "index": 16,
      "prefix": "(* This program is free software; you can redistribute it and/or      *)\n(* modify it under the terms of the GNU Lesser General Public License *)\n(* as published by the Free Software Foundation; either version 2.1   *)\n(* of the License, or (at your option) any later version.             *)\n(*                                                                    *)\n(* This program is distributed in the hope that it will be useful,    *)\n(* but WITHOUT ANY WARRANTY; without even the implied warranty of     *)\n(* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      *)\n(* GNU General Public License for more details.                       *)\n(*                                                                    *)\n(* You should have received a copy of the GNU Lesser General Public   *)\n(* License along with this program; if not, write to the Free         *)\n(* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA *)\n(* 02110-1301 USA                                                     *)\n\n\nRequire Export complexes.\nSet Implicit Arguments.\nUnset Strict Implicit.\nParameter partie_reelle : C -> R.\nParameter partie_imaginaire : C -> R.\n \nAxiom\n  partie_reelle_def :\n    forall (z : C) (a b : R), z = cons_cart a b -> a = partie_reelle z.\n \nAxiom\n  partie_imaginaire_def :\n    forall (z : C) (a b : R), z = cons_cart a b -> b = partie_imaginaire z.\n \nAxiom\n  forme_algebrique_def :\n    forall (z : C) (a b : R),\n    a = partie_reelle z -> b = partie_imaginaire z -> z = cons_cart a b.\n \nLemma car_image_forme_algebrique :\n forall (z : C) (M : PO),\n M = image z ->\n partie_reelle z = abscisse M /\\ partie_imaginaire z = ordonnee M.\nintros.\nelim existence_coordonnees with (O := O) (I := I) (J := J) (M := M);\n [ intros x H2; elim H2; intros y H3 | auto with geo ].\ncut (z = cons_cart x y); intros.\nrewrite <- (partie_reelle_def H0).\nrewrite <- (partie_imaginaire_def H0).\nsplit; eauto with geo.\neauto with geo.\nQed.\n \nLemma coordonnees_affixe :\n forall M : PO, cons_cart (abscisse M) (ordonnee M) = affixe M :>C.\nintros.\nelim existence_affixe_point with (M := M); intros z H;\n try clear existence_affixe_point; try exact H.\nelim car_image_forme_algebrique with (z := z) (M := M);\n [ intros; try exact H1 | eauto with geo ].\nrewrite <- H1; rewrite <- H0; rewrite <- H.\nsymmetry  in |- *; eauto with geo.\nQed.\n#[export] Hint Resolve coordonnees_affixe: geo.\n \nLemma absvec_ordvec_affixe :\n forall (a b : R) (A B : PO),\n a = absvec (vec A B) ->\n b = ordvec (vec A B) -> cons_cart a b = affixe_vec (vec A B).\nintros a b A B.\nelim existence_representant_vecteur with (A := O) (B := A) (C := B);\n intros D H1; try exact H1.\nrewrite <- H1; intros.\napply affixe_point_vecteur.\nrewrite H0; rewrite H; rewrite (ordvec_ordonnee (O:=O) (I:=I) (J:=J) D);\n auto with geo.\nrewrite (absvec_abscisse (O:=O) (I:=I) (J:=J) D); auto with geo.\nQed.\nParameter module : C -> R.\nParameter argument : C -> AV.\n \nAxiom\n  module_def :\n    forall (z : C) (M : PO), M = image z -> module z = distance O M.\n \nAxiom\n  argument_def :\n    forall (M : PO) (z : C),\n    O <> M -> M = image z -> argument z = cons_AV (vec O I) (vec O M).\n#[export] Hint Resolve module_def argument_def: geo.\n \nLemma module_def2 :\n forall (z : C) (M : PO), z = affixe M -> module z = distance O M.\nintros; eauto with geo.\nQed.\n \nLemma argument_def2 :\n forall (M : PO) (z : C),\n O <> M -> z = affixe M -> argument z = cons_AV (vec O I) (vec O M).\nintros; eauto with geo.\nQed.\n \nLemma existence_module : forall z : C, exists r : R, module z = r.\nintros.\nelim existence_image_complexe with (z := z); intros M H1;\n try clear existence_image_complexe; try exact H1.\nexists (distance O M); eauto with geo.\nQed.\n \nDefinition zeroC := cons_cart 0 0.\n \nLemma image_zeroC : image zeroC = O.\nelim existence_image_complexe with (z := zeroC); unfold zeroC in |- *;\n intros M H1; try exact H1.\ncut (vec O M = add_PP (mult_PP 0 (vec O I)) (mult_PP 0 (vec O J))); intros;\n eauto with geo.\nrewrite <- H1.\nsymmetry  in |- *.\napply vecteur_nul_conf.\nrewrite H.\nRingvec.\nQed.\n#[export] Hint Resolve image_zeroC: geo.\n \nLemma affixe_origine : zeroC = affixe O.\neauto with geo.\nQed.\n#[export] Hint Resolve affixe_origine: geo.\n \nLemma module_zeroC : module zeroC = 0.\nrewrite (module_def (z:=zeroC) (M:=O)); auto with geo.\nQed.\n \nLemma module_nul_zeroC : forall z : C, module z = 0 -> z = zeroC.\nintros.\nelim existence_image_complexe with (z := z); intros M H1;\n try clear existence_image_complexe; try exact H1.\ncut (O = M); intros.\nrewrite (affixe_image H1).\nrewrite <- H0; auto with geo.\napply distance_refl1.\nrewrite <- H; symmetry  in |- *; auto with geo.\nQed.\n#[export] Hint Resolve module_zeroC module_nul_zeroC: geo.\n \nLemma module_non_zero : forall z : C, z <> zeroC -> module z <> 0.\nred in |- *; intros.\napply H; auto with geo.\nQed.\n \nLemma nonzero_module : forall z : C, module z <> 0 -> z <> zeroC.\nred in |- *; intros.\napply H; rewrite H0; auto with geo.\nQed.\n#[export] Hint Resolve module_non_zero nonzero_module: geo.\n \nLemma image_nonzero_nonorigine :\n forall (M : PO) (z : C), z <> zeroC :>C -> M = image z -> O <> M.\nintros.\nred in |- *; intros; apply H.\nreplace z with (affixe M).\nrewrite <- H1; auto with geo.\nsymmetry  in |- *; auto with geo.\nQed.\n#[export] Hint Resolve image_nonzero_nonorigine: geo.\n \nLemma nonorigine_image_nonzero :\n forall (M : PO) (z : C), O <> M -> M = image z -> z <> zeroC :>C.\nintros.\nred in |- *; intros; apply H.\nrewrite H0; rewrite H1.\nsymmetry  in |- *; auto with geo.\nQed.\n#[export] Hint Resolve nonorigine_image_nonzero: geo.\n \nLemma existence_argument :\n forall z : C, z <> zeroC -> exists a : R, argument z = image_angle a.\nintros.\nelim existence_image_complexe with (z := z); intros M H1;\n try clear existence_image_complexe; try exact H1.\ncut (O <> M); intros; eauto with geo.\nmesure O I O M.\nexists x.\nrewrite H2; eauto with geo.\nQed.\n \nLemma existence_forme_polaire :\n forall z : C,\n z <> zeroC ->\n exists r : R, (exists a : R, module z = r /\\ argument z = image_angle a).\nintros.\nelim existence_module with (z := z); intros r H0; try clear existence_module;\n try exact H0.\nelim existence_argument with (z := z);\n [ intros a H1; try clear existence_argument; try exact H1 | auto ].\nexists r; exists a; auto.\nQed.\nParameter cons_pol : R -> R -> C.\n \nAxiom\n  forme_polaire_def :\n    forall (z : C) (r a : R),\n    z <> zeroC ->\n    module z = r -> argument z = image_angle a -> z = cons_pol r a.\n \nAxiom complexe_polaire_module : forall r a : R, module (cons_pol r a) = r.\n \nAxiom\n  complexe_polaire_argument :\n    forall r a : R, r <> 0 -> argument (cons_pol r a) = image_angle a.\n \nLemma polaire_non_nul : forall r a : R, r <> 0 -> cons_pol r a <> zeroC.\nintros.\napply nonzero_module.\nrewrite complexe_polaire_module; auto.\nQed.\n \nLemma complexe_pol_module :\n forall (z : C) (r a : R), z <> zeroC -> z = cons_pol r a -> module z = r.\nintros.\nrewrite H0; rewrite complexe_polaire_module; auto.\nQed.\n \nLemma complexe_pol_argument :\n forall (z : C) (r a : R),\n z <> zeroC -> z = cons_pol r a -> argument z = image_angle a.\nintros.\nrewrite H0; rewrite complexe_polaire_argument; auto.\nrewrite <- (complexe_pol_module (z:=z) (r:=r) (a:=a)); auto with geo.\nQed.\n#[export] Hint Resolve forme_polaire_def complexe_pol_module complexe_pol_argument\n  polaire_non_nul complexe_polaire_module complexe_polaire_module: geo.\n \nLemma pol_complexe_module :\n forall (z : C) (r a : R) (M : PO),\n z <> zeroC -> z = cons_pol r a -> M = image z -> distance O M = r.\nintros.\nrewrite <- (module_def H1); eauto with geo.\nQed.\n \nLemma pol_complexe_argument :\n forall (z : C) (r a : R) (M : PO),\n z <> zeroC ->\n z = cons_pol r a ->\n M = image z -> cons_AV (vec O I) (vec O M) = image_angle a.\nintros.\nrewrite <- (argument_def (M:=M) (z:=z)); eauto with geo.\nQed.\n#[export] Hint Resolve pol_complexe_argument pol_complexe_module: geo.\n \nLemma image_forme_polaire :\n forall (z : C) (M : PO),\n O <> M ->\n M = image z ->\n module z = distance O M /\\ argument z = cons_AV (vec O I) (vec O M).\nintros.\nsplit; eauto with geo.\nQed.\n \nLemma unicite_forme_polaire_nonzero :\n forall (z : C) (r a r' a' : R),\n z <> zeroC ->\n z = cons_pol r a ->\n z = cons_pol r' a' -> r = r' /\\ image_angle a = image_angle a'.\nintros.\nsplit.\nrewrite <- (complexe_pol_module (z:=z) (r:=r) (a:=a)); eauto with geo.\nrewrite <- (complexe_pol_argument (z:=z) (r:=r) (a:=a)); eauto with geo.\nQed.\n#[export] Hint Resolve unicite_forme_polaire_nonzero image_forme_polaire: geo.\n \nLemma passage_polaire_algebrique :\n forall (z : C) (r a x y : R),\n z <> zeroC ->\n z = cons_cart x y -> z = cons_pol r a -> x = r * cos a /\\ y = r * sin a.\nintros.\nelim existence_image_complexe with (z := z); intros M H2;\n try clear existence_image_complexe; try exact H2.\nelim\n coordonnees_polaires_cartesiennes\n  with\n    (x := x)\n    (y := y)\n    (a := a)\n    (r := r)\n    (O := O)\n    (I := I)\n    (J := J)\n    (M := M);\n [ intros; eauto with geo\n | eauto with geo\n | eauto with geo\n | eauto with geo\n | eauto with geo\n | eauto with geo ].\nsymmetry  in |- *; eauto with geo.\nsymmetry  in |- *; eauto with geo.\nQed.\n \nLemma passage_algebrique_module :\n forall (z : C) (x y : R),\n z = cons_cart x y -> module z = sqrt (Rsqr x + Rsqr y).\nintros.\nelim existence_image_complexe with (z := z); intros M H2;\n try clear existence_image_complexe; try exact H2.\nreplace (module z) with (distance O M); auto.\nrewrite (distance_coordonnees (O:=O) (I:=I) (J:=J) (M:=M) (x:=x) (y:=y));\n eauto with geo.\nsymmetry  in |- *; eauto with geo.\nQed.\n \nLemma passage_algebrique_argument :\n forall (z : C) (r x y a : R),\n z <> zeroC ->\n z = cons_cart x y -> z = cons_pol r a -> cos a = / r * x /\\ sin a = / r * y.\nintros.\nelim\n passage_polaire_algebrique with (z := z) (r := r) (a := a) (x := x) (y := y);\n [ intros | eauto with geo | eauto with geo | eauto with geo ].\ncut (r <> 0); intros.\nsplit; [ try assumption | idtac ].\nrewrite H2.\nfield; auto.\nrewrite H3.\nfield; auto.\nreplace r with (module z); eauto with geo.\nQed.\n \nLemma egalite_forme_polaire :\n forall z z' : C,\n z <> zeroC ->\n z' <> zeroC -> module z = module z' -> argument z = argument z' -> z = z'.\nintros.\nelim existence_forme_polaire with (z := z);\n [ intros r H3; elim H3; intros a H4; elim H4; intros H5 H6;\n    try clear H4 H3 existence_forme_polaire; try exact H6\n | auto ].\nelim existence_forme_polaire with (z := z');\n [ intros r0 H7; elim H7; intros a0 H8; elim H8; intros H9 H10;\n    try clear H8 H7 existence_forme_polaire; try exact H10\n | auto ].\nrewrite (forme_polaire_def (z:=z) (r:=r) (a:=a)); auto.\nrewrite (forme_polaire_def (z:=z') (r:=r) (a:=a)); auto.\nrewrite <- H5; auto.\nrewrite <- H6; auto.\nQed.\n#[export] Hint Resolve passage_algebrique_module passage_algebrique_argument\n  egalite_forme_polaire: geo.\n \nLemma algebrique_zeroC :\n forall a b : R, cons_cart a b = zeroC :>C -> a = 0 /\\ b = 0.\nintros.\napply unicite_parties_relles_imaginaires with zeroC; auto.\nQed.\n \nLemma polaire_calcul_algebrique :\n forall (z : C) (r a : R),\n z <> zeroC :>C ->\n z = cons_pol r a :>C -> z = cons_cart (r * cos a) (r * sin a) :>C.\nintros.\nelim existence_parties_relles_imaginaires with (z := z); intros a0 H1;\n elim H1; intros b H2; try clear H1 existence_parties_relles_imaginaires;\n try exact H2.\nelim\n passage_polaire_algebrique\n  with (z := z) (r := r) (a := a) (x := a0) (y := b);\n [ intros; try exact H4 | auto | auto | auto ].\nrewrite H2; rewrite H3; rewrite H4; auto.\nQed.\n#[export] Hint Resolve polaire_calcul_algebrique: geo.\n \nDefinition Rinj (x : R) := cons_cart x 0.\n \nDefinition oneC := cons_cart 1 0.\n#[export] Hint Unfold oneC zeroC Rinj: geo.\n \nLemma Rinj_zero : Rinj 0 = zeroC.\nunfold Rinj, zeroC in |- *; auto.\nQed.\n \nLemma Rinj_un : Rinj 1 = oneC.\nunfold Rinj, oneC in |- *; auto.\nQed.\n \nLemma module_oneC : module oneC = 1.\nintros.\nrewrite (passage_algebrique_module (z:=oneC) (x:=1) (y:=0)).\nreplace (Rsqr 1 + Rsqr 0) with 1 by (unfold Rsqr; ring).\nexact sqrt_1.\nunfold oneC in |- *; auto.\nQed.\n \nLemma oneC_nonzero : oneC <> zeroC.\napply nonzero_module.\nrewrite module_oneC; auto with real.\nQed.\n#[export] Hint Resolve module_oneC oneC_nonzero: geo.\n \nLemma argument_oneC : argument oneC = image_angle 0.\nelim existence_forme_polaire with (z := oneC);\n [ intros r H; elim H; intros a H0; elim H0; intros H1 H2;\n    try clear H0 H existence_forme_polaire; try exact H2\n | auto with geo ].\nrewrite module_oneC in H1.\nrewrite H2.\nelim\n passage_algebrique_argument\n  with (z := oneC) (r := 1) (x := 1) (y := 0) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\napply egalite_angle_trigo.\nrewrite sin_zero; rewrite H4; ring.\nrewrite H3; rewrite cos_zero; field.\nQed.\n#[export] Hint Resolve argument_oneC: geo.\n \nDefinition i := cons_cart 0 1.\n#[export] Hint Unfold i: geo.\n \nLemma module_i : module i = 1.",
      "suffix": "\n \nLemma i_nonzero : i <> zeroC.\napply nonzero_module.\nrewrite module_i; auto with real.\nQed.\n#[export] Hint Resolve module_i i_nonzero: geo.\n \nLemma argument_i : argument i = image_angle pisurdeux.\nelim existence_forme_polaire with (z := i);\n [ intros r H; elim H; intros a H0; elim H0; intros H1 H2;\n    try clear H0 H existence_forme_polaire; try exact H2\n | auto with geo ].\nelim\n passage_algebrique_argument\n  with (z := i) (r := 1) (x := 0) (y := 1) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\nrewrite module_i in H1.\nrewrite H2.\nelim\n passage_algebrique_argument\n  with (z := i) (r := 1) (x := 0) (y := 1) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\napply egalite_angle_trigo.\nrewrite sin_pisurdeux; rewrite H4; field.\nrewrite H3; rewrite cos_pisurdeux; ring.\nQed.\n#[export] Hint Resolve argument_i: geo.\n \nLemma forme_polaire_oneC : oneC = cons_pol 1 0.\napply forme_polaire_def; auto with geo.\nQed.\n \nLemma forme_polaire_i : i = cons_pol 1 pisurdeux.\napply forme_polaire_def; auto with geo.\nQed.\n#[export] Hint Resolve forme_polaire_oneC forme_polaire_i: geo.\n \nLemma egalite_cart_pol :\n forall x y r a : R,\n r <> 0 ->\n module (cons_cart x y) = r ->\n argument (cons_cart x y) = image_angle a :>AV ->\n cons_cart x y = cons_pol r a :>C.\nintros.\nrewrite <- (forme_polaire_def (z:=cons_cart x y) (r:=r) (a:=a));\n auto with geo.\napply nonzero_module.\nrewrite H0; auto.\nQed.\n \nLemma module_opp_un : module (Rinj (-1)) = 1.\nunfold Rinj in |- *.\nrewrite (passage_algebrique_module (z:=cons_cart (-1) 0) (x:=-1) (y:=0));\n auto with geo.\nreplace (Rsqr (-1) + Rsqr 0) with 1 by (unfold Rsqr; ring).\nexact sqrt_1.\nQed.\n \nLemma opp_un_nonzero : Rinj (-1) <> zeroC :>C.\napply nonzero_module.\nrewrite module_opp_un; auto with real.\nQed.\n#[export] Hint Resolve opp_un_nonzero module_opp_un: geo.\n \nLemma argument_opp_un : argument (Rinj (-1)) = image_angle pi.\nelim existence_forme_polaire with (z := Rinj (-1));\n [ intros r H1; elim H1; intros a H2; elim H2; intros H3 H4; try clear H2 H1;\n    try exact H4\n | auto with geo ].\nrewrite module_opp_un in H3.\nelim\n passage_algebrique_argument\n  with (z := Rinj (-1)) (r := 1) (x := -1) (y := 0) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\nrewrite H4.\napply egalite_angle_trigo.\nrewrite sin_pi; rewrite H0; ring.\nrewrite H; rewrite cos_pi; field.\nQed.\n#[export] Hint Resolve argument_opp_un: geo.\n \nLemma forme_polaire_opp_un : Rinj (-1) = cons_pol 1 pi.\napply forme_polaire_def; auto with geo.\nQed.\n \nLemma module_reel : forall x : R, module (Rinj x) = Rabs x.\nunfold Rinj in |- *; intros.\nrewrite (passage_algebrique_module (z:=cons_cart x 0) (x:=x) (y:=0));\n auto with geo.\nreplace (Rsqr x + Rsqr 0) with (Rsqr x) by (unfold Rsqr; ring).\nrewrite sqrt_Rsqr_abs; auto.\nQed.\n \nLemma module_reel_pos : forall x : R, 0 <= x -> module (Rinj x) = x.\nunfold Rinj in |- *; intros.\nrewrite (passage_algebrique_module (z:=cons_cart x 0) (x:=x) (y:=0));\n auto with geo.\nreplace (Rsqr x + Rsqr 0) with (Rsqr x) by (unfold Rsqr in |- *; ring).\nrewrite sqrt_Rsqr; auto.\nQed.\n \nLemma reel_non_nul : forall x : R, x <> 0 -> Rinj x <> zeroC.\nintros.\napply nonzero_module.\nrewrite module_reel.\napply Rabs_no_R0; auto.\nQed.\n#[export] Hint Resolve reel_non_nul module_reel_pos module_reel: geo.\n \nLemma argument_reel_pos :\n forall x : R, 0 < x -> argument (Rinj x) = image_angle 0.\nintros.\ncut (x <> 0); intros.\nelim existence_forme_polaire with (z := Rinj x);\n [ intros r H1; elim H1; intros a H2; elim H2; intros H3 H4; try clear H2 H1;\n    try exact H4\n | auto with geo ].\ncut (x = r); intros.\nelim\n passage_algebrique_argument\n  with (z := Rinj x) (r := r) (x := x) (y := 0) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\nrewrite H4.\napply egalite_angle_trigo.\nrewrite sin_zero; rewrite H5; ring.\nrewrite H2; rewrite <- H1; rewrite cos_zero; field; trivial.\nrewrite module_reel_pos in H3; auto.\nlra.\nauto with real.\nQed.\n#[export] Hint Resolve argument_reel_pos: geo.\n \nLemma forme_pol_reel_pos : forall x : R, 0 < x -> Rinj x = cons_pol x 0 :>C.\nintros.\napply forme_polaire_def; auto with geo.\napply reel_non_nul; auto with real.\napply module_reel_pos; auto with real.\nQed.\n \nLemma module_reel_neg : forall x : R, 0 > x -> module (Rinj x) = - x.\nintros.\nrewrite module_reel; auto.\napply Rabs_left1; auto with real.\nQed.\n#[export] Hint Resolve module_reel_neg: geo.\n \nLemma argument_reel_neg :\n forall x : R, 0 > x -> argument (Rinj x) = image_angle pi.\nintros.\ncut (x <> 0); intros.\nelim existence_forme_polaire with (z := Rinj x);\n [ intros r H1; elim H1; intros a H2; elim H2; intros H3 H4; try clear H2 H1;\n    try exact H4\n | auto with geo ].\nelim\n passage_algebrique_argument\n  with (z := Rinj x) (r := r) (x := x) (y := 0) (a := a);\n [ intros | auto with geo | auto with geo | auto with geo ].\nrewrite H4.\napply egalite_angle_trigo.\nrewrite sin_pi; rewrite H2; ring.\ncut (r = - x); intros.\nrewrite H1; rewrite H5; rewrite cos_pi;  field; trivial.\nrewrite <- H3.\nrewrite module_reel_neg in |- *; [  ring | auto with geo ].\nauto with real.\nQed.\n#[export] Hint Resolve argument_reel_neg: geo.\n \nLemma forme_pol_reel_neg :\n forall x : R, 0 > x -> Rinj x = cons_pol (- x) pi :>C.\nintros.\napply forme_polaire_def; auto with geo.\napply reel_non_nul; auto with real.\nQed.\n \nLemma module_pos : forall z : C, module z >= 0.\nintros.\nelim existence_image_complexe with (z := z); intros M H;\n try clear existence_image_complexe; try exact H.\nrewrite (module_def H); auto with geo.\nQed.\n#[export] Hint Resolve module_pos: geo.\n \nLemma module_stric_pos : forall z : C, z <> zeroC :>C -> module z > 0.\nintros.\ncut (module z >= 0); intros; auto with geo.\nelim H0; intros; auto.\nabsurd (module z = 0); auto with geo.\nQed.\n#[export] Hint Resolve module_stric_pos: geo.\n \nLemma abs_module : forall z : C, module z = Rabs (module z).\nintros.\ncut (module z >= 0); intros; auto with geo.\nrewrite Rabs_right; auto.\nQed.\n#[export] Hint Resolve abs_module: geo.\n",
      "theorem": "Lemma module_i : module i = 1.",
      "ground_truth": "intros.\nrewrite (passage_algebrique_module (z:=i) (x:=0) (y:=1)).\nreplace (Rsqr 0 + Rsqr 1) with 1 by (unfold Rsqr; ring).\nexact sqrt_1.\nunfold i in |- *; auto.\nQed."
    },
    {
      "split": "train-sft",
      "index": 17,
      "prefix": "From Coq Require Extraction.\n\n(* Assignment taken from: https://people.cs.umass.edu/~arjun/courses/cs691pl-spring2014/assignments/groups.html *)\n\n(* The set of the group. *)\nVariable G : Set.\nExtraction G.\n(* The binary operator. *)\nVariable f : G -> G -> G.\nExtraction f.\n(* The group identity. *)\nVariable e : G.\nExtraction e.\n\n(* The inverse operator. *)\nVariable i : G -> G.\nExtraction i.\n\n(* For readability, we use infix <+> to stand for the binary operator. *)\nInfix \"<+>\" := f (at level 50, left associativity).\n\n(* The operator [f] is associative. *)\nAxiom assoc : forall a b c, a <+> b <+> c = a <+> (b <+> c).\nExtraction assoc.\n(* [e] is the right-identity for all elements [a] *)\nAxiom id_r : forall a, a <+> e = a.\nExtraction id_r.\n(* [i a] is the right-inverse of [a]. *)\nAxiom inv_r : forall a, a <+> i a = e.\n\n(* all of these theorems need to be proven using crush.*)\n\n(* The identity [e] is unique. *)\nTheorem unique_id : forall a, a <+> a = a -> a = e.\nProof. intros a Idem.\n       replace a with (a <+> a <+> i a).\n       rewrite Idem.\n       apply inv_r.\n       rewrite assoc.\n       rewrite inv_r.\n       apply id_r.\nQed.\nExtraction unique_id.\nTheorem unique_id_crushed : \n  forall a, \n    a <+> a = a\n    -> (a <+> a) <+> i a = a <+> i a\n    -> a <+> (a <+> i a) = e\n    -> a <+> e = e\n    -> a = e.\n  (*crush.*)\nAdmitted. \n    \n(* Parentheses can move left with 4 arguments. *)\nLemma quatre : forall a b c d, a <+> b <+> (c <+> d) = a <+> (b <+> c) <+> d.\nProof. intros a b c d.\n       rewrite -> assoc.\n       rewrite -> assoc.\n       rewrite assoc. \n       reflexivity.\nQed.\n\n(* [i a] is the left-inverse of [a]. *)\nTheorem inv_l : forall a, i a <+> a = e.\nProof. intros a.\n       apply unique_id.\n       rewrite quatre.\n       rewrite inv_r.\n       rewrite id_r.\n       reflexivity.\nQed.\n\n(* [e] is the left-identity. *)\nTheorem id_l : forall a, e <+> a = a.\nProof. intros a.\n       replace e with (a <+> i a).\n       rewrite assoc.\n       rewrite inv_l.\n       apply id_r.\n       apply inv_r.\nQed.\n\n(* equality if, and only if, inverse are equal. *)\n(*Lemma eq_iff_inveq : forall a b, a = b <-> i a = i b.\n  Proof. intros a b.\n       split.\n       2:{ intro H1.\n           assert (H2: b <+> i a = e).\n           rewrite -> H1.\n           apply inv_r.\n           assert (H3 :).\n           rewrite -> H1.\n         }\n       1:{ intro H0.\n           rewrite H0.\n           reflexivity.\n         }\nAdmitted. *)\n\n(* [x] can be cancelled on the right. *)\nTheorem cancel_r : forall a b x, a <+> x = b <+> x -> a = b.\nProof. intros a b x H0.\n       assert (H1: a <+> x <+> i x = b <+> x <+> i x).\n       - rewrite H0.\n         reflexivity.\n       - rewrite assoc in H1.\n         rewrite inv_r in H1.\n         rewrite id_r  in H1.\n         rewrite assoc in H1.\n         rewrite inv_r in H1.\n         rewrite id_r  in H1.\n         assumption.  \nQed. \n\n(* [x] can be cancelled on the left. *)\nTheorem cancel_l : forall a b x, x <+> a = x <+> b -> a = b.\nProof. intros a b x H0.\n       assert (H1: i x <+> (x <+> a) = i x <+> (x <+> b)).\n       - rewrite H0.\n         reflexivity.\n       - rewrite <- assoc in H1.\n         rewrite inv_l in H1.\n         rewrite id_l in H1.\n         rewrite <- assoc in H1.\n         rewrite inv_l in H1.\n         rewrite id_l in H1.\n         assumption.\nQed.\n\n(* The left identity is unique. *)\nTheorem e_uniq_l : forall a p, p <+> a = a -> p = e.\nProof. intros a p H0.\n       assert (H1: p <+> a <+> i a = a <+> i a).\n       - rewrite H0. reflexivity.\n       - rewrite assoc in H1.\n         rewrite inv_r in H1.\n         rewrite id_r in H1.\n         assumption. \nQed.\n\n(* The left inverse is unique. *)\nTheorem inv_uniq_l : forall a b, a <+> b = e -> a = i b.\nProof. intros a b H0.\n       assert (H1: a <+> b <+> i b = e <+> i b).\n       - rewrite H0. reflexivity.\n       - rewrite assoc in H1.\n         rewrite inv_r in H1.\n         rewrite id_l in H1.\n         rewrite id_r in H1.\n         assumption.\nQed.\n\n(* The right inverse is unique. *)\nTheorem inv_uniq_r : forall a b, a <+> b = e -> b = i a.\nProof. intros a b H0.\n       assert (H1: i a <+> a <+> b = i a <+> e).\n       - rewrite assoc. rewrite H0. reflexivity.\n       - rewrite inv_l in H1.\n         rewrite id_l in H1.\n         rewrite id_r in H1.\n         assumption.\nQed.\n\n(* The inverse operator contravariantly distributes over the group operator. *)\nTheorem inv_distr : forall a b, i (a <+> b) = i b <+> i a.\nProof. intros a b.\n       assert (H0: i (a <+> b) <+> (a <+> b) = e).\n       - rewrite inv_l. reflexivity.\n       - assert (H1: i b <+> i a <+> (a <+> b) = e).\n         rewrite quatre. \n         rewrite inv_l. \n         rewrite id_r. \n         rewrite inv_l. \n         reflexivity.\n         rewrite <- H1 in H0.\n         apply cancel_r in H0.\n         assumption.\nQed.\n\n(* The inverse of an inverse produces the original element. *)\nTheorem double_inv : forall a, i (i a) = a.",
      "suffix": "\n\n(* The identity is its own inverse. *)\nTheorem id_inv : i e = e.\nProof. assert (H0: i e <+> e = e).\n       - rewrite inv_l. reflexivity.\n       - rewrite id_r in H0.\n         assumption. \nQed.",
      "theorem": "Theorem double_inv : forall a, i (i a) = a.",
      "ground_truth": "Proof. intros a.\n       assert (H0: i (i a) <+> i a = e).\n       - rewrite inv_l. reflexivity.\n       - assert (H1: a <+> i a = e).\n         rewrite inv_r.\n         reflexivity.\n         rewrite <- H1 in H0.\n         apply cancel_r in H0.\n         assumption. \nQed."
    },
    {
      "split": "train-sft",
      "index": 18,
      "prefix": "(* Intuitionistic logic is extended to classical logic\n   by assuming a classical axiom. There are different\n   possibilities for the choice of a classical axiom.\n   In this practical work we show the logical equivalence\n   of three different classical axioms. *)\n\n(* The following are three classical axioms *)\n\nDefinition excluded_middle := forall A:Prop, A \\/ ~A.\nDefinition peirce := forall A B:Prop, ((A -> B)-> A) -> A.\nDefinition double_negation := forall A:Prop, ~~A -> A.\n\n(* To show that these are equivalent,\n   we need to prove (at least) three implications.\n   As an example, the implication\n   excluded_middle implies peirce is given. *)\n\nLemma one : excluded_middle -> peirce.\nProof.\nunfold excluded_middle.\nunfold peirce.\nunfold not.\nintro EM.\nintro A.\nintro B.\nelim (EM A).\n\nintro x.\nintro y.\nassumption.\n\nintro x.\nintro y.\napply y.\nintro z.\nelimtype False.\napply x.\nassumption.\nQed.\n\n(* There is a new element in the syntax:\n   a universal quantification over propositions.\n   So in fact these formulas are second-order;\n   we come back to that later in the course. *)\n\n(* How to work with these universal quantifications ?\n   With \"intro\" and \"apply\". Explanation by example:\n\n   If the current goal is \"forall A:Prop, A -> A\",\n   then by doing \"intro A\" the new goal is A -> A\n   and a new hypothesis \"A:Prop\" appears.\n\n   If the current goal is \"C\" and there is a hypothesis\n   \"x: forall A:Prop, B -> A\"\n   then by \"apply x\" the current goal is transformed into \"B\".\n   The universally quantified A is instantiated by C.\n\n   Now suppose that the current goal is \"C\" and\n   there is a hypothesis \"x: forall A B:Prop, B -> A\".\n   Then \"apply x\" does not work because from the\n   current goal we can see how to instantiate A\n   (namely with C) but not how to instantiate B.\n   Therefore we should say \"apply x with something.\"\n   choosing something appropriately. *)\n\n(* exercise; you need the \"apply with\". *)\nLemma two : peirce -> double_negation.\nProof.\nunfold peirce.\nunfold double_negation.\nunfold not.\nintro PE.\nintro A.\nintro.\napply PE with False.\nintro.\nelimtype False.\napply H.\nassumption.\n\nQed.\n\n(* exercise *)\nLemma three : double_negation -> excluded_middle.\nProof.\nunfold double_negation.\nunfold excluded_middle.\nunfold not.\nintro DN.\nintro.\napply DN.\nintro.\napply H.\nright.\nintro.\napply H.\nleft.\nexact H0.\n\nQed.\n\n(* exercise *)\nLemma four : excluded_middle -> double_negation.\nProof.\nunfold excluded_middle.\nunfold double_negation.\nunfold not.\nintro EM.\nintro A.\nintro x.\nelim (EM A).\nintro.\nexact H.\n\nintro.\nelimtype False.\napply x.\nexact H.\n\nQed.\n\n(* exercise *)\nLemma everything_related :\n  excluded_middle -> forall A B : Prop , (A -> B) \\/ (B -> A).\nProof.\nunfold excluded_middle.\nunfold not.\nintro EM.\nintros A B.\nelim EM with (A := B).\nintro.\nleft.\nintro.\nassumption.\nintro.\nright.\nintro.\nelimtype False.\napply H.\nassumption.\nQed.\n\nLemma de_morgan :\n  excluded_middle -> forall A B : Prop , ~(~A/\\~B) -> A\\/B.\nProof.\nunfold excluded_middle.\nunfold not.\nintro EM.\nintro A.\nintro B.\nintro H.\nelim EM with (A := A).\nintro.\nleft.\nassumption.\nintro H0.\nelim EM with (A := B).\nintro.\nright.\nassumption.\nintro H1.\nelimtype False.\napply H.\nsplit.\nassumption.\nassumption.\nQed.\n\n(* exercise\n   note that this lemma is true intuitionistically *)\nLemma about_implication : forall A B : Prop , (~A \\/ B) -> (A -> B).\nProof.\nintro A.\nintro B.\nunfold not.\nintro.\nintro.\nelim H.\nintro.\nelimtype False.\napply H1.\nassumption.\nintro.\nassumption.\nQed.\n\n(* exercise\n   for the converse of the previous lemma we need a classical axiom *)\nLemma classical_implication :\n  excluded_middle -> forall A B : Prop , (A -> B) -> (~A \\/ B).",
      "suffix": "\n\n(* exercise *)\nLemma about_classical_implication :\n  excluded_middle -> forall A B : Prop , ~B \\/ (A ->B).\nProof.\nunfold excluded_middle.\nunfold not.\nintro EM.\nintros A B.\nelim EM with (A:=B).\nright.\nintro.\nelim EM with (A:=A).\nintro.\nassumption.\nintro.\nassumption.\nleft.\nassumption.\n\nQed.\n(*\nvim: filetype=coq\n*)\n",
      "theorem": "Lemma classical_implication :\n  excluded_middle -> forall A B : Prop , (A -> B) -> (~A \\/ B).",
      "ground_truth": "Proof.\nunfold excluded_middle.\nunfold not.\nintro EM.\nintros A B.\nintro x.\nelim EM with (A:=B).\nintro.\nright.\nassumption.\nintro.\n\nleft.\nelim EM with (A := B).\nintros.\napply H.\nassumption.\nintros.\napply H0.\napply x.\nassumption.\n\n\n\nQed."
    },
    {
      "split": "train-sft",
      "index": 19,
      "prefix": "(**\nParts of this file are copied and modified from the Coq Demos\nof the lecture Semantics at Saarland University\nhttp://www.ps.uni-saarland.de/courses/sem-ws17/confluence.v\n**)\n\nSet Implicit Arguments.\nRequire Import Morphisms FinFun.\n\n(** Pretty version of inversion *)\nLtac inv H := inversion H; subst; clear H.\n\nNotation \"R <<= S\" := (forall x y, R x y -> S x y) (at level 70).\nNotation \"R === S\" := (R <<= S /\\ S <<= R) (at level 70).\n\nSection ClosureRelations.\n  Variables (X: Type) (R: X -> X -> Prop).\n  Implicit Types x y z : X.\n\n  Definition functional := forall x y z, R x y -> R x z -> y = z.\n\n  Inductive star : X -> X -> Prop :=\n  | starRefl x     : star x x\n  | starStep x x' y : R x x' -> star x' y -> star x y.\n\n  Inductive plus : X -> X -> Prop :=\n  | plusSingle x y: R x y -> plus x y\n  | plusStep x x' y: R x x' -> plus x' y -> plus x y.\n\n  Inductive counted : nat -> X -> X -> Prop :=\n  | countedRefl x: counted 0 x x\n  | countedStep x x' y n: R x x' -> counted n x' y -> counted (S n) x y.\n\n  Inductive sym: X -> X -> Prop :=\n  | symId x y: R x y -> sym x y\n  | symInv x y: R y x -> sym x y.\n\n\n  Hint Constructors star plus counted.\n\n  Lemma star_trans x y z :\n    star x y -> star y z -> star x z.\n  Proof.\n    induction 1; eauto.\n  Qed.\n\n\n  Lemma plus_trans x y z :\n    plus x y -> plus y z -> plus x z.\n  Proof.\n    induction 1; eauto.\n  Qed.\n\n\n  Fact counted_trans x y z m n:\n    counted m x y -> counted n y z -> counted (m + n) x z.\n  Proof.\n    induction 1; cbn; eauto.\n  Qed.\n\n\n\n  Fact star_exp :\n    R <<= star.\n  Proof.\n    eauto.\n  Qed.\n\n  Fact plus_exp :\n    R <<= plus.\n  Proof.\n    eauto.\n  Qed.\n\n  Fact counted_exp :\n    R === counted 1.\n  Proof.\n    split; eauto.\n    intros x y H; inv H; inv H2; eauto.\n  Qed.\n\n\n  Lemma plus_star : plus <<= star.\n  Proof.\n    induction 1; eauto.\n  Qed.\n\n  Lemma plus_destruct x y: plus x y <-> exists2 x', (R x x') & (star x' y).\n  Proof.\n    split.\n    - induction 1; eauto.\n      destruct IHplus; eexists; eauto.\n    - intros [? H1 H2]; revert x H1; induction H2; eauto.\n  Qed.\n\n\n  Lemma step_star_plus x y z:\n    R x y -> star y z -> plus x z.\n  Proof.\n    intros H1 H2; apply plus_destruct; eauto.\n  Qed.\n\n  Lemma plus_star_step x y z :\n    plus x y -> star y z -> plus x z.\n  Proof.\n    intros [] % plus_destruct ?. eapply plus_destruct.\n    eexists; eauto using star_trans.\n  Qed.\n\nEnd ClosureRelations.\n\n\nDefinition equiv X (R: X -> X -> Prop) := star (sym R).\n\n\n\nHint Constructors star plus counted.\nHint Resolve star_trans plus_trans counted_trans star_exp plus_exp counted_exp.\n\n\n\n\nSection Properties.\n  Variable X: Type.\n  Implicit Types (x y z : X) (R S : X -> X -> Prop).\n\n  Fact star_mono R S :\n    R <<= S -> star R <<= star S.\n  Proof.\n    intros H x y.\n    induction 1; eauto.\n  Qed.\n\n  Fact plus_mono R S :\n    R <<= S -> plus R <<= plus S.\n  Proof.\n    intros H x y.\n    induction 1; eauto.\n  Qed.\n\n\n  Fact star_closure R S :\n    PreOrder S -> R <<= S -> star R <<= S.\n  Proof.\n    intros H1 H2 x y.\n    induction 1 as [x|x x' y H4 _ IH].\n    - reflexivity.\n    - transitivity x'; auto.\n  Qed.\n\n  Fact star_idem R :\n    star (star R) === star R.\n  Proof.\n    split.\n    - induction 1; eauto.\n    - apply star_mono, star_exp.\n  Qed.\n\n  Fact plus_idem R :\n    plus (plus R) === plus R.\n  Proof.\n    split; eauto.\n    induction 1; eauto.\n  Qed.\n\n  Fact plus_fixpoint R :\n    plus (star R) === star R.\n  Proof.\n    split.\n    - induction 1; eauto.\n    - eauto.\n  Qed.\n\n  Fact star_absorbtion R :\n    star (plus R) === star R.\n  Proof.\n    split.\n    - induction 1; eauto.\n      apply plus_destruct in H. destruct H. eauto.\n    - eapply star_mono. eauto.\n  Qed.\n\n\n  Lemma sym_symmetric R x y:\n    sym R x y -> sym R y x.\n  Proof.\n    intros []; eauto using sym.\n  Qed.\n\n  Lemma refl_star R x y:\n    x = y -> star R x y.\n  Proof.\n    intros ->; eauto.\n  Qed.\n\n  Lemma refl_equiv R x:\n    equiv R x x.\n  Proof.\n    constructor.\n  Qed.\n\n  Lemma equiv_trans R x y z:\n    equiv R x y -> equiv R y z -> equiv R x z.\n  Proof. eapply star_trans. Qed.\n\n  Lemma equiv_symm R x y:\n    equiv R x y -> equiv R y x.\n  Proof.\n    induction 1.\n    constructor; eauto.\n    eapply star_trans; eauto.\n    econstructor 2; eauto using refl_equiv, sym_symmetric.\n  Qed.\n\n\n  Lemma equiv_star R x y:\n    star R x y -> equiv R x y.\n  Proof.\n    induction 1; unfold equiv in *; eauto using sym, star.\n  Qed.\n\nEnd Properties.\n\n\n(** Strong normalisation *)\nSection StrongNormalisation.\n\n  Variables (X A: Type).\n  Variables (R: X -> X -> Prop) (S: A -> A -> Prop).\n\n  Definition Normal x := forall y, ~ R x y.\n  Definition evaluates s t := star R s t /\\ Normal t.\n\n  Inductive SN {X} (R: X -> X -> Prop) : X -> Prop :=\n  | SNC x : (forall y, R x y -> SN R y) -> SN R x.\n\n  Lemma SN_ext Q x :\n    (forall x y, R x y <-> Q x y) ->\n    SN R x <-> SN Q x.\n  Proof.\n    split; induction 1; econstructor; firstorder.\n  Qed.\n\n  Fact SN_unfold x :\n    SN R x <-> forall y, R x y -> SN R y.\n  Proof.\n    split.\n    - destruct 1 as [x H]. exact H.\n    - intros H. constructor. exact H.\n  Qed.\n\n  Fact Normal_SN x :\n    Normal x -> SN R x.\n  Proof.\n    intros H. constructor. intros y H1.\n    exfalso. eapply H; eauto.\n  Qed.\n\n\n  Fact Normal_star_stops x:\n    Normal x -> forall y, star R x y -> x = y.\n  Proof.\n    destruct 2; firstorder.\n  Qed.\n\n\n  Fact SN_plus x :\n    SN R x <-> SN (plus R) x.\n  Proof.\n    split.\n    - induction 1 as [x _ IH].\n      constructor. induction 1; eauto.\n      apply IHplus. intros z H1 % plus_exp.\n      destruct (IH x' H) as [H2].\n      apply H3. eauto.\n    - induction 1 as [x _ IH].\n      constructor. intros y H1. apply IH. eauto.\n  Qed.\n\n  Definition morphism  (f: X -> A) := forall x y, R x  y -> S (f x) (f y).\n\n  Fact SN_morphism f x :\n    morphism f -> SN S (f x) -> SN R x.\n  Proof.\n    intros H H1.\n    remember (f x) as a eqn:H2. revert x H2.\n    induction H1 as [a _ IH]. intros x ->.\n    constructor. intros y H1 % H.\n    apply (IH _ H1). reflexivity.\n  Qed.\n\n  Fact SN_finite_steps:\n     (forall x, (exists y, R x y) \\/ Normal x) -> forall x, SN R x -> exists2 y, star R x y & Normal y.",
      "suffix": "\n\n\nEnd StrongNormalisation.\n\nSection Confluence.\n\n  Variable X: Type.\n  Implicit Types (x y z : X) (R S : X -> X -> Prop).\n\n\n  Definition joinable R x y := exists2 z, R x z & R y z.\n  Definition diamond R := forall x y z, R x y -> R x z -> joinable R y z.\n  Definition confluent R := diamond (star R).\n  Definition semi_confluent R :=\n    forall x y z, R x y -> star R x z -> joinable (star R) y z.\n\n\n  Fact diamond_semi_confluent R :\n    diamond R -> semi_confluent R.\n  Proof.\n    intros H x y1 y2 H1 H2. revert y1 H1.\n    induction H2 as [x|x x' y2 H2 _ IH]; intros y1 H1.\n    - exists y1; eauto.\n    - assert (joinable R y1 x') as [z H3 H4].\n      { eapply H; eauto. }\n      assert (joinable (star R) z y2) as [u H5 H6].\n      { apply IH; auto. }\n      exists u; eauto.\n  Qed.\n\n  Fact confluent_semi R :\n    confluent R <-> semi_confluent R.\n  Proof.\n    split.\n    - intros H x y1 y2 H1 H2.\n      eapply H; [|exact H2]. auto.\n    - intros H x y1 y2 H1 H2. revert y2 H2.\n      induction H1 as [x|x x' y1 H1 _ IH]; intros y2 H2.\n      + exists y2; auto.\n      + assert (joinable (star R) x' y2) as [z H3 H4].\n        { eapply H; eauto. }\n        assert (joinable (star R) y1 z) as [u H5 H6].\n        { apply IH; auto. }\n        exists u; eauto.\n  Qed.\n\n  Fact diamond_confluent R :\n    diamond R -> confluent R.\n  Proof.\n    intros H.\n    apply confluent_semi, diamond_semi_confluent, H.\n  Qed.\n\n  Fact joinable_ext R S x y:\n    R === S -> joinable R x y -> joinable S x y.\n  Proof.\n    firstorder.\n  Qed.\n\n  Fact diamond_ext R S:\n    R === S -> diamond S -> diamond R.\n  Proof.\n    intros H1 H2 x y z H3 H4.\n    assert (joinable S y z); firstorder.\n  Qed.\n\n  Lemma confluence_normal_left R x y z:\n    confluent R -> Normal R y ->\n    star R x y -> star R x z ->\n    star R z y.\n  Proof.\n    intros H1 H2 H3 H4. destruct (H1 _ _ _ H3 H4) as [x' A B].\n    enough (x' = y) by congruence.\n    destruct A; eauto; exfalso; eapply H2; eauto.\n  Qed.\n\n  Lemma confluence_normal_right R x y z:\n    confluent R -> Normal R z ->\n    star R x y -> star R x z ->\n    star R y z.\n  Proof.\n    intros H1 H2 H3 H4. destruct (H1 _ _ _ H3 H4) as [x' A B].\n    enough (x' = z) by congruence.\n    destruct B; eauto; exfalso; eapply H2; eauto.\n  Qed.\n\n\n  Lemma confluence_unique_normal_forms R x y z:\n    confluent R -> Normal R y -> Normal R z ->\n    star R x y -> star R x z -> y = z.\n  Proof.\n    intros H1 H2 H3 H4 H5. destruct (H1 _ _ _ H4 H5) as [x' A B].\n    destruct A; [destruct B | ]; eauto; exfalso; [ eapply H3 | eapply H2 ];  eauto.\n  Qed.\n\n\n  Lemma church_rosser (R: X -> X -> Prop) s t:\n    confluent R -> equiv R s t -> exists v: X, star R s v /\\ star R t v.\n  Proof.\n    induction 2.\n    - now (exists x).\n    - inv H0.\n      + destruct IHstar as [v];  exists v; intuition;  eauto.\n      + destruct IHstar; intuition.\n        edestruct H.\n        eapply H3. econstructor 2; eauto.\n        exists x1; split; eauto.\n  Qed.\n\n\nEnd Confluence.\n\n\n(** Right-recursive version of star. *)\n\nInductive starL {X: Type} (R: X -> X -> Prop) (x : X):  X -> Prop :=\n| starReflL : starL R x x\n| starStepL  y y':  starL R x y -> R y y' -> starL R x y'.\n\nHint Constructors starL.\n\nLemma star_starL X (R : X -> X -> Prop) x y :\n  starL R x y <-> star R x y .\nProof.\n  split.\n  - induction 1; auto. induction IHstarL; eauto.\n  - induction 1; eauto. clear H0. induction IHstar; eauto.\nQed.\n\n\n\n(**  Typeclass Instances **)\nGlobal Instance subrel_star {X} (R : X -> X -> Prop) :\n  subrelation (plus R) (star R).\nProof.\n  intros ?; eapply plus_star.\nQed.\n\nGlobal Instance subrel_star_mono {X} (R S: X -> X -> Prop) (H: subrelation R S) :\n  subrelation (star R) (star S).\nProof.\n  exact (star_mono _ H).\nQed.\n\nGlobal Instance subrel_plus_mono {X} (R S: X -> X -> Prop) (H: subrelation R S) :\n  subrelation (plus R) (plus S).\nProof.\n  exact (plus_mono _ H).\nQed.\n\nGlobal Instance subrel_star_equiv {X} (R: X -> X -> Prop) :\n  subrelation (star R) (equiv R).\nProof.\n  exact (@equiv_star _ R).\nQed.\n\n\nGlobal Instance star_preorder {X} (R: X -> X -> Prop):\n  PreOrder (star R).\nProof.\n  constructor; hnf; eauto using star_trans.\nQed.\n\nGlobal Instance star_expansive {X} (R: X -> X -> Prop):\n  subrelation R (star R).\nProof.\n  intros ?; eapply star_exp.\nQed.\n\n\nGlobal Instance plus_expansive {X} (R: X -> X -> Prop):\n  subrelation R (plus R).\nProof.\n  intros?; eapply plus_exp.\nQed.\n\nGlobal Instance plus_transitive {X} (R: X -> X -> Prop):\n  Transitive (plus R).\nProof.\n  intros ?; eapply plus_trans.\nQed.\n\nGlobal Instance sym_Symmetric {X} (R: X -> X -> Prop):\n  Symmetric (sym R).\nProof.\n  firstorder using sym_symmetric.\nQed.\n\n\nGlobal Instance equiv_Equivalence {X} (R: X -> X -> Prop):\n  Equivalence (equiv R).\nProof.\n  constructor; try firstorder using refl_equiv, equiv_trans, equiv_symm.\n  intros ? ? ? ; eapply equiv_trans.\nQed.\n",
      "theorem": "Fact SN_finite_steps:\n     (forall x, (exists y, R x y) \\/ Normal x) -> forall x, SN R x -> exists2 y, star R x y & Normal y.",
      "ground_truth": "Proof.\n    intros H; induction 1 as [x H1 IH]. destruct (H x) as [[y H2]|].\n    + edestruct IH as [z H3 H4]; eauto.\n    + eexists; eauto.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 20,
      "prefix": "Require Export aire_signee.\nRequire Export angles_droites.\nRequire Export angles_vecteurs.\nRequire Export Droite_espace.\nRequire Export triangles_semblables.\n\nDefinition orient ( A B C :PO) : Prop :=\n     aire (vec A B) (vec A C) >0.\n\nLemma orient_cycle :\n    forall (A B C :PO), orient A B C -> orient B C A.\nintros A B C H.\nunfold orient in *.\nrewrite aire_ordre_cycle ;auto.\nQed.\n\n\nLemma orient_compensation :\n    forall (A B C :PO), ~orient A B C \\/ ~orient B A C .",
      "suffix": "\n\nLemma position_3points_1:\n   forall (A B C :PO), (~ orient A B C /\\ ~ orient B A C) \\/ ~ alignes A B C.\nintros A B C.\nelim (classic (~ orient A B C /\\ ~ orient B A C));(intros H;auto).\nright.\nelim (@not_and_or (~orient A B C)(~orient B A C));auto;intro H1.\nassert(orient A B C) by (apply NNPP;auto).\nred;intros H2.\nunfold orient in H0.\nassert ( aire (vec A B)(vec A C) = 0) by apply (@aire_alignement A B C H2) .\nlra.\n\nassert(orient B A C) by (apply NNPP;auto).\nred;intros H2.\nassert (alignes B A C);auto with geo.\nunfold orient in H0.\nassert ( aire (vec B A)(vec B C) = 0) by apply (@aire_alignement B A C H3) .\nlra.\nQed.\n\nLemma position_3points_2:\n   forall (A B C :PO), orient A B C \\/ orient B A C \\/ alignes A B C.\nintros A B C .\ndestruct (@total_order_T (aire (vec A B)(vec A C)) 0) as [[H | H ] |H].\nright;left.\napply orient_cycle;apply orient_cycle.\nunfold orient.\nrewrite aire_anti_symetrique;lra.\nelim (classic (A=B));intros H0.\nright;right.\nrewrite H0;auto with geo.\ndestruct (@aire_nulle_colineaires A B A C H0 H) as [k H1].\nright;right.\napply  colineaire_alignes with (k:=k);auto.\nleft.\nunfold orient;auto.\nQed.\nLemma orient_4point:\n(*correspondant un axiom de Knuth\n  prouve grace a l'axiom position_4points *)\nforall (A B C D : PO), orient A B D -> orient B C D ->\n          orient C A D -> orient A B C.\nintros A B C D H0 H1 H2.\nunfold orient in *.\nrewrite aire_ordre_cycle2 in H2.\nassert (H4:aire (vec A D) (vec B A) >0).\nrewrite aire_anti_symetrique.\nVReplace (vec B A) (mult_PP (-1) (vec A B)).\nrewrite aire_colineaire_l;lra.\nassert (H5: aire (vec A D) (vec B C) >0).\nrewrite <-(@Chasles_vec B A C).\nrewrite aire_distrib_l;lra.\nassert (H6 : aire (vec D B)(vec B C)>0).\nrewrite aire_anti_symetrique.\nVReplace (vec D B) (mult_PP (-1) (vec B D)).\nrewrite aire_colineaire_r;lra.\nassert (H7: aire (vec A B) (vec B C) >0).\nrewrite <-(@Chasles_vec A D B).\nrewrite aire_distrib_r;lra.\nrewrite <-(@Chasles_vec A B C ).\nrewrite aire_distrib_l.\nrewrite aire_ABAB;lra.\nQed.\n\nLemma orient_deroule :\n    forall ( A B C :PO), orient A B C ->\n             ~orient B A C /\\ ~alignes A B C /\\\n             A<>B /\\ A <> C /\\ B<>C.\nintros A B C H.\ncut (~orient B A C);intro H0.\ncut (~alignes A B C);intro H1.\nrepeat split;auto.\nred;intro H2.\nrewrite H2 in H.\nassert (alignes B B C ) by intuition.\nrewrite H2 in H1.\nelim H1;assumption.\nred;intro H2.\nrewrite H2 in H.\nassert (alignes C B C ) by intuition.\nrewrite H2 in H1.\nelim H1;assumption.\nred;intro H2.\nrewrite H2 in H1.\nassert (alignes A C C ) by intuition.\nelim H1;assumption.\ndestruct (position_3points_1 A B C) as [[H2 H3]|h4] ;intuition.\nelim (orient_compensation A B C );intros H1;elim H1;auto.\nQed.\n\n\nLtac deroule_orient H:=\n(*find out others trivial hypotheses from the one*)\n(*  match goal with H : orient ?A ?B ?C|- _ =>*)\n  generalize H; let name := fresh in intros name ; decompose [and] (@orient_deroule _ _ _ name ).\n(*end.*)\n\nDefinition  positifColineaire ( A B M:PO):Prop :=\n       exists k :R, A <> B /\\ vec A M = mult_PP k (vec A B) /\\ k>0.\n\nDefinition  negatifColineaire ( A B M:PO):Prop :=\n       exists k :R, A <> B /\\ vec A M = mult_PP k (vec A B) /\\ k<0.\n\nAxiom colineaire_position :\n      forall A B C :PO, A<>B->\n              C = A \\/ positifColineaire A B C \\/ negatifColineaire A B C.\nAxiom positifColineaire_permute :\n      forall A B C :PO, positifColineaire A B C -> positifColineaire A C B.\nAxiom positifColineaire_negatifColineaire :\n       forall A B C :PO, positifColineaire A B C ->\n                B=C \\/ negatifColineaire C B A \\/ negatifColineaire B C A  .\nAxiom positifColineaire_negatifColineaire1 :\n       forall A B C :PO, positifColineaire A B C ->\n                positifColineaire B A C -> negatifColineaire C B A  .\n\nAxiom negatifColineaire_permute :\n      forall A B C :PO, negatifColineaire A B C -> negatifColineaire A C B.\nAxiom negatifColineaire_positifColineaire :\n       forall A B C :PO, negatifColineaire A B C ->\n                positifColineaire C A B /\\ positifColineaire B A C.\n\nLemma inversion_colineaire :\n forall (k : R) (A B C : PO),\n A <> C -> vec A C = mult_PP k (vec A B) -> vec A B = mult_PP (/ k) (vec A C).\nintros.\ncut (k <> 0); intros.\nrewrite H0.\nFieldvec k.\ncontrapose H.\napply vecteur_nul_conf.\nrewrite H0; rewrite H1; Ringvec.\nQed.\n\nLemma alignes_positifColineaire :\n           forall ( A B M :PO), A<>B ->alignes A B M ->\n                    positifColineaire A B M \\/ positifColineaire B A M.\nintros A B M H H0.\nelim H0;intros H1.\nelim H;auto.\nassert (H2: col_vec A B A M) by (apply alignes1_colineaire;auto).\nelim H2;intros k H3.\nelim (Rle_or_lt k 0);intro H4.\n\nassert ( H5 : vec B M =mult_PP (1-k) (vec B A)).\nrewrite <-(Chasles_vec B A M) .\nrewrite ->(opp_vecteur A B) .\nrewrite H3.\nrewrite (mult_mult_vec A B (1-k) (-1)).\nreplace ((1-k)* -1) with (k-1); [idtac | ring].\nassert (H6: add_PP (mult_PP (-1) (vec A B))(mult_PP k (vec A B))=\n                   mult_PP (-1 +k) (vec A B )) by RingPP.\nrewrite H6.\nreplace (-1 + k ) with (k-1);[auto|ring].\nassert (H7: 1-k >0).\nlra.\nright;unfold positifColineaire.\nexists (1-k);auto.\nleft;unfold positifColineaire.\nexists k;auto.\nQed.\n\n\n(* BEGIN consequences *)\nLemma positifColineaire_orient_l:\nforall (A B C M :PO), orient A B C -> positifColineaire A B M ->\n          orient A M C.\nintros A B C M H [k [H0 [H1 H2]]].\nunfold orient in *.\nrewrite H1.\nrewrite aire_colineaire_l.\napply Rmult_gt_0_compat;auto.\nQed.\n\nLemma negatifColineaire_orient_l:\nforall (A B C M :PO), orient A B C -> negatifColineaire A B M ->\n          orient A C M.\nintros A B C M H [k [H0 [H1 H2]]].\nunfold orient in *.\nrewrite H1.\nrewrite aire_colineaire_r.\nrewrite aire_anti_symetrique.\nrewrite  Ropp_mult_distr_r_reverse.\nrewrite <- Ropp_mult_distr_l_reverse.\napply Rmult_gt_0_compat;auto with real.\nQed.\n\nLemma positifColineaire_orient_r:\nforall (A B C M :PO), orient A B C -> positifColineaire A C M ->\n          orient A B M.\nintros A B C M H [k [H0 [H1 H2]]].\nunfold orient in *.\nrewrite H1.\nrewrite aire_colineaire_r.\napply Rmult_gt_0_compat;auto.\nQed.\n\nLemma negatifColineaire_orient_r:\nforall (A B C M :PO), orient A B C -> negatifColineaire A C M ->\n          orient A M B.\nintros A B C M H [k [H0 [H1 H2]]].\nunfold orient in *.\nrewrite H1.\nrewrite aire_colineaire_l.\nrewrite aire_anti_symetrique.\nrewrite  Ropp_mult_distr_r_reverse.\nrewrite <- Ropp_mult_distr_l_reverse.\napply Rmult_gt_0_compat;auto with real.\nQed.\n\n\nLemma positifColineaire_orient_inv_l:\nforall (A B C M :PO), orient A B C -> orient A M C ->\n          alignes A B M -> positifColineaire A B M.\nintros A B C M H H0 H1 .\ndestruct H1 as [H2|H3].\nderoule_orient H.\nelim H4;auto.\nassert (H2: col_vec A B A M) by (apply alignes1_colineaire;auto).\ndestruct H2 as [k H4].\ndestruct (@total_order_T k 0) as [[H1 | H1] |H1].\nassert(orient A C M).\napply negatifColineaire_orient_l with (B:=B);auto.\nexists k; deroule_orient H;auto.\ndestruct (orient_compensation C M A);elim H5;apply orient_cycle;auto.\nassert ( A = M) by (apply (@produit_zero_conf k A M A B);auto).\nderoule_orient H0.\nelim H7;auto.\nunfold positifColineaire.\nexists k;repeat split;auto.\nderoule_orient H;auto.\nQed.\n\nLemma positifColineaire_orient_inv_r:\nforall (A B C M :PO), orient A B C -> orient A B M  ->\n           alignes A C M ->  positifColineaire A C M.\nintros A B C M H H0 H1 .\ndestruct H1 as [H2|H3].\nderoule_orient H.\nelim H6;auto.\nassert (H2: col_vec A C A M) by (apply alignes1_colineaire;auto).\ndestruct H2 as [k H4].\ndestruct (@total_order_T k 0) as [[H1 | H1] |H1].\nassert(orient A M B).\napply negatifColineaire_orient_r with (C:=C) ;auto.\nexists k;deroule_orient H;auto.\ndestruct (orient_compensation B M A);elim H5;apply orient_cycle;auto.\nassert ( A = M) by (apply (@produit_zero_conf k A M A C);auto).\nderoule_orient H0.\nelim H9;auto.\nunfold positifColineaire.\nexists k;repeat split;auto.\nderoule_orient H;auto.\nQed.\n\n\nLemma negatifColineaire_orient_inv_l:\nforall (A B C M :PO), orient A B C -> orient A C M->alignes A B M->\n          negatifColineaire A B M.\nintros A B C M H H0 H1.\ndestruct H1 as [H2|H2].\nderoule_orient H.\nelim H4;auto.\ndestruct (@alignes1_colineaire A B M) as [k H3];auto.\ndestruct (@Rtotal_order k 0) as [H4 |[H4|H4]].\nexists k;deroule_orient H;auto.\nrewrite H4 in H3.\nassert ( A =M) by (apply (@produit_zero_conf 0 A M A B);auto).\nderoule_orient H0.\nelim H9;auto.\nassert (H5 : orient A M C).\napply (@positifColineaire_orient_l A B C M ); auto.\nexists k;deroule_orient H;auto.\nelim (@orient_compensation A M C);intros H6;elim H6;\n   [auto |apply orient_cycle;apply orient_cycle;auto].\nQed.\n\nLemma negatifColineaire_orient_inv_r:\nforall (A B C M :PO), orient A B C -> orient A M B->alignes A C M->\n          negatifColineaire A C M.\nintros A B C M H H0 H1.\ndestruct H1 as [H2|H2].\nderoule_orient H.\nelim H6;auto.\ndestruct (@alignes1_colineaire A C M) as [k H3];auto.\ndestruct (@Rtotal_order k 0) as [H4 |[H4|H4]].\nexists k;deroule_orient H;auto.\nrewrite H4 in H3.\nassert ( A =M) by (apply (@produit_zero_conf 0 A M A C);auto).\nderoule_orient H0.\nelim H7;auto.\nassert (H5 : orient A B M ).\napply (@positifColineaire_orient_r A B C M ); auto.\nexists k;deroule_orient H; auto.\nelim (@orient_compensation A B M );intros H6;elim H6;\n   [auto |apply orient_cycle;apply orient_cycle;auto].\nQed.\n\n\n\n\n(* Lemma for angle and orientation *)\nLemma orient_SinusPositif :\nforall A B C  :PO,\n           orient A B C-> Sin (cons_AV (vec A B )(vec A C ))>0.\nintros A B C H.\ngeneralize H;intros H0.\nunfold orient in H0.\nrewrite def_aire in *;deroule_orient H;auto.\nelim (@distance_pos A B );intros H10 ;\n      [idtac|elim (@distincts_dist_non_nulle A B H3);auto].\nelim (@distance_pos A C );intros H11 ;\n      [idtac|elim (@distincts_dist_non_nulle A C H5);auto].\nassert (H9 :0< distance A C * Sin(cons_AV (vec A B )(vec A C)) ).\napply Rmult_lt_reg_l with (r:= distance A B);auto with real.\nreplace (distance A B *0)  with 0  ;auto with real.\nred.\napply Rmult_lt_reg_l with (r:= distance A C);auto with real.\nreplace (distance A C *0)  with 0  ;auto with real.\nQed.\n\nLemma anglesEgaux_orient :\nforall (A B C M N P : PO), orient A B C -> M<>N -> M <>P->\n         cons_AV (vec M N) (vec M P) = cons_AV (vec A B ) ( vec A C)->\n         orient M N P.\nintros A B C M N P H H0 H1 H2.\ngeneralize H;intros H3.\nunfold orient in H3.\nunfold orient .\nrewrite def_aire in *;deroule_orient H;auto.\nelim (@distance_pos A B );intros H11 ;\n      [idtac|elim (@distincts_dist_non_nulle A B H6);auto].\nelim (@distance_pos A C );intros H12 ;\n      [idtac|elim (@distincts_dist_non_nulle A C H8);auto].\nelim (@distance_pos M N );intros H13 ;\n      [idtac|elim (@distincts_dist_non_nulle M N H0);auto].\nelim (@distance_pos M P );intros H14 ;\n      [idtac|elim (@distincts_dist_non_nulle M P H1);auto].\nrewrite H2.\napply Rmult_gt_0_compat;auto.\napply Rmult_gt_0_compat;auto.\nreplace 0 with (distance A B *0) in H3;auto with real.\napply orient_SinusPositif;auto.\nQed.\n\nLemma  consAD_orient_consAV:\nforall A B C M N P :PO,\ndouble_AV (cons_AV (vec A B)(vec A C))= double_AV (cons_AV (vec M N) (vec M P))->\norient A B C -> orient M N P ->\ncons_AV (vec A B) (vec A C) = cons_AV (vec M N) (vec M P).\nintros A B C M N P H H0 H1.\nunfold double_AV in H.\nderoule_orient H0.\nderoule_orient H1.\ndestruct  (tout_angle_a_une_mesure (A:=A) (B:=B) (C:=A) (D:=C)) as [x H15]; auto with geo.\ndestruct  (tout_angle_a_une_mesure (A:=M) (B:=N) (C:=M) (D:=P)) as [y H16]; auto with geo.\nrewrite <-H15 in *.\nrewrite <-H16 in *.\nrewrite <-add_mes_compatible in H.\nrewrite <-add_mes_compatible in H.\nreplace (x+x) with (2*x) in H.\nreplace (y+y) with (2*y) in H.\ncut (sin x = sin y).\nintros H17.\ncut (cos x = cos y).\nintros H18.\napply egalite_angle_trigo;auto.\nassert (H19:sin (2*x) = sin (2*y)) by (apply sin_deux_mes;auto).\nrepeat rewrite duplication_sin in H19.\nrewrite H17 in H19.\napply Rmult_eq_reg_l with (r:=sin y).\napply Rmult_eq_reg_l with (r:=2);auto with real.\napply Rgt_not_eq.\nrewrite (@egalite_sin_Sin M N P y);auto.\napply orient_SinusPositif;auto.\nassert (H19:cos (2*x) = cos (2*y)) by (apply cos_deux_mes;auto).\nrepeat rewrite duplication_cos2 in H19.\napply Rsqr_inj.\nassert (sin x >0) by\n(rewrite (@egalite_sin_Sin A B C x);auto; apply orient_SinusPositif;auto).\nlra.\nassert (sin y >0) by\n(rewrite (@egalite_sin_Sin M N P y);auto; apply orient_SinusPositif;auto).\nlra.\napply Rmult_eq_reg_l with (r:=2);auto with real.\nassert (-(2*Rsqr (sin x)) = -((2*Rsqr (sin y)))) by (apply Rplus_eq_reg_l with (r:=1);auto with real).\nreplace (2 * Rsqr(sin x)) with (-(-(2 * Rsqr(sin x))));auto with real.\nreplace (2 * Rsqr(sin y)) with (-(-(2 * Rsqr(sin y))));auto with real.\nring.\nring.\nQed.\n\nLemma  consAD_orient_consAVplusPi:\nforall A B C M N P :PO,\ndouble_AV (cons_AV (vec A B)(vec A C))= double_AV (cons_AV (vec M N) (vec M P))->\norient A B C -> orient M P N ->\ncons_AV (vec A B) (vec A C) = plus (cons_AV (vec M N) (vec M P)) (image_angle pi).\nintros A B C M N P H H0 H1.\nunfold double_AV in H.\nderoule_orient H0.\nderoule_orient H1.\ndestruct  (tout_angle_a_une_mesure (A:=A) (B:=B) (C:=A) (D:=C)) as [x H15]; auto with geo.\ndestruct  (tout_angle_a_une_mesure (A:=M) (B:=N) (C:=M) (D:=P)) as [y H16]; auto with geo.\nrewrite <-H15 in *.\nrewrite <-H16 in *.\nrewrite <-add_mes_compatible in H.\nrewrite <-add_mes_compatible in H.\nreplace (x+x) with (2*x) in H; [idtac|ring].\nreplace (y+y) with (2*y) in H; [idtac|ring].\ncut (sin x = -sin y).\nintros H17.\ncut (cos x = -cos y).\nintros H18.\nrewrite <-add_mes_compatible.\napply egalite_angle_PiPres_trigo;auto.\nassert (H19:sin (2*x) = sin (2*y)) by (apply sin_deux_mes;auto).\nrepeat rewrite duplication_sin in H19.\nrewrite H17 in H19.\nreplace (cos x) with ( - -cos x);auto with real.\napply Ropp_eq_compat.\napply Rmult_eq_reg_l with (r:=sin y).\napply Rmult_eq_reg_l with (r:=2);auto with real.\nrewrite <-H19.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Ropp_mult_distr_r_reverse;auto.\n\nassert (Sin (cons_AV(vec M P)(vec M N)) >0) by (apply orient_SinusPositif;auto).\nassert (cons_AV (vec M P) (vec M N) = opp (cons_AV (vec M N) (vec M P))).\napply opp_angle.\nrewrite Chasles;auto.\nrewrite <-angle_nul;auto.\nrewrite <-H16 in H18.\nrewrite <-mes_opp in H18.\nrewrite <-(@egalite_sin_Sin M P N (-y)) in H13;auto.\nrewrite  sin_impaire in H13.\nassert (sin y <0).\nlra.\napply Rlt_not_eq;auto.\n\nassert (H19:cos (2*x) = cos (2*y)) by (apply cos_deux_mes;auto).\nrepeat rewrite duplication_cos2 in H19.\nrewrite (@Rsqr_neg (sin y)) in H19.\napply Rsqr_inj.\nassert (sin x >0) by\n(rewrite (@egalite_sin_Sin A B C x);auto; apply orient_SinusPositif;auto).\nlra.\n\nassert (Sin (cons_AV(vec M P)(vec M N)) >0) by (apply orient_SinusPositif;auto).\nassert (cons_AV (vec M P) (vec M N) = opp (cons_AV (vec M N) (vec M P))).\napply opp_angle.\nrewrite Chasles;auto.\nrewrite <-angle_nul;auto.\nrewrite <-H16 in H17.\nrewrite <-mes_opp in H17.\nrewrite <-(@egalite_sin_Sin M P N (-y)) in H13;auto.\nrewrite  sin_impaire in H13.\nlra.\napply Rmult_eq_reg_l with (r:=2);auto with real.\nassert (-(2*Rsqr (sin x)) = -((2*Rsqr (-sin y)))) by (apply Rplus_eq_reg_l with (r:=1);auto with real).\nreplace (2 * Rsqr(sin x)) with (-(-(2 * Rsqr(sin x))));auto with real.\nreplace (2 * Rsqr(-sin y)) with (-(-(2 * Rsqr(-sin y))));auto with real.\nQed.\n\n\n\n\n(*  Des consequences concernant l'intersection*)\nDefinition vecEntreDeuxVec ( A B C M :PO) : Prop :=\n           (orient A B C /\\ orient A B M /\\ orient A M C)\\/\n           (orient A C B /\\ orient A C M /\\ orient A M B).\n\nLemma (*lemme*) vecEntreDeuxVec_permute :\nforall ( A B C M :PO), vecEntreDeuxVec A B C M ->\n          vecEntreDeuxVec A C B M.\nintros A B C M [[H0 [H1 H2]]|[H0 [H1 H2]]].\nright;auto.\nleft;auto.\nQed.\n\nLemma vecEntreDeuxVec_intersection_middle1:\n           forall ( A B C D :PO),orient A B C -> vecEntreDeuxVec A B C D ->\n           forall M:PO, alignes A D M /\\ alignes B C M ->\n           positifColineaire A D M.\nintros A B C D H H0 M [H2 H1] .\nelim H0;intros [H3 [H4 H5]].\ndestruct H2 as [H2|H2].\nderoule_orient H5;elim H8;auto.\ndestruct (@alignes1_colineaire A D M) as [k H6];auto.\ndestruct (@Rtotal_order k 0) as [H7|[H7|H7]].\nassert (orient A C M)\n  by (apply (@negatifColineaire_orient_l A D C M H5 );auto;\n  exists k; deroule_orient H5;auto).\nassert (orient A M B)\n  by (apply (@negatifColineaire_orient_r A B D M H4 );auto;\n  exists k; deroule_orient H4;auto).\nassert (orient M B C).\napply orient_4point with (D:=A);auto.\napply orient_cycle; auto.\napply orient_cycle;auto.\napply orient_cycle;auto.\nderoule_orient H10.\nelim H14;apply alignes_ordre_cycle2;auto.\nassert (A=M) by (apply produit_zero_conf with (k:=k) (C:=A)(D:=D);auto).\nrewrite <-H8 in H1.\nderoule_orient H3.\nelim H12;auto with geo.\nexists k;repeat split;auto.\nderoule_orient H5;auto.\ndestruct  (@orient_compensation A B C) as [H6|H6].\nelim H6;auto.\nelim H6;apply orient_cycle;apply orient_cycle;auto.\nQed.\n\n\nLemma vecEntreDeuxVec_intersection_middle2:\n           forall ( A B C D  :PO),orient A B C -> vecEntreDeuxVec A B C D ->\n           forall M:PO, alignes A D M /\\ alignes B C M ->\n           positifColineaire B C M /\\ positifColineaire C B M.\nintros A B C D  H H0 M [H2 H1].\nelim H0;intros [H3 [H4 H5]].\nassert (positifColineaire A D M) by  (apply(@vecEntreDeuxVec_intersection_middle1 A B C D );auto).\nassert (orient A B M) by (apply positifColineaire_orient_r with (C:=D);auto).\nassert (orient A M C) by (apply  positifColineaire_orient_l with (B:=D);auto).\nsplit.\napply (@positifColineaire_orient_inv_l B C A M);auto.\napply orient_cycle;assumption.\napply orient_cycle;assumption.\napply (@positifColineaire_orient_inv_r C A B M);auto.\napply orient_cycle;apply orient_cycle;assumption.\napply orient_cycle;apply orient_cycle;assumption.\napply permute_alignes;assumption.\ndestruct  (@orient_compensation A B C) as [H6|H6].\nelim H6;auto.\nelim H6;apply orient_cycle;apply orient_cycle;auto.\nQed.\n\nLemma vecEntreDeuxVec_intersection_middle:\n           forall ( A B C D :PO), vecEntreDeuxVec A B C D ->\n           forall M:PO, alignes A D M /\\ alignes B C M ->\n           positifColineaire B C M /\\ positifColineaire C B M /\\ positifColineaire A D M.\nintros A B C D H M [H1 H0].\nelim H;intros [H2 [H3 H4]].\nassert (positifColineaire B C M /\\ positifColineaire C B M).\napply (@vecEntreDeuxVec_intersection_middle2 A B C D );auto.\nassert (positifColineaire A D M).\napply (@vecEntreDeuxVec_intersection_middle1 A B C D );auto.\ndestruct H5 as [H7 H8].\nsplit;auto.\nassert (vecEntreDeuxVec A C B D) by\n        (unfold vecEntreDeuxVec;left;split;auto).\nassert (positifColineaire C B M /\\ positifColineaire B C M).\napply (@vecEntreDeuxVec_intersection_middle2 A C B D );auto with geo.\nassert (positifColineaire A D M).\napply (@vecEntreDeuxVec_intersection_middle1 A C B D );auto with geo.\ndestruct H6 as [H8 H9].\nsplit;auto.\nQed.\n\nLemma vecEntreDeuxVec_intersection_left1:\n           forall ( A B C D :PO), vecEntreDeuxVec A B C D ->\n           forall M :PO, alignes A B M /\\ alignes C D M ->\n           (positifColineaire C D M -> positifColineaire A B M) /\\\n           (positifColineaire A B M -> positifColineaire C D M /\\ positifColineaire M D C ) .\nintros A B C D H M [H3 H2].\nrepeat split.\nintro H1.\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient A M C).\napply orient_cycle.\napply positifColineaire_orient_r with (C:=D);auto.\napply orient_cycle;apply orient_cycle;auto.\napply positifColineaire_orient_inv_l with (C:=C);auto.\nassert (H4 : orient A C M).\napply orient_cycle;apply orient_cycle.\napply positifColineaire_orient_l with (B:=D);auto.\napply orient_cycle;auto.\napply positifColineaire_orient_inv_r with (B:=C);auto.\n\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient C A M ).\napply orient_cycle;apply orient_cycle;auto.\napply positifColineaire_orient_l with (B:=B);auto.\napply positifColineaire_orient_inv_r with (B:=A);auto.\napply orient_cycle;apply orient_cycle;auto.\nassert (H4 : orient C M A ).\napply orient_cycle;auto.\napply positifColineaire_orient_r with (C:=B);auto.\napply positifColineaire_orient_inv_l with (C:=A);auto.\napply orient_cycle;auto.\n\n\n\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient M C A ).\napply orient_cycle.\napply positifColineaire_orient_l with (B:=B);auto.\nassert (H5 : orient M D A ).\napply orient_cycle.\napply positifColineaire_orient_l with (B:=B);auto.\napply positifColineaire_orient_inv_l with (C:=A);auto with geo.\nassert (H4 : orient M A C ).\napply orient_cycle;apply orient_cycle.\napply positifColineaire_orient_r with (C:=B);auto.\nassert (H5 : orient M A D ).\napply orient_cycle;apply orient_cycle.\napply positifColineaire_orient_r with (C:=B);auto.\napply positifColineaire_orient_inv_r with (B:=A);auto with geo.\nQed.\n\nLemma vecEntreDeuxVec_intersection_left2:\n           forall ( A B C D :PO), vecEntreDeuxVec A B C D ->\n           forall M :PO, alignes A B M /\\ alignes C D M ->\n           (negatifColineaire C D M -> negatifColineaire A B M) /\\\n           (negatifColineaire A B M -> negatifColineaire C D M  ) .\nintros A B C D H M [H3 H2].\nrepeat split;intro H1.\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient A C M).\napply orient_cycle;apply orient_cycle.\napply negatifColineaire_orient_r with (C:=D);auto.\napply orient_cycle;apply orient_cycle;auto.\napply negatifColineaire_orient_inv_l with (C:=C);auto.\nassert (H4 : orient A M C ).\napply orient_cycle.\napply negatifColineaire_orient_l with (B:=D);auto.\napply orient_cycle;auto.\napply negatifColineaire_orient_inv_r with (B:=C);auto.\n\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient C M A ).\napply orient_cycle.\napply negatifColineaire_orient_l with (B:=B);auto.\napply negatifColineaire_orient_inv_r with (B:=A);auto.\napply orient_cycle;apply orient_cycle;auto.\nassert (H4 : orient C A M  ).\napply orient_cycle;apply orient_cycle.\napply negatifColineaire_orient_r with (C:=B);auto.\napply negatifColineaire_orient_inv_l with (C:=A);auto.\napply orient_cycle;auto.\nQed.\n\n\nLemma vecEntreDeuxVec_intersection_right1:\n           forall ( A B C D :PO), vecEntreDeuxVec A B C D ->\n           forall M :PO, alignes A C M /\\ alignes B D M ->\n           (positifColineaire B D M -> positifColineaire A C M) /\\\n           (positifColineaire A C M -> positifColineaire B D M /\\ positifColineaire M D B ) .\nintros A B C  D H M [H3 H2].\nrepeat split.\nintro H1.\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient A B M).\napply orient_cycle;apply orient_cycle.\napply positifColineaire_orient_l with (B:=D);auto.\napply orient_cycle;auto.\napply positifColineaire_orient_inv_r with (B:=B);auto.\nassert (H4 : orient A M B).\napply orient_cycle.\napply positifColineaire_orient_r with (C:=D);auto.\napply orient_cycle;apply orient_cycle;auto.\napply positifColineaire_orient_inv_l with (C:=B);auto.\n\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient B M A ).\napply orient_cycle;auto.\napply positifColineaire_orient_r with (C:=C);auto.\napply positifColineaire_orient_inv_l with (C:=A);auto.\napply orient_cycle;auto.\nassert (H4 : orient B A M ).\napply orient_cycle;apply orient_cycle;auto.\napply positifColineaire_orient_l with (B:=C);auto.\napply positifColineaire_orient_inv_r with (B:=A);auto.\napply orient_cycle;apply orient_cycle;auto.\n\n\n\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient M A B ).\napply orient_cycle;apply orient_cycle.\napply positifColineaire_orient_r with (C:=C);auto.\nassert (H5 : orient M A D ).\napply orient_cycle;apply orient_cycle.\napply positifColineaire_orient_r with (C:=C);auto.\napply positifColineaire_orient_inv_r with (B:=A);auto with geo.\nassert (H4 : orient M B A ).\napply orient_cycle.\napply positifColineaire_orient_l with (B:=C);auto.\nassert (H5 : orient M D A ).\napply orient_cycle.\napply positifColineaire_orient_l with (B:=C);auto.\napply positifColineaire_orient_inv_l with (C:=A);auto with geo.\nQed.\n\nLemma vecEntreDeuxVec_intersection_right2:\n           forall ( A B C D :PO), vecEntreDeuxVec A B C D ->\n           forall M :PO, alignes A C M /\\ alignes B D M ->\n           (negatifColineaire B D M -> negatifColineaire A C M) /\\\n           (negatifColineaire A C M -> negatifColineaire B D M  ) .\nintros A B C D H M [H3 H2].\nrepeat split;intro H1.\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient A M B ).\napply orient_cycle.\napply negatifColineaire_orient_l with (B:=D);auto.\napply orient_cycle;auto.\napply negatifColineaire_orient_inv_r with (B:=B);auto.\nassert (H4 : orient A B M ).\napply orient_cycle;apply orient_cycle.\napply negatifColineaire_orient_r with (C:=D);auto.\napply orient_cycle;apply orient_cycle;auto.\napply negatifColineaire_orient_inv_l with (C:=B);auto.\n\ndestruct H as [[H19 [H20 H21]] |[H19 [H20 H21]]].\nassert (H4 : orient B A M  ).\napply orient_cycle;apply orient_cycle.\napply negatifColineaire_orient_r with (C:=C);auto.\napply negatifColineaire_orient_inv_l with (C:=A);auto.\napply orient_cycle;auto.\nassert (H4 : orient B M A ).\napply orient_cycle.\napply negatifColineaire_orient_l with (B:=C);auto.\napply negatifColineaire_orient_inv_r with (B:=A);auto.\napply orient_cycle;apply orient_cycle;auto.\nQed.\n\n\n\nLemma Exists_Intersection1 : (* on peut prouver grace au lemme\ndroites_non_paralleles *)\nforall (A B C D :PO),\n          vecEntreDeuxVec A B C D ->\n          exists E :PO, alignes A D E /\\ alignes B C E.\nintros A B C D H.\nassert (H0 : ~alignes A D B /\\ A <>D)\n by(destruct H as [[_ [H2 _]]|[_ [_ H2]]];deroule_orient H2;auto with geo).\ndestruct H0 as [H0 H1].\nassert (H2 : ~alignes A D C)\n by(destruct H as [[_ [_ H3 ]]|[_ [H3 _]]];deroule_orient H3;auto with geo).\nassert (H3 : B<>C)\n by(destruct H as [[H4 [_ _]]|[H4 [_ _]]];deroule_orient H4;auto with geo).\ndestruct (@existence_pt_intersection A D B C ) as [E H4];auto.\nassert (H4: ~ paralleles (droite A D) (droite B C)).\nred;intros H4.\ndestruct (@existence_representant_vecteur A B C) as [D' H5].\ndestruct (@paralleles_vecteur A D B C ) as [k H6];auto.\ndestruct H as [[H7 [H8 H9]]|[H7 [H8 H9]]].\nassert (aire(vec B C)(vec A D) = 0) by (apply aire_colinearite with (k:=k) ;auto).\nrewrite <-(@Chasles_vec B A C) in H.\nrewrite aire_distrib_r in H.\nassert (aire (vec B A)(vec A D) <0).\nVReplace (vec B A) (mult_PP (-1) (vec A B)).\nrewrite aire_colineaire_l.\nunfold orient in H8;lra.\nassert (aire (vec A C)(vec A D) <0).\nrewrite aire_anti_symetrique.\nunfold orient in H9;lra.\nlra.\nassert (aire(vec B C)(vec A D) = 0) by (apply aire_colinearite with (k:=k) ;auto).\nrewrite <-(@Chasles_vec B A C) in H.\nrewrite aire_distrib_r in H.\nassert (aire (vec B A)(vec A D) >0).\nVReplace (vec B A) (mult_PP (-1) (vec A B)).\nrewrite aire_colineaire_l.\nrewrite aire_anti_symetrique.\nunfold orient in H9.\nreplace (-1) with (-(1)) by ring.\nrewrite Ropp_mult_distr_l_reverse.\nrewrite Ropp_mult_distr_r_reverse.\nlra.\nassert (aire (vec A C)(vec A D) >0).\nunfold orient in H8;auto.\nlra.\nelim (@droites_non_paralleles  B C A D H3 H1 H4);auto.\nintros H5.\n(*here we use an axiom of plane geometry,\nwhich one to say that every 4 points are COPLANAR   *)\nassert (H6: coplanaires B C A D) by apply geometrie_plane.\nelim H5;auto.\nexists E;auto.\napply def_pt_intersection2;auto.\nQed.\n\nLemma Exists_Intersection: (* on peut prouver grace au lemme\ndroites_non_paralleles *)\nforall (A B C D :PO),\n          vecEntreDeuxVec A B C D ->\n          exists M :PO,positifColineaire B C M /\\ positifColineaire C B M /\\ positifColineaire A D M.\nintros A B C D H.\ndestruct (@Exists_Intersection1 A B C D) as [M [H0 H1]];auto.\nexists M.\napply vecEntreDeuxVec_intersection_middle;auto.\nQed.\n\n(*Consequence concernant angles inscrits oriente*)\nAxiom differencePiNull : image_angle 0 <>image_angle pi.\n\nRequire Export cocyclicite.\n\nLtac deroule_sont_cocycliques :=\n  match goal with H : sont_cocycliques ?A ?B ?C ?D|- _ =>\n  generalize H ; let name := fresh in intros name  ;\n  unfold sont_cocycliques in name;\n  destruct name ;decompose [and] name; clear name;\n repeat match goal with H' : circonscrit ?O ?A ?B ?C  |- _ =>\n  unfold circonscrit  in H';\n  decompose [and] H' ; clear H' end ;\n repeat match goal with H' : isocele ?O ?A ?B  |- _ =>\n  unfold isocele  in H'\n  end\nend.\n\nLemma sont_cocycliques_avec_ordre_cycle:\nforall (A B C D :PO),\n         sont_cocycliques A B C D ->sont_cocycliques B C D A.\nintros A B C D H.\nderoule_sont_cocycliques .\nunfold sont_cocycliques .\nexists x.\nunfold circonscrit in *.\nunfold isocele in *.\nrepeat split ;auto.\nrewrite H4 in H2;auto.\nrewrite H3 in H0;auto.\nrewrite H4 in H2;auto.\nQed.\n\nLemma sont_cocycliques_avec_ordre_permute:\nforall (A B C D :PO),\n         sont_cocycliques A B C D ->sont_cocycliques A B D C.\nintros A B C D H.\nderoule_sont_cocycliques .\nunfold sont_cocycliques .\nexists x.\nunfold circonscrit in *.\nunfold isocele in *.\nrepeat split ;auto.\nQed.\n\n\n\n\n\n\nTheorem SommeAnglesInscritsOriente:\nforall (A B C D : PO),\n         sont_cocycliques A B C D ->orient A B C ->\n                    orient A C D -> orient A B D.\nintros A B C D H H0 H1.\ndestruct (@position_3points_2 A B D) as [H2|[H2|H2]];auto.\nassert (H3:orient B C D).\napply orient_4point with (D:=A);auto.\napply orient_cycle;auto.\napply orient_cycle;auto.\napply orient_cycle;apply orient_cycle;auto.\n\n\nassert (H4:cons_AV(vec A D )(vec A B) = cons_AV (vec C D)(vec C B)).\napply consAD_orient_consAV.\napply cocyclicite;auto with geo.\nderoule_orient H2 ;auto with geo.\nderoule_orient H3 ;auto with geo.\napply sont_cocycliques_avec_ordre_cycle.\napply sont_cocycliques_avec_ordre_permute.\napply sont_cocycliques_avec_ordre_cycle;apply sont_cocycliques_avec_ordre_cycle;auto.\napply orient_cycle;auto.\napply orient_cycle;auto.\nassert (H5:cons_AV(vec A B )(vec A C) = cons_AV (vec D B)(vec D C)).\napply consAD_orient_consAV;auto.\napply cocyclicite;auto with geo.\nderoule_orient H0 ;auto with geo.\nderoule_orient H3 ;auto with geo.\napply sont_cocycliques_avec_ordre_permute.\napply sont_cocycliques_avec_ordre_cycle;auto.\napply orient_cycle;apply orient_cycle;auto.\nassert (H6:cons_AV(vec A C )(vec A D) = cons_AV (vec B C)(vec B D)).\napply consAD_orient_consAV;auto.\napply cocyclicite;auto with geo.\nderoule_orient H1 ;auto with geo.\nderoule_orient H3 ;auto with geo.\napply sont_cocycliques_avec_ordre_cycle.\napply sont_cocycliques_avec_ordre_cycle;auto.\nassert (plus (cons_AV (vec C D) (vec C B))\n   (plus (cons_AV (vec D B) (vec D C)) (cons_AV (vec B C) (vec B D))) = image_angle pi).\napply somme_triangle;deroule_orient H3;auto.\nrewrite <-H4 in H7.\nrewrite <-H5 in H7.\nrewrite <-H6 in H7.\nrewrite Chasles in H7;(deroule_orient H0;deroule_orient H1;auto).\nrewrite Chasles in H7;(deroule_orient H0;deroule_orient H1;auto).\nrewrite <-angle_nul in H7;auto.\n\nelim differencePiNull;auto.\n\nassert (H3: col_vec A B A D) .\napply alignes1_colineaire;auto with geo.\nunfold alignes in H2.\nelim H2;intros;auto.\nderoule_orient H0.\nelim H6;auto.\ndestruct H3 as [k H4].\ndestruct (@total_order_T k 0) as [[H5| H5] |H5].\nassert (H6: vec B D = mult_PP (1-k) (vec B A)).\nrewrite <-(@Chasles_vec B A D) .\nrewrite H4.\nVReplace (vec A B) (mult_PP (-1) (vec B A)).\nrewrite mult_mult_vec.\nreplace (k*-1) with (-k);[idtac|ring].\nreplace (1-k) with (1+(-k));auto with real.\nVReplace (vec B A) (mult_PP (1) (vec B A)).\nRingPP.\nassert (H7: 1-k >0).\nlra.\nassert(H8 : orient D B C).\napply orient_cycle;apply orient_cycle.\napply positifColineaire_orient_r with (C:=A).\napply orient_cycle;auto.\nexists (1-k);deroule_orient H0;auto.\nassert (H9:cons_AV(vec D B )(vec D C) = cons_AV (vec A B)(vec A C)).\napply consAD_orient_consAV;auto.\napply cocyclicite;auto with geo.\nderoule_orient H8 ;auto with geo.\nderoule_orient H0 ;auto with geo.\napply sont_cocycliques_avec_ordre_cycle;auto.\n\nassert (trianglesSD C A B C D B ).\nrepeat split.\nderoule_orient H0;auto with geo.\nderoule_orient H8;auto with geo.\nauto.\nrewrite (@angle_produit_positif_r (1-k) B A D  B C ) ;auto.\nderoule_orient H0;auto with geo.\nderoule_orient H0;auto with geo.\nassert (cons_AV (vec C A)(vec C B) =cons_AV (vec C D)(vec C B)).\napply (@trianglesSD_angles_egaux  C A B C D B);auto.\nassert (cons_AV (vec C A) (vec C D) = image_angle 0).\nrewrite <-(@Chasles C A C B C D);(deroule_orient H0;deroule_orient H1;auto with geo).\nrewrite H10.\nrewrite Chasles;auto with geo.\nrewrite (@ angle_nul C D) ;auto.\ndestruct (@angle_nul_positif_colineaire C A D) as [k' [H12 H13]];(deroule_orient H0;deroule_orient H1;auto).\nassert (alignes C A D) .\napply colineaire_alignes with (k:=k');auto.\nelim H23.\napply   alignes_ordre_permute .\napply alignes_ordre_cycle;auto.\n\n\n\n\nassert (A=D).\napply (@produit_zero_conf k A D A B);auto.\nderoule_orient H1.\nelim H10;auto.\n\nassert (orient A D C).\napply (@positifColineaire_orient_l A B C D H0);auto.\nexists k;deroule_orient H0;auto.\nelim (@orient_compensation D C A);intro.\nelim H6.\napply orient_cycle;auto.\n\nelim H6.\napply orient_cycle;auto.\nQed.\n",
      "theorem": "Lemma orient_compensation :\n    forall (A B C :PO), ~orient A B C \\/ ~orient B A C .",
      "ground_truth": "intros A B C.\nelim (classic (orient A B C));(intros H;auto).\nassert (H0 : orient B C A ) by (apply orient_cycle ;auto).\nright;red;intros H1.\nunfold orient in *.\nrewrite aire_anti_symetrique in H1.\nlra.\nQed."
    },
    {
      "split": "train-sft",
      "index": 21,
      "prefix": "(* Coq\n   \u899a\u3048\u3066\u304a\u304f\u3068\u4fbf\u5229\u306a\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u30fc\n   2010_09_19\n*)\n(*\n  (1) \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3092\u76f4\u63a5\u4f7f\u3046\u4f8b\u3002apply(\u307e\u305f\u306fcase)\u3092\u4f7f\u7528\u3002\n  (1') \u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u3092\u76f4\u63a5\u4f7f\u3046\u4f8b\u3002constructor\u3092\u4f7f\u7528\u3002constructor 1\u306e1\u306f\u7701\u304f\u3053\u3068\u304c\u3067\u304d\u308b\u3002\n  (2) \u63a8\u8ad6\u898f\u5247\u306b\u5bfe\u5fdc\u3057\u305f\u6226\u7565(\u307e\u305f\u306fdestruct)\u3092\u4f7f\u3046\u4f8b\u3002\n*)\n\n\nParameters P Q R : Prop.\n\n\n(************************)\n(* And                  *)\n(************************)\nPrint and.\n\n\nTheorem goal_and : P -> Q -> P /\\ Q.\n  intros H1 H2.\n  (* Goal : P/\\Q *)\n  apply conj.                               (* constructor. *) (* split. *) \n  apply H1.\n  apply H2.\nQed.\n\n\nTheorem hypothese_and : P /\\ Q -> P.\n  intros.\n  (* H : P/\\Q *)\n  case H.\n  intros H1 H2.\n  apply H1.\nQed.\n\n\nTheorem hypothese_and2 : P /\\ Q -> P.\n  intros.\n  (* H : P/\\Q *)\n  destruct H as [ H1 H2 ].\n  apply H1.\nQed.\n\n\n(************************)\n(* Or                   *)\n(************************)\nPrint or.\n\n\nTheorem goal_or : Q -> P \\/ Q \\/ R.\n  intros H.\n  (* Goal : P\\/Q\\/R *)\n  apply or_intror.                          (* constructor 2. *) (* right. *)\n  (* Goal : Q\\/R *)\n  apply or_introl.                          (* constructor 1. *) (* left *)\n  (* Goal : Q *)\n  apply H.\nQed.\n\n\nTheorem hypothese_or : P \\/ Q -> (P -> R) -> (Q -> R) -> R.\n  intros H1 H2 H3.\n  (* H1 : P\\/Q *)\n  case H1.\n  (* Subgoal 1 : P-> R,  Subgoal 2 : Q->R *)\n  intros HA.\n  apply (H2 HA).                            (* apply H2. apply HA. *)\n\n\n  intros HB.\n  apply (H3 HB).\nQed.\n\n\nTheorem hypothese_or2 : P \\/ Q -> (P -> R) -> (Q -> R) -> R.\n  intros H1 H2 H3.\n  (* H1 : P\\/Q *)\n  destruct H1 as [ HA | HB ].\n  apply (H2 HA).\n  apply (H3 HB).\nQed.\n\n\n(************************)\n(* Ex                   *)\n(************************)\n\n\nPrint ex.\n\n\nTheorem goal_exists : exists n : nat, n = 0.\n  apply ex_intro with 0.                    (* constructor 1 with 0. *) (* exists 0. *)\n  reflexivity.                              (* goal_eq \u3092\u53c2\u7167\u306e\u3053\u3068\u3002 *)\nQed.\n\n\nTheorem hypothese_exists : forall P : nat -> Prop,\n  (exists n : nat, ~ P n) -> ~ (forall n : nat, P n).",
      "suffix": "\n\n\nTheorem hypothese_exists2 : forall P : nat -> Prop,\n  (exists n : nat, ~ P n) -> ~ (forall n : nat, P n).\n  intros p H1 H2.\n  \n  destruct H1 as [ n H3 ].\n  \n  apply H3.\n  apply H2.\nQed.\n\n\n(************************)\n(* Eq                   *)\n(* \u7b49\u5f0f\u8ad6\u7406\u306f\u3001\u65b0\u305f\u306b\u9805\u76ee\u3092\u7acb\u3066\u308b *)\n(************************)\nPrint eq.\n\n\nTheorem goal_eq : forall m n, m = n -> S m = S n.\n  intros m n H.\n  (* Goal : Sm = Sn\u3001H :  m=n *)\n  case H.                                   (* hypothese_eq\u53c2\u7167  *)\n  \n  (* Goal : Sm = Sm *)\n  apply refl_equal.                         (* constructor *) (* reflexivity. *) \nQed.\n\n\n(************************)\n(* True                 *)\n(************************)\nPrint True.\n\n\nTheorem goal_true : True.\n  (* Goal True *)\n  apply I.                                  (* trivial. *) (* constructor. *)\n  (* \u5f15\u6570\u3092\u53d6\u3089\u306a\u3044\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bfI\u3092\u9069\u7528\u3059\u308b\u3002 *)\nQed.\n(* \u524d\u63d0\u306bTure\u304c\u3042\u3063\u3066\u3082\u3001\u5f79\u306b\u7acb\u305f\u306a\u3044 *)\n\n\n(************************)\n(* False                *)\n(************************)\nPrint False.\n\n\n(* \u30b4\u30fc\u30eb\u306eFalse\u306f\u3001\u8a3c\u660e\u3067\u304d\u306a\u3044\u3002*)\nTheorem hypothese_false : False -> True.\n  intro.\n  case H.\n  (* \u5834\u5408\u5206\u3051\u3092\u3059\u308b\u3068\u3001\u76f4\u3061\u306b\u8a3c\u660e\u304c\u7d42\u4e86\u3059\u308b *)\nQed.\n\n\n(* END *)",
      "theorem": "Theorem hypothese_exists : forall P : nat -> Prop,\n  (exists n : nat, ~ P n) -> ~ (forall n : nat, P n).",
      "ground_truth": "intros p H1 H2.\n  \n  case H1.\n  intros n H3.\n  \n  apply H3.\n  apply H2.\nQed."
    },
    {
      "split": "train-sft",
      "index": 22,
      "prefix": "(** Miscellaneous extensions of \"Coq\" standard library *)\n\nRequire List.\nRequire Import Sorting.Permutation.\nImport List.ListNotations.\nLocal Open Scope list_scope.\n\n(** A \"fixpoint\" variant of \"List.Forall\" (in the style of \"List.In\") *)\nFixpoint Forall {A} (P: A -> Prop) (l: list A) : Prop :=\n  match l with\n  | [] => True\n  | x::l' => P x /\\ Forall P l'\n  end.\n\nLemma Forall_monotone {A} (l: list A) (P Q: A -> Prop):\n  Forall P l -> (forall x, P x -> Q x) -> Forall Q l.\nProof.\n  induction l; simpl; intuition.\nQed.\n\nLemma Forall_ListForall  {A} (l: list A) (P: A -> Prop):\n  Forall P l <-> List.Forall P l.\nProof.\n  constructor 1.\n    - induction l; simpl; intuition.\n    - induction 1; simpl; intuition.\nQed.\n\nLemma Forall_ListForIn  {A} (l: list A) (P: A -> Prop):\n  Forall P l <-> (forall x, List.In x l -> P x).\nProof.\n  induction l; simpl; intuition (subst; auto).\nQed.\n\nLemma Forall_cons {A} (x : A) (l : list A) (P: A -> Prop): P x -> Forall P l -> Forall P (x :: l).\nProof.\n  simpl; intuition.\nQed.\n\nLemma Forall_app {A} (l1 l2 : list A) (P: A -> Prop): Forall P l1 -> Forall P l2 -> Forall P (l1 ++ l2).\nProof.\n  induction l1; simpl; intuition auto.\nQed.\nHint Resolve Forall_app.\n\nLemma Forall_Forall_cons {A} l1: forall a (P: A -> A -> Prop) (l2: list A),\n   Forall (fun x => P x a) l1 -> Forall (fun x => Forall (P x) l2) l1 -> Forall (fun x => Forall (P x) (a::l2)) l1.\nProof.\n  simpl; induction l1; simpl; intuition auto.\nQed.\n\n\n\nSection FilterProp.\n\nVariable A : Type.\nVariable f : A -> bool.\n\nLemma Forall_negb_true_false (l: list A):\n  Forall (fun x => negb (f x) = true) l -> Forall (fun x => (f x)=false) l.\nProof.\n  intros; eapply Forall_monotone; eauto.\n  simpl; intros x; case (f x); simpl; auto.\nQed.\n\nLemma Forall_false_negb_true (l: list A):\n  Forall (fun x => (f x)=false) l -> Forall (fun x => negb (f x) = true) l.\nProof.\n  intros; eapply Forall_monotone; eauto.\n  simpl; intros x; case (f x); simpl; auto.\nQed.\n\nLemma filter_app l1 l2: List.filter f (l1++l2) = (List.filter f l1) ++ (List.filter f l2).\nProof.  \n  induction l1; simpl; auto.\n  destruct (f a); simpl; congruence.\nQed.\n\nLemma filter_triv_true l: (Forall (fun x => f x = true) l) -> List.filter f l = l.\nProof.\n  induction l; simpl; intuition auto.\n  rewrite H0; simpl; congruence.\nQed.\n\nLemma filter_triv_false l: (Forall (fun x => f x = false) l) -> List.filter f l = [].\nProof.\n  induction l; simpl; intuition auto.\n  rewrite H0; simpl; congruence.\nQed.\n\nLemma filter_empty_false l: List.filter f l = [] -> (Forall (fun x => f x = false) l).\nProof.\n  induction l; simpl; auto.\n  case (f a); simpl; intuition discriminate.\nQed.\n\n\nLocal Hint Constructors Permutation.\nLocal Hint Resolve Permutation_sym Permutation_middle.\nLemma filter_split l: Permutation ((List.filter f l)++(List.filter (fun x => negb (f x)) l)) l.\nProof.\n  induction l; simpl; auto.\n  destruct (f a); simpl; auto.\n  apply Permutation_sym.\n  eapply Permutation_trans. \n  2: eauto.\n  auto.\nQed.\n\nEnd FilterProp.\n\n\n\n(** Additional lemmas on Q *)\nRequire NArith.\nRequire ZArith.\nRequire QArith.\nRequire Qcanon.\nRequire BinInt.\n\nModule Q.\n  Import NArith.\n  Import ZArith.\n  Import QArith.\n  Import Z.\n(* XXX: The proofs in this module are ugly. *)\n\n  Lemma PZMul: forall n1 n2 n3: positive, Zmult (Zpos n1) (Zpos (Pmult n2 n3)) = Zmult (Zpos (Pmult n1 n2)) (Zpos n3).\n    intros n1 n2 n3; unfold Zmult; rewrite Pmult_assoc; trivial.\n  Qed.\n\n  Lemma Qplus_lt_compat: forall n1 n2 n3 n4: Q, Qlt n1 n2 -> Qlt n3 n4 -> Qlt (Qplus n1 n3) (Qplus n2 n4).",
      "suffix": "\n\n  Lemma Qplus_eqlt_compat: forall n1 n2 n3 n4: Q, n1 = n2 -> Qlt n3 n4 -> Qlt (Qplus n1 n3) (Qplus n2 n4).\n    intros [n1 d1] [n2 d2] [n3 d3] [n4 d4] h1.\n    rewrite h1.\n    unfold Qlt, Qplus.\n    simpl.\n    intro h2.\n    repeat ring_simplify.\n    rewrite <- (Zmult_assoc n2 (Zpos d3) (Zpos (Pmult d2 d4))), <- (Zmult_assoc n2 (Zpos d4) (Zpos (Pmult d2 d3))).\n    rewrite (Pmult_comm d2 d4), (Pmult_comm d2 d3).\n    rewrite (PZMul d3 d4 d2), (PZMul d4 d3 d2).\n    rewrite (Pmult_comm d4 d3).\n    apply Zplus_lt_compat_l.\n    rewrite (Zmult_comm (Zpos (Pmult d4 d2)) n3).\n    rewrite <- Zmult_assoc.\n    rewrite <- (PZMul d4 d2 d2).\n    rewrite Zmult_assoc.\n    rewrite (Pmult_comm d3 d2).\n    rewrite (PZMul d2 d2 d3).\n    rewrite <- (Zmult_assoc (Zpos (Pmult d2 d2)) (Zpos d3) n4).\n    rewrite (Zmult_comm (Zpos (Pmult d2 d2)) (Zmult (Zpos d3) n4)).\n    rewrite (Zmult_comm (Zpos d3) n4).\n    apply Zmult_lt_compat_r;\n    [ apply gt_lt_iff; apply Zgt_pos_0 | assumption ].\n  Qed.\n\nEnd Q.\n\nModule Qc.\n  Import QArith.\n  Import Qcanon.\n\n  Lemma Qcplus_lt_compat: forall n1 n2 n3 n4: Qc,\n      Qclt n1 n2 -> Qclt n3 n4 -> Qclt (Qcplus n1 n3) (Qcplus n2 n4).\n    unfold Qcplus, Qclt, Q2Qc, this.\n    intros [n1 nP1] [n2 nP2] [n3 nP3] [n4 nP4] h1 h2.\n    repeat rewrite Qred_correct.\n    apply Q.Qplus_lt_compat; assumption.\n  Qed.\n\n  Lemma Qcplus_eqlt_compat: forall n1 n2 n3 n4: Qc,\n      n1 = n2 -> Qclt n3 n4 -> Qclt (Qcplus n1 n3) (Qcplus n2 n4).\n    intros [n1 nP1] [n2 nP2] [n3 nP3] [n4 nP4] h1; rewrite h1.\n    unfold Qcplus, Qclt, Q2Qc, this.\n    repeat rewrite Qred_correct.\n    apply Q.Qplus_eqlt_compat; trivial.\n  Qed.\n\n  Lemma Qcopp_lt_compat1: forall n1 n2: Qc,\n                           Qclt n1 n2 -> Qclt (Qcopp n2) (Qcopp n1).\n    intros n1 n2 h.\n    apply (Qcplus_eqlt_compat (Qcopp n2) (Qcopp n2) n1 n2 eq_refl) in h.\n    apply (Qcplus_eqlt_compat (Qcopp n1) (Qcopp n1) _ _ eq_refl) in h.\n    rewrite (Qcplus_comm (Qcopp n2) n1) in h.\n    rewrite (Qcplus_assoc (Qcopp n1) n1 (Qcopp n2)) in h.\n    rewrite (Qcplus_comm (Qcopp n1) n1) in h.\n    rewrite (Qcplus_comm (Qcopp n2) n2) in h.\n    repeat rewrite Qcplus_opp_r in h.\n    rewrite Qcplus_0_l, Qcplus_0_r in h.\n    exact h.\n  Qed.\n\n  Lemma Qcopp_lt_compat2: forall n1 n2: Qc,\n                            Qclt (Qcopp n1) (Qcopp n2) -> Qclt n2 n1.\n    intros n1 n2 h.\n    apply Qcopp_lt_compat1 in h.\n    repeat rewrite Qcopp_involutive in h.\n    exact h.\n  Qed.\n\n  Lemma Qcopp_lt_compat: forall n1 n2: Qc,\n                           Qclt n1 n2 <-> Qclt (Qcopp n2) (Qcopp n1).\n    exact (fun n1 n2 => conj (Qcopp_lt_compat1 n1 n2) (Qcopp_lt_compat2 n2 n1)).\n  Qed.\n\n  Lemma QcQLt: forall q1 q2: Q, Qlt q1 q2 <-> Qclt (Q2Qc q1) (Q2Qc q2).\n    intros q1 q2.\n    split;\n      intro h.\n    - apply Qclt_alt.\n      unfold Qccompare.\n      simpl.\n      rewrite <- Qred_compare.\n      assumption.\n    - apply (proj1 (Qclt_alt _ _)) in h.\n      unfold Qccompare in h.\n      simpl in h.\n      rewrite <- Qred_compare in h.\n      assumption.\n  Qed.\n\nEnd Qc.\n\nRequire BinNums.\nRequire String.\nAxiom posPr: BinNums.positive -> String.string.\nAxiom posPrRaw: BinNums.positive -> String.string.\nAxiom zPr: BinNums.Z -> String.string.\nAxiom zPrRaw: BinNums.Z -> String.string.\n\nRequire List.\nImport Ascii String.\nLocal Open Scope string_scope.\n\n(** New line *)\nDefinition nl: string := String (ascii_of_nat 10%nat) EmptyString.\n\n(** Append one character at the end of a string.\nThis is really not an efficient way to build a string,\nbuild this will do for now. *)\nDefinition append1: string -> ascii -> string\n  := fun s c => append s (String c EmptyString).\n\n(** Concatenate the elements of a list of strings, separating each\npair of elements by [sep]. *)\nFixpoint concat (sep: string) (l: list string): string\n  := match l with\n       | nil => EmptyString\n       | cons h1 l1 =>\n         match l1 with\n           | nil => h1\n           | cons h2 l2 => h1 ++ sep ++ (concat sep l1)\n         end\n     end.\n\nDefinition substStr: string -> list string -> string\n  := fun s l =>\n       match l with\n         | List.nil => append s \"[missing arg]\"\n         | List.cons h _ => append s h\n       end.\n\nFixpoint sprintfAux (s: string): list string -> string -> string\n  := fun l acc =>\n       match s with\n         | EmptyString => acc\n         | String c s1 =>\n           match ascii_dec \"%\"%char c with\n             | left _ =>\n               match s1 with\n                 | EmptyString => append acc \"[bad %_]\"\n                 | String c' s2 =>\n                   match ascii_dec \"s\"%char c' with\n                     | left _ => sprintfAux s2 (List.tl l) (substStr acc l)\n                     | right _ =>\n                   match ascii_dec \"%\"%char c' with\n                     | left _ => sprintfAux s2 l (append1 acc c')\n                     | right _ => sprintfAux s2 l (append acc \"[bad %_]\")\n                   end\n                   end\n               end\n             | right _ =>\n           match ascii_dec \"\\\"%char c with\n             | left _ =>\n               match s1 with\n                 | EmptyString => append acc \"[bad \\_]\"\n                 | String c' s2 =>\n                   match ascii_dec \"n\"%char c' with\n                     | left _ => sprintfAux s2 l (append acc nl)\n                     | right _ =>\n                   match ascii_dec \"\\\"%char c' with\n                     | left _ => sprintfAux s2 l (append1 acc c')\n                     | right _ => sprintfAux s2 l (append acc \"[bad \\_]\")\n                   end\n                   end\n               end\n             | right _ => sprintfAux s1 l (append1 acc c)\n           end\n           end\n       end.\n\n(** Poor man's implementation of [sprintf].\nIt only recognizes only [\"%s\"] and [\"%%\"] specifications.\nFor [\"%s\"] specification, a corresponding parameter is looked\nup in the [list string] argument. [\"\\n\"] substrings are replaced\nby new line charaters. Use [\"\\\\\"] to output a backslash.\nInvalid arguments (e.g. bad specifications or wrong number \nof string arguments) lead to inline errors in the output string. *)\nDefinition sprintf: string -> list string -> string\n  := fun s l => sprintfAux s l EmptyString.\n",
      "theorem": "Lemma Qplus_lt_compat: forall n1 n2 n3 n4: Q, Qlt n1 n2 -> Qlt n3 n4 -> Qlt (Qplus n1 n3) (Qplus n2 n4).",
      "ground_truth": "unfold Qlt, Qplus.\n    intros [n1 d1] [n2 d2] [n3 d3] [n4 d4].\n    simpl.\n    intros h1 h2.\n    repeat ring_simplify.\n    apply Zplus_lt_compat.\n\n    rewrite (Pmult_comm d2 d4), (Pmult_comm d1 d3).\n    repeat rewrite <- Zmult_assoc.\n    rewrite (PZMul d3 d4 d2), (PZMul d4 d3 d1).\n    rewrite (Zmult_comm (Zpos (Pmult d3 d4)) (Zpos d2)). \n    rewrite (Zmult_comm (Zpos (Pmult d4 d3)) (Zpos d1)).\n    repeat rewrite Zmult_assoc.\n    rewrite (Pmult_comm d4 d3).\n    apply Zmult_lt_compat_r;\n      [ apply gt_lt_iff; apply Zgt_pos_0 | assumption ].\n\n    rewrite (Pmult_comm d2 d4), (Pmult_comm d1 d3).\n    rewrite (Zmult_comm (Zpos (Pmult d4 d2)) n3), (Zmult_comm (Zpos (Pmult d3 d1)) n4).\n    repeat rewrite <- Zmult_assoc.\n    repeat rewrite <- PZMul.\n    repeat rewrite Zmult_assoc.\n    rewrite (Pmult_comm d2 d1).\n    apply Zmult_lt_compat_r;\n    [ apply gt_lt_iff; apply Zgt_pos_0 | assumption ].\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 23,
      "prefix": "(* https://coq.github.io/doc/master/stdlib/Coq.Unicode.Utf8_core.html *)\nRequire Import Unicode.Utf8_core.\n\nInductive day : Type :=\n  | monday : day\n  | tuesday : day\n  | wednesday : day\n  | thursday : day\n  | friday : day\n  | saturday : day\n  | sunday : day.\n\nInductive month: Type :=\n  | Jan : month.\n\nDefinition next_weekday (d: day): day :=\n  match d with\n  | monday => tuesday\n  | tuesday => wednesday\n  | wednesday => thursday\n  | thursday => friday\n  | friday => monday\n  | saturday => monday\n  | sunday => monday\n  end.\n\nCompute next_weekday monday.\nEval simpl in (next_weekday friday).\nEval simpl in (next_weekday (next_weekday saturday)).\n\nExample test_next_weekday:\n  (next_weekday (next_weekday saturday)) = tuesday.\nProof.\n  simpl. reflexivity.\nQed.\n\nInductive bool: Type :=\n  | true  : bool\n  | false : bool.\n\n\nDefinition negb (b:bool): bool :=\n  match b with\n  | true => false\n  | false => true\n  end.\n\n\nDefinition andb (b1 b2 : bool) : bool :=\n  match b1 with\n  | true  => b2\n  | false => false\n  end.\n\nDefinition orb (b1 b2 : bool) : bool :=\n  match b1 with\n  | true => true\n  | false => b2\n  end.\n\nExample test_orb1: (orb true false) = true.\nProof. simpl. reflexivity. Qed.\n\nExample test_orb2: (orb false false) = false.\nProof. simpl. reflexivity. Qed.\n\nExample test_orb3: (orb false true) = true.\nProof. simpl. reflexivity. Qed.\n\nExample test_orb4: (orb true false) = true.\nProof. simpl. reflexivity. Qed.\n\n\nDefinition admit {T: Type} : T. Admitted.\nCheck admit.\n\nDefinition nandb (b1 b2: bool) : bool :=\n  admit.\n\nExample test_nandb1: (nandb true false) = true.\nAdmitted.\nExample test_nandb2: (nandb false false) = true.\nAdmitted.\nExample test_nandb3: (nandb false true) = true.\nAdmitted.\nExample test_nandb4: (nandb true true) = false.\nAdmitted.\n\n\nDefinition andb3 (b1:bool) (b2:bool) (b3:bool) : bool :=\n   admit.\n\nExample test_andb31: (andb3 true true true) = true.\nAdmitted.\nExample test_andb32: (andb3 false true true) = false.\nAdmitted.\nExample test_andb33: (andb3 true false true) = false.\nAdmitted.\nExample test_andb34: (andb3 true true false) = false.\nAdmitted.\n\n\n(* Check\u3067\u578b\u3092\u78ba\u8a8d *)\n\nCheck (negb true).\nCheck negb.\nCheck admit.\n\n\nModule Playground1.\n\nInductive nat: Type :=\n  | O : nat\n  | S : nat -> nat.\n\nEnd Playground1.\n\nDefinition minustwo (n: nat): nat :=\n  match n with\n  | O => O\n  | S O => O\n  | S (S n') => n'\n  end.\n\n\nCheck S (S (S (S O))).\nEval simpl in (minustwo 4).\n\nCheck S.\nCheck pred.\nCheck minustwo.\n\n\nFixpoint evenb (n: nat): bool :=\n  match n with\n  | O => true\n  | S O => false\n  | S (S n') => evenb n'\n  end.\n\n\n(* Definition oddb (n: nat): nat := negb (evenb n). *)\n(* \u578b\u63a8\u8ad6\u3059\u3052\u30fc *)\nDefinition oddb n := negb (evenb n).\n\nExample test_oddb1: (oddb (S O)) = true.\nProof. simpl. reflexivity. Qed.\nExample test_oddb2: (oddb (S (S (S (S O))))) = false.\nProof. simpl. reflexivity. Qed.\n\n\nModule Playground2.\nFixpoint plus n m : nat :=\n  match n with\n  | O => m\n  | S n' => S (plus n' m)\n  end.\nEval simpl in (plus (S (S (S O))) (S (S O))).\n\nCheck plus.\n\nFixpoint mult n m : nat :=\n  match n with\n  | O => O\n  | S n' => plus m (mult n' m)\n  end.\n\n\nFixpoint minus n m : nat :=\n  match n, m with\n  | O, _ => O\n  | S _, O => n\n  | S n', S m' => minus n' m'\n  end.\n\nEnd Playground2.\n\nFixpoint exp (base power : nat) : nat :=\n  match power with\n  | O => S O\n  | S p => mult base (exp base p)\n  end.\n\nExample test_mult1: mult 3 3 = 9.\nProof. simpl. reflexivity. Qed.\n\nFixpoint factorial (n:nat) : nat :=\n  match n with\n  | O => S O\n  | S n' => mult n (factorial n')\n  end.\n\nExample test_factorial1: (factorial 3) = 6.\nProof. auto. Qed.\nExample test_factorial2: (factorial 5) = (mult 10 12).\nProof. auto. Qed.\n\n\nNotation \"x + y\" := (plus x y) (at level 50, left associativity) : nat_scope.\nNotation \"x - y\" := (minus x y) (at level 50, left associativity) : nat_scope.\nNotation \"x * y\" := (mult x y) (at level 40, left associativity) : nat_scope.\n\nCheck ((0 + 1) + 1).\nCheck Type.\nCheck nat.\nCheck Set.\n\nCompute (nat*nat)%type.\n\nFixpoint beq_nat (n m : nat) : bool :=\n  match n with\n  | O => match m with\n         | O => true\n         | S m' => false\n         end\n  | S n' => match m with\n            | O => false\n            | S m' => beq_nat n' m'\n            end\n  end.\n\nFixpoint ble_nat (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => ble_nat n' m'\n      end\n  end.\n\nExample test_ble_nat1: (ble_nat 2 2) = true.\nProof. simpl. reflexivity. Qed.\nExample test_ble_nat2: (ble_nat 2 4) = true.\nProof. simpl. reflexivity. Qed.\nExample test_ble_nat3: (ble_nat 4 2) = false.\nProof. simpl. reflexivity. Qed.\n\n\nFixpoint blt_nat (n m : nat) : bool :=\n  match n with\n  | O =>\n    match m with\n    | O => false\n    | _ => true\n    end\n  | S n' =>\n    match m with\n    | O => false\n    | S m' => blt_nat n' m'\n    end\n  end.\n\nExample test_blt_nat1: (blt_nat 2 2) = false.\nProof. auto. Qed.\nExample test_blt_nat2: (blt_nat 2 4) = true.\nProof. auto. Qed.\nExample test_blt_nat3: (blt_nat 4 2) = false.\nProof. auto. Qed.\n\nTheorem plus_O_n' : forall n:nat, 0 + n = n.\nProof.\n  reflexivity. Qed.\n\nEval simpl in (forall n:nat, n + 0 = n).\nEval simpl in (forall n:nat, 0 + n = n).\n\nTheorem plus_O_n'' : forall n:nat, 0 + n = n.\nProof.\n  intros n. reflexivity. Qed.\n\nTheorem plus_1_l : forall n:nat, 1 + n = S n.\nProof.\n  intros n.\n  Info 3 reflexivity. Qed.\n\nTheorem mult_0_l : forall n:nat, 0 * n = 0.\nProof.\n  intros n. reflexivity. Qed.\n\nTheorem plus_id_example: forall n m : nat,\n  n = m -> n + n = m + m.\nProof.\n  intros n m.\n  intros H.\n  rewrite -> H.\n  reflexivity.\nQed.\n\n\n(* \u7df4\u7fd2\u554f\u984c x *)\nTheorem plus_id_exercise : \u2200 n m o : nat,\n  n = m \u2192 m = o \u2192 n + m = m + o.\nProof.\n  intros.\n  rewrite H.\n  rewrite H0.\n  reflexivity.\nQed.\n\nTheorem mult_0_plus : \u2200 n m : nat,\n  (0 + n) * m = n * m.\nProof.\n  intros n m.\n  rewrite -> plus_O_n.\n  reflexivity. Qed.\n\n(* \u7df4\u7fd2\u554f\u984c xx *)\nTheorem mult_1_plus : \u2200 n m : nat,\n  (1 + n) * m = m + (n * m).\nProof.\n  intros.\n  simpl.\n  reflexivity.\nQed.\n\nTheorem plus_1_neq_0 : \u2200 n : nat,\n  beq_nat (n + 1) 0 = false.\nProof.\n  intros n. simpl.\n(*   destruct n as [| n']. *) (* as \u3044\u3089\u306a\u3055\u305d\u3046\u3060\u3088\u306d *)\n  destruct n.\n  simpl. reflexivity.\n  simpl.\n(*\n\u306a\u305c beq_nat (plus n (S 0)) 0 \u3060\u3068\u7c21\u7d04\u5316\u3067\u304d\u306a\u304f\u3066\uff0c\nbeq_nat (plus (S n) (S 0)) 0 \u3060\u3068\u7c21\u7d04\u5316\u3067\u304d\u305f\u306e\u304b\uff0e\nS \u3060\u3068\u308f\u304b\u3063\u3066\u3044\u308b\u304b\u3089\uff0c\nS (plus S n (S 0)) \u3078\u3068 simplify \u3055\u308c\u307e\u3059\nbeq_nat \u306e match \u306b\u3072\u3063\u304b\u304b\u308a\u307e\u3059\uff0c\u3063\u3066\u304b\u3093\u3058\u304b\n*)\nreflexivity.\nQed.\n\nTheorem negb_involutive : \u2200 b : bool,\n  negb (negb b) = b.\nProof.\n  intros b. destruct b.\n    reflexivity.\n    reflexivity. Qed.\n\n\nTheorem zero_nbeq_plus_1 : \u2200 n : nat,\n  beq_nat 0 (n + 1) = false.\nProof.\n  intros.\n  simpl.\n  destruct n.\n  reflexivity.\n  reflexivity.\nQed.\n\n\nRequire String. Open Scope string_scope.\n\nLtac move_to_top x :=\n  match reverse goal with\n  | H : _ |- _ => try move x after H\n  end.\n\nTactic Notation \"assert_eq\" ident(x) constr(v) :=\n  let H := fresh in\n  assert (x = v) as H by reflexivity;\n  clear H.\n\nTactic Notation \"Case_aux\" ident(x) constr(name) :=\n  first [\n    set (x := name); move_to_top x\n  | assert_eq x name; move_to_top x\n  | fail 1 \"because we are working on a different case\" ].\n\nTactic Notation \"Case\" constr(name) := Case_aux Case name.\nTactic Notation \"SCase\" constr(name) := Case_aux SCase name.\nTactic Notation \"SSCase\" constr(name) := Case_aux SSCase name.\nTactic Notation \"SSSCase\" constr(name) := Case_aux SSSCase name.\nTactic Notation \"SSSSCase\" constr(name) := Case_aux SSSSCase name.\nTactic Notation \"SSSSSCase\" constr(name) := Case_aux SSSSSCase name.\nTactic Notation \"SSSSSSCase\" constr(name) := Case_aux SSSSSSCase name.\nTactic Notation \"SSSSSSSCase\" constr(name) := Case_aux SSSSSSSCase name.\n\nTheorem andb_true_elim1 : \u2200 b c : bool,\n  andb b c = true \u2192 b = true.\nProof.\n  intros b c H.\n  destruct b.\n  - (* b = fales *)\n    reflexivity.\n  - (* b = false *)\n    rewrite <- H.\n    simpl. reflexivity. Qed.\n\n(* TODO : \u3046\uff0c Case \u306a\u3093\u304b\u4f7f\u3048\u306a\u3044 *)\n\nTheorem andb_true_elim2 : \u2200 b c : bool,\n  andb b c = true \u2192 c = true.\nProof.\n  intros.\n  destruct c.\n  - (* c = true *)\n  reflexivity.\n  - (* c = false *)\n  rewrite <- H.\n  destruct b.\n  -- (* b = true *)\n  simpl. reflexivity.\n  -- (* b = false *)\n  simpl. reflexivity.\nQed.\n\n\n\nTheorem plus_0_r: \u2200 n:nat,\n  n + 0 = n.\nProof.\n  intros n. induction n as [| n'].\n  -\n  simpl. reflexivity.\n  -\n  simpl. rewrite IHn'. reflexivity.\nQed.\n\nTheorem minus_diag : \u2200 n,\n  minus n n = 0.\nProof.\n  intros n. induction n as [| n'].\n  -\n    simpl. reflexivity.\n  -\n    simpl. rewrite -> IHn'. reflexivity. Qed.\n\n(* \u7df4\u7fd2\u554f\u984c xx -- *)\nTheorem mult_0_r : \u2200 n:nat,\n  n * 0 = 0.\nProof.\n  intros. induction n.\n  -\n  reflexivity.\n  -\n  Print Nat.mul.\n  simpl. trivial.\nQed.\n\nTheorem plus_n_Sm : \u2200 n m : nat,\n  S (n + m) = n + (S m).\nProof.\n  intros.\n  induction n.\n  - auto.\n  - auto.\nQed.\n\nTheorem plus_comm : \u2200 n m : nat,\n  n + m = m + n.\nProof.\n  intros.\n  induction n.\n  -\n    auto.\n  -\n    simpl. rewrite IHn.\n    induction m.\n    --\n      auto.\n    --\n      auto.\nQed.\n(* -- *)\n\n\nFixpoint double (n:nat) :=\n  match n with\n  | O => O\n  | S n' => S (S (double n'))\n  end.\n\n(* \u7df4\u7fd2\u554f\u984c xx *)\nLemma double_plus : \u2200 n, double n = n + n .\nProof.\n  intros.\n  induction n.\n  -\n    trivial.\n  -\n    simpl. rewrite IHn.\n    Print plus_comm.\n    specialize (plus_comm n (S n)).\n    intro. rewrite H. simpl.\n    reflexivity.\nQed.\n\n(*\n\u7df4\u7fd2\u554f\u984c: \u2605 (destruct_induction)\ndestruct\u3068induction\u306e\u9055\u3044\u3092\u77ed\u304f\u8aac\u660e\u3057\u306a\u3055\u3044\u3002\n*)\n\n(*\n\n\u5834\u5408\u5206\u3051\u3068\u5e30\u7d0d\u6cd5 ?\n\ndestruct x.\n\u306f\uff0c x : A \u3060\u3068\u3057\u305f\u3089\uff0c\nInductive A :=\n  | \u306a\u3093\u3068\u304b1 : A\n  | \u306a\u3093\u3068\u304b2 : A.\n\n\u307f\u305f\u3044\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u3082\u306e\u306b\u3064\u3044\u3066\uff0c\u3069\u306e\u5b9a\u7fa9\u306e\u5f62\u3092\u3057\u3066\u3044\u308b\u304b\uff0c\u3092\u5206\u3051\u308b\uff0e\n\n\ninduction x.\n\u306f\uff0c x : A \u3060\u3068\u3057\u305f\u3089\uff0c\n\nInductive A :=\n  | O : A\n  | S O : A -> A.\n\n\u307f\u305f\u3044\u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u3068\u3057\u305f\u3089\uff0c\n\u3082\u3068\u306e\u30b4\u30fc\u30eb\u304c forall x:A, P x.\n\u3060\u3068\u3057\u305f\u3089\uff0c\nP 0 /\\ (forall n:A, P n -> P (S n)) \u3092\u5c0e\u51fa\u3057\u3066\uff0c\u3082\u3068\u306e\u30b4\u30fc\u30eb\u3092\u793a\u3059\uff0e\n\n\n*)\n\n(* CoqIDE \u304a\u3061\u3066\u30c7\u30fc\u30bf\u5c11\u3057\u98db\u3093\u3060\uff0c\u3044\u3044\u3084 *)\n\n\nTheorem plus_assoc : forall n m p : nat,\n  (n + m) + p = n + (m + p).\nProof.\n  intros.\n  induction n.\n  trivial.\n  simpl.\n  rewrite IHn.\n  reflexivity.\nQed.\n\n\nTheorem plus_swap' : \u2200 n m p : nat,\n  n + (m + p) = m + (n + p).\nProof.\n  intros n m p.\n  rewrite <- plus_assoc.\n  rewrite <- plus_assoc.\n  Admitted.\n\n\n(*\n\u7df4\u7fd2\u554f\u984c: \u2605\u2605\u2605\u2605\u2605 (binary_inverse)\n\u3053\u306e\u7df4\u7fd2\u554f\u984c\u306f\u524d\u306e\u554f\u984c\u306e\u7d9a\u304d\u3067\u30012\u9032\u6570\u306b\u95a2\u3059\u308b\u3082\u306e\u3067\u3042\u308b\u3002\u524d\u306e\u554f\u984c\u3067\u4f5c\u6210\u3055\u308c\u305f\u5b9a\u7fa9\u3084\u5b9a\u7406\u3092\u3053\u3053\u3067\u7528\u3044\u3066\u3082\u3088\u3044\u3002\n\n(a) \u307e\u305a\u81ea\u7136\u6570\u30922\u9032\u6570\u306b\u5909\u63db\u3059\u308b\u95a2\u6570\u3092\u66f8\u304d\u306a\u3055\u3044\u3002\u305d\u3057\u3066\u300c\u4efb\u610f\u306e\u81ea\u7136\u6570\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u3057\u3001\u305d\u308c\u30922\u9032\u6570\u306b\u30b3\u30f3\u30d0\u30fc\u30c8\u3057\u3001\u305d\u308c\u3092\u3055\u3089\u306b\u81ea\u7136\u6570\u306b\u30b3\u30f3\u30d0\u30fc\u30c8\u3059\u308b\u3068\u3001\u30b9\u30bf\u30fc\u30c8\u6642\u306e\u81ea\u7136\u6570\u306b\u623b\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u306a\u3055\u3044\u3002\n\n(b) \u3042\u306a\u305f\u306f\u304d\u3063\u3068\u3001\u9006\u65b9\u5411\u306b\u3064\u3044\u3066\u306e\u8a3c\u660e\u3092\u3057\u305f\u307b\u3046\u304c\u3044\u3044\u306e\u3067\u306f\u3001\u3068\u8003\u3048\u3066\u3044\u308b\u3067\u3057\u3087\u3046\u3002\u305d\u308c\u306f\u3001\u4efb\u610f\u306e2\u9032\u6570\u304b\u3089\u59cb\u307e\u308a\u3001\u305d\u308c\u3092\u81ea\u7136\u6570\u306b\u30b3\u30f3\u30d0\u30fc\u30c8\u3057\u3066\u304b\u3089\u3001\u307e\u305f2\u9032\u6570\u306b\u30b3\u30f3\u30d0\u30fc\u30c8\u3057\u76f4\u3057\u305f\u3082\u306e\u304c\u3001\u5143\u306e\u81ea\u7136\u6570\u3068\u4e00\u81f4\u3059\u308b\u3001\u3068\u3044\u3046\u8a3c\u660e\u3067\u3059\u3002\u3057\u304b\u3057\u306a\u304c\u3089\u3001\u3053\u306e\u7d50\u679c\u306ftrue\u306b\u306f\u306a\u308a\u307e\u305b\u3093\u3002\uff01\uff01\u305d\u306e\u539f\u56e0\u3092\u8aac\u660e\u3057\u306a\u3055\u3044\u3002\n\n(c) 2\u9032\u6570\u3092\u5f15\u6570\u3068\u3057\u3066\u53d6\u308a\u3001\u305d\u308c\u3092\u4e00\u5ea6\u81ea\u7136\u6570\u306b\u5909\u63db\u3057\u305f\u5f8c\u3001\u307e\u305f2\u9032\u6570\u306b\u5909\u63db\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059normalize\u95a2\u6570\u3092\u4f5c\u6210\u3057\u3001\u8a3c\u660e\u3057\u306a\u3055\u3044\u3002\n\n*)\n\nInductive bin:Type :=\n  | O : bin\n  | D : bin -> bin\n  | A : bin -> bin.\n\n\nDefinition incb a:bin := A a.\n\nFixpoint bin2nat (a:bin): nat :=\n  match a with\n  | O => 0\n  | D x => 2 * bin2nat x\n  | A x => 1 + bin2nat x\n  end.\n\nDefinition inc (x:nat):nat := S x.\n\nLemma inc_trans_comm: forall b:bin,\n  bin2nat (incb b) = inc (bin2nat b).",
      "suffix": "\n\n(*\n\n\u7df4\u7fd2\u554f\u984c: \u2605\u2605, optional (decreasing)\n\u5404\u95a2\u6570\u306e\u5f15\u6570\u306e\u3044\u304f\u3064\u304b\u304c\"\u6e1b\u5c11\u7684\"\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3001\u3068\u3044\u3046\u8981\u6c42\u4ed5\u69d8\u306f\u3001Coq\u306e\u30c7\u30b6\u30a4\u30f3\u306b\u304a\u3044\u3066\u57fa\u790e\u3068\u306a\u3063\u3066\u3044\u308b\u3082\u306e\u3067\u3059\u3002\u7279\u306b\u3001\u305d\u306e\u3053\u3068\u306b\u3088\u3063\u3066\u3001Coq\u4e0a\u3067\u4f5c\u6210\u3055\u308c\u305f\u95a2\u6570\u304c\u3001\u3069\u3093\u306a\u5165\u529b\u3092\u4e0e\u3048\u3089\u308c\u3066\u3082\u5fc5\u305a\u3044\u3064\u304b\u7d42\u4e86\u3059\u308b\u3001\u3068\u3044\u3046\u3053\u3068\u304c\u4fdd\u969c\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u3057\u304b\u3057\u3001Coq\u306e\"\u6e1b\u5c11\u7684\u306a\u89e3\u6790\"\u304c\u300c\u3068\u3066\u3082\u6d17\u7df4\u3055\u308c\u3066\u3044\u308b\u3068\u307e\u3067\u306f\u3044\u3048\u306a\u3044\u300d\u305f\u3081\u3001\u6642\u306b\u306f\u4e0d\u81ea\u7136\u306a\u66f8\u304d\u65b9\u3067\u95a2\u6570\u3092\u5b9a\u7fa9\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u3001\u3068\u3044\u3046\u3053\u3068\u3082\u3042\u308a\u307e\u3059\u3002\n\n\u3053\u308c\u3092\u5177\u4f53\u7684\u306b\u611f\u3058\u308b\u305f\u3081\u3001Fixpoint\u3067\u5b9a\u7fa9\u3055\u308c\u305f\u3001\u3088\u308a\u300c\u5fae\u5999\u306a\u300d\u95a2\u6570\u306e\u66f8\u304d\u65b9\u3092\u8003\u3048\u3066\u307f\u307e\u3057\u3087\u3046\uff08\u81ea\u7136\u6570\u306b\u95a2\u3059\u308b\u7c21\u5358\u306a\u95a2\u6570\u3067\u304b\u307e\u3044\u307e\u305b\u3093\uff09\u3002\u305d\u308c\u304c\u5168\u3066\u306e\u5165\u529b\u3067\u505c\u6b62\u3059\u308b\u3053\u3068\u3068\u3001Coq\u304c\u305d\u308c\u3092\u3001\u3053\u306e\u5236\u9650\u306e\u305f\u3081\u53d7\u3051\u5165\u308c\u3066\u304f\u308c\u306a\u3044\u3053\u3068\u3092\u78ba\u8a8d\u3057\u306a\u3055\u3044\u3002\n\n*)\n\n(*\nFixpoint f (a:nat): nat :=\n  match a with\n  | 0 => 0\n  | 1 => 1\n  | 13 => f 100\n  | S (S x) => 5 + f x\n  end.\n*)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "theorem": "Lemma inc_trans_comm: forall b:bin,\n  bin2nat (incb b) = inc (bin2nat b).",
      "ground_truth": "Proof.\n  intros.\n  induction b.\n  -\n    auto.\n  -\n    simpl. unfold inc. reflexivity.\n  -\n    simpl. auto.\nQed."
    },
    {
      "split": "train-sft",
      "index": 24,
      "prefix": "Require Import String.\n\nDefinition Zero := Empty_set.\nInductive Succ {S : Set} : Set := v0 | vS (s : S).\n\nFixpoint level (V : nat) : Set :=\n  match V with\n  | 0 => Zero\n  | S V => @Succ (level V)\n  end.\n\nInductive var {V : nat} :=\n| free (name : string) (index : nat)\n| bound (v : level V).\n\nDefinition wkv {V} (v : @var V) : @var (S V) :=\n  match v with\n  | free n i => free n i\n  | bound v => @bound (S V) (vS v)\n  end.\n\nDefinition openv a {V} (v : @var (S V)) : @var V :=\n  match v with\n  | free xn xi =>\n    if string_dec a xn then\n      free xn (S xi)\n    else\n      free xn xi\n  | bound (vS v) => bound v\n  | bound v0 => free a 0\n  end.\n\nDefinition closev a {V} (v : @var V) : @var (S V) :=\n  match v with\n  | free xn xi =>\n    if string_dec a xn then\n      match xi with\n      | 0 => @bound (S V) v0\n      | S xi' => free xn xi'\n      end\n    else\n      free xn xi\n  | bound v => @bound (S V) (vS v)\n  end.\n\nDefinition bindv {V} (v : @var (S V)) : option (@var V) :=\n  match v with\n  | free xn xi => Some (free xn xi)\n  | bound v0 => None\n  | bound (vS v) => Some (@bound V v)\n  end.\n\nNotation shiftv a v := (openv a (wkv v)).\n\nArguments openv : simpl nomatch.\nArguments closev : simpl nomatch.\nArguments bindv : simpl nomatch.\n\nLtac string_eqs :=\n  match goal with\n  | |- context C [string_dec ?x ?x] =>\n    destruct (string_dec x x) as [_ | Neq]; cbn; try easy\n  | |- context C [string_dec ?x ?y] =>\n    let Neq := fresh \"Hneq_\" x y in\n    destruct (string_dec x y) as [-> | Neq]; cbn; try easy\n  end.\n\nLemma rw_openv_closev a {V} (v : @var V) : openv a (closev a v) = v.\nProof.\n  unfold openv, closev.\n  destruct v as [vn [|vi]|v]; cbn; try easy; repeat string_eqs.\nQed.\nLemma rw_closev_same a {V} :\n  @closev a V (free a 0) = @bound (S V) v0.\nProof. unfold closev. string_eqs. Qed.\nLemma rw_closev_openv a {V} (v : @var (S V)) : closev a (openv a v) = v.\nProof.\n  unfold openv, closev.\n  destruct v as [vn vi|[|v]]; cbn; try easy; repeat string_eqs.\nQed.\nLemma rw_bindv_wkv {V} (v : @var V) : bindv (wkv v) = Some v.\nProof. destruct v; easy. Qed.\nLemma rw_shiftv_wkv b {V} (v : @var V) :\n  shiftv b (wkv v) = wkv (shiftv b v). \nProof. unfold openv; destruct v; cbn; try easy. string_eqs. Qed.\nHint Rewrite @rw_closev_openv @rw_closev_same @rw_openv_closev @rw_bindv_wkv\n     @rw_shiftv_wkv : rw_names.\n(* Slightly weird, but useful *)\nLemma rw_closev_wkv_shiftv a {V} (v : @var V) :\n  closev a (wkv (shiftv a v)) = wkv (wkv v).\nProof. rewrite <- rw_shiftv_wkv. rewrite rw_closev_openv. easy. Qed.\nHint Rewrite @rw_closev_wkv_shiftv : rw_names.\n\nLemma compare_aux a {V} (x : @var V) :\n  (x = free a 0) + { xi' | x = shiftv a xi' }.\nProof.\n  unfold openv.\n  destruct x as [xn xi | x]; cbn.\n  destruct (string_dec a xn) as [->|Neq].\n  destruct xi.\n  - left; easy.\n  - right; exists (free xn xi); cbn. string_eqs.\n  - right; exists (free xn xi); cbn. string_eqs.\n  - right; exists (bound x); easy.\nQed.\n\nInductive var_comparison (a : string) {V} : @var V -> Set :=\n| samev : var_comparison a (@free V a 0)\n| diffv x : var_comparison a (shiftv a x).\nDefinition compare a {V} (x : @var V) : var_comparison a x.\ndestruct (compare_aux a x) as [-> | [xi ->]]; constructor. Defined.\n\n\nInductive v0_comparison {V} : @var (S V) -> Set :=\n| samev0 : v0_comparison (@bound (S V) v0)\n| diffv0 v : v0_comparison (wkv v).\nDefinition compare0 {V} (v : @var (S V)) : v0_comparison v.\nProof.\n  destruct v as [v i|[|v]].\n  - change (@free (S V) v i) with (@wkv V (free v i)); constructor.\n  - constructor.\n  - change (@bound (S V) (vS v)) with (@wkv V (bound v)); constructor.\nQed.\n\n\nInductive term {V : nat} :=\n| vv : @var V -> @term V\n| const : nat -> @term V\n| lam : @term (S V) -> @term V\n| app : @term V -> @term V -> @term V.\n\nFixpoint open a {V} (t : @term (S V)) :=\n  match t with\n  | vv v => vv (openv a v)\n  | const k => const k\n  | lam t => lam (open a t)\n  | app f e => app (open a f) (open a e)\n  end.\n\nFixpoint close a {V} (t : @term V) :=\n  match t with\n  | vv v => vv (closev a v)\n  | const k => const k\n  | lam t => lam (close a t)\n  | app f e => app (close a f) (close a e)\n  end.\n\nFixpoint wk {V} (t : @term V) :=\n  match t with\n  | vv v => vv (wkv v)\n  | const k => const k\n  | lam t => lam (wk t)\n  | app f e => app (wk f) (wk e)\n  end.\n\nFixpoint wkn {V} (t : @term 0) :=\n  match V with\n  | 0 => t\n  | S V => wk (wkn t)\n  end.\n\nFixpoint bind {V} (u : @term 0) (t : @term (S V)) :=\n  match t with\n  | vv v =>\n    match bindv v with\n    | Some v => vv v\n    | None => wkn u\n    end\n  | const k => const k\n  | lam t => lam (bind u t)\n  | app f e => app (bind u f) (bind u e)\n  end.\n\n\nInductive ren :=\n| r_id\n| r_comp (r : ren) (s : ren)\n| r_shift (b : string) (r : ren)\n| r_rename (b : string) (r : ren) (a : string)\n| r_subst (t : @term 0) (r : ren) (a : string).\nNotation r_under a r := (r_rename a r a).\n\nFixpoint map_term (f : forall V, @var V -> @term V) {V} (t : @term V) : @term V :=\n  match t with\n  | vv v => f _ v\n  | const k => const k\n  | lam t => lam (map_term f t)\n  | app a b => app (map_term f a) (map_term f b)\n  end.\n\n\nFixpoint applyv (r : ren) {V} (v : @var V) {struct r} : @term V :=\n  match r with\n  | r_id => vv v\n  | r_comp r s => map_term (@applyv r) (applyv s v)\n  | r_shift b r => open b (applyv r (wkv v))\n  | r_rename b r a => open b (applyv r (closev a v))\n  | r_subst u r a => bind u (applyv r (closev a v))\n  end.\nArguments applyv !r V v /.\nNotation apply r := (map_term (@applyv r)).\n\nFixpoint is_renaming (r : ren) : Prop :=\n  match r with\n  | r_id => True\n  | r_comp r s => is_renaming r /\\ is_renaming s\n  | r_shift b r => is_renaming r\n  | r_rename b r a => is_renaming r\n  | r_subst u r a => False\n  end.\n\nDefinition proj1 {A B : Prop} (H : A /\\ B) := let (a, _) := H in a.\nDefinition proj2 {A B : Prop} (H : A /\\ B) := let (_, b) := H in b.\nFixpoint applyrv r : forall (rn : is_renaming r) {V} (v : @var V), @var V :=\n  match r with\n  | r_id => fun _ _ v => v\n  | r_comp r s => fun rn _ v => applyrv r (proj1 rn) (applyrv s (proj2 rn) v)\n  | r_shift b r => fun rn _ v => openv b (applyrv r rn (wkv v))\n  | r_rename b r a => fun rn _ v => openv b (applyrv r rn (closev a v))\n  | r_subst _ _ _ => False_rec _\n  end.\n\nDefinition apply' r {V} (t : @term V) :=\n  match r with\n  | r_id => t\n  | r_comp r s => apply r (apply s t)\n  | r_shift b r => open b (apply r (wk t))\n  | r_rename b r a => open b (apply r (close a t))\n  | r_subst u r a => bind u (apply r (close a t))\n  end.\nArguments apply' !r V t /.\nLemma expand_apply r {V} {t : @term V} :\n  apply r t = apply' r t.\nProof. induction t; destruct r; cbn; f_equal; auto. Qed.\nLtac expand_apply :=\n  repeat (rewrite expand_apply; cbn); repeat rewrite <- expand_apply.\n\n(* Better dependent induction *)\nDefinition induction_S\n  (ty : nat -> Set)\n  (P : forall V, ty (S V) -> Prop)\n  (Thm : forall V (t : ty V),\n      match V return ty V -> Prop with\n      | 0 => fun _ => True\n      | S V => P V\n      end t) : forall V t, P V t :=\n  fun V t => Thm (S V) t.\n\nLtac induction_S :=\n  match goal with\n  | |- forall (V : nat) (tm : ?ty (S V)), @?P V tm =>\n    apply (@induction_S ty P);\n    induction tm;\n    match goal with\n    | |- match ?V with 0 => fun _ => True | S _ => _ end _ =>\n      destruct V; [exact I | idtac]\n    | _ => idtac\n    end\n  end.\n\nLemma rw_close_open a :\n  forall {V} (t : @term (S V)), close a (open a t) = t.\nProof.\n  induction_S; cbn; try (f_equal; easy).\n  autorewrite with rw_names; easy.\nQed.\n\nLemma rw_open_close a :\n  forall {V} (t : @term V), open a (close a t) = t.\nProof.\n  induction t; cbn; try (f_equal; easy).\n  autorewrite with rw_names; easy.\nQed.\n\nLemma rw_bind_wk u :\n  forall {V} (t : @term V), bind u (wk t) = t.\nProof.\n  induction t; cbn; try (f_equal; easy).\n  autorewrite with rw_names; easy.\nQed.\n\nHint Rewrite @rw_close_open @rw_open_close @rw_bind_wk : rw_names.\n\n\nNotation shift a t := (apply (r_shift a r_id) t).\n\n(* identity and composition for apply *)\nLemma rw_apply_id {V} (t : @term V) : apply r_id t = t.\nProof. rewrite expand_apply; easy. Qed.\nLemma rw_apply_comp r s {V} (t : @term V) :\n  apply r (apply s t) = apply (r_comp r s) t.\nProof. rewrite (expand_apply (r_comp r s)); easy. Qed.\nHint Rewrite @rw_apply_id @rw_apply_comp : rw_names.\n\n(* Simple rewritings on applyv and shiftv (more later) *)\nLemma rw_applyv_bound r : forall {V} (v : level V),\n  applyv r (bound v) = vv (bound v).\nProof.\n  induction r; cbn; intros; autorewrite with rw_names; cbn;\n    repeat match goal with [ H : _ |- _ ] => rewrite H; clear H end;\n    cbn; easy.\nQed.\nLemma rw_applyrv_bound r (rn : is_renaming r) : forall {V} (v : level V),\n  applyrv r rn (bound v) = bound v.\nProof.\n  induction r; try destruct rn; cbn; intros; auto;\n    repeat match goal with [ H : _ |- _ ] => rewrite H; clear H end;\n    cbn; easy.\nQed.\nHint Rewrite @rw_applyv_bound (*@rw_shift_shiftv*) @rw_applyrv_bound: rw_names.\n\n(* Rewrite to do the following:\n    - group balanced pairs of operations into 'ren's\n    - push opens/bind right and wk/close left\n    - simplify rens *)\n\nLemma rw_group_rename a b {V} (t : @term V) :\n  open a (close b t) = apply (r_rename a r_id b) t.\nProof. expand_apply; easy. Qed.\nLemma rw_group_shift a {V} (t : @term V) :\n  open a (wk t) = apply (r_shift a r_id) t.\nProof. expand_apply; easy. Qed.\nLemma rw_group_subst u a {V} (t : @term V) :\n  bind u (close a t) = apply (r_subst u r_id a) t.\nProof. expand_apply; easy. Qed.\nHint Rewrite @rw_group_rename @rw_group_shift @rw_group_subst : rw_names.\n\n\n(* wk commutes with shift *)\nLemma rw_shift_wk b {V} (t : @term V) :\n  shift b (wk t) = wk (shift b t).\nProof.\n  induction t; cbn; try (f_equal; auto).\n  autorewrite with rw_names; easy.\nQed.\nHint Rewrite @rw_shift_wk : rw_names.\n\n(* wk commutes with apply.\n   Somewhat harder to prove than I'd expect *)\n\nLemma apply_if_applyv_wk r :\n  (forall {V} (v : @var V), applyv r (wkv v) = wk (applyv r v)) ->\n  (forall {V} (t : @term V), apply r (wk t) = wk (apply r t)).\nProof. intro H. induction t; cbn; auto; f_equal; auto. Qed.\n\nLemma rw_applyv_wkv r : forall {V} (v : @var V), applyv r (wkv v) = wk (applyv r v).\nProof.\n  induction r; cbn; intros.\n  - easy.\n  - rewrite IHr2. apply apply_if_applyv_wk. auto.\n\n  - repeat rewrite IHr.\n    autorewrite with rw_names. easy.\n\n  - destruct (compare a v); cbn;\n    autorewrite with rw_names; cbn; autorewrite with rw_names; cbn; try easy.\n    repeat rewrite IHr.\n    autorewrite with rw_names. easy.\n\n  - destruct (compare a v); cbn;\n    autorewrite with rw_names; cbn; autorewrite with rw_names; cbn; try easy.\n    repeat rewrite IHr.\n    autorewrite with rw_names; easy.\nQed.\n\n\n(* FIXME where? *)\nLemma applyrv_is_applyv :\n  forall r (rn : is_renaming r) {V} (v : @var V),\n    applyv r v = vv (applyrv r rn v).\nProof.\n  induction r; cbn; intuition.\n  - erewrite IHr2; cbn. erewrite IHr1. reflexivity.\n  - erewrite IHr. reflexivity.\n  - erewrite IHr. cbn. reflexivity.\nQed.\n\nLemma rw_applyrv_wkv :\n  forall r (rn : is_renaming r) {V} (v : @var V),\n    applyrv r rn (wkv v) = wkv (applyrv r rn v).\nProof.\n  intros.\n  assert (Inj : forall {V} (a b : @var V), vv a = vv b -> a = b) by congruence.\n  apply Inj. rewrite <- applyrv_is_applyv.\n  rewrite rw_applyv_wkv.\n  rewrite (applyrv_is_applyv r rn).\n  easy.\nQed.\n\nLemma rw_apply_wk r {V} (t : @term V) : apply r (wk t) = wk (apply r t).\nProof. apply apply_if_applyv_wk. apply rw_applyv_wkv. Qed.\n\nLemma rw_apply_wkn r {V} (t : @term 0) :\n  apply r (@wkn V t) = @wkn V (apply r t).\nProof.\n  induction V; cbn; try easy.\n  rewrite rw_apply_wk; rewrite IHV; easy.\nQed.\n\nHint Rewrite @rw_applyv_wkv @rw_applyrv_wkv @rw_apply_wk @rw_apply_wkn : rw_names.\n\nLemma rw_applyv_wkv_free r {an ai V} :\n  applyv r (@free (S V) an ai) = wk (applyv r (@free V an ai)).\nProof.\n  change (@free (S V) an ai) with (wkv (@free V an ai)).\n  apply rw_applyv_wkv.\nQed.\nLemma rw_applyrv_wkv_free r rn {an ai V} :\n  applyrv r rn (@free (S V) an ai) = wkv (applyrv r rn (@free V an ai)).\nProof.\n  change (@free (S V) an ai) with (wkv (@free V an ai)).\n  apply rw_applyrv_wkv.\nQed.\nHint Rewrite @rw_applyv_wkv_free @rw_applyrv_wkv_free : rw_names.\n\nLtac names :=\n  cbn;\n  repeat progress (autorewrite with rw_names; cbn).\n\n(* Reductions for applyv to particular variables *)\nLemma rw_applyv_shift_comp r b {V} (x : @var V) :\n  applyv (r_comp r (r_shift b r_id)) x = applyv r (shiftv b x).\nProof. easy. Qed.\nLemma rw_applyv_rename_same b r a {V} :\n  applyv (r_rename b r a) (@free V a 0) = vv (free b 0).\nProof. names; easy. Qed.\nLemma rw_applyv_rename_same_comp r' b r a {V} :\n  applyv (r_comp r' (r_rename b r a)) (@free V a 0) = applyv r' (free b 0).\nProof. names; easy. Qed.\nLemma rw_applyv_rename_diffv b r a {V} (x : @var V) :\n  applyv (r_rename b r a) (shiftv a x) =\n  applyv (r_shift b r) x.\nProof. names; easy. Qed.\nLemma rw_applyv_rename_diffv_comp r' b r a {V} (x : @var V) :\n  applyv (r_comp r' (r_rename b r a)) (shiftv a x) =\n  applyv (r_comp r' (r_shift b r)) x.\nProof. names; easy. Qed.\nLemma rw_applyv_subst_same u r a {V} :\n  applyv (r_subst u r a) (@free V a 0) = wkn u.\nProof. names; easy. Qed.\nLemma rw_applyv_subst_same_comp r' u r a {V} :\n  applyv (r_comp r' (r_subst u r a)) (@free V a 0) =\n  wkn (apply r' u).\nProof. names; easy. Qed.\nLemma rw_applyv_subst_diffv u r a {V} (x : @var V) :\n  applyv (r_subst u r a) (shiftv a x) = applyv r x.\nProof. names; easy. Qed.\nLemma rw_applyv_subst_diffv_comp r' u r a {V} (x : @var V) :\n  applyv (r_comp r' (r_subst u r a)) (shiftv a x) =\n  applyv (r_comp r' r) x.\nProof. names; easy. Qed.\nGoal forall a b {V} (v : @var (S V)), \n  vv (openv a (shiftv b v)) = applyv (r_under a (r_shift b r_id)) (openv a v).\nintros. cbn. names. easy. Qed.\nGoal forall r a {V} (v : @var (S V)),\n  applyv r (closev a v) = close a (applyv (r_under a r) v).\nProof. intros; names. easy. Qed.\n\nLemma comm_bind_apply u : forall {V} (t : @term (S V)) r,\n  apply r (bind u t) = bind (apply r u) (apply r t).\nProof.\n  induction_S; intro r; cbn; try solve [f_equal; auto].\n  destruct (compare0 v); cbn; autorewrite with rw_names; easy.\nQed.\n\n\n(* FIXME: maybe this should just be \"names\"? *)\nLemma rw_close_shift a r {V} (t : @term V) :\n  close a (apply (r_shift a r) t) = wk (apply r t).\nProof. expand_apply. rewrite rw_apply_wk. rewrite rw_close_open. easy. Qed.\nLemma rw_subst_open u r b {V} (t : @term (S V)) :\n  apply (r_subst u r b) (open b t) = bind u (apply r t).\nProof. expand_apply. rewrite rw_close_open. easy. Qed.\nLemma rw_rename_open a b {V} (t : @term (S V)) :\n  apply (r_rename a r_id b) (open b t) = open a t.\nProof. expand_apply. rewrite rw_close_open. easy. Qed.\nHint Rewrite @rw_close_shift @rw_subst_open @rw_rename_open : rw_names.\n\n\n(* FIXME: lots of applyrv rewritings below here *)\n\n\n\n(* FIXME: not great, tbh *)\n\n(* Commuting bind with apply.\n   It seems more natural to make\n     bind (r u) . r  --> r . bind u\n   since bind is similar to open, and open moves right.\n   But that rule breaks confluence, and isn't very useful\n   as bind doesn't show up in terms. So, binds move left\n   instead. *)\nLemma rw_push_bind u r {V} (t : @term (S V)) :\n  apply r (bind u t) = bind (apply r u) (apply r t).\nProof. apply comm_bind_apply. Qed.\n(* Shifts go the other way.\n   This is confluent/terminating because shift doesn't simplify to apply (?) *)\nLemma rw_push_bind_shift u r s a {V} (t : @term (S V)) :\n  bind (apply (r_shift a r) u) (apply (r_shift a s) t) =\n  shift a (bind (apply r u) (apply s t)).\nProof. rewrite comm_bind_apply. expand_apply. names. easy. Qed.\nLemma rw_push_bind_shiftvu v a {V} (t : @term (S V)) :\n  bind (vv (shiftv a v)) (shift a t) = shift a (bind (vv v) t).\nProof.\n  change (vv (shiftv a v)) with (shift a (vv v)).\n  rewrite rw_push_bind_shift. autorewrite with rw_names. easy.\nQed.\nHint Rewrite\n  @rw_push_bind @rw_push_bind_shift @rw_push_bind_shiftvu : rw_names.\n\n\n(* Morphisms. *)\nRequire Import Setoid.\nRequire Import Morphisms.\n\n(* FIXME: is it better to define eqr over all vars or just free ones? *)\nDefinition eqr (r s : ren) : Prop :=\n  forall {V} (v : @var V), applyv r v = applyv s v.\n\nInstance eqr_Equivalence : Equivalence eqr.\nProof.\n  split; red; unfold eqr; auto.\n  intros. etransitivity; eauto.\nQed.\n\nInstance mor_applyv : Proper\n  (eqr ==> forall_relation (fun _ => (eq ==> eq))) applyv.\nProof. intros r s Hrs V v v' <-. auto. Qed.\n\nInstance mor_map_term : Proper\n  (forall_relation (fun _ => (eq ==> eq)) ==> forall_relation (fun _ => (eq ==> eq))) map_term.\nProof.\n  intros f g Hfg V t t' <-. cbv in Hfg.\n  induction t; cbn; try (f_equal; auto).\nQed.\n\n(* FIXME applyv, applyrv, shift below  *)\n\n\n\n\nLtac easy_eqr :=\n  repeat intro; cbn;\n  repeat (match goal with [ H : _ |- _ ] => rewrite H; clear H end);\n  expand_apply; names; easy.\n\nInstance mor_r_comp   : Proper (eqr ==> eqr ==> eqr) r_comp. easy_eqr. Qed.\nInstance mor_r_shift  : Proper (eq ==> eqr ==> eqr) r_shift. easy_eqr. Qed.\nInstance mor_r_rename : Proper (eq ==> eqr ==> eq ==> eqr) r_rename. easy_eqr. Qed.\nInstance mor_r_subst  : Proper (eq ==> eqr ==> eq ==> eqr) r_subst. easy_eqr. Qed.\n\nLemma rw_ren_id_comp r : eqr (r_comp r_id r) r.\nProof. easy_eqr. Qed.\nLemma rw_ren_comp_id r : eqr (r_comp r r_id) r.\nProof. easy_eqr. Qed.\nLemma rw_ren_comp_assoc r s t :\n  eqr (r_comp r (r_comp s t)) (r_comp (r_comp r s) t).\nProof. easy_eqr. Qed.\nLemma rw_ren_under_id x :\n  eqr (r_under x r_id) r_id.\nProof. easy_eqr. Qed.\nLemma rw_ren_rename_rename c b a r s :\n  eqr (r_comp (r_rename c r b) (r_rename b s a))\n      (r_rename c (r_comp r s) a).\nProof. easy_eqr. Qed.\nLemma rw_ren_rename_rename_comp l c b a r s :\n  eqr (r_comp (r_comp l (r_rename c r b)) (r_rename b s a))\n      (r_comp l (r_rename c (r_comp r s) a)).\nProof. easy_eqr. Qed.\nLemma rw_ren_rename_shift c b r s :\n  eqr (r_comp (r_rename c r b) (r_shift b s))\n      (r_shift c (r_comp r s)).\nProof.\n  repeat intro; cbn. expand_apply. names. easy. Qed.\nLemma rw_ren_rename_shift_comp l c b r s :\n  eqr (r_comp (r_comp l (r_rename c r b)) (r_shift b s))\n      (r_comp l (r_shift c (r_comp r s))).\nProof. \n  repeat intro; cbn. expand_apply. rewrite rw_close_open; easy. Qed.\nLemma rw_ren_subst_rename u r a s b :\n  eqr (r_comp (r_subst u r a) (r_rename a s b))\n      (r_subst u (r_comp r s) b).\nProof. repeat intro; cbn; expand_apply; repeat rewrite rw_close_open; easy. Qed.\nLemma rw_ren_subst_rename_comp l u r a s b :\n  eqr (r_comp (r_comp l (r_subst u r a)) (r_rename a s b))\n      (r_comp l (r_subst u (r_comp r s) b)).\nProof. repeat intro; cbn; expand_apply; repeat rewrite rw_close_open; easy. Qed.\nLemma rw_ren_subst_shift u r a s :\n  eqr (r_comp (r_subst u r a) (r_shift a s))\n      (r_comp r s).\nProof.\n  repeat intro; expand_apply; cbn; expand_apply.\n  rewrite rw_close_open. rewrite rw_applyv_wkv. rewrite rw_apply_wk. rewrite rw_bind_wk.\n  easy.\nQed.\nLemma rw_ren_subst_shift_comp l u r a s :\n  eqr (r_comp (r_comp l (r_subst u r a)) (r_shift a s))\n      (r_comp l (r_comp r s)).\nProof.\n  repeat intro; expand_apply; cbn; expand_apply.\n  rewrite rw_close_open. autorewrite with rw_names. easy.\nQed.\nLemma rw_ren_shift_any a r s :\n  eqr (r_comp (r_shift a r) s) (r_shift a (r_comp r s)).\nProof.\n  repeat intro; expand_apply; cbn; expand_apply.\n  autorewrite with rw_names. easy.\nQed.\nLemma rw_ren_shift_any_comp l a r s :\n  eqr (r_comp (r_comp l (r_shift a r)) s) (r_comp l (r_shift a (r_comp r s))).\nProof.\n  repeat intro; expand_apply; cbn; expand_apply.\n  autorewrite with rw_names. easy.\nQed.\nLemma rw_ren_any_subst r u s x :\n  eqr (r_comp r (r_subst u s x)) (r_subst (apply r u) (r_comp r s) x).\nProof. easy_eqr. Qed.\n\n(* No _comp version required for any_subst *)\n(* Ensure crit pair of rw_ren_shift_any and rw_ren_any_subst is confluent *)\nLemma rw_ren_shift_subst_crit a u r b :\n  eqr (r_subst (shift a u) (r_shift a r) b)\n      (r_shift a (r_subst u r b)).\nProof.\n  repeat intro; cbn.\n  autorewrite with rw_names.\n  rewrite rw_ren_shift_any.\n  rewrite rw_push_bind_shift.\n  rewrite rw_ren_comp_id. repeat rewrite rw_apply_id.\n  change (bind u (@applyv r (S V) (closev b v))) with (@applyv (r_subst u r b) V v).\n  change (bind u (@applyv r (S (S V)) (closev b (wkv v)))) with (@applyv (r_subst u r b) (S V) (wkv v)).\n  rewrite rw_applyv_wkv.\n  names; easy.\nQed.\n\nHint Rewrite\n  @rw_ren_id_comp\n  @rw_ren_comp_id\n  @rw_ren_comp_assoc\n  @rw_ren_under_id\n  @rw_ren_rename_rename\n  @rw_ren_rename_rename_comp\n  @rw_ren_rename_shift\n  @rw_ren_rename_shift_comp\n  @rw_ren_subst_rename\n  @rw_ren_subst_rename_comp\n  @rw_ren_subst_shift\n  @rw_ren_subst_shift_comp\n  @rw_ren_shift_any\n  @rw_ren_shift_any_comp\n  @rw_ren_any_subst\n  @rw_ren_shift_subst_crit : rw_names.\n\nGoal\n  forall a b c {V},\n    apply (r_shift a (r_rename b r_id c)) (vv (@free V c 0)) =\n    vv (shiftv a (free b 0)).\n  intros. names.\n  (* FIXME: should shiftv be a notation? *)\n  unfold shiftv; cbn.\n  match goal with [ |- ?x = ?x ] => reflexivity end.\nQed.\n\nGoal\n  forall a r b {V} (t : @term V),\n    apply (r_rename a r b) (shift b t) = shift a (apply r t).\n  intros. names.\n  match goal with [ |- ?x = ?x ] => reflexivity end.\nQed.\n\n\n(* Commuting open and close with apply *)\n\nLemma rw_push_open a r {V} (t : @term (S V)) :\n  open a (apply r t) = apply (r_under a r) (open a t).\nProof. expand_apply; names; easy. Qed.\nLemma rw_push_close a r {V} (t : @term V) :\n  apply r (close a t) = close a (apply (r_under a r) t).\nProof. expand_apply; names; easy. Qed.\nHint Rewrite @rw_push_open @rw_push_close : rw_names.\n\n\n\n(*\n * Simply-typed lambda calculus\n *)\n\n\n\nInductive context {A : Set} : Set :=\n| ctx_empty\n| ctx_cons (\u0393 : @context A) (a : string) (val : A).\nNotation \"\u0393 ',,' x '~' A\" := (ctx_cons \u0393 x A) (at level 60).\n\nFixpoint has {A} (ctx : @context A) (x : @var 0) (v : A) :=\n  match ctx with\n  | ctx_empty => False\n  | ctx_cons ctx y val =>\n    match bindv (closev y x) with\n    | None => val = v\n    | Some x' => has ctx x' v\n    end\n  end.\n\nInductive type := Base | Fn (a b : type).\n\nReserved Notation \"\u0393 '\u22a2' e '~' A\" (at level 60).\nInductive types (\u0393 : @context type) : @term 0 -> type -> Prop :=\n| VAR x {A} :\n   has \u0393 x A\n   ->\n   \u0393 \u22a2 vv x ~ A\n| BASE k :\n   \u0393 \u22a2 const k ~ Base\n| LAM body {A B} :\n   (forall x, (\u0393,, x ~ A) \u22a2 open x body ~ B)\n   ->\n   \u0393 \u22a2 lam body ~ Fn A B\n| APP f e {A B} :\n   \u0393 \u22a2 f ~ Fn A B ->\n   \u0393 \u22a2 e ~ A ->\n   \u0393 \u22a2 app f e ~ B\nwhere \"\u0393 '\u22a2' e '~' A\" := (types \u0393 e A).\n\nNotation \"\u0393 \u2286 [ r , rn ] \u0394\" :=\n  (forall v A, has \u0393 v A -> has \u0394 (applyrv r rn v) A)\n  (at level 60, format \"\u0393  \u2286 [ r , rn ]  \u0394\").\n\nLemma ctx_extend_weakening {\u0393 \u0394 x} {A : type} {r} {rn : is_renaming r} :\n  \u0393 \u2286 [ r , rn ] \u0394 -> (\u0393,, x ~ A) \u2286[r_under x r,rn] (\u0394,, x ~ A).\nProof.\n  intros H v B; cbn.\n  destruct (compare x v); names; auto.\nQed.\n\nTheorem weakening {\u0393 e A}:\n  \u0393 \u22a2 e ~ A ->\n  forall r (rn : is_renaming r) \u0394,\n    \u0393 \u2286[r, rn] \u0394 ->\n    \u0394 \u22a2 apply r e ~ A.\nProof.\n  induction 1; cbn; intros.\n  - erewrite applyrv_is_applyv.\n    constructor.\n    auto.\n  - constructor.\n  - constructor; intro v.\n    names.\n    eauto using ctx_extend_weakening.\n  - econstructor; eauto.\nQed.\n\n\nNotation \"\u0393 \u2286 [ r ] \u0394\" :=\n  (forall v A, has \u0393 v A -> \u0394 \u22a2 applyv r v ~ A)\n  (at level 60, format \"\u0393  \u2286 [ r ]  \u0394\").\n\nLemma ctx_extend_substitution {\u0393 \u0394 x} {A : type} {r} :\n  \u0393 \u2286[r] \u0394 -> (\u0393,, x ~ A) \u2286[r_under x r] (\u0394,, x ~ A).\nProof.\n  intros H v B; cbn.\n  destruct (compare x v); names.\n  - intros ->. constructor. names. auto.\n  - intros \u0393B. eapply (weakening (H _ _ \u0393B) (r_shift x r_id) I).\n    intros; names; auto.\nQed.\n\nTheorem substitution {\u0393 e A} :\n  \u0393 \u22a2 e ~ A ->\n  forall r \u0394,\n    \u0393 \u2286[r] \u0394 ->\n    \u0394 \u22a2 apply r e ~ A.\nProof.\n  induction 1; cbn; intros.\n  - auto.\n  - constructor.\n  - constructor; intro v.\n    names.\n    eauto using ctx_extend_substitution.\n  - econstructor; eauto.\nQed.\n\n\nCorollary weakening1 {\u0393 e A B x} :\n  \u0393 \u22a2 e ~ A ->\n  \u0393,, x ~ B \u22a2 shift x e ~ A.\nProof.\n  intro H. eapply (weakening H (r_shift x r_id) I).\n  intros; names; auto.\nQed.\n\nCorollary renaming1 {\u0393 e A B x y} :\n  \u0393,, x ~ B \u22a2 e ~ A ->\n  \u0393,, y ~ B \u22a2 apply (r_rename y r_id x) e ~ A.\nProof.\n  intro H. eapply (weakening H (r_rename y r_id x) I).\n  intros v C. destruct (compare x v); names; auto.\nQed.\n\nCorollary substitution1 {\u0393 e e' A B x} :\n  \u0393,, x ~ B \u22a2 e ~ A ->\n  \u0393 \u22a2 e' ~ B ->\n  \u0393 \u22a2 apply (r_subst e' r_id x) e ~ A.\nProof.\n  intros He He'. eapply substitution; eauto.\n  intros v C. destruct (compare x v); names.\n  - intros <-; auto.\n  - apply VAR.\nQed.\n\n\n\nLemma LAM' x {\u0393 body} {A B} :\n  \u0393,, x ~ A \u22a2 open x body ~ B ->\n  \u0393 \u22a2 lam body ~ (Fn A B).\nProof.\n  intro H.\n  apply LAM.\n  intro y.\n  replace (open y body) with (apply (r_rename y r_id x) (open x body)) by (names; easy).\n  auto using renaming1.\nQed.\n\nDefinition swap_bound {V} (v : @var (S (S V))) : @var (S (S V)) :=\n  match v with\n  | free vn vi =>\n    free vn vi\n  | bound v =>\n    @bound (S (S V))\n    (match v with\n     | v0 => vS v0\n     | vS v0 => v0\n     | vS (vS v) => vS (vS v)\n     end)\n  end.\n\nLemma close_distinct {x an ai} (Hxy : x <> an) {V} :\n  closev x (@free V an ai) = free an ai.\nProof. unfold closev. string_eqs. Qed.\n\n(* This surprised me. *)\nLemma swap_shift_shift {x y} {V} (v : @var V) :\n  shiftv x (shiftv y v) = shiftv y (shiftv x v).\nProof.\n  destruct v as [vn vi|b]; unfold shiftv, openv; cbn; try easy.\n  repeat string_eqs.\nQed.\n\nLemma shift_distinct {x y} (Hxy : x <> y) {V} :\n  shiftv x (@free V y 0) = @free V y 0.\nProof. unfold shiftv, openv; cbn. string_eqs. Qed.\n\nLemma swap_shift_close {x y} (Hxy : x <> y) {V} (v : @var V) :\n  closev x (shiftv y v) = shiftv y (closev x v).\nProof.\n  destruct (compare x v).\n  - rewrite shift_distinct; autorewrite with rw_names. easy. auto.\n  - rewrite swap_shift_shift. autorewrite with rw_names; easy.\nQed.\n\nLemma swap_close_close {x y} (Hxy : x <> y) {V} {v : @var V} :\n  closev x (closev y v) = swap_bound (closev y (closev x v)).\nProof.\n  destruct (compare y v); autorewrite with rw_names; cbn.\n  - replace (free y 0) with (shiftv x (@free V y 0)).\n    autorewrite with rw_names. easy.\n    unfold shiftv, openv; cbn. string_eqs.\n  - rewrite swap_shift_close by assumption. autorewrite with rw_names.\n    destruct x0 as [n i | b]; unfold closev; cbn; try easy.\n    string_eqs. destruct i; easy.\nQed.\n\nLemma swap_subst_subst {x y} (Hxy : x <> y) {u v R} :\n  eqr (r_subst u (r_subst v R x) y) (r_subst v (r_subst u R y) x).\nProof.\n  intros V p. cbn.\n  rewrite (swap_close_close Hxy).\n  destruct (closev y (closev x _)) as [pn pi|[|[|b]]]; cbn;\n  autorewrite with rw_names; cbn; autorewrite with rw_names; easy.\nQed.\n\nLemma barendregt_substitution_debruijn x y (M : @term 0) (L N : @term 0) :\n  x <> y ->\n  apply (r_subst L r_id y) (apply (r_subst N r_id x) M) =\n  apply (r_subst (apply (r_subst L r_id y) N) r_id x) (apply (r_subst (shift x L) r_id y) M).\nProof.\n  intros Hdistinct.\n  autorewrite with rw_names.\n  rewrite (swap_subst_subst Hdistinct); easy.\nQed.\n\nInductive Vclosed : @term 0 -> Set :=\n| vc_vv v : Vclosed (vv v)\n| vc_const n : Vclosed (const n)\n| vc_lam t : (forall n, Vclosed (open n t)) -> Vclosed (lam t)\n| vc_app f e : Vclosed f -> Vclosed e -> Vclosed (app f e).\n\nFixpoint Vclosedk (V : nat) : @term V -> Set :=\n  match V with\n  | 0 => fun t => Vclosed t\n  | S V => fun t => forall n, Vclosedk V (open n t)\n  end.\n\nFixpoint always_Vclosedk {V : nat} (t : term) {struct t} : Vclosedk V t :=\n  match t with\n  | vv v =>\n    let fix go {V} : forall (v : @var V), Vclosedk V (vv v) :=\n      match V with 0 => vc_vv | S V => fun v n => go _ end in\n    go v\n\n  | const n =>\n    let fix go {V} : Vclosedk V _ :=\n      match V with 0 => vc_const n | S V => fun _ => go end in\n    go\n\n  | lam t =>\n    let fix go {V} : forall t, Vclosedk (S V) t -> Vclosedk V (lam t) :=\n      match V with 0 => vc_lam | S V => fun _ vc a => go _ (vc a) end in\n    go _ (always_Vclosedk t)\n\n  | app f e  =>\n    let fix go {V} : forall f e, Vclosedk V f -> Vclosedk V e -> Vclosedk V (app f e) :=\n      match V with 0 => vc_app | S V => fun _ _ vf ve a => go _ _ (vf a) (ve a) end in\n    go _ _ (always_Vclosedk f) (always_Vclosedk e)\n  end.\n\n\nLemma always_Vclosedk_open x : forall {V} (t : @term (S V)),\n  always_Vclosedk t x = always_Vclosedk (open x t).\nProof.\n  induction_S; induction V; cbn; try easy.\n  - rewrite IHt. easy.\n  - rewrite IHt. easy.\n  - rewrite IHt2. rewrite IHt1. easy.\n  - rewrite IHt1. rewrite IHt2. easy.\nQed.\nHint Rewrite always_Vclosedk_open : rw_names.\nOpen Scope string.\n\nNotation \"'\u03bb' v ~> t\" := (lam (close v t)) (at level 60, format \"'\u03bb' v  ~>  t\").\nNotation \"f & e\" := (app f e) (at level 59, left associativity).\nNotation \"! k\" := (vv (free k 0)) (at level 10, format \"! k\").\n\nFixpoint cps {tm} (t : Vclosed tm) : @term 0 :=\n  match t with\n  | vc_vv v =>\n    \u03bb\"k\" ~>\n      !\"k\" & shift \"k\" (vv v)\n\n  | vc_const n =>\n    \u03bb\"k\" ~>\n     !\"k\" & const n\n\n  | vc_lam _ t =>\n    \u03bb\"k\" ~>\n     !\"k\" & \u03bb\"x\" ~>\n        shift \"k\" (cps (t \"x\"))\n\n  | vc_app _ _ f e =>\n    \u03bb\"k\" ~>\n       shift \"k\" (cps f) & \u03bb\"f\" ~>\n          shift \"f\" (shift \"k\" (cps e)) & \u03bb\"v\" ~>\n             !\"f\" & !\"v\" & !\"k\"\n  end.\nPrint cps.\n\n(* \n   Meyer and Wand's theorem about typed CPS transforms\n     (\"Continuation semantics in typed lambda calculi\", 1985)\n   This follows Harper and Lillibridge's presentation.\n     (\"Polymorphic Type Assignment and CPS Conversion\", 1992)\n *)\n\nDefinition cont R A :=\n  Fn (Fn A R) R.\n\nFixpoint cpsty R A :=\n  match A with\n  | Base => Base\n  | Fn A B => Fn (cpsty R A) (cont R (cpsty R B))\n  end.\n\nFixpoint cpsctx R ctx {struct ctx} :=\n  match ctx with\n  | ctx_empty => ctx_empty\n  | ctx_cons G x A => ctx_cons (cpsctx R G) x (cpsty R A)\n  end.\n\nLemma cpsctx_has {R \u0393 A} : forall x,\n  has \u0393 x A -> has (cpsctx R \u0393) x (cpsty R A).\nProof.\n  induction \u0393; cbn; auto.\n  intro x; destruct (compare a x); names; [intros ->|]; auto.\nQed.\n\nTheorem cps_type_preserving {\u0393 e A R} :\n  types \u0393 e A ->\n  types (cpsctx R \u0393) (cps (always_Vclosedk e)) (cont R (cpsty R A)).",
      "suffix": "\nPrint Assumptions cps_type_preserving.\n\n",
      "theorem": "Theorem cps_type_preserving {\u0393 e A R} :\n  types \u0393 e A ->\n  types (cpsctx R \u0393) (cps (always_Vclosedk e)) (cont R (cpsty R A)).",
      "ground_truth": "Proof.\n  induction 1; names; intros.\n  - apply LAM; intro y; cbn.\n    eapply APP.\n    eapply VAR. cbn. names. easy.\n    eapply VAR. cbn. names.\n    apply cpsctx_has; auto.\n  - apply LAM; intro y; cbn.\n    eapply APP.\n    eapply VAR; cbn; names. easy.\n    apply BASE.\n  - apply (LAM' \"k\"); names.\n    eapply APP. apply VAR. names. easy.\n    apply (LAM' \"x\"); names.\n    eapply weakening. eauto. cbn.\n    intros v T'. cbn. names.\n    rewrite swap_shift_close  by easy.\n    destruct (compare \"x\" v); names;  easy.\n  - apply (LAM' \"k\"). names.\n    eapply APP.\n    eapply weakening1; eauto.\n    apply (LAM' \"f\"). names.\n    eapply APP.\n    eapply weakening. eauto.\n    intros v T'. names. easy.\n    apply (LAM' \"v\"). names.\n    eapply APP.\n    eapply APP.\n    eapply VAR. cbn. easy.\n    eapply VAR. cbn. easy.\n    eapply VAR. cbn. easy.\n  Unshelve. cbn. easy. cbn; easy.\nQed."
    },
    {
      "split": "train-sft",
      "index": 25,
      "prefix": "Require Import Coq.Logic.Classical_Prop.\nRequire Import Coq.Logic.PropExtensionality.\nRequire Import Coq.Logic.ClassicalChoice.\n\nRequire Import ClassicalEnsembles.Core.\nRequire Import ClassicalEnsembles.Tactics.\nRequire Import ClassicalEnsembles.Algebra.\nRequire Import ClassicalEnsembles.Families.\nRequire Import ClassicalEnsembles.Maps.\n\nImport SetElementNotation.\nImport SetAlgebraNotation.\nImport SetFamilyNotation.\nImport SetImageNotation.\n\nInductive Cartesian {X Y} (A : Ensemble X) (B : Ensemble Y) : Ensemble (X * Y)\n  := Cartesian_intro : forall x y, x \u2208 A -> y \u2208 B -> (x, y) \u2208 Cartesian A B.\nInductive Unit : Ensemble unit\n  := Unit_intro : tt \u2208 Unit.\nInductive FamilyCartesian {I E} (F : forall (i : I), Ensemble (E i)) : Ensemble (forall i, E i)\n  := FamilyCartesian_intro : forall f, (forall i, f i \u2208 F i) -> f \u2208 FamilyCartesian F.\n\nModule SetCartesianNotation.\n\nNotation \"A \u00d7 B\" := (Cartesian A B)\n  (at level 66, left associativity).\nNotation \"\u220f p => e\" := (FamilyCartesian (fun p => e))\n  (at level 66, left associativity).\nNotation \"\u220f ' p => e\" := (FamilyCartesian (fun p => e))\n  (at level 66, left associativity, p strict pattern).\n\nEnd SetCartesianNotation.\nImport SetCartesianNotation.\n\nGlobal Hint Resolve Cartesian_intro : sets.\nGlobal Hint Resolve Unit_intro : sets.\nGlobal Hint Resolve FamilyCartesian_intro : sets.\n\nTheorem cartesian_char {X Y} (A : Ensemble X) (B : Ensemble Y) x y\n  : (x, y) \u2208 A \u00d7 B = (x \u2208 A /\\ y \u2208 B).\nProof.\n  apply propositional_extensionality. split.\n  - now inversion 1.\n  - now intros [].\nQed.\n\nTheorem cartesian_char_eta {X Y} (A : Ensemble X) (B : Ensemble Y) p\n  : p \u2208 A \u00d7 B = (fst p \u2208 A /\\ snd p \u2208 B).\nProof.\n  apply propositional_extensionality. split.\n  - now intros [].\n  - now destruct p.\nQed.\n\nTheorem unit_char x\n  : x \u2208 Unit = True.\nProof.\n  apply propositional_extensionality. split; auto.\n  now destruct x.\nQed.\n\nTheorem family_cartesian_char {I E} (F : forall (i : I), Ensemble (E i)) f\n  : f \u2208 FamilyCartesian F = forall i, f i \u2208 F i.\nProof.\n  apply propositional_extensionality. split; auto with sets.\n  now intros [].\nQed.\n\nGlobal Hint Rewrite @cartesian_char : sets.\nGlobal Hint Rewrite @cartesian_char_eta : sets.\nGlobal Hint Rewrite @unit_char : sets.\nGlobal Hint Rewrite @family_cartesian_char : sets.\n\nTheorem cartesian_mono {X Y} (A1 A2 : Ensemble X) (B1 B2 : Ensemble Y)\n  : A1 \u2282 A2 -> B1 \u2282 B2 -> A1 \u00d7 B1 \u2282 A2 \u00d7 B2.\nProof. setsolve. Qed.\n\nTheorem family_cartesian_mono {I E} (F1 F2 : forall (i : I), Ensemble (E i))\n  : (forall i, F1 i \u2282 F2 i) -> FamilyCartesian F1 \u2282 FamilyCartesian F2.\nProof. setsolve. Qed.\n\nTheorem cartesian_empty_left {X Y} (A : Ensemble Y)\n  : \u2205 \u00d7 A = \u2205 :> Ensemble (X * Y).\nProof. setsolve. Qed.\n\nTheorem cartesian_empty_right {X Y} (A : Ensemble X)\n  : A \u00d7 \u2205 = \u2205 :> Ensemble (X * Y).\nProof. setsolve. Qed.\n\nTheorem family_cartesian_empty {I E} (F : forall (i : I), Ensemble (E i)) i\n  : F i = \u2205 -> FamilyCartesian F = \u2205.\nProof. setsolve. Qed.\n\nTheorem cartesian_full {X Y}\n  : \u22a4 \u00d7 \u22a4 = \u22a4 :> Ensemble (X * Y).\nProof. setsolve. Qed.\n\nTheorem family_cartesian_full {I E} (F : forall (i : I), Ensemble (E i))\n  : (forall i, F i = \u22a4) -> FamilyCartesian F = \u22a4.\nProof.\n  intros p. apply full_equals. unset.\n  intros f _ i. now rewrite p.\nQed.\n\nTheorem cartesian_is_empty {X Y} (A : Ensemble X) (B : Ensemble Y)\n  : is_empty A \\/ is_empty B <-> is_empty (A \u00d7 B).\nProof.\n  split.\n  - intros [i | j] ? [x y].\n    + now apply (i x).\n    + now apply (j y).\n  - intros u. apply NNPP. intros [i j]%not_or_and.\n    apply i. intros x ?. apply j. intros y ?.\n    specialize (u (x, y)).\n    now apply u.\nQed.\n\nTheorem family_cartesian_is_empty {I E} (F : forall (i : I), Ensemble (E i))\n  : (exists i, is_empty (F i)) <-> is_empty (FamilyCartesian F).\nProof.\n  split.\n  - setsolve_firstorder.\n  - unfold is_empty. unset.\n    intros u. apply NNPP. intros ne.\n    assert (exists f, forall i, f i \u2208 F i) as [f].\n    {\n      apply choice_dependent. intros i. apply NNPP.\n      intros n. apply ne. exists i. intros x ?.\n      apply n. now exists x.\n    }\n    now apply (u f).\nQed.\n\nTheorem cartesian_is_full {X Y} (A : Ensemble X) (B : Ensemble Y)\n  : (X -> False) \\/ (Y -> False) \\/ (is_full A /\\ is_full B) <-> is_full (A \u00d7 B).\nProof.\n  split.\n  - intros [ | [ | [p q]]].\n    + intros []. contradiction.\n    + intros []. contradiction.\n    + intros []. specialize (p x). now specialize (q y).\n  - intros p.\n    destruct (classic (inhabited X)) as [[x] | ].\n    + destruct (classic (inhabited Y)) as [[y] | ].\n      * right. right. split.\n        ** intros x'. specialize (p (x', y)). setsolve.\n        ** intros y'. specialize (p (x, y')). setsolve.\n      * right. left. auto.\n    + left. auto.\nQed.\n\nTheorem family_cartesian_is_full {I E} (F : forall (i : I), Ensemble (E i))\n  : (exists i, E i -> False) \\/ (forall i, is_full (F i)) <-> is_full (FamilyCartesian F).\nProof.\n  split.\n  - intros [[i] | p].\n    + intros f. contradiction (f i).\n    + intros f. constructor. intros i. apply p.\n  - intros p.\n    destruct (classic (exists i, E i -> False)) as [ | ne]; auto.\n    right.\n    assert (exists (f : forall i, E i), forall (i : I), True) as [f].\n    {\n      apply (choice_dependent (fun _ _ => True)).\n      intros i. apply NNPP. intros n.\n      apply ne. exists i. intros ?. now apply n.\n    }\n    intros i x.\n    apply classic_set_in_prop_context. intros lem.\n    set (f' j := match lem (i = j) with\n                     | left e => eq_rect _ E x _ e\n                     | right _ => f j\n                     end).\n    replace x with (f' i).\n    + now destruct (p f').\n    + subst f'. simpl.\n      destruct lem as [e | ].\n      * replace e with (@eq_refl _ i); auto.\n        apply proof_irrelevance.\n      * contradiction.\nQed.\n\nTheorem intersection_cartesian {X Y} (A1 A2 : Ensemble X) (B1 B2 : Ensemble Y)\n  : (A1 \u00d7 B1) \u2229 (A2 \u00d7 B2) = (A1 \u2229 A2) \u00d7 (B1 \u2229 B2).\nProof. setsolve. Qed.\n\nTheorem intersection_family_cartesian {I E} (F G : forall (i : I), Ensemble (E i))\n  : FamilyCartesian F \u2229 FamilyCartesian G = \u220f i => (F i \u2229 G i).\nProof. setsolve_firstorder. Qed.\n\nTheorem family_intersection_cartesian {I X Y} (F : I -> Ensemble X) (G : I -> Ensemble Y)\n  : \u22c2 i => F i \u00d7 G i = FamilyIntersection F \u00d7 FamilyIntersection G.\nProof. setsolve_firstorder. Qed.\n\nTheorem family_intersection_family_cartesian {I J E} (F : J -> forall (i : I), Ensemble (E i))\n  : \u22c2 j => FamilyCartesian (F j) = \u220f i => \u22c2 j => F j i.\nProof. setsolve. Qed.\n\nTheorem complement_cartesian {X Y} (A : Ensemble X) (B : Ensemble Y)\n  : (A \u00d7 B)\u1d9c = (A \u1d9c \u00d7 B) \u222a (A \u00d7 B \u1d9c) \u222a (A \u1d9c \u00d7 B \u1d9c).\nProof. setsolve. Qed.\n\nTheorem fst_image_empty {X Y}\n  : (Y -> False) -> Image (@fst X Y) = \u2205.\nProof.\n  intros ?. apply empty_equals. unset.\n  now intros ? [[x y] ->].\nQed.\n\nTheorem fst_image_full {X Y}\n  : Y -> Image (@fst X Y) = \u22a4.\nProof.\n  intros y. apply full_equals. unset.\n  intros x. now exists (x, y).\nQed.\n\nTheorem snd_image_empty {X Y}\n  : (X -> False) -> Image (@snd X Y) = \u2205.\nProof.\n  intros ?. apply empty_equals. unset.\n  now intros ? [[x y] ->].\nQed.\n\nTheorem snd_image_full {X Y}\n  : X -> Image (@snd X Y) = \u22a4.\nProof.\n  intros x. apply full_equals. unset.\n  intros y. now exists (x, y).\nQed.\n\nTheorem projection_image_empty {I} (E : I -> Type) i\n  : (E i -> False) -> Image (fun (f : forall i, E i) => f i) = \u2205.\nProof.\n  intros ?. apply empty_equals. unset.\n  intros x [f ->]. auto.\nQed.\n\nTheorem projection_image_full {I} (E : I -> Type) i\n  : (forall i, E i) -> Image (fun (f : forall i, E i) => f i) = \u22a4.\nProof.\n  intros f. apply full_equals. unset.\n  intros x _.\n  apply classic_set_in_prop_context. intros lem.\n  exists (fun j => match lem (i = j) with\n                   | left e => eq_rect _ E x _ e\n                   | right _ => f j\n                   end).\n  destruct lem as [e | ].\n  - replace e with (@eq_refl _ i); auto.\n    apply proof_irrelevance.\n  - contradiction.\nQed.\n\nTheorem fst_direct_image_cartesian {X Y} (A : Ensemble X) (B : Ensemble Y) y\n  : y \u2208 B -> fst\u00b9 (A \u00d7 B) = A.\nProof.\n  intros ?. setext. unset. split.\n  - now intros ? [[x' y'] [[] ->]].\n  - intros x. now exists (x, y).\nQed.\n\nTheorem snd_direct_image_cartesian {X Y} (A : Ensemble X) (B : Ensemble Y) x\n  : x \u2208 A -> snd\u00b9 (A \u00d7 B) = B.\nProof.\n  intros ?. setext. unset. split.\n  - now intros ? [[x' y'] [[] ->]].\n  - intros y. now exists (x, y).\nQed.\n\nTheorem projection_direct_image_cartesian {I E} (F : forall (i : I), Ensemble (E i)) i\n  : (forall i, exists x, x \u2208 F i) -> (fun f => f i)\u00b9 (FamilyCartesian F) = F i.\nProof.\n  intros ?. setext. unset. split.\n  - now intros x [f [? ->]].\n  - intros x ?.\n    assert (exists f, forall i, f i \u2208 F i) as [f].\n    {\n      now apply choice_dependent.\n    }\n    apply classic_set_in_prop_context. intros lem.\n    exists (fun j => match lem (i = j) with\n                     | left e => eq_rect _ E x _ e\n                     | right _ => f j\n                     end).\n    split.\n    + intros j. destruct lem as [-> | ]; auto.\n    + destruct lem as [e | ].\n      * replace e with (@eq_refl _ i); auto.\n        apply proof_irrelevance.\n      * contradiction.\nQed.\n\nTheorem fst_preimage {X Y} (A : Ensemble X)\n  : fst\u207b\u00b9 A = A \u00d7 \u22a4 :> Ensemble (X * Y).",
      "suffix": "\n\nTheorem snd_preimage {X Y} (A : Ensemble Y)\n  : snd\u207b\u00b9 A = \u22a4 \u00d7 A :> Ensemble (X * Y).\nProof. setsolve. Qed.\n\nTheorem projection_preimage {I E} (F : forall (i : I), Ensemble (E i)) i (A : Ensemble (E i))\n  : (fun (f : forall i, E i) => f i)\u207b\u00b9 A = \u220f j => EnsembleLEM (i = j) (eq_rect _ (fun i => Ensemble (E i)) A _) (fun _ => \u22a4).\nProof.\n  setext. unset. split.\n  - intros f ? j.\n    destruct (classic (i = j)) as [p | p].\n    + rewrite (ensemble_lem_true _ _ p).\n      now destruct p.\n    + now rewrite (ensemble_lem_false _ _ p).\n  - intros f u. specialize (u i).\n    now rewrite (ensemble_lem_true _ _ eq_refl) in u.\nQed.\n",
      "theorem": "Theorem fst_preimage {X Y} (A : Ensemble X)\n  : fst\u207b\u00b9 A = A \u00d7 \u22a4 :> Ensemble (X * Y).",
      "ground_truth": "Proof. setsolve. Qed."
    },
    {
      "split": "train-sft",
      "index": 26,
      "prefix": "(**\nMathComp \u306e \u7a7a\u96c6\u5408 \u306b\u3064\u3044\u3066\n======\n2019/05/02\n\n\u3053\u306e\u6587\u66f8\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306f\u4ee5\u4e0b\u306b\u3042\u308a\u307e\u3059\u3002\n\n\nhttps://github.com/suharahiromichi/coq/blob/master/pearl/ssr_set0_notP.v\n\n *)\n\n(**\nOCaml 4.07.1, Coq 8.9.0, MathComp 1.9.0\n *)\n\n(**\n# \u8aac\u660e\n\nMathComp \u3067\u3001\u578b ``T : finType`` \u3092\u5168\u4f53\u96c6\u5408\u3068\u3059\u308b\u3068\u304d\u3001\n\u578b ``T -> bool`` \u306e\u95a2\u6570\u3001\u3059\u306a\u308f\u3061\u8ff0\u8a9e ``p : pred T`` \n\u3067\u6c7a\u307e\u308b\u90e8\u5206\u96c6\u5408\u3092\u8003\u3048\u307e\u3059\u3002\n\n\u305d\u306e\u90e8\u5206\u96c6\u5408\u304c\u7a7a\u96c6\u5408\u3001\u3042\u308b\u3044\u306f\u3001\u6fc3\u5ea6\u304c0\u3067\u3042\u308b\u5834\u5408\u3001\n\u8ff0\u8a9e ``p`` \u306f\u5e38\u306b ``false`` \u3092\u8fd4\u3059\u306f\u305a\u3067\u3059\u3002\n\u305d\u308c\u3092\u8a3c\u660e\u3057\u3066\u307f\u307e\u3059\u3002\n\nMathComp \u3067\u306f\u3001\u7a7a\u96c6\u5408\u306f``set0``\u3001\u96c6\u5408\u306e\u6fc3\u5ea6\u306f ``#|_|`` \u3067\u8868\u73fe\u3057\u307e\u3059\u3002\n*)\n\n(**\n# \u30b3\u30fc\u30c9\u4f8b\n\n## \u7a7a\u96c6\u5408\u306e\u5834\u5408\u306b\u3064\u3044\u3066\u306e\u8a3c\u660e\n\n\u8a3c\u660e\u305d\u306e\u3082\u306e\u306f\u30b9\u30c8\u30ec\u30fc\u30c8\u3067\u3059\u304c\u3001\nsetP \u3084 inE \u3068\u3044\u3046\u3001\u77e5\u3089\u306a\u3051\u308c\u3070\u4f7f\u3048\u306a\u3044\u88dc\u984c\u304c\u5fc5\u9808\u306b\u306a\u308b\u4f8b\u3067\u3059\u3002\n *)\n\nFrom mathcomp Require Import all_ssreflect.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n(* Set Print All. *)\n\nSection Test.\n\n  Lemma set0_notPP (A : finType) (p : pred A) :\n    [set x | p x] = set0 <-> (forall x, ~ p x).\n  Proof.\n    split.\n    - move/setP => H x.\n      move: (H x) => {H}.\n      rewrite 2!inE.\n        by move/idP.\n      \n    - move=> H.\n      apply/setP => x.\n      rewrite 2!inE.\n        by apply/idP.\n  Qed.\n\n(**\nsetP \u306f\u3001\u3075\u305f\u3064\u306e\u96c6\u5408\u304c\u7b49\u3057\u3044\u3068\u304d\u306bbool\u5024\u306etrue\u3092\u8fd4\u3059 ``=i`` \u3068\u3001\nCoq\u672c\u6765\u306eProp\u578b\u306e\u7b49\u5f0f ``=`` \u304c\u540c\u5024\u3067\u3042\u308b\u3053\u3092\u793a\u3057\u307e\u3059\u3002\n *)\n  \n  Check setP : forall (T : finType) (A B : {set T}), A =i B <-> A = B.\n\n(**\n\u3053\u308c\u3092\u3064\u304b\u3063\u3066\u3001\n``[set x | p x] = set0`` \u3092 ``[set x | p x] =i set0``\n \u306b\u66f8\u304d\u63db\u3048\u3066\u3044\u307e\u3059\u3002\n\n\u3053\u306e\u3088\u3046\u306b\u66f8\u304d\u63db\u3048\u308b\u3068\u3001x \u3092\u9069\u7528\u3059\u308b\uff08\u524d\u63d0\u306e\u5834\u5408\uff09\u3001\n\u307e\u305f\u306f\u3001x \u3092 intro\u3059\u308b\uff08\u30b4\u30fc\u30eb\u306e\u5834\u5408\uff09\u3068\n``(x \\in [set x0 | p x0]) = (x \\in set0)``\n\u306e\u3088\u3046\u306b\u3001``\\in`` \uff08\u2208) \u306e\u8868\u8a18\u306b\u76f4\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\n*)\n\n(**\n\u4e00\u65b9\u3001inE \u306f\u3001\u8907\u96d1\u3067\u4e2d\u3092\u307f\u3066\u3082\u3088\u304f\u308f\u304b\u308a\u307e\u305b\u3093\u304c\u3001\n``x \\in [set x0 | p x0]`` \u3092 ``p x`` \n\u306b\u66f8\u304d\u63db\u3048\u307e\u3059\u3002\n\n- ``\\in`` \u306e\u53f3\u306f\u3001\u8ff0\u8a9e p \uff08\u5b9f\u969b\u306f A -> bool \u306e\u95a2\u6570\uff09\u304c true \u3068\u306a\u308b\u5024\u306e\u96c6\u5408\n- ``\\in`` \u306e\u5de6\u306e ``x`` \u306f\u3001\u4e0a\u8a18\u306e\u8981\u7d20\n\n\u3067\u3042\u308b\u306e\u3067\u3001x \u306b\u3064\u3044\u3066 \u8ff0\u8a9e p \u304c true \u3068\u306a\u308a\u307e\u3059\u3002\u3059\u306a\u308f\u3061 ``p x`` \u306b\u306a\u308b\u308f\u3051\u3067\u3059\u3002\n *)\n\n(**\n\u4e00\u65b9\u3001\u7a7a\u96c6\u5408 ``set0`` \u306f\u3001``[set x0 | false]`` \u3067\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u3059\u304b\u3089\u3001\n``x \\in set0`` \u306f\u3001\u5358\u306b ``false`` \u306b\u306a\u308a\u307e\u3059\u3002\n *)\n\n(**\n``2!`` \u3092\u3064\u3051\u308b\u3053\u3068\u3067\u3001\u7b49\u5f0f\u306e\u5de6\u8fba\u3068\u53f3\u8fba\u306e\u4e21\u65b9\u306b\u9069\u7528\u3057\u307e\u3059\u3002\n\n\u6700\u5f8c\u306f\u3001``p x = false`` \u3092 idP \u3092\u4f7f\u3063\u3066 ``~ (p x)`` \u306b\u5909\u63db\u3059\u308b\u3053\u3068\u3067\u3001\n\u8a3c\u660e\u304b\u7d42\u308f\u308a\u307e\u3059\u3002\n *)\n\n  Check @idP : forall b1 : bool, reflect (b1 = true) b1.\n\n(**\nidP \u306f\u3001Prop\u578b\u3068bool\u578b\u306e\u9593\u3067\uff08\u306a\u306b\u3082\u3057\u306a\u3044\uff09\u30ea\u30d5\u30ec\u30af\u30c8\u88dc\u984c\u3067\u3059\u304c\u3001\n\u3053\u308c\u3092\u3001\u524d\u63d0\u306b\u5bfe\u3057\u3066 ``move/idP`` \u3068view\u3068\u3057\u3066\u4f7f\u3046\u3053\u3068\u3067\u3001elimF \u304c\u88dc\u308f\u308c\u3066\u3001\n\u524d\u63d0\u306e ``p x = false`` \u304c ``~ p x`` \u3068\u306a\u308a\u307e\u3059\u3002\n *)\n\n  Check elimF idP : _ = false -> ~ _.\n\n(**\n\u540c\u69d8\u306b\u3001\u30b4\u30fc\u30eb\u306e\u5bfe\u3057\u3066 ``apply/idP`` \u3068view\u3068\u3057\u3066\u4f7f\u3046\u3053\u3068\u3067\u3001introF \u304c\u88dc\u308f\u308c\u3066\u3001\n\u30b4\u30fc\u30eb\u306e ``p x = false`` \u304c ``~ p x`` \u3068\u306a\u308a\u307e\u3059\u3002\n *)\n  \n  Check introF idP : ~ _ -> _ = false.\n\n\n(**\n## MathComp \u98a8\u306e\u88dc\u984c\n\nMathComp \u98a8\u306b\u3001booelan \u306e\u7b49\u5f0f\u306b\u3057\u305f\u88dc\u984c\u3082\u8a3c\u660e\u3057\u3066\u307f\u307e\u3059\u3002\n *)\n\n  Lemma set0_notPE (A : finType) (p : pred A) :\n    ([set x | p x] == set0) = [forall x, ~~ p x].\n  Proof.\n    apply/idP/idP.\n    - move/eqP => H.\n      apply/forallP => x.\n      apply/negP.\n      move: x.\n        by apply/set0_notPP.\n\n    - move=> H.\n      apply/eqP/set0_notPP.\n      move/forallP in H.\n      move=> x.\n        by apply/negP.\n  Qed.\n  \n(**\n## \u5fdc\u7528\n\n\u4e0a\u8a18\u306e\u88dc\u984c\u3092\u4f7f\u7528\u3057\u3066\u3001\u5225\u306a\u306a\u8868\u8a18\u306e\u5834\u5408\u306b\u3064\u3044\u3066\u3082\u8a3c\u660e\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n *)\n  \n  Lemma set0_notP' (A : finType) (p : pred A) :\n    ([set x in p] == set0) = [forall x, ~~ p x].\n  Proof.\n      by apply: set0_notPE.\n  Qed.\n\n(**\n   \u4e0a\u8a18\u306e\u69cb\u6587\u7cd6\u3067\u3059\u3002\n *)\n  \n  Lemma set0_notP'' (A : finType) (p : pred A) :\n    ([set x | x \\in p] == set0) = [forall x, ~~ p x].",
      "suffix": "  \n\n\n(**\n## \u6fc3\u5ea6\u304c0\u3067\u3042\u308b\u5834\u5408\u306b\u3064\u3044\u3066\u306e\u8a3c\u660e    \n\n\u7a7a\u96c6\u5408\u3067\u3042\u308b\u3053\u3068\u3068\u6fc3\u5ea6\u304c0\u3067\u3042\u308b\u3053\u3068\u306f\u540c\u5024\u3067\u3059\u304c\u3001\u305d\u308c\u306b\u3064\u3044\u3066\u3082\u8a3c\u660e\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n*)\n\n  Lemma card0_notP (A : finType) (p : pred A) :\n    (#|[set x in p]| == 0) = [forall x, ~~ p x].\n  Proof.\n    rewrite cards_eq0.\n    apply: set0_notPE.\n  Qed.\n\n\n(**\n## \u88dc\u8db3\n\nset0_notP' \u3092\u76f4\u63a5\u8a3c\u660e\u3059\u308b\n*)\n\n  Lemma p__inp (A : finType) (p : pred A) :\n    (forall x : A, p x) <-> (forall x, (x \\in p)).\n  Proof.\n    done.\n  Qed.\n  \n  Lemma np__ninp (A : finType) (p : pred A) :\n    (forall x : A, ~ p x) <-> (forall x, (x \\in p) = false).\n  Proof.\n    split => H x; move: (H x) => {H} H.\n    - apply: (@contraFF (x \\in p) (p x)).\n      + done.                               (* x \\in p -> p x *)\n      + by apply/negbTE/negP.\n    - move/(@contraFN (p x) (x \\in p)) in H.\n      apply/negP/H.\n      done.                                 (* p x -> x \\in p *)\n  Qed.\n  \n(**\n# \u6700\u521d\u306b\u4f7f\u3063\u305f\u7b87\u6240\n\nFRAP Map.v \u306e MathComp \u3078\u306e\u79fb\u690d\n\nhttps://github.com/suharahiromichi/coq/blob/master/frap/ssr_map.v\n*)\n\n\n(**\n# \u4f8b\u984c\n\noption\u578b\u3092\u8fd4\u3059\uff08\u90e8\u5206\uff09\u95a2\u6570 m \u304c\u3042\u308b\u3068\u3057\u307e\u3059\u3002\n\u305d\u306e\u30c9\u30e1\u30a4\u30f3\uff08Some _ \u3092\u8fd4\u3059\u5f15\u6570\uff09\u306e\u96c6\u5408 dom \u3092\u8003\u3048\u307e\u3059\u3002\n\n\u3053\u306e\u3068\u304d\u3001\noption\u578b\u306f\u3001eqType \u3068\u306f\u9650\u3089\u306a\u3044\u306e\u3067\u3001Some _ \u304b None \u304b\u3069\u3046\u304b\u3067 true \u304b false \u3092\u6c7a\u5b9a\u3059\u308b\n\u95a2\u6570 option_dec \u3092\u7528\u610f\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n\u95a2\u6570 m \u306e\u30c9\u30e1\u30a4\u30f3\u304c\u7a7a\u96c6\u5408\u3067\u3042\u308b\u5834\u5408\u3001m \u306f\u3059\u3079\u3066\u306e\u5f15\u6570\u306b\u5bfe\u3057\u3066 None \u3092\u8fd4\u3059\n(option_dec \u304c false) \u306b\u306a\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u307e\u3059\u3002\n*)\n  \n  Definition fmap (A : finType) (B : Type) := A -> option B.\n\n  Definition option_dec B (x : option B) :=\n    match x with\n    | Some _ => true\n    | None => false\n    end.\n  \n  Definition dom A B (m : fmap A B) : {set A} := [set x | option_dec (m x)].\n\n  Lemma domE A B (m : fmap A B) :\n    (dom m == set0) = ([forall k, option_dec (m k) == false]).\n  Proof.\n    apply/idP/idP => H.\n    \n    - apply/forallP => x.\n      rewrite eqbF_neg.\n\n      rewrite set0_notPE in H.\n      move/forallP in H.\n      move: (H x) => {H} H.\n      done.\n      \n    - rewrite set0_notPE.\n      apply/forallP => x.\n      \n      move/forallP in H.\n      move: (H x) => {H} H.\n      rewrite eqbF_neg in H.\n      done.\n  Qed.\n\nEnd Test.\n\n(* END *)\n",
      "theorem": "Lemma set0_notP'' (A : finType) (p : pred A) :\n    ([set x | x \\in p] == set0) = [forall x, ~~ p x].",
      "ground_truth": "Proof.\n      by apply: set0_notPE.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 27,
      "prefix": "From Coq Require Import Lia.\nDefinition dec (X: Type) : Type := X + (X -> False).\nDefinition eqdec X := forall x y: X, dec (x = y).\nDefinition decider {X} (p: X -> Type) := forall x, dec (p x).\nNotation sig := sigT.\nNotation Sig := existT.\nNotation pi1 := projT1.\nNotation pi2 := projT2.\nNotation \"'Sigma' x .. y , p\" :=\n  (sigT (fun x => .. (sigT (fun y => p%type)) ..))\n    (at level 200, x binder, right associativity,\n     format \"'[' 'Sigma'  '/  ' x  ..  y ,  '/  ' p ']'\")\n    : type_scope.\n\n\nDefinition inv {X Y: Type} (g: Y -> X) (f: X -> Y) := forall x, g (f x) = x.\nInductive injection (X Y: Type) : Type :=\n| Injection {f: X -> Y} {g: Y -> X} (_: inv g f).\n\n(*** EWO Basics *)\n\nDefinition ewo (X:Type) :=\n  forall p: X -> Prop, decider p -> ex p -> sig p.\n\nFact bot_ewo:\n  ewo False.\nProof.\n  intros p _ [[] _].\n  (* note computational falsity elimination *)\nQed.\n\nGoal ewo True.\nProof.\n  intros p d H.\n  destruct (d I) as [H1|H1].\n  - eauto.\n  - exfalso. destruct H as [[] H]. auto.\n    (* note computational falsity elimination *)\nQed.\n\nGoal ewo bool.\nProof.\n  intros p d H.\n  destruct (d true) as [H1|H1].\n  - eauto.\n  - destruct (d false) as [H2|H2].\n    + eauto.\n    + exfalso. destruct H as [[|] H]; auto.\n      (* note computational falsity elimination *)\nQed.\n\nTheorem ewo_or X (p q: X -> Prop) :\n  ewo X -> decider p -> decider q -> ex p \\/ ex q -> sig p + sig q.\nProof.\n    intros E dp dq H.\n    destruct (E (fun x => p x \\/ q x)) as [x H1].\n    - intros x. unfold dec.\n      destruct (dp x) as [H1|H1]. { auto. }\n      destruct (dq x) as [H2|H2]. { auto. }\n      tauto.\n    - destruct H as  [[x H]|[x H]]; eauto.\n    - destruct (dp x) as [H2|H2]. { eauto. }\n      destruct (dq x) as [H3|H3]. { eauto. }\n      exfalso. tauto.\nQed.\n\nDefinition option_ewo {X} :\n  ewo X -> ewo (option X).\nProof.\n  intros E p p_dec H.\n  destruct (p_dec None) as [H1|H1].\n  - eauto.\n  - destruct (E (fun x => p (Some x))) as [x H2].\n    + easy. \n    + destruct H as [[x|] H].\n      * eauto.\n      * easy.\n    + eauto.\nQed.\n\nDefinition option_ewo' {X} :\n  ewo (option X) -> ewo X.\nProof.\n  intros E p p_dec H.\n  destruct (E (fun a => match a with Some x => p x | none => False end)) as [[x|] H1].\n  - intros [x|].\n      + easy.\n      + right; easy.\n  - destruct H as [x H]. exists (Some x); exact H.\n  - eauto.\n  - easy.\nQed.\n\nFixpoint Fin n : Type :=\n  match n with 0 => False | S n' => option (Fin n') end.\n\nFact Fin_ewo :\n  forall n, ewo (Fin n).\nProof.\n  induction n as [|n IH]; cbn.\n  - apply bot_ewo.\n  - apply option_ewo, IH.\nQed.\n\nFact injection_ewo X Y :\n  injection X Y -> ewo Y -> ewo X.\nProof.\n  intros [f g H] E p p_dec H1.\n  destruct (E (fun y => p (g y))) as [y H2].\n  - easy.\n  - destruct H1 as [x H1]. exists (f x). congruence.\n  - eauto.\nQed.\n\n\n(*** Inverse functions via EWOs *)\n\nDefinition injective {X Y} (f: X -> Y) :=\n  forall x x', f x = f x' -> x = x'.\nDefinition surjective {X Y} (f: X -> Y) :=\n  forall y, exists x, f x = y.\nDefinition bijective {X Y} (f: X -> Y) :=\n  injective f /\\ surjective f.\n\nFact surjective_inv {X Y f} :\n  @surjective X Y f -> ewo X -> eqdec Y -> Sigma g, inv f g.\nProof.\n  intros H e d.\n  enough (G: forall y, Sigma x, f x = y).\n  { exists (fun y => pi1 (G y)). intros y. apply (pi2 (G y)). }\n  intros y. apply e.\n  - intros x. apply d.\n  - apply H. \nQed.\n\nFact bijective_inv X Y f :\n  @bijective X Y f -> ewo X -> eqdec Y -> Sigma g, inv g f /\\ inv f g.\nProof.\n  intros [H1 H2] e d.\n  destruct (surjective_inv H2 e d) as [g H3].\n  exists g. split. 2:exact H3.\n  intros x. apply H1. congruence.\nQed.\n  \n(*** Linear Search Types and EWO for nat *)\n\nModule EWO_nat.\nSection EWO_nat.\n  Variable p: nat -> Prop.\n  Variable p_dec: decider p.\n\n  Inductive T (n: nat) : Prop := C (phi: ~p n -> T (S n)).\n\n  Lemma T_base n :\n    p n -> T n.\n  Proof.\n    intros H. constructor. intros H1. destruct (H1 H).\n  Qed.\n\n  Lemma T_step n :\n    T (S n) -> T n.\n  Proof.\n    intros H. constructor. intros _. exact H.\n  Qed.\n\n  Lemma T_zero n :\n    T n -> T 0.\n  Proof.\n    induction n as [|n IH].\n    - auto.\n    - intros H. apply IH. apply T_step, H.\n  Qed.\n\n  Lemma V n :\n    p n -> T 0.\n  Proof.\n    intros H. eapply T_zero, T_base, H.\n  Qed.\n\n  Definition W'\n    : forall n, T n -> sig p\n    := fix f n a := let (phi) := a in\n                    match p_dec n with\n                    | inl h => (Sig p n h)\n                    | inr h => f (S n) (phi h)\n                    end.\n\n  Theorem W :\n    ex p -> sig p.\n  Proof.\n    intros H. apply (W' 0).\n    destruct H as [n H].\n    apply (V n), H.\n  Qed.\n\n  (* Eliminator generalizing W' *)\n  \n  Definition elim_T (q: nat -> Type)\n    : (forall n, (~p n -> q (S n)) -> q n) ->\n      forall n, T n -> q n\n    := fun e => fix f n a := let (phi) := a in e n (fun h => f (S n) (phi h)).\n\n  Fact W'_elim_T_agree :\n    W' = elim_T (fun _ => sig p)\n           (fun n f => match p_dec n with\n                    | inl h => (Sig p n h)\n                    | inr h => f h\n                    end).\n  Proof.\n    reflexivity.\n  Qed.\n \n  Fact elim_T_unfold q e n phi :\n    elim_T q e n (C n phi) = e n (fun h => elim_T q e (S n) (phi h)).",
      "suffix": "\n  \n  Goal forall n, T n -> sig p.\n  Proof.\n    refine (elim_T _ (fun n IH => _)). cbn in IH.\n    destruct (p_dec n) as [H|H].\n    - exists n. exact H.\n    - exact (IH H).\n  Qed.\n\n  (** Existential characterisation of T *)\n\n  Fact T_step_add k n :\n    T (k + n) -> T n.\n  Proof.\n    induction k as [|k IH].\n    - auto. \n    - intros H. apply IH, T_step, H.\n  Qed.\n\n  Fact T_p_zero n :\n    p n -> T 0.\n  Proof.\n    intros H%T_base%T_zero. exact H.\n  Qed.\n\n  Fact T_ex_ge n :\n    T n <-> exists k, k >= n /\\ p k.\n  Proof.\n    split.\n    - revert n.\n      refine (elim_T _ (fun n IH => _)). cbn in IH.\n      destruct (p_dec n) as [H|H].\n      + exists n. auto.\n      + destruct (IH H) as (k&H1&H2).\n        exists k. split. lia. exact H2.\n    - intros (k&H1&H2). apply (T_step_add (k - n)).\n      replace (k - n + n) with k by lia.\n      constructor. easy. \n  Qed.\n\n  (* Padding *)\n  \n  Definition pad3 n (d: T n) : T n :=\n    C n (fun h => C (S n) (fun h1 => C (S (S n)) (fun h2 =>\n       let (phi) := d in\n       let (phi1) := phi h in\n       let (phi2) := phi1 h1 in\n       phi2 h2))).\n\nEnd EWO_nat.\nEnd EWO_nat.\n\nFact ewo_nat : ewo nat.\nProof.\n  exact EWO_nat.W.\nQed.\n\nFact ewo_injection_nat X :\n  injection X nat -> ewo X.\nProof.\n  intros H %injection_ewo. apply H. apply ewo_nat.\nQed.\n    \n\n(*** More EWOs *)\n\nFact ewo_binary :\n  injection (nat * nat) nat ->\n  forall p: nat -> nat -> Prop,\n  forall d: forall x y, dec (p x y),\n    (exists x y, p x y) -> Sigma x y, p x y.\nProof.\n  intros E %injection_ewo. 2:exact ewo_nat.\n  intros p d H.\n  pose (q a := p (fst a) (snd a)).\n  specialize (E (fun a => p (fst a) (snd a))) as [[x y] E].\n  - intros [x y]. apply d.\n  - destruct H as (x&y&H). exists (x,y). exact H.\n  - eauto.\nQed.\n\nSection Step_indexed_eqdec.\n  Variable X: Type.\n  Variable f: X -> X -> nat -> bool.\n  Variable f_prop: forall x y, x = y <-> exists n, f x y n = true.\n  Goal eqdec X.\n  Proof.\n    intros x y.\n    enough (Sigma n, f x x n = true) as [n H].\n    { destruct (f x y n) eqn:H1.\n      - left. apply f_prop. exists n. exact H1.\n      - right. intros <-. congruence. }\n    apply ewo_nat.\n    - intros n.\n      destruct (f x x n).\n      + left. auto.\n      + right. intros [=].\n    - apply f_prop. reflexivity.\n  Qed.\nEnd Step_indexed_eqdec.\n",
      "theorem": "Fact elim_T_unfold q e n phi :\n    elim_T q e n (C n phi) = e n (fun h => elim_T q e (S n) (phi h)).",
      "ground_truth": "Proof.\n    reflexivity.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 28,
      "prefix": "\n(** * Extra lemmas for seq *)\n\nFrom Coq Require Import List Relations Morphisms.\nFrom mathcomp Require Import ssreflect ssrbool ssrnat seq eqtype ssrfun.\nFrom ssrlib Require Import Compatibility Lists.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\n(** Lemmas for sequences of Type *)\n\nSection SeqLemmas.\n\n  Variable A : Type.\n\n  Variable B : Type.\n\n  Variable default : A.\n\n  Lemma in_cat (x : A) (s1 s2 : seq A) :\n    In x (s1 ++ s2) -> In x s1 \\/ In x s2.\n  Proof.\n    elim: s1 s2 => [| y s1 IH] s2 /=.\n    - move=> H; right; assumption.\n    - case => H.\n      + left; left; assumption.\n      + case: (IH _ H) => {}H.\n        * left; right; assumption.\n        * right; assumption.\n  Qed.\n\n  Lemma in_cat_l (x : A) (s1 s2 : seq A) :\n    In x s1 -> In x (s1 ++ s2).\n  Proof.\n    elim: s1 s2 => [| y s1 IH] s2 //=. case => H.\n    + left; assumption.\n    + right; exact: (IH _ H).\n  Qed.\n\n  Lemma in_cat_r (x : A) (s1 s2 : seq A) :\n    In x s2 -> In x (s1 ++ s2).\n  Proof.\n    elim: s1 s2 => [| y s1 IH] s2 //=. move=> H; right; exact: (IH _ H).\n  Qed.\n\n  Lemma in_singleton (x y : A) :\n    In x [:: y] -> x = y.\n  Proof. by case => //=. Qed.\n\n  Lemma singleton_seq (l : seq A) :\n    size l = 1%N -> exists x : A, l = x :: nil.\n  Proof.\n    elim: l => //=.\n    move=> hd tl; elim tl => //=.\n    move=> _ _; exists hd.\n    reflexivity.\n  Qed.\n\n  Lemma last_decomp (l : seq A) (n : nat) :\n    size l = (n + 1)%N -> exists s x, l = rcons s x.\n  Proof.\n    move: l n. apply: last_ind => /=.\n    - by case.\n    - move=> l x IH n H. exists l; exists x; reflexivity.\n  Qed.\n\n  Lemma last_default_irrelevant (l : seq A) (n : nat) b1 b2 :\n    size l = (n + 1)%N -> last b1 l = last b2 l.\n  Proof.\n    move: l n b1 b2. apply: last_ind => /=.\n    - move=> n b1 b2; by case n.\n    - move=> l lst IH n b1 b2 H. rewrite !last_rcons. reflexivity.\n  Qed.\n\n  Lemma nth_cons (x : A) (l : list A) (n : nat) :\n    0 < n -> nth default (x::l) n = nth default l (n - 1).\n  Proof. case: n => //=. move=> n _. by rewrite subn1 -pred_Sn. Qed.\n\n  Lemma nth_tl (l : list A) (n : nat) : nth default (tl l) n = nth default l (n + 1).\n  Proof.\n    case: l => [| x l] //=.\n    - by rewrite 2!nth_nil.\n    - rewrite nth_cons; last by rewrite addn_gt0 orbT. by rewrite addn1 subn1 -pred_Sn.\n  Qed.\n\n  Lemma drop_take (s : seq A) n m :\n    n <= m -> m < size s -> drop (m - n) (take m s) = take n (drop (m - n) s).\n  Proof.\n    elim: s n m => [| x s IH] n m Hnm Hms //. rewrite /= in Hms.\n    case: m Hnm Hms.\n    - rewrite leqn0 => /eqP ->. rewrite subnn drop0 take0. reflexivity.\n    - move=> m Hnm Hms. rewrite -(addn1 m) -(addn1 (size s)) ltn_add2r in Hms.\n      rewrite leq_eqVlt in Hnm. case/orP: Hnm => Hnm.\n      + rewrite (eqP Hnm) subnn !drop0. reflexivity.\n      + rewrite ltnS in Hnm. rewrite take_cons. rewrite !(subSn Hnm) !drop_cons.\n        exact: (IH _ _ Hnm Hms).\n  Qed.\n\n  Lemma take_take (s : seq A) (n m : nat) : take n (take m s) = take (minn n m) s.\n  Proof.\n    elim: s n m => [| x s IH] n m //.\n    case: m => [| m] //. case: n => [| n] //. rewrite minnSS.\n    rewrite !take_cons. rewrite IH. reflexivity.\n  Qed.\n\n  Lemma nseq_addn (x : A) n m : nseq (n + m) x = nseq n x ++ nseq m x.\n  Proof.\n    elim: n m => [| n IHn] m //=. rewrite IHn. reflexivity.\n  Qed.\n\n  Lemma drop_nseq (x : A) n m : drop n (nseq m x) = nseq (m - n) x.\n  Proof.\n    case Hnm: (m <= n).\n    - rewrite -{1}(subnK Hnm). rewrite -drop_drop.\n      have Hm: m = size (nseq m x) by rewrite size_nseq.\n      rewrite {2}Hm. rewrite drop_size /=. rewrite -subn_eq0 in Hnm.\n      rewrite (eqP Hnm) /=. reflexivity.\n    - move/idP/negP: Hnm. rewrite -ltnNge => Hnm. move: (subnK (ltnW Hnm)) => H.\n      rewrite -{1}H. rewrite addnC nseq_addn.\n      rewrite drop_size_cat; last by rewrite size_nseq. reflexivity.\n  Qed.\n\n  Lemma take_nseq (x : A) n m : take n (nseq m x) = nseq (minn n m) x.\n  Proof.\n    case Hnm: (n <= m).\n    - move/minn_idPl: (Hnm) => ->. move: (subnK Hnm) => <-.\n      rewrite addnC nseq_addn. rewrite take_size_cat; last by rewrite size_nseq.\n      reflexivity.\n    - move/idP/negP: Hnm. rewrite -ltnNge => Hnm.\n      move/minn_idPr: (ltnW Hnm) => ->. rewrite take_oversize; first by reflexivity.\n      rewrite size_nseq. exact: (ltnW Hnm).\n  Qed.\n\n  Lemma drop_nseq_more (s : seq A) (x : A) n m :\n    n <= m -> drop n s = nseq (size s - n) x -> drop m s = nseq (size s - m) x.\n  Proof.\n    move=> Hmn Hdn. move: (subnK Hmn) => H. rewrite -{1}H.\n    rewrite -drop_drop. rewrite Hdn. rewrite drop_nseq. rewrite -subnDA.\n    rewrite addnC H. reflexivity.\n  Qed.\n\n  Lemma take_nseq_less_minn (s : seq A) (x : A) n m :\n    m <= n -> take n s = nseq (minn n (size s)) x ->\n    take m s = nseq (minn m (size s)) x.\n  Proof.\n    move=> Hmn. case Hns: (n <= size s).\n    - move/minn_idPl: (Hns) => ->. move/minn_idPl: (leq_trans Hmn Hns) => ->.\n      elim: s n m Hmn Hns => [| e s IH] n m Hmn Hns.\n      + rewrite leqn0 in Hns. rewrite (eqP Hns) in Hmn.\n        rewrite leqn0 in Hmn. rewrite (eqP Hmn). reflexivity.\n      + case: n Hmn Hns => [| n] Hmn Hns.\n        * rewrite leqn0 in Hmn. rewrite (eqP Hmn). reflexivity.\n        * case: m Hmn => [| m] Hmn.\n          -- reflexivity.\n          -- rewrite /= !ltnS in Hmn Hns. rewrite !take_cons.\n             rewrite -(addn1 n) -(addn1 m). rewrite (addnC n) (addnC m).\n             rewrite !nseq_addn /=. case => -> H.\n             rewrite (IH _ _ Hmn Hns H). reflexivity.\n    - move/idP/negP: Hns. rewrite -ltnNge => Hsn. move/minn_idPr: (ltnW Hsn) => ->.\n      rewrite (take_oversize (ltnW Hsn)). move=> ->. rewrite size_nseq.\n      case Hms: (m <= size s).\n      + rewrite take_nseq. move/minn_idPl: (Hms) => ->. reflexivity.\n      + move/idP/negP: Hms. rewrite -ltnNge => Hsm. move/minn_idPr: (ltnW Hsm) => ->.\n        rewrite take_oversize; first reflexivity.\n        rewrite size_nseq. exact: (ltnW Hsm).\n  Qed.\n\n  Lemma take_nseq_less (s : seq A) (x : A) n m :\n    m <= n -> n <= size s -> take n s = nseq n x -> take m s = nseq m x.\n  Proof.\n    move=> Hmn Hns. move/minn_idPl: (leq_trans Hmn Hns) => {2}<-.\n    move/minn_idPl: (Hns) => {2}<-. exact: (take_nseq_less_minn Hmn).\n  Qed.\n\n  Lemma catsl_inj (s1 s2 s3 : seq A) : s1 ++ s2 = s1 ++ s3 -> s2 = s3.\n  Proof. elim: s1 s2 s3 => [| hd tl IH] s2 s3 //=. case. exact: IH. Qed.\n\n  Lemma catsr_inj (s1 s2 s3 : seq A) : s2 ++ s1 = s3 ++ s1 -> s2 = s3.\n  Proof.\n    elim: s1 s2 s3 => [| hd tl IH] s2 s3 /=.\n    - rewrite !cats0. by apply.\n    - rewrite -!cat_rcons. move=> H. move: (IH _ _ H) => {} H.\n      move: (rcons_inj H). case. by apply.\n  Qed.\n\n  Lemma In_rcons x (s : seq A) l :\n    List.In x (rcons s l) <-> List.In x s \\/ x = l.\n  Proof.\n    elim: s => [| hd tl IH] /=.\n    - split; case=> H //=.\n      + right. symmetry. assumption.\n      + left; symmetry. assumption.\n    - move: IH=> [IH1 IH2]. split; case => H /=.\n      + left; left. assumption.\n      + case: (IH1 H) => {} H.\n        * left; right; assumption.\n        * right; assumption.\n      + case: H => H.\n        * left; assumption.\n        * right. exact: (IH2 (or_introl H)).\n      + right. exact: (IH2 (or_intror H)).\n  Qed.\n\n  Lemma incl_consl (a : A) (l m : seq A) :\n    incl (a :: l) m -> In a m /\\ incl l m.\n  Proof.\n    move=> H. split.\n    - apply: (H a). exact: in_eq.\n    - move=> x Hinx. apply: (H x). apply: List.in_cons. assumption.\n  Qed.\n\n  Lemma incl_empty (s : seq A) :\n    incl s [::] -> s = [::].\n  Proof.\n    elim: s => [| x s IH] //=. move=> H. move: (incl_consl H) => [H1 H2].\n    apply: False_ind. exact: (List.in_nil H1).\n  Qed.\n\n  Lemma split_cons (x : A * B) (s : seq (A * B)) :\n    split (x::s) = (x.1::(split s).1, x.2::(split s).2).\n  Proof.\n    rewrite /=. case Hs: (split s) => [sa sb] /=. case: x => [xa xb] /=.\n    reflexivity.\n  Qed.\n\n  Lemma split_cat (s1 s2 : seq (A * B)) :\n    split (s1 ++ s2) = ((split s1).1 ++ (split s2).1, (split s1).2 ++ (split s2).2).\n  Proof.\n    elim: s1 => [| [hd1a hd1b] tl1 IH] //=.\n    - by case: (split s2).\n    - move: IH. case: (split (tl1 ++ s2)) => [cs1 cs2].\n      case: (split tl1) => [tl11 tl12]. case: (split s2) => [tl21 tl22] /=.\n      case=> ? ?; subst. reflexivity.\n  Qed.\n\n  Lemma split_rcons (s : seq (A * B)) (x : A * B) :\n    split (rcons s x) = (rcons (split s).1 x.1, rcons (split s).2 x.2).\n  Proof.\n    move: s x. apply: last_ind.\n    - move=> [xa xb] /=. reflexivity.\n    - move=> s [ya yb] IH [xa xb] /=. rewrite IH /=.\n      rewrite -(cats1 s) rcons_cat. rewrite split_cat /=.\n      rewrite -cats1 cat_rcons. rewrite -cats1 cat_rcons. reflexivity.\n  Qed.\n\n  Lemma split_rev (s : seq (A * B)) :\n    split (rev s) = (rev (split s).1, rev (split s).2).\n  Proof.\n    elim: s => [| [hda hdb] tl IH] //=. rewrite rev_cons.\n    rewrite split_rcons. rewrite IH /=. case: (split tl) => [s1 s2] /=.\n    rewrite !rev_cons. reflexivity.\n  Qed.\n\n  Lemma catrevs0 (s : seq A) : catrev s [::] = rev s.\n  Proof. by rewrite catrevE cats0. Qed.\n\n  Lemma catrev0s (s : seq A) : catrev [::] s = s.\n  Proof. reflexivity. Qed.\n\n  Lemma in_map_exists (s : seq A) (f : A -> B) (x : B) :\n    In x (map f s) -> exists y, In y s /\\ x = f y.\n  Proof.\n    elim: s => [| hd tl IH] //=. case=> Hin.\n    - subst. exists hd. tauto.\n    - move: (IH Hin) => [y [Hiny Hxy]]. exists y. tauto.\n  Qed.\n\n  Lemma In_rev x (s : seq A) :\n    In x (rev s) <-> In x s.\n  Proof.\n    elim: s => [| e s IH] //=. move: IH => [IH1 IH2].\n    rewrite rev_cons. split => H.\n    - case/In_rcons: H => H.\n      + right; exact: (IH1 H).\n      + left; rewrite H; reflexivity.\n    - apply/In_rcons. case: H => H.\n      + right; rewrite H; reflexivity.\n      + left; exact: (IH2 H).\n  Qed.\n\n  Lemma catrev_rev (s1 s2 : seq A) :\n    catrev (rev s1) s2 = s1 ++ s2.\n  Proof.\n    move: s1 s2. apply: last_ind => [| s1 x1 IH1] s2 //=.\n    rewrite rev_rcons /= IH1. rewrite cat_rcons. reflexivity.\n  Qed.\n\n  (* all, has, Forall, and Exists *)\n\n  Lemma all_Forall (P : pred A) (s : seq A) :\n    all P s <-> Forall P s.\n  Proof.\n    split.\n    - elim: s => [| e s IH] //=. move/andP=> [H1 H2]. move: (IH H2) => {}H2.\n      by apply: Forall_cons.\n    - elim: s => [| e s IH] //=. move=> /Forall_cons_iff [H1 H2].\n      by rewrite H1 (IH H2).\n  Qed.\n\n  Lemma all_forall (P : pred A) (s : seq A) :\n    all P s <-> (forall e, In e s -> P e).\n  Proof.\n    split => H.\n    - apply/Forall_forall. apply/all_Forall. assumption.\n    - apply/all_Forall. apply/Forall_forall. assumption.\n  Qed.\n\n  Lemma has_Exists (P : pred A) (s : seq A) :\n    has P s <-> Exists P s.\n  Proof.\n    split.\n    - elim: s => [| e s IH] //=. case/orP=> H.\n      + apply: Exists_cons_hd. assumption.\n      + apply: Exists_cons_tl. exact: (IH H).\n    - elim: s => [| e s IH] //=.\n      + move/Exists_nil. by elim.\n      + case/Exists_cons => H.\n        * by rewrite H.\n        * by rewrite (IH H) orbT.\n  Qed.\n\n  Lemma has_exists (P : pred A) (s : seq A) :\n    has P s <-> exists e, In e s /\\ P e.\n  Proof.\n    split.\n    - move/has_Exists. move/Exists_exists. by apply.\n    - move/Exists_exists. move/has_Exists. by apply.\n  Qed.\n\n  Lemma all_flatten (P : pred A) (ss : seq (seq A)) :\n    all P (flatten ss) = all (all P) ss.\n  Proof.\n    elim: ss => [| s ss IH] //=. rewrite all_cat IH. reflexivity.\n  Qed.\n\n  Lemma has_flatten (P : pred A) (ss : seq (seq A)) :\n    has P (flatten ss) = has (has P) ss.\n  Proof.\n    elim: ss => [| s ss IH] //=. rewrite has_cat IH. reflexivity.\n  Qed.\n\n  Lemma all_in (P : pred A) (s : seq A) (x : A) :\n    all P s -> In x s -> P x.\n  Proof. move/all_forall. by apply. Qed.\n\nEnd SeqLemmas.\n\n\n(** Lemmas for foldl and folr *)\n\nSection Fold.\n\n  Context {A : Type} {B : Type} {R : relation B} {E : Equivalence R}.\n\n  Context {f : B -> A -> B}.\n\n  Context {g : A -> B -> B}.\n\n  Context {Rf_swap : forall (a1 a2 : A) (b : B),\n              R (f (f b a1) a2) (f (f b a2) a1)}.\n\n  Context {R_foldl : forall (b1 b2 : B) (ls : seq A),\n              R b1 b2 -> R (foldl f b1 ls) (foldl f b2 ls)}.\n\n  Lemma foldl_fold_left a s : foldl f a s = fold_left f s a.\n  Proof. by elim: s a => [| x s IH] a //=. Qed.\n\n  Lemma foldr_fold_right a s : foldr g a s = fold_right g a s.\n  Proof. reflexivity. Qed.\n\n  Lemma foldl_map {C : Type} (h : C -> A) r s :\n    foldl f r (map h s) = foldl (fun x y => f x (h y)) r s.\n  Proof. by elim: s r => [| x s IH] r //=. Qed.\n\n  Lemma foldl_cons (hd : A) (tl : seq A) (r : B) :\n    R (foldl f r (hd::tl)) (f (foldl f r tl) hd).\n  Proof.\n    elim: tl hd r => /=.\n    - move=> hd r. reflexivity.\n    - move=> tl_hd tl_tl IH hd r. rewrite -(IH hd (f r tl_hd)).\n      move: (Rf_swap tl_hd hd r) => H. rewrite (R_foldl _ H). reflexivity.\n  Qed.\n\n  Lemma flodr_cons r x s : foldr g r (x::s) = g x (foldr g r s).\n  Proof. reflexivity. Qed.\n\n  Lemma foldr_rev r s : foldr g r (rev s) = foldl (fun r x => g x r) r s.\n  Proof.\n    elim: s r => [| x s IH] r //=. rewrite rev_cons foldr_rcons. rewrite IH.\n    reflexivity.\n  Qed.\n\nEnd Fold.\n\n\n(** Tail-recursive flatten, the result is the reverse of flatten *)\n\nSection TailRecursiveFlatten.\n\n  Context {A : Type}.\n\n  Definition tflatten (ss : seq (seq A)) := foldl (fun r s => catrev s r) [::] ss.\n\n  Lemma tflatten_flatten ss : tflatten ss = rev (flatten ss).\n  Proof.\n    rewrite /tflatten. rewrite -(cats0 (rev (flatten ss))).\n    move: [::]. move: ss. apply: last_ind => [| ss x IH] l //=.\n    rewrite flatten_rcons. rewrite rev_cat -catA. rewrite -IH.\n    rewrite foldl_rcons. rewrite catrevE. reflexivity.\n  Qed.\n\n  Lemma tflatten_cons s ss : tflatten (s::ss) = (tflatten ss) ++ (rev s).\n  Proof. rewrite !tflatten_flatten /=. rewrite rev_cat. reflexivity. Qed.\n\n  Lemma tflatten_rcons ss s :\n    tflatten (rcons ss s) = rev s ++ tflatten ss.\n  Proof. rewrite !tflatten_flatten. rewrite flatten_rcons rev_cat. reflexivity. Qed.\n\n  Lemma tflattens_cat ss1 ss2 :\n    tflatten (ss1 ++ ss2) = tflatten ss2 ++ tflatten ss1.\n  Proof. rewrite !tflatten_flatten. rewrite flatten_cat rev_cat. reflexivity. Qed.\n\n  Lemma filter_tflatten ss (p : pred A) :\n    filter p (tflatten ss) = tflatten [seq filter p i | i <- ss].\n  Proof.\n    rewrite (tflatten_flatten [seq filter p i | i <- ss]).\n    rewrite -filter_flatten. rewrite -filter_rev. rewrite -tflatten_flatten.\n    reflexivity.\n  Qed.\n\n  Lemma all_tflatten (p : pred A) ss :\n    all p (tflatten ss) = all (all p) ss.\n  Proof. rewrite tflatten_flatten. rewrite all_rev. exact: all_flatten. Qed.\n\n  Lemma has_tflatten (p : pred A) ss :\n    has p (tflatten ss) = has (has p) ss.\n  Proof. rewrite tflatten_flatten. rewrite has_rev. exact: has_flatten. Qed.\n\nEnd TailRecursiveFlatten.\n\nLemma map_tflatten {A B : Type} (f : A -> B) ss :\n  map f (tflatten ss) = tflatten (map (map f) ss).\nProof.\n  rewrite (tflatten_flatten (map (map f) ss)). rewrite -map_flatten.\n  rewrite -map_rev. rewrite -tflatten_flatten. reflexivity.\nQed.\n\n\n(* Tail-recursive maps.\n   mapr: the result is the reverse of map\n   tmap: the result is the same as map *)\n\nSection MapRev.\n\n  Context {A : Type} {B : Type}.\n\n  Variable f : A -> B.\n\n  Fixpoint mapr_rec res es :=\n    match es with\n    | [::] => res\n    | hd::tl => mapr_rec (f hd::res) tl\n    end.\n\n  Definition mapr es := mapr_rec [::] es.\n\n  Lemma mapr_rec_rev_map res es : mapr_rec res es = rev (map f es) ++ res.\n  Proof.\n    elim: es res => [| e es IH] res //=. rewrite IH. rewrite rev_cons.\n    rewrite cat_rcons. reflexivity.\n  Qed.\n\n  Lemma mapr_rev_map es : mapr es = rev (map f es).\n  Proof. rewrite /mapr. rewrite mapr_rec_rev_map. by rewrite cats0. Qed.\n\n  Lemma mapr_map es : mapr es = map f (rev es).\n  Proof. rewrite map_rev. exact: mapr_rev_map. Qed.\n\n  Lemma mapr_rec_cons res e es : mapr_rec res (e::es) = mapr_rec (f e::res) es.\n  Proof. reflexivity. Qed.\n\n  Lemma mapr_rec_split res es : mapr_rec res es = mapr_rec [::] es ++ res.\n  Proof.\n    elim: es res => [| e es IH] //= res. rewrite (IH (f e::res)).\n    rewrite (IH [:: f e]). rewrite -cat_rcons. rewrite -cats1. reflexivity.\n  Qed.\n\n  Lemma mapr_cons e es : mapr (e::es) = rcons (mapr es) (f e).\n  Proof.\n    rewrite !mapr_map. rewrite rev_cons map_rcons. reflexivity.\n  Qed.\n\n  Lemma mapr_rec_rcons res es e :\n    mapr_rec res (rcons es e) = f e :: mapr_rec res es.\n  Proof. by elim: es res e => [| e1 es IH] //=. Qed.\n\n  Lemma mapr_rcons es e : mapr (rcons es e) = f e :: mapr es.\n  Proof. exact: mapr_rec_rcons. Qed.\n\n  Lemma mapr_rec_cat res es1 es2 :\n    mapr_rec res (es1 ++ es2) = mapr_rec (mapr_rec res es1) es2.\n  Proof. by elim: es1 res es2 => [| e1 es1 IH] res es2 //=. Qed.\n\n  Lemma mapr_cat es1 es2 : mapr (es1 ++ es2) = mapr es2 ++ mapr es1.\n  Proof.\n    rewrite !mapr_map. rewrite rev_cat map_cat. reflexivity.\n  Qed.\n\n  Lemma size_mapr es : size (mapr es) = size es.\n  Proof.\n    rewrite mapr_map. rewrite size_map size_rev. reflexivity.\n  Qed.\n\n  Lemma mapr_rev es : mapr (rev es) = map f es.\n  Proof.\n    elim: es => [| e es IH] //=. rewrite rev_cons. rewrite mapr_rcons.\n    rewrite IH. reflexivity.\n  Qed.\n\n\n  Definition tmap es := mapr (rev es).\n\n  Lemma tmap_map es : tmap es = map f es.\n  Proof. rewrite /tmap mapr_rev. reflexivity. Qed.\n\n  Lemma in_tmap e es : In e es -> In (f e) (tmap es).\n  Proof.\n    rewrite tmap_map. exact: in_map.\n  Qed.\n\nEnd MapRev.\n\nSection FlattenMap.\n\n  Lemma in_flatten {A : Type} x (ss : seq (seq A)) :\n    In x (flatten ss) <-> exists s, In s ss /\\ In x s.\n  Proof.\n    elim: ss => [| s ss IH] //=.\n    - split => //=. move=> [s H]. tauto.\n    - move: IH => [IH1 IH2]. split => H.\n      + case: (in_cat H) => {}H.\n        * exists s. split; [ by left | assumption ].\n        * move: (IH1 H) => [t [Hint Hinx]]. exists t; tauto.\n      + move: H => [t [Hint Hinx]]. case: Hint => Hint.\n        * subst. apply: in_cat_l. assumption.\n        * apply: in_cat_r. apply: IH2. exists t. tauto.\n  Qed.\n\n  Lemma in_tflatten {A : Type} x (ss : seq (seq A)) :\n    In x (tflatten ss) <-> exists s, In s ss /\\ In x s.\n  Proof.\n    rewrite tflatten_flatten. move: (in_flatten x ss) => Hin. split => H.\n    - move/In_rev: H. tauto.\n    - apply/In_rev. tauto.\n  Qed.\n\n  Lemma in_flatten_map {A B : Type} (f : B -> seq A) x e (s : seq B) :\n    In e s ->\n    In x (f e) ->\n    In x (flatten (map f s)).\n  Proof.\n    move=> Hine Hinx. apply/in_flatten. exists (f e). split; [| assumption ].\n    apply: in_map. assumption.\n  Qed.\n\n  Lemma in_tflatten_tmap {A B : Type} (f : B -> seq A) x e (s : seq B) :\n    In e s ->\n    In x (f e) ->\n    In x (tflatten (tmap f s)).\n  Proof.\n    move=> H1 H2. rewrite tflatten_flatten tmap_map.\n    apply/In_rev. exact: (in_flatten_map H1 H2).\n  Qed.\n\nEnd FlattenMap.\n\n\n(** Tail-recursive append. *)\n\nSection TailRecursiveAppend.\n\n  Context {A : Type}.\n\n  Definition tappend (es1 es2 : seq A) := rev_append (rev es1) es2.\n\n  Lemma tappend_cat es1 es2 : tappend es1 es2 = es1 ++ es2.\n  Proof.\n    rewrite /tappend. move: es1 es2. apply: last_ind => [| es1 e1 IH1] es2 //=.\n    rewrite rev_rcons /=. rewrite IH1. rewrite cat_rcons. reflexivity.\n  Qed.\n\nEnd TailRecursiveAppend.\n\n\n\n(** Lemmas for sequences of eqType *)\n\nSection EqSeqLemmas.\n\n  Variable A : eqType.\n\n  Variable B : eqType.\n\n  Lemma singleton_eq (x y : A) : ([::x] == [::y]) = (x == y).\n  Proof.\n    case H: (x == y).\n    - by rewrite (eqP H) eqxx.\n    - apply/negP => /eqP [] Heq. by rewrite Heq eqxx in H.\n  Qed.\n\n  Lemma in_In (x : A) (s : seq A) : x \\in s <-> In x s.\n  Proof.\n    elim: s => [| y ys IH] //=. rewrite in_cons. case H: (x == y) => /=.\n    - split.\n      + move=> _. left. rewrite (eqP H). reflexivity.\n      + done.\n    - split.\n      + move=> Hin. right. apply/IH. exact: Hin.\n      + case.\n        * move=> Hyx; rewrite Hyx eqxx in H; discriminate.\n        * move/IH. by apply.\n  Qed.\n\n  Lemma map_l_nil (f : A -> B) (l : seq A) :\n    (map f l == [::]) = (l == [::]).\n  Proof. by case: l. Qed.\n\n  Lemma seq_neq_split (x y : A) (xs ys : seq A) :\n    (x::xs != y::ys) = ((x != y) || (xs != ys)).\n  Proof.\n    rewrite negb_and -/eqseq. case Hxy: (x == y) => /=; by trivial.\n  Qed.\n\n  Lemma has_catrev p (l1 l2 : seq A) : has p (catrev l1 l2) = has p l1 || has p l2.\n  Proof.\n    elim: l1 l2 => [| hd tl IH] l2 //=. rewrite -cat1s catrev_catr has_cat IH /=.\n    rewrite orbF (Bool.orb_comm (has p tl)). reflexivity.\n  Qed.\n\n  Lemma all_catrev p (l1 l2 : seq A) : all p (catrev l1 l2) = all p l1 && all p l2.\n  Proof.\n    elim: l1 l2 => [| hd tl IH] l2 //=. rewrite -cat1s catrev_catr all_cat IH /=.\n    rewrite andbT (Bool.andb_comm (all p tl)). reflexivity.\n  Qed.\n\n  Lemma cat_nseql (x : A) s1 s2 n :\n    s1 ++ s2 = nseq n x -> s1 = nseq (size s1) x.\n  Proof.\n    move=> H. have: size (s1 ++ s2) = size (nseq n x) by rewrite H.\n    rewrite size_cat size_nseq => Hn. rewrite -Hn in H.\n    rewrite nseq_addn in H. move/eqP: H. rewrite eqseq_cat; last by rewrite size_nseq.\n    move/andP=> [/eqP <- _]. reflexivity.\n  Qed.\n\n  Lemma cat_nseqr (x : A) s1 s2 n :\n    s1 ++ s2 = nseq n x -> s2 = nseq (size s2) x.\n  Proof.\n    move=> H. have: size (s1 ++ s2) = size (nseq n x) by rewrite H.\n    rewrite size_cat size_nseq => Hn. rewrite -Hn in H.\n    rewrite nseq_addn in H. move/eqP: H. rewrite eqseq_cat; last by rewrite size_nseq.\n    move/andP=> [_ /eqP <-]. reflexivity.\n  Qed.\n\n  Lemma in_rcons (x : A) s (y : A) :\n    x \\in rcons s y = (x \\in s) || (x == y).\n  Proof. rewrite mem_rcons in_cons orbC. reflexivity. Qed.\n\n  Lemma in_rev (x : A) s :\n    (x \\in rev s) = (x \\in s).\n  Proof.\n    elim: s => [| y s IH] //=. rewrite rev_cons in_rcons IH in_cons orbC.\n    reflexivity.\n  Qed.\n\n  Lemma in_split_rev_l {C : Type} (x : A) (s : seq (A * C)) :\n    (x \\in (split (rev s)).1) = (x \\in (split s).1).\n  Proof.\n    rewrite split_rev /=. rewrite mem_rev. reflexivity.\n  Qed.\n\n  Lemma in_split_rev_r {C : Type} (x : B) (s : seq (C * B)) :\n    (x \\in (split (rev s)).2) = (x \\in (split s).2).\n  Proof.\n    rewrite split_rev /=. rewrite mem_rev. reflexivity.\n  Qed.\n\n\n  (* Tail-recursive filter function, the result is the reverse of filter *)\n\n  Variable p : pred A.\n\n  Definition tfilter es := foldl (fun r x => if p x then x::r else r) [::] es.\n\n  Lemma tfilter_filter es : tfilter es = filter p (rev es).\n  Proof.\n    rewrite -(cats0 (filter p (rev es))). rewrite /tfilter. rewrite filter_rev.\n    move: [::]. elim: es => [| e es IH] r //=. case: (p e).\n    - rewrite rev_cons. rewrite cat_rcons. rewrite -IH. reflexivity.\n    - exact: IH.\n  Qed.\n\n  Lemma tfilter_cat es1 es2 : tfilter (es1 ++ es2) = tfilter es2 ++ tfilter es1.\n  Proof.\n    rewrite !tfilter_filter. rewrite rev_cat filter_cat. reflexivity.\n  Qed.\n\n  Lemma tfilter_rcons es e :\n    tfilter (rcons es e) = if p e\n                           then e::(tfilter es)\n                           else tfilter es.\n  Proof.\n    rewrite !tfilter_filter. rewrite rev_rcons /=. reflexivity.\n  Qed.\n\n  Lemma tfilter_cons e es :\n    tfilter (e::es) = if p e\n                      then rcons (tfilter es) e\n                      else tfilter es.\n  Proof.\n    rewrite !tfilter_filter. rewrite rev_cons filter_rcons. reflexivity.\n  Qed.\n\n  Lemma tfilter_nil : tfilter [::] = [::].\n  Proof. reflexivity. Qed.\n\nEnd EqSeqLemmas.\n\n\n(* Tail-recursive zip *)\n\nSection TailRecursiveZip.\n\n  Context {A : Type} {B : Type}.\n\n  Fixpoint zipr_rec res_rev (xs : seq A) (ys : seq B) : seq (A * B) :=\n    match xs, ys with\n    | _, [::]\n    | [::], _ => res_rev\n    | x::xs, y::ys => zipr_rec ((x, y)::res_rev) xs ys\n    end.\n\n  Definition zipr (xs : seq A) (ys : seq B) : seq (A * B) := zipr_rec [::] xs ys.\n\n  Definition unzip1r := mapr (@fst A B).\n\n  Definition unzip2r := mapr (@snd A B).\n\n  Lemma zipr_rec_cons r x xs y ys : zipr_rec r (x::xs) (y::ys) = zipr_rec ((x, y)::r) xs ys.\n  Proof. reflexivity. Qed.\n\n  Lemma zipr_zip xs ys : zipr xs ys = rev (zip xs ys).\n  Proof.\n    rewrite /zipr. rewrite -(cats0 (rev (zip xs ys))). move: [::].\n    elim: xs ys => [| x xs IHx] [| y ys] r //=. rewrite IHx. rewrite rev_cons.\n    rewrite cat_rcons. reflexivity.\n  Qed.\n\n  Lemma unzip1r_unzip1 s : unzip1r s = rev (unzip1 s).\n  Proof. rewrite /unzip1r. rewrite mapr_map map_rev. reflexivity. Qed.\n\n  Lemma unzip2r_unzip2 s : unzip2r s = rev (unzip2 s).\n  Proof. rewrite /unzip2r. rewrite mapr_map map_rev. reflexivity. Qed.\n\n  Lemma zipr_cons x xs y ys : zipr (x::xs) (y::ys) = rcons (zipr xs ys) (x, y).\n  Proof. rewrite !zipr_zip /=. rewrite rev_cons. reflexivity. Qed.\n\n  Lemma zipr_rcons xs x ys y :\n    size xs = size ys -> zipr (rcons xs x) (rcons ys y) = (x, y)::(zipr xs ys).\n  Proof.\n    move=> Hs. rewrite !zipr_zip. rewrite (zip_rcons _ _ Hs).\n    rewrite rev_rcons. reflexivity.\n  Qed.\n\n  Lemma zipr_cat xs1 xs2 ys1 ys2 :\n    size xs1 = size ys1 -> zipr (xs1 ++ xs2) (ys1 ++ ys2) = zipr xs2 ys2 ++ zipr xs1 ys1.\n  Proof.\n    move=> Hs. rewrite !zipr_zip. rewrite (zip_cat _ _ Hs). rewrite rev_cat.\n    reflexivity.\n  Qed.\n\n  Lemma rev_zipr xs ys : size xs = size ys -> rev (zipr xs ys) = zipr (rev xs) (rev ys).\n  Proof.\n    move=> Hs. rewrite !zipr_zip. rewrite (rev_zip Hs). reflexivity.\n  Qed.\n\n  Lemma unzip1_zipr s t : size s <= size t -> unzip1 (zipr s t) = rev s.\n  Proof.\n    rewrite zipr_zip => Hs. move: (unzip1_zip Hs). rewrite /unzip1.\n    rewrite map_rev. move=> ->. reflexivity.\n  Qed.\n\n  Lemma unzip2_zipr s t : size t <= size s -> unzip2 (zipr s t) = rev t.\n  Proof.\n    rewrite zipr_zip => Hs. move: (unzip2_zip Hs). rewrite /unzip2.\n    rewrite map_rev. move=> ->. reflexivity.\n  Qed.\n\n  Lemma unzip1r_zipr s t : size s <= size t -> unzip1r (zipr s t) = s.\n  Proof.\n    rewrite unzip1r_unzip1 => Hs. rewrite (unzip1_zipr Hs). by rewrite revK.\n  Qed.\n\n  Lemma unzip2r_zipr s t : size t <= size s -> unzip2r (zipr s t) = t.\n  Proof.\n    rewrite unzip2r_unzip2 => Hs. rewrite (unzip2_zipr Hs). by rewrite revK.\n  Qed.\n\n  Lemma size1_zipr s t : size s <= size t -> size (zipr s t) = size s.\n  Proof.\n    rewrite zipr_zip => Hs. rewrite size_rev. rewrite (size1_zip Hs). reflexivity.\n  Qed.\n\n  Lemma size2_zipr s t : size t <= size s -> size (zipr s t) = size t.\n  Proof.\n    rewrite zipr_zip => Hs. rewrite size_rev. rewrite (size2_zip Hs). reflexivity.\n  Qed.\n\n  Lemma size_zipr xs ys : size (zipr xs ys) = minn (size xs) (size ys).\n  Proof. rewrite zipr_zip size_rev size_zip. reflexivity. Qed.\n\n  Lemma nth_zipr x y s t i :\n    size s = size t -> nth (x, y) (zipr s t) i = (nth x (rev s) i, nth y (rev t) i).\n  Proof.\n    move=> Hs. rewrite zipr_zip. rewrite (rev_zip Hs). rewrite nth_zip; first reflexivity.\n    rewrite !size_rev; assumption.\n  Qed.\n\n  Lemma zipr_map {C : eqType} (f : C -> A) (g : C -> B) (s : seq C) :\n    zipr (map f s) (map g s) = mapr (fun x => (f x, g x)) s.\n  Proof. rewrite zipr_zip. rewrite zip_map mapr_map map_rev. reflexivity. Qed.\n\n  Lemma zipr_mapr {C : eqType} (f : C -> A) (g : C -> B) (s : seq C) :\n    zipr (mapr f s) (mapr g s) = map (fun x => (f x, g x)) s.\n  Proof.\n    rewrite zipr_zip. rewrite !mapr_map !map_rev.\n    rewrite rev_zip; last by rewrite !size_rev !size_map. rewrite !revK.\n    rewrite zip_map. reflexivity.\n  Qed.\n\nEnd TailRecursiveZip.\n\nSection ZipLemmas.\n\n  Context {A : eqType} {B : eqType}.\n\n  Lemma unzip1_l_nil (pairs : seq (A * B)) :\n    (unzip1 pairs == [::]) = (pairs == [::]).\n  Proof. by rewrite /unzip1 map_l_nil. Qed.\n\n  Lemma unzip2_l_nil (pairs : seq (A * B)) :\n    (unzip2 pairs == [::]) = (pairs == [::]).\n  Proof. by rewrite /unzip2 map_l_nil. Qed.\n\nEnd ZipLemmas.\n\n\nSection Map2.\n\n  Context {S T U : Type}.\n\n  Context (f : S -> T -> U).\n\n  (* This function is tail-recursive. *)\n  Definition map2 (s : seq S) (t : seq T) : seq U :=\n    mapr (fun '(a, b) => f a b) (zipr s t).\n\n  Lemma map2s0 s : map2 s [::] = [::].\n  Proof. by case: s. Qed.\n\n  Lemma map20s t : map2 [::] t = [::].\n  Proof. by case: t. Qed.\n\n  Lemma map2_cons s ss t tt : map2 (s::ss) (t::tt) = (f s t)::(map2 ss tt).\n  Proof. rewrite /map2. rewrite zipr_cons mapr_rcons. reflexivity. Qed.\n\n  Lemma map2_rcons ss s tt t :\n    size ss = size tt ->\n    map2 (rcons ss s) (rcons tt t) = rcons (map2 ss tt) (f s t).\n  Proof.\n    move=> Hs. rewrite /map2 (zipr_rcons _ _ Hs). rewrite mapr_cons. reflexivity.\n  Qed.\n\n  Lemma map2_cat ss1 ss2 tt1 tt2 :\n    size ss1 = size tt1 ->\n    map2 (ss1 ++ ss2) (tt1 ++ tt2) = (map2 ss1 tt1) ++ (map2 ss2 tt2).\n  Proof.\n    move=> Hs. rewrite /map2. rewrite (zipr_cat _ _ Hs). rewrite mapr_cat. reflexivity.\n  Qed.\n\n  Lemma map2_equal_size ss tt :\n    map2 ss tt = map2 (take (minn (size ss) (size tt)) ss)\n                      (take (minn (size ss) (size tt)) tt).\n  Proof.\n    elim: ss tt => [| s ss IH] [| t tt] //=. rewrite map2_cons. rewrite !minnSS.\n    rewrite !take_cons map2_cons. rewrite -IH. reflexivity.\n  Qed.\n\n  Lemma map2_size_gt_l ss tt :\n    size tt < size ss -> map2 ss tt = map2 (take (size tt) ss) tt.",
      "suffix": "\n\n  Lemma map2_size_gt_r ss tt :\n    size ss < size tt -> map2 ss tt = map2 ss (take (size ss) tt).\n  Proof.\n    move=> Hs. rewrite map2_equal_size /minn. rewrite Hs take_size.\n    reflexivity.\n  Qed.\n\nEnd Map2.\n\nSection Map2SSS.\n\n  Context {S : Type}.\n  Context (f : S -> S -> S).\n  Context {f_commutative : commutative f}.\n  Context {f_associative : associative f}.\n  Context {f_idempotent : idempotent f}.\n\n  Lemma map2_comm xs ys : map2 f xs ys = map2 f ys xs.\n  Proof.\n    elim: xs ys => [| x xs IH] [| y ys] //=.\n    rewrite !map2_cons. rewrite f_commutative IH. reflexivity.\n  Qed.\n\n  Lemma map2_assoc xs ys zs : map2 f xs (map2 f ys zs) = map2 f (map2 f xs ys) zs.\n  Proof.\n    elim: xs ys zs => [| x xs IH] //=.\n    - move=> ys zs. rewrite !map20s. reflexivity.\n    - case=> [| y ys] //=.\n      + move=> zs. rewrite map20s map2s0. reflexivity.\n      + case=> [| z zs] //=.\n        * rewrite !map2s0. reflexivity.\n        * rewrite !map2_cons. rewrite f_associative IH. reflexivity.\n  Qed.\n\n  Lemma map2_idem xs : map2 f xs xs = xs.\n  Proof.\n    elim: xs => [| x xs IH] //=. rewrite map2_cons f_idempotent IH. reflexivity.\n  Qed.\n\nEnd Map2SSS.\n\n\nSection PrefixOf.\n\n  Variable A : eqType.\n\n  Implicit Type s : seq A.\n\n  Fixpoint prefix_of (s1 s2 : seq A) : bool :=\n    match s1 with\n    | [::] => true\n    | x1::s1 => match s2 with\n                | [::] => false\n                | x2::s2 => (x1 == x2) && (prefix_of s1 s2)\n                end\n    end.\n\n  Lemma prefix_of_nil s : prefix_of nil s.\n  Proof. done. Qed.\n\n  Lemma prefix_of_is_nil s : prefix_of s nil = (s == nil).\n  Proof. by case: s. Qed.\n\n  Lemma prefix_of_take s1 s2 :\n    prefix_of s1 s2 = (s1 == take (size s1) s2).\n  Proof.\n    elim: s1 s2 => [|x1 s1 IH1] /=.\n    - by move=> ?; rewrite take0 eqxx.\n    - case => //=. move=> x2 s2. rewrite eqseq_cons IH1. reflexivity.\n  Qed.\n\n  Lemma prefix_of_size s1 s2 : prefix_of s1 s2 -> size s1 <= size s2.\n  Proof.\n    rewrite prefix_of_take. move=> /eqP ->. rewrite size_take.\n    case H: (size s1 < size s2) => //=. by apply: ltnW.\n  Qed.\n\n  Lemma prefix_of_cons x1 s1 x2 s2 :\n    prefix_of (x1::s1) (x2::s2) = ((x1 == x2) && prefix_of s1 s2).\n  Proof. reflexivity. Qed.\n\n  Lemma prefix_of_rcons s1 s2 x :\n    prefix_of s1 s2 -> prefix_of s1 (rcons s2 x).\n  Proof.\n    elim: s1 s2 x => [| hd1 tl1 IH1] [| hd2 tl2] x //=.\n    move=> /andP [/eqP -> Htl]. by rewrite eqxx (IH1 _ _ Htl).\n  Qed.\n\n  Lemma prefix_of_cat s1 s2 s3 :\n    prefix_of s1 s2 -> prefix_of s1 (s2 ++ s3).\n  Proof.\n    move: s3 s2. apply: last_ind => [| s3 x IH] s2 Hpre12 //=.\n    - rewrite cats0. assumption.\n    - rewrite -rcons_cat. apply: prefix_of_rcons. exact: (IH _ Hpre12).\n  Qed.\n\n  Lemma prefix_of_belast x s1 s2 :\n    prefix_of (x::s1) s2 -> prefix_of (belast x s1) s2.\n  Proof.\n    elim: s1 s2 x => [| hd1 tl1 IH1] [| hd2 [| tl2_hd tl2_tl]] x //=.\n    - by rewrite andbF.\n    - move=> /andP [/eqP -> /andP [/eqP -> H]]. rewrite eqxx andTb. apply: IH1.\n      by rewrite prefix_of_cons eqxx H.\n  Qed.\n\n  Lemma prefix_of_refl s : prefix_of s s.\n  Proof. elim: s => //=. move=> ? ? ->; by rewrite eqxx. Qed.\n\n  Lemma prefix_of_antisym s1 s2 : (prefix_of s1 s2 && prefix_of s2 s1) = (s1 == s2).\n  Proof.\n    elim: s1 s2 => [| hd1 tl1 IH1] /=.\n    - move=> s2. rewrite prefix_of_is_nil eq_sym. reflexivity.\n    - case=> [|hd2 tl2] => //=. rewrite (andbA ((hd1 == hd2) && prefix_of tl1 tl2)).\n      rewrite -(andbA (hd1 == hd2)). rewrite (andbC (prefix_of tl1 tl2)).\n      rewrite andbA. rewrite (eq_sym hd2). rewrite Bool.andb_diag. rewrite -andbA.\n      rewrite IH1. reflexivity.\n  Qed.\n\n  Lemma prefix_of_trans s1 s2 s3 :\n    prefix_of s1 s2 -> prefix_of s2 s3 -> prefix_of s1 s3.\n  Proof.\n    elim: s1 s2 s3 => [| hd1 tl1 IH1] [| hd2 tl2] [| hd3 tl3] //=.\n    move=> /andP [/eqP -> H12] /andP [/eqP -> H23].\n      by rewrite eqxx (IH1 _ _ H12 H23).\n  Qed.\n\n  Lemma prefix_of_cons_ident x s1 s2 :\n    prefix_of (x::s1) s2 -> prefix_of s1 s2 -> constant (x::s1).\n  Proof.\n    elim: s1 s2 x => [| hd1 tl1 IH1] [| hd2 [| tl2_hd tl2_tl]] x //=.\n    - by rewrite andbF.\n    - move=> /andP [/eqP <- /andP [/eqP <- H1]]. move=> /andP [/eqP -> H2].\n      rewrite eqxx andTb. apply: (IH1 _ _ _ H2).\n      by rewrite prefix_of_cons eqxx andTb H1.\n  Qed.\n\n  Variable default : A.\n\n  Lemma prefix_of_nth s1 s2 i :\n    prefix_of s1 s2 -> i < size s1 -> nth default s1 i = nth default s2 i.\n  Proof.\n    rewrite prefix_of_take. move=> /eqP Hs Hi. rewrite Hs (nth_take _ Hi).\n    reflexivity.\n  Qed.\n\nEnd PrefixOf.\n\n\nSection ExtSeq.\n\n  Context {A : Type} (a : A).\n  (* Extend a sequence *)\n  Fixpoint extseq (xs ys : seq A) :=\n    match xs, ys with\n    | _, [::] => [::]\n    | [::], _::ys => a::(extseq xs ys)\n    | x::xs, y::ys => x::(extseq xs ys)\n    end.\n\n  Lemma extseq_cons x xs y ys :\n    extseq (x::xs) (y::ys) = x::(extseq xs ys).\n  Proof. reflexivity. Qed.\n\n  Lemma extseqs0 xs : extseq xs [::] = [::].\n  Proof. by elim: xs => [| x xs IH] //=. Qed.\n\n  Lemma extseq0s ys : extseq [::] ys = nseq (size ys) a.\n  Proof.\n    elim: ys => [| y ys IH] //=. rewrite IH. reflexivity.\n  Qed.\n\n  Lemma extseq_eqsize xs ys : size xs = size ys -> extseq xs ys = xs.\n  Proof.\n    elim: xs ys => [| x xs IH] [| y ys] //= Hs. move: (eq_add_S _ _ Hs) => {}Hs.\n    rewrite (IH _ Hs). reflexivity.\n  Qed.\n\n  Lemma extseq_lesize xs ys :\n    size xs <= size ys -> extseq xs ys = xs ++ nseq (size ys - size xs) a.\n  Proof.\n    elim: xs ys => [| x xs IH] [| y ys] //=.\n    - move=> _. rewrite extseq0s. reflexivity.\n    - move=> Hs. move: (ltnSE Hs) => {}Hs. rewrite subSS. rewrite (IH _ Hs).\n      reflexivity.\n  Qed.\n\n  Lemma extseq_gesize xs ys : size ys <= size xs -> extseq xs ys = take (size ys) xs.\n  Proof.\n    elim: xs ys => [| x xs IH] [| y ys] //=. move=> Hs. move: (ltnSE Hs) => {}Hs.\n    rewrite (IH _ Hs). reflexivity.\n  Qed.\n\n  Lemma size_extseq xs ys : size (extseq xs ys) = size ys.\n  Proof.\n    case Hseq: (size xs == size ys).\n    - rewrite (extseq_eqsize (eqP Hseq)). exact: (eqP Hseq).\n    - case/orP: (leq_total (size xs) (size ys)) => Hs.\n      + rewrite (extseq_lesize Hs). rewrite seq.size_cat size_nseq.\n        rewrite (subnKC Hs). reflexivity.\n      + rewrite (extseq_gesize Hs). rewrite size_take. rewrite leq_eqVlt in Hs.\n        rewrite eq_sym in Hseq. rewrite Hseq /= in Hs. rewrite Hs. reflexivity.\n  Qed.\n\nEnd ExtSeq.\n",
      "theorem": "Lemma map2_size_gt_l ss tt :\n    size tt < size ss -> map2 ss tt = map2 (take (size tt) ss) tt.",
      "ground_truth": "Proof.\n    move=> Hs. rewrite map2_equal_size /minn. move: (ltn_geF Hs).\n    rewrite leq_eqVlt. move/Bool.orb_false_elim => [_ {}Hs]. rewrite Hs take_size.\n    reflexivity.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 29,
      "prefix": "From Coq Require Import Setoid.\nFrom Coq Require Import Streams.\n\n(** Additional streams utilities *)\n\nDeclare Scope stream_scope.\nDelimit Scope stream_scope with Stream.\nInfix \"\u22c5\" := Cons (at level 60, right associativity) : stream_scope.\nInfix \"\u2261\" := EqSt (at level 70, no associativity) : stream_scope.\nNotation \"s # n \" := (Str_nth n s) (at level 9) : stream_scope.\nOpen Scope stream_scope.\n\nFact Str_nth_0:\n  forall {A} (xs: Stream A) x,\n    (x \u22c5 xs) # 0 = x.\nProof. reflexivity. Qed.\n\nFact Str_nth_S:\n  forall {A} (xs: Stream A) x n,\n    (x \u22c5 xs) # (S n) = xs # n.\nProof. reflexivity. Qed.\n\nFact Str_nth_0_hd:\n  forall {A} (xs: Stream A),\n    xs # 0 = (hd xs).\nProof. reflexivity. Qed.\n\nFact Str_nth_S_tl:\n  forall {A} (xs: Stream A) n,\n    xs # (S n) = (tl xs) # n.\nProof. reflexivity. Qed.\n\nSection map.\n  Context {A B : Type}.\n\n  Variable (f : (A -> B)).\n\n  Lemma map_Cons : forall a (sa : Stream A),\n      (map f (a \u22c5 sa)) = ((f a) \u22c5 (map f sa)).\n  Proof.\n    intros a sa; simpl.\n    rewrite unfold_Stream at 1; reflexivity.\n  Qed.\nEnd map.\n\nSection map2.\n  Context {A B C : Type}.\n\n  Variable (f : (A -> B -> C)).\n\n  CoFixpoint map2 (sa : Stream A) (sb : Stream B) : Stream C :=\n    match sa, sb with\n    | hda \u22c5 tla, hdb \u22c5 tlb =>\n      (f hda hdb) \u22c5 (map2 tla tlb)\n    end.\n\n  Lemma map2_Cons : forall a b (sa : Stream A) (sb : Stream B),\n      (map2 (a \u22c5 sa) (b \u22c5 sb)) = ((f a b) \u22c5 (map2 sa sb)).\n  Proof.\n    intros a b sa sb; simpl.\n    rewrite unfold_Stream at 1; reflexivity.\n  Qed.\n\n  Lemma map2_hd : forall (sa : Stream A) (sb : Stream B),\n      f (hd sa) (hd sb) = hd (map2 sa sb).",
      "suffix": "\n\n  Lemma map2_tl : forall (sa : Stream A) (sb : Stream B),\n      map2 (tl sa) (tl sb) = tl (map2 sa sb).\n  Proof. intros [a sa] [b sb]; reflexivity. Qed.\n\n  Lemma Str_nth_tl_map2 : forall n (sa : Stream A) (sb : Stream B),\n      Str_nth_tl n (map2 sa sb) = map2 (Str_nth_tl n sa) (Str_nth_tl n sb).\n  Proof.\n    induction n; intros sa sb; simpl.\n    - reflexivity.\n    - destruct sa. destruct sb. simpl.\n      auto.\n  Qed.\n\n  Lemma Str_nth_map2 : forall n (sa : Stream A) (sb : Stream B),\n      Str_nth n (map2 sa sb) = f (Str_nth n sa) (Str_nth n sb).\n  Proof.\n    unfold Str_nth.\n    induction n; intros [hda tla] [hdb tlb].\n    - reflexivity.\n    - simpl. auto.\n  Qed.\nEnd map2.\n\nAdd Parametric Relation A : (Stream A) (@EqSt A)\n    reflexivity proved by (@EqSt_reflex A)\n    symmetry proved by (@sym_EqSt A)\n    transitivity proved by (@trans_EqSt A)\n      as EqStrel.\n\nAdd Parametric Morphism A B C f : (@map2 A B C f)\n    with signature (@EqSt A) ==> (@EqSt B) ==> (@EqSt C) as map2_EqSt.\nProof.\n  cofix map2_EqSt.\n  intros [? ?] [? ?] Eqa [? ?] [? ?] Eqb.\n  inversion Eqa; simpl in *; subst; clear Eqa.\n  inversion Eqb; simpl in *; subst; clear Eqb.\n  rewrite map2_Cons. rewrite map2_Cons.\n  constructor; simpl; auto.\nQed.\n\nSection Forall.\n  Context {A : Type}.\n  Variable (P : A -> Prop).\n\n  CoInductive SForall : Stream A -> Prop :=\n  | Forall_Cons : forall a sa,\n      P a ->\n      SForall sa ->\n      SForall (a \u22c5 sa).\n\n  Lemma SForall_forall : forall sa,\n      SForall sa <-> forall n, P (Str_nth n sa).\n  Proof with auto.\n    intros sa.\n    split; intros H.\n    - intro n; revert n sa H.\n      induction n; intros [a sa] Hf; inversion Hf; subst.\n      + rewrite Str_nth_0...\n      + rewrite Str_nth_S...\n    - revert sa H.\n      cofix forall_Forall.\n      intros [a sa] H. constructor.\n      + specialize (H 0). rewrite Str_nth_0 in H...\n      + apply forall_Forall.\n        intro n. specialize (H (S n)).\n        rewrite Str_nth_S in H...\n  Qed.\nEnd Forall.\n\nLemma const_Cons : forall {A} (a : A),\n    Streams.const a = a \u22c5 (Streams.const a).\nProof.\n  intros.\n  rewrite unfold_Stream at 1. reflexivity.\nQed.\n",
      "theorem": "Lemma map2_hd : forall (sa : Stream A) (sb : Stream B),\n      f (hd sa) (hd sb) = hd (map2 sa sb).",
      "ground_truth": "Proof. intros [a sa] [b sb]; reflexivity. Qed."
    },
    {
      "split": "train-sft",
      "index": 30,
      "prefix": "(* Functions *)\n\nFrom intuitionism Require Import lib set seq spr fan.\n\n(* A well defined function from A to B. *)\nDefinition well_defined A B (f : dom A -> dom B) :=\n  \u2200\u03b1, \u03b1 \u2208 A -> f \u03b1 \u2208 B.\n\n(* Strong converse of a = b -> f a = f b. *)\nDefinition strong_extensional A B (f : dom A -> dom B) :=\n  \u2200\u03b1 \u03b2, \u03b1 \u2208 A -> \u03b2 \u2208 A -> f \u03b1 # f \u03b2 -> \u03b1 # \u03b2.\n\n(* Classic injective function. *)\nDefinition weak_injective A B (f : dom A -> dom B) :=\n  \u2200a \u03b1, a \u2208 A -> \u03b1 \u2208 A -> f a = f \u03b1 -> a = \u03b1.\n\n(* Strong injective function. *)\nDefinition injective A B (f : dom A -> dom B) :=\n  \u2200a \u03b1, a \u2208 A -> \u03b1 \u2208 A -> a # \u03b1 -> f a # f \u03b1.\n\n(* Surjective function. *)\nDefinition surjective A B (f : dom A -> dom B) :=\n  \u2200\u03b2, \u03b2 \u2208 B -> \u2203\u03b1, \u03b1 \u2208 A /\\ f \u03b1 = \u03b2.\n\n(* An injective and surjective function is bijective. *)\nDefinition bijective A B f := injective A B f /\\ surjective A B f.\n\n(* Notation for 'there exists an injective mapping from A to B'. *)\nDefinition preceq A B f := well_defined A B f /\\ injective A B f.\nNotation \"A \u227c B\" := (\u2203f, preceq A B f) (at level 50).\nNotation \"A \u227a B\" := (~(B \u227c A)) (at level 50).\n\n(* Notation for 'there exists a one-to-one mapping between A and B'. *)\nDefinition equivalent A B := \u2203f, well_defined A B f /\\ bijective A B f.\nNotation \"A === B\" := (equivalent A B) (at level 50).\nNotation \"A !== B\" := (~equivalent A B) (at level 50).\n\n(* Definition of denumerable and uncountable sets. *)\nDefinition denumerable A := Nat === A.\nDefinition uncountable A := \u2200f, well_defined Nat A f -> ~surjective Nat A f.\n\n(* A definition of infinity without natural numbers by Dedekind. *)\nDefinition Dedekind_infinite A :=\n  \u2203x f, x \u2208 A /\\ well_defined A A f /\\ injective A A f /\\ \u2200y, f y # x.\n\nTheorem injective_weaken A B f :\n  injective A B f -> weak_injective A B f.\nProof.\nintros H a \u03b1 Ha H\u03b1 Hf. apply apart_spec; intros P.\napply H in P; auto. apply apart_spec in P; auto.\nQed.\n\nTheorem seq_uncountable :\n  uncountable Seq.",
      "suffix": "\n\n(*\nThe following is a formalization of the fact that FSeq is denumerable and that\nSeq and Bin are equivalent. Although both are quite straightforward on paper,\nthe formal proofs require quite a number of definitions and lemmas.\n*)\nRequire Import Coq.PArith.BinPosDef.\nImport Pnat.\n\n(*\nAll finite sequences are denumerable. We translate finite sequences to a binary\nsequence (of type positive) and encode this as a number rather than using prime\nfactorization (which is often used in mathematics).\n*)\nSection FSeqDenumerable.\n\n(* Process xI as S and xO/xH as separator. *)\nFixpoint pos_to_fseq (p : positive) (acc : nat) : fseq :=\n  match p with\n  | xI q => pos_to_fseq q (S acc)\n  | xO q => acc :: pos_to_fseq q 0\n  | xH => [acc]\n  end.\n\n(* Prepend n 1 bits before p. *)\nFixpoint repeat_xI n p :=\n  match n with\n  | 0 => p\n  | S m => xI (repeat_xI m p)\n  end.\n\n(* Inverse of pos_to_fseq (injective for s <> []). *)\nFixpoint fseq_to_pos (s : fseq) :=\n  match s with\n  | [] => xH\n  | [n] => repeat_xI n xH\n  | n :: t => repeat_xI n (xO (fseq_to_pos t))\n  end.\n\nDefinition nat_to_fseq n :=\n  if n =? 0 then [] else pos_to_fseq (Pos.of_nat n) 0.\n\nDefinition fseq_to_nat s :=\n  if length s =? 0 then 0 else Pos.to_nat (fseq_to_pos s).\n\nLemma pos_to_fseq_nil p acc :\n  pos_to_fseq p acc <> [].\nProof.\nrevert acc; induction p; simpl; intros.\napply IHp. easy. easy.\nQed.\n\nLemma pos_to_fseq_neq p tl acc n :\n  acc :: tl <> pos_to_fseq p (acc + S n).\nProof.\nrevert n; induction p; simpl; intros.\n1: replace (S (acc + S n)) with (acc + (S (S n))) by lia; apply IHp.\nall: intros H; injection H; lia.\nQed.\n\nCorollary pos_to_fseq_neq_S p tl acc : acc :: tl <> pos_to_fseq p (S acc).\nProof. rewrite <-add_1_r; apply pos_to_fseq_neq. Qed.\n\nLemma pos_to_fseq_weak_inj p q acc :\n  pos_to_fseq p acc = pos_to_fseq q acc -> p = q.\nProof.\nrevert p acc; induction q; simpl; intros; destruct p; simpl in H.\n- replace q with p. easy. eapply IHq; apply H.\n- exfalso; eapply pos_to_fseq_neq_S. apply H.\n- exfalso; eapply pos_to_fseq_neq_S. apply H.\n- exfalso; eapply pos_to_fseq_neq_S. symmetry; apply H.\n- replace q with p. easy. eapply IHq. injection H; intros E; apply E.\n- injection H; intros. exfalso; eapply pos_to_fseq_nil. symmetry; apply H0.\n- exfalso; eapply pos_to_fseq_neq_S. symmetry; apply H.\n- injection H; intros. exfalso; eapply pos_to_fseq_nil. apply H0.\n- easy.\nQed.\n\nLemma nat_to_fseq_weak_inj :\n  weak_injective Nat FSeq nat_to_fseq.\nProof.\nintros m n _ _. unfold nat_to_fseq. destruct m, n; auto.\n- cbn; intros; exfalso; eapply pos_to_fseq_nil. symmetry; apply H.\n- cbn; intros; exfalso; eapply pos_to_fseq_nil. apply H.\n- replace (S m =? 0) with false by easy; replace (S n =? 0) with false by easy.\n  intros; apply pos_to_fseq_weak_inj in H. now apply Nat2Pos.inj.\nQed.\n\nLemma pos_to_fseq_repeat_xI_xH m n :\n  pos_to_fseq (repeat_xI m xH) n = [m + n].\nProof.\nrevert n; induction m; simpl; intros; auto.\nrewrite IHm. now replace (m + S n) with (S (m + n)) by lia.\nQed.\n\nLemma pos_to_fseq_repeat_xI_xO m n p :\n  pos_to_fseq (repeat_xI m (xO p)) n = (m + n) :: pos_to_fseq p 0.\nProof.\nrevert n; induction m; simpl; intros; auto.\nrewrite IHm. now replace (m + S n) with (S (m + n)) by lia.\nQed.\n\nLemma pos_to_fseq_inv s :\n  s <> [] -> pos_to_fseq (fseq_to_pos s) 0 = s.\nProof.\ninduction s; simpl. easy. destruct s.\n- now rewrite pos_to_fseq_repeat_xI_xH, add_0_r.\n- rewrite pos_to_fseq_repeat_xI_xO, add_0_r. rewrite IHs; easy.\nQed.\n\nLemma nat_to_fseq_involutive s :\n  nat_to_fseq (fseq_to_nat s) = s.\nProof.\ndestruct s. easy. unfold nat_to_fseq, fseq_to_nat.\nreplace (length _ =? 0) with false by easy.\nedestruct Pos2Nat.is_succ; rewrite H at 1.\nreplace (S _ =? 0) with false by easy; clear H x.\nrewrite Pos2Nat.id. now apply pos_to_fseq_inv.\nQed.\n\nTheorem fseq_denumerable :\n  denumerable FSeq.\nProof.\nexists nat_to_fseq; split. easy. split.\n- intros n m nN mN Hnm. simpl in *; unfold dec_apart in *.\n  intros H; apply Hnm. apply nat_to_fseq_weak_inj; auto.\n- intros s _. exists (fseq_to_nat s); split.\n  apply I. apply nat_to_fseq_involutive.\nQed.\n\nEnd FSeqDenumerable.\n\n(*\nIt is possible to construct an injection from Seq (Baire space) to\nBin (Cantor space). We use the same scheme as in the previous part, but without\nthe positive type (which we needed to encode and decode nat).\n*)\nModule SeqToBin.\n\n(*\nWe determine the n-th value by counting down starting with i = 0 where i\ntracks the next index of \u03b1 to check. Although it can be proved directly that\nthis function is strongly extensional, several attempts at a proof failed and I\ndecided this was not really important.\n*)\nFixpoint f i c \u03b1 n :=\n  match c with\n  | 0 =>\n    (* separator *)\n    match n with\n    | 0 => 0\n    | S n' =>  f (S i) (\u03b1 i) \u03b1 n'\n    end\n  | S c' =>\n    (* counting down *)\n    match n with\n    | 0 => 1\n    | S n' => f i c' \u03b1 n'\n    end\n  end.\n\n(* Skip n numbers in the image of \u03b1. *)\nDefinition skipn n \u03b1 := n + fold_right add 0 \u27e8\u03b1;n\u27e9.\nDefinition apart_at (\u03b1 \u03b2 : seq) n := skipn n \u03b1 + (1 + min (\u03b1 n) (\u03b2 n)).\n\nLemma f_count_down \u03b1 i n k : f i (\u03b1 n) \u03b1 (\u03b1 n + k) = f i 0 \u03b1 k.\nProof. induction (\u03b1 n); simpl; auto. Qed.\n\nLemma skipn_S \u03b1 n : skipn (S n) \u03b1 = skipn n \u03b1 + 1 + \u03b1 n.\nProof. unfold skipn; simpl. lia. Qed.\n\nLemma skipn_f \u03b1 m n :\n  f 0 0 \u03b1 (skipn m \u03b1 + n) = f m 0 \u03b1 n.\nProof.\nrevert n; induction m; intros. easy. rewrite skipn_S; simpl.\nreplace (skipn m \u03b1 + 1 + \u03b1 m + n) with (skipn m \u03b1 + (1 + (\u03b1 m + n))) by lia.\nrewrite IHm; simpl. now rewrite f_count_down.\nQed.\n\nLemma different_at \u03b1 \u03b2 n k :\n  \u03b2 n = \u03b1 n + S k -> f n 0 \u03b1 (1 + \u03b1 n) <> f n 0 \u03b2 (1 + \u03b1 n).\nProof.\nsimpl. intros R; rewrite R; clear R.\ninduction (\u03b1 n); simpl; auto.\nQed.\n\nLemma f_wd i c \u03b1 :\n  f i c \u03b1 \u2208 Bin.\nProof.\nintros m; simpl. induction m; simpl; auto. repeat bool_to_Prop; auto. clear IHm.\nrevert i c; induction m; simpl; intros; destruct c; try lia; apply IHm.\nQed.\n\nLemma f_inj \u03b1 \u03b2 n :\n  eqn n \u03b1 \u03b2 -> \u03b1 n <> \u03b2 n -> exists m, f 0 0 \u03b1 m <> f 0 0 \u03b2 m.\nProof.\nintros H1 H2; exists (apart_at \u03b1 \u03b2 n); unfold apart_at.\nassert(R: skipn n \u03b1 = skipn n \u03b2).\n{ unfold skipn. now replace \u27e8\u03b2;n\u27e9 with \u27e8\u03b1;n\u27e9 by (now apply eqn_eq_get). }\nrewrite skipn_f, R, skipn_f. destruct (min_dec (\u03b1 n) (\u03b2 n)); rewrite e.\n- apply different_at with (k:=\u03b2 n - \u03b1 n - 1). lia.\n- apply neq_sym. apply different_at with (k:=\u03b1 n - \u03b2 n - 1). lia.\nQed.\n\nEnd SeqToBin.\n\nTheorem bin_preceq_seq :\n  Bin \u227c Seq.\nProof.\npose(f (\u03b1 : seq) := \u03b1). exists f; split.\nnow intros \u03b1 H\u03b1. intros \u03b1 \u03b2 H\u03b1 H\u03b2; now unfold f.\nQed.\n\nTheorem seq_preceq_bin :\n  Seq \u227c Bin.\nProof.\nexists (SeqToBin.f 0 0); split.\n- intros \u03b1 _. apply SeqToBin.f_wd.\n- intros \u03b1 \u03b2 _ _ H.\n  apply epsilon_smallest in H as [n [H1n H2n]]. 2: intros; apply neq_dec.\n  apply SeqToBin.f_inj with (n:=n); auto.\n  intros m Hm; assert(H := H2n m); lia.\nQed.\n",
      "theorem": "Theorem seq_uncountable :\n  uncountable Seq.",
      "ground_truth": "Proof.\nintros f f_wd f_surj.\npose(\u03b3 (n : nat) := f n n + 1).\nassert(P: \u03b3 \u2208 Seq). apply I.\napply f_surj in P as [n [Hn Hf]].\napply equal_f with (x:=n) in Hf.\nunfold \u03b3 in Hf. lia.\nQed."
    },
    {
      "split": "train-sft",
      "index": 31,
      "prefix": "Require Import Bool String List.\nRequire Import Lib.CommonTactics Lib.ilist Lib.Word.\nRequire Import Lib.Struct Lib.FMap Lib.StringEq Lib.Indexer.\nRequire Import Kami.Syntax Kami.Semantics Kami.RefinementFacts Kami.Renaming Kami.Wf.\nRequire Import Kami.Renaming Kami.Specialize Kami.Inline Kami.InlineFacts Kami.Decomposition.\nRequire Import Kami.Tactics Kami.Notations.\nRequire Import Ex.MemTypes Ex.SC Ex.NativeFifo Ex.MemAsync Ex.ProcThreeStage Ex.ProcThreeStInl.\nRequire Import Eqdep ProofIrrelevance.\n\nSet Implicit Arguments.\n\nSection Invariants.\n  Variables addrSize iaddrSize instBytes dataBytes rfIdx: nat.\n\n  Variables (fetch: AbsFetch addrSize iaddrSize instBytes dataBytes)\n            (dec: AbsDec addrSize instBytes dataBytes rfIdx)\n            (exec: AbsExec addrSize instBytes dataBytes rfIdx).\n\n  Variable (d2eElt: Kind).\n  Variable (d2ePack:\n              forall ty,\n                Expr ty (SyntaxKind (Bit 2)) -> (* opTy *)\n                Expr ty (SyntaxKind (Bit rfIdx)) -> (* dst *)\n                Expr ty (SyntaxKind (Bit addrSize)) -> (* addr *)\n                Expr ty (SyntaxKind (Array Bool dataBytes)) -> (* byteEn *)\n                Expr ty (SyntaxKind (Data dataBytes)) -> (* val1 *)\n                Expr ty (SyntaxKind (Data dataBytes)) -> (* val2 *)\n                Expr ty (SyntaxKind (Data instBytes)) -> (* rawInst *)\n                Expr ty (SyntaxKind (Pc addrSize)) -> (* curPc *)\n                Expr ty (SyntaxKind (Pc addrSize)) -> (* nextPc *)\n                Expr ty (SyntaxKind Bool) -> (* epoch *)\n                Expr ty (SyntaxKind d2eElt)).\n  Variables\n    (d2eOpType: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                           Expr ty (SyntaxKind (Bit 2)))\n    (d2eDst: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                        Expr ty (SyntaxKind (Bit rfIdx)))\n    (d2eAddr: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                         Expr ty (SyntaxKind (Bit addrSize)))\n    (d2eByteEn: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                           Expr ty (SyntaxKind (Array Bool dataBytes)))\n    (d2eVal1 d2eVal2: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                                 Expr ty (SyntaxKind (Data dataBytes)))\n    (d2eRawInst: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                            Expr ty (SyntaxKind (Data instBytes)))\n    (d2eCurPc: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                          Expr ty (SyntaxKind (Pc addrSize)))\n    (d2eNextPc: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                           Expr ty (SyntaxKind (Pc addrSize)))\n    (d2eEpoch: forall ty, fullType ty (SyntaxKind d2eElt) ->\n                          Expr ty (SyntaxKind Bool)).\n\n  Hypotheses\n    (Hd2eOpType: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eOpType _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr opType)\n    (Hd2eDst: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eDst _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr dst)\n    (Hd2eAddr: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eAddr _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr addr)\n    (Hd2eByteEn: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eByteEn _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr byteEn)\n    (Hd2eVal1: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eVal1 _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr val1)\n    (Hd2eVal2: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eVal2 _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr val2)\n    (Hd2eRawInst: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eRawInst _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr rawInst)\n    (Hd2eCurPc: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eCurPc _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr curPc)\n    (Hd2eNextPc: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eNextPc _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr nextPc)\n    (Hd2eEpoch: forall opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch,\n        evalExpr (d2eEpoch _ (evalExpr (d2ePack opType dst addr byteEn val1 val2 rawInst curPc nextPc epoch))) = evalExpr epoch).\n\n  Variable (e2wElt: Kind).\n  Variable (e2wPack:\n              forall ty,\n                Expr ty (SyntaxKind d2eElt) -> (* decInst *)\n                Expr ty (SyntaxKind (Data dataBytes)) -> (* execVal *)\n                Expr ty (SyntaxKind e2wElt)).\n  Variables\n    (e2wDecInst: forall ty, fullType ty (SyntaxKind e2wElt) ->\n                            Expr ty (SyntaxKind d2eElt))\n    (e2wVal: forall ty, fullType ty (SyntaxKind e2wElt) ->\n                        Expr ty (SyntaxKind (Data dataBytes))).\n\n  Hypotheses\n    (He2wDecInst: forall decInst val,\n        evalExpr (e2wDecInst _ (evalExpr (e2wPack decInst val))) = evalExpr decInst)\n    (He2wVal: forall decInst val,\n        evalExpr (e2wVal _ (evalExpr (e2wPack decInst val))) = evalExpr val).\n\n  Variable (init: ProcInit addrSize dataBytes rfIdx).\n\n  Definition p3stInl :=\n    projT1 (p3stInl fetch dec exec\n                    d2ePack d2eOpType d2eDst d2eAddr d2eByteEn d2eVal1 d2eVal2\n                    d2eRawInst d2eCurPc d2eNextPc d2eEpoch\n                    e2wPack e2wDecInst e2wVal init).\n\n  (** Now invariants are defined below *)\n\n  Definition p3st_pinit_inv_body\n             (pinitv: fullType type (SyntaxKind Bool))\n             (fepochv: fullType type (SyntaxKind Bool))\n             (sbflagsv: fullType type (SyntaxKind (Vector Bool rfIdx)))\n             (d2eeltv: fullType type (SyntaxKind d2eElt))\n             (d2efullv: fullType type (SyntaxKind Bool))\n             (w2dfullv: fullType type (SyntaxKind Bool))\n             (eepochv: fullType type (SyntaxKind Bool))\n             (e2weltv: fullType type (SyntaxKind e2wElt))\n             (e2wfullv: fullType type (SyntaxKind Bool))\n             (stallv: fullType type (SyntaxKind Bool))\n             (stalledv: fullType type (SyntaxKind d2eElt)) :=\n    pinitv = false ->\n    fepochv = evalExpr ($$Default)%kami_expr /\\\n    sbflagsv = evalExpr ($$Default)%kami_expr /\\\n    d2eeltv = evalExpr ($$Default)%kami_expr /\\\n    d2efullv = evalExpr ($$Default)%kami_expr /\\\n    w2dfullv = evalExpr ($$Default)%kami_expr /\\\n    eepochv = evalExpr ($$Default)%kami_expr /\\\n    e2weltv = evalExpr ($$Default)%kami_expr /\\\n    e2wfullv = evalExpr ($$Default)%kami_expr /\\\n    stallv = evalExpr ($$Default)%kami_expr /\\\n    stalledv = evalExpr ($$Default)%kami_expr.\n\n  Record p3st_pinit_inv (o: RegsT) : Prop :=\n    { pinitv : fullType type (SyntaxKind Bool);\n      Hpinitv : M.find \"pinit\"%string o = Some (existT _ _ pinitv);\n      pinitRqv : fullType type (SyntaxKind Bool);\n      HpinitRqv : M.find \"pinitRq\"%string o = Some (existT _ _ pinitRqv);\n      pinitRqOfsv : fullType type (SyntaxKind (Bit iaddrSize));\n      HpinitRqOfsv : M.find \"pinitRqOfs\"%string o = Some (existT _ _ pinitRqOfsv);\n      pinitRsOfsv : fullType type (SyntaxKind (Bit iaddrSize));\n      HpinitRsOfsv : M.find \"pinitRsOfs\"%string o = Some (existT _ _ pinitRsOfsv);\n      \n      fepochv : fullType type (SyntaxKind Bool);\n      Hfepochv : M.find \"fEpoch\"%string o = Some (existT _ _ fepochv);\n      sbv : fullType type (SyntaxKind (Vector Bool rfIdx));\n      Hsbv : M.find \"sbFlags\"%string o = Some (existT _ _ sbv);\n\n      d2eeltv : fullType type (SyntaxKind d2eElt);\n      Hd2eeltv : M.find \"d2e\"--\"elt\"%string o = Some (existT _ _ d2eeltv);\n      d2efullv : fullType type (SyntaxKind Bool);\n      Hd2efullv : M.find \"d2e\"--\"full\"%string o = Some (existT _ _ d2efullv);\n      w2dfullv : fullType type (SyntaxKind Bool);\n      Hw2dfullv : M.find \"w2d\"--\"full\"%string o = Some (existT _ _ w2dfullv);\n\n      eepochv : fullType type (SyntaxKind Bool);\n      Heepochv : M.find \"eEpoch\"%string o = Some (existT _ _ eepochv);\n      e2weltv : fullType type (SyntaxKind e2wElt);\n      He2weltv : M.find \"e2w\"--\"elt\"%string o = Some (existT _ _ e2weltv);\n      e2wfullv : fullType type (SyntaxKind Bool);\n      He2wfullv : M.find \"e2w\"--\"full\"%string o = Some (existT _ _ e2wfullv);\n\n      stallv : fullType type (SyntaxKind Bool);\n      Hstallv : M.find \"stall\"%string o = Some (existT _ _ stallv);\n      stalledv : fullType type (SyntaxKind d2eElt);\n      Hstalledv : M.find \"stalled\"%string o = Some (existT _ _ stalledv);\n\n      Hinvf : p3st_pinit_inv_body\n                pinitv fepochv sbv\n                d2eeltv d2efullv w2dfullv eepochv e2weltv e2wfullv\n                stallv stalledv;\n      HinvtD : d2efullv = true -> pinitv = true;\n      HinvtW : e2wfullv = true -> pinitv = true;\n      HinvtS : stallv = true -> pinitv = true\n    }.\n      \n  Definition p3st_scoreboard_waw_inv_body\n             (d2efullv: fullType type (SyntaxKind Bool))\n             (d2eeltv: fullType type (SyntaxKind d2eElt))\n             (e2wfullv: fullType type (SyntaxKind Bool))\n             (e2weltv: fullType type (SyntaxKind e2wElt))\n             (stallv: fullType type (SyntaxKind Bool))\n             (stalledv: fullType type (SyntaxKind d2eElt))\n             (sbv: fullType type (SyntaxKind (Vector Bool rfIdx))) :=\n    (d2efullv = true ->\n     ((evalExpr (d2eOpType _ d2eeltv) = opLd ->\n       sbv (evalExpr (d2eDst _ d2eeltv)) = true) /\\\n      (evalExpr (d2eOpType _ d2eeltv) = opNm ->\n       sbv (evalExpr (d2eDst _ d2eeltv)) = true))) /\\\n    (e2wfullv = true ->\n     let decInst := evalExpr (e2wDecInst _ e2weltv) in\n     ((evalExpr (d2eOpType _ decInst) = opLd ->\n       sbv (evalExpr (d2eDst _ decInst)) = true) /\\\n      (evalExpr (d2eOpType _ decInst) = opNm ->\n       sbv (evalExpr (d2eDst _ decInst)) = true))) /\\\n    (stallv = true ->\n     ((evalExpr (d2eOpType _ stalledv) = opLd ->\n       sbv (evalExpr (d2eDst _ stalledv)) = true) /\\\n      (evalExpr (d2eOpType _ stalledv) = opNm ->\n       sbv (evalExpr (d2eDst _ stalledv)) = true))) /\\\n    (d2efullv = true -> e2wfullv = true ->\n     let decInst := evalExpr (e2wDecInst _ e2weltv) in\n     (evalExpr (d2eOpType _ d2eeltv) = opLd \\/ evalExpr (d2eOpType _ d2eeltv) = opNm) ->\n     (evalExpr (d2eOpType _ decInst) = opLd \\/ evalExpr (d2eOpType _ decInst) = opNm) ->\n     evalExpr (d2eDst _ d2eeltv) <> evalExpr (d2eDst _ decInst)) /\\\n    (d2efullv = true -> stallv = true ->\n     (evalExpr (d2eOpType _ d2eeltv) = opLd \\/ evalExpr (d2eOpType _ d2eeltv) = opNm) ->\n     (evalExpr (d2eOpType _ stalledv) = opLd \\/ evalExpr (d2eOpType _ stalledv) = opNm) ->\n     evalExpr (d2eDst _ d2eeltv) <> evalExpr (d2eDst _ stalledv)) /\\\n    (e2wfullv = true -> stallv = true ->\n     let decInst := evalExpr (e2wDecInst _ e2weltv) in\n     (evalExpr (d2eOpType _ decInst) = opLd \\/ evalExpr (d2eOpType _ decInst) = opNm) ->\n     (evalExpr (d2eOpType _ stalledv) = opLd \\/ evalExpr (d2eOpType _ stalledv) = opNm) ->\n     evalExpr (d2eDst _ decInst) <> evalExpr (d2eDst _ stalledv)).\n  \n  Record p3st_scoreboard_waw_inv (o: RegsT) : Prop :=\n    { sbv0 : fullType type (SyntaxKind (Vector Bool rfIdx));\n      Hsbv0 : M.find \"sbFlags\"%string o = Some (existT _ _ sbv0);\n      \n      d2eeltv0 : fullType type (SyntaxKind d2eElt);\n      Hd2eeltv0 : M.find \"d2e\"--\"elt\"%string o = Some (existT _ _ d2eeltv0);\n      d2efullv0 : fullType type (SyntaxKind Bool);\n      Hd2efullv0 : M.find \"d2e\"--\"full\"%string o = Some (existT _ _ d2efullv0);\n\n      e2weltv0 : fullType type (SyntaxKind e2wElt);\n      He2weltv0 : M.find \"e2w\"--\"elt\"%string o = Some (existT _ _ e2weltv0);\n      e2wfullv0 : fullType type (SyntaxKind Bool);\n      He2wfullv0 : M.find \"e2w\"--\"full\"%string o = Some (existT _ _ e2wfullv0);\n\n      stallv0 : fullType type (SyntaxKind Bool);\n      Hstallv0 : M.find \"stall\"%string o = Some (existT _ _ stallv0);\n      stalledv0 : fullType type (SyntaxKind d2eElt);\n      Hstalledv0 : M.find \"stalled\"%string o = Some (existT _ _ stalledv0);\n\n      Hinv0 : p3st_scoreboard_waw_inv_body d2efullv0 d2eeltv0 e2wfullv0 e2weltv0\n                                           stallv0 stalledv0 sbv0 }.\n\n  (* NOTE: this invariant requires p3st_scoreboard_waw_inv *)\n  Definition p3st_raw_inv_body\n             (prevv nextv: fullType type (SyntaxKind Bool))\n             (preveltv nexteltv: fullType type (SyntaxKind d2eElt)) :=\n    prevv = true -> nextv = true ->\n    (evalExpr (d2eOpType _ nexteltv) = opLd \\/ evalExpr (d2eOpType _ nexteltv) = opNm) ->\n    ((evalExpr (d2eOpType _ preveltv) = opSt ->\n      (evalExpr (d2eDst _ nexteltv) <> evalExpr (getStSrc _ (evalExpr (d2eRawInst _ preveltv))) /\\\n       evalExpr (d2eDst _ nexteltv) <> evalExpr (getStVSrc _ (evalExpr (d2eRawInst _ preveltv))))) /\\\n     (evalExpr (d2eOpType _ preveltv) = opLd ->\n      evalExpr (d2eDst _ nexteltv) <> evalExpr (getLdSrc _ (evalExpr (d2eRawInst _ preveltv)))) /\\\n     (evalExpr (d2eOpType _ preveltv) = opNm ->\n      (evalExpr (d2eDst _ nexteltv) <> evalExpr (getSrc1 _ (evalExpr (d2eRawInst _ preveltv))) /\\\n       evalExpr (d2eDst _ nexteltv) <> evalExpr (getSrc2 _ (evalExpr (d2eRawInst _ preveltv)))))).\n  \n  Record p3st_raw_inv (o: RegsT) : Prop :=\n    { d2eeltv1 : fullType type (SyntaxKind d2eElt);\n      Hd2eeltv1 : M.find \"d2e\"--\"elt\"%string o = Some (existT _ _ d2eeltv1);\n      d2efullv1 : fullType type (SyntaxKind Bool);\n      Hd2efullv1 : M.find \"d2e\"--\"full\"%string o = Some (existT _ _ d2efullv1);\n\n      e2weltv1 : fullType type (SyntaxKind e2wElt);\n      He2weltv1 : M.find \"e2w\"--\"elt\"%string o = Some (existT _ _ e2weltv1);\n      e2wfullv1 : fullType type (SyntaxKind Bool);\n      He2wfullv1 : M.find \"e2w\"--\"full\"%string o = Some (existT _ _ e2wfullv1);\n\n      stallv1 : fullType type (SyntaxKind Bool);\n      Hstallv1 : M.find \"stall\"%string o = Some (existT _ _ stallv1);\n      stalledv1 : fullType type (SyntaxKind d2eElt);\n      Hstalledv1 : M.find \"stalled\"%string o = Some (existT _ _ stalledv1);\n\n      Hd2einv1 : p3st_raw_inv_body d2efullv1 stallv1 d2eeltv1 stalledv1;\n      He2winv1 : p3st_raw_inv_body e2wfullv1 stallv1 (evalExpr (e2wDecInst _ e2weltv1)) stalledv1;\n      Hd2winv1 : p3st_raw_inv_body d2efullv1 e2wfullv1 d2eeltv1 (evalExpr (e2wDecInst _ e2weltv1))\n    }.\n\n  (* NOTE: this invariant requires p3st_raw_inv *)\n  Definition p3st_decode_inv_body\n             (pgmv: fullType type (SyntaxKind (Vector (Data instBytes) iaddrSize)))\n             (rfv: fullType type (SyntaxKind (Vector (Data dataBytes) rfIdx)))\n             (d2eeltv: fullType type (SyntaxKind d2eElt))\n             (d2efullv: fullType type (SyntaxKind Bool)) :=\n    d2efullv = true ->\n    let rawInst := evalExpr (d2eRawInst _ d2eeltv) in\n    (rawInst = pgmv (evalExpr (toIAddr _ (evalExpr (d2eCurPc _ d2eeltv)))) /\\\n     evalExpr (d2eOpType _ d2eeltv) = evalExpr (getOptype _ rawInst) /\\\n     (evalExpr (d2eOpType _ d2eeltv) = opLd ->\n      (evalExpr (d2eDst _ d2eeltv) = evalExpr (getLdDst _ rawInst) /\\\n       evalExpr (d2eAddr _ d2eeltv) =\n       evalExpr (calcLdAddr _ (evalExpr (getLdAddr _ rawInst))\n                            (rfv (evalExpr (getLdSrc _ rawInst)))))) /\\\n     (evalExpr (d2eOpType _ d2eeltv) = opSt ->\n      evalExpr (d2eAddr _ d2eeltv) =\n      evalExpr (calcStAddr _ (evalExpr (getStAddr _ rawInst))\n                           (rfv (evalExpr (getStSrc _ rawInst)))) /\\\n      evalExpr (d2eByteEn _ d2eeltv) = evalExpr (calcStByteEn _ rawInst) /\\\n      evalExpr (d2eVal1 _ d2eeltv) = rfv (evalExpr (getStVSrc _ rawInst)))) /\\\n    (evalExpr (d2eOpType _ d2eeltv) = opNm ->\n     (evalExpr (d2eDst _ d2eeltv) = evalExpr (getDst _ rawInst) /\\\n      evalExpr (d2eVal1 _ d2eeltv) = rfv (evalExpr (getSrc1 _ rawInst)) /\\\n      evalExpr (d2eVal2 _ d2eeltv) = rfv (evalExpr (getSrc2 _ rawInst)))).\n\n  Record p3st_decode_inv (o: RegsT) : Prop :=\n    { pgmv2 : fullType type (SyntaxKind (Vector (Data instBytes) iaddrSize));\n      Hpgmv2 : M.find \"pgm\"%string o = Some (existT _ _ pgmv2);\n\n      rfv2 : fullType type (SyntaxKind (Vector (Data dataBytes) rfIdx));\n      Hrfv2 : M.find \"rf\"%string o = Some (existT _ _ rfv2);\n\n      d2eeltv2 : fullType type (SyntaxKind d2eElt);\n      Hd2eeltv2 : M.find \"d2e\"--\"elt\"%string o = Some (existT _ _ d2eeltv2);\n      d2efullv2 : fullType type (SyntaxKind Bool);\n      Hd2efullv2 : M.find \"d2e\"--\"full\"%string o = Some (existT _ _ d2efullv2);\n\n      e2weltv2 : fullType type (SyntaxKind e2wElt);\n      He2weltv2 : M.find \"e2w\"--\"elt\"%string o = Some (existT _ _ e2weltv2);\n      e2wfullv2 : fullType type (SyntaxKind Bool);\n      He2wfullv2 : M.find \"e2w\"--\"full\"%string o = Some (existT _ _ e2wfullv2);\n\n      Hd2einv2 : p3st_decode_inv_body pgmv2 rfv2 d2eeltv2 d2efullv2;\n      He2winv2 : p3st_decode_inv_body pgmv2 rfv2 (evalExpr (e2wDecInst _ e2weltv2)) e2wfullv2\n    }.\n\n  (* NOTE: this invariant requires p3st_decode_inv *)\n  Definition p3st_stalled_inv_body\n             (pgmv: fullType type (SyntaxKind (Vector (Data instBytes) iaddrSize)))\n             (rfv: fullType type (SyntaxKind (Vector (Data dataBytes) rfIdx)))\n             (stallv: fullType type (SyntaxKind Bool))\n             (stalledv: fullType type (SyntaxKind d2eElt)) :=\n    stallv = true ->\n    let rawInst := evalExpr (d2eRawInst _ stalledv) in\n    evalExpr (d2eOpType _ stalledv) = evalExpr (getOptype _ rawInst) /\\\n    rawInst = pgmv (evalExpr (toIAddr _ (evalExpr (d2eCurPc _ stalledv)))) /\\\n    (evalExpr (d2eOpType _ stalledv) = opLd ->\n     evalExpr (d2eDst _ stalledv) = evalExpr (getLdDst _ rawInst) /\\\n     evalExpr (d2eAddr _ stalledv) =\n     evalExpr (calcLdAddr _ (evalExpr (getLdAddr _ rawInst))\n                          (rfv (evalExpr (getLdSrc _ rawInst))))).\n\n  Record p3st_stalled_inv (o: RegsT) : Prop :=\n    { pgmv3 : fullType type (SyntaxKind (Vector (Data instBytes) iaddrSize));\n      Hpgmv3 : M.find \"pgm\"%string o = Some (existT _ _ pgmv3);\n\n      rfv3 : fullType type (SyntaxKind (Vector (Data dataBytes) rfIdx));\n      Hrfv3 : M.find \"rf\"%string o = Some (existT _ _ rfv3);\n\n      stallv3 : fullType type (SyntaxKind Bool);\n      Hstallv3 : M.find \"stall\"%string o = Some (existT _ _ stallv3);\n      stalledv3 : fullType type (SyntaxKind d2eElt);\n      Hstalledv3 : M.find \"stalled\"%string o = Some (existT _ _ stalledv3);\n\n      Hinv3 : p3st_stalled_inv_body pgmv3 rfv3 stallv3 stalledv3 }.\n\n  Definition p3st_exec_inv_body\n             (rfv: fullType type (SyntaxKind (Vector (Data dataBytes) rfIdx)))\n             (e2wfullv: fullType type (SyntaxKind Bool))\n             (e2weltv: fullType type (SyntaxKind e2wElt)) :=\n    e2wfullv = true ->\n    let d2eeltv := evalExpr (e2wDecInst _ e2weltv) in\n    let rawInst := evalExpr (d2eRawInst _ d2eeltv) in\n    evalExpr (d2eOpType _ d2eeltv) = opNm ->\n    evalExpr (e2wVal _ e2weltv) =\n    evalExpr (doExec _ (rfv (evalExpr (getSrc1 _ rawInst))) (rfv (evalExpr (getSrc2 _ rawInst)))\n                     (evalExpr (d2eCurPc _ d2eeltv)) rawInst).\n\n  Record p3st_exec_inv (o: RegsT) : Prop :=\n    { rfv4 : fullType type (SyntaxKind (Vector (Data dataBytes) rfIdx));\n      Hrfv4 : M.find \"rf\"%string o = Some (existT _ _ rfv4);\n\n      e2weltv4 : fullType type (SyntaxKind e2wElt);\n      He2weltv4 : M.find \"e2w\"--\"elt\"%string o = Some (existT _ _ e2weltv4);\n      e2wfullv4 : fullType type (SyntaxKind Bool);\n      He2wfullv4 : M.find \"e2w\"--\"full\"%string o = Some (existT _ _ e2wfullv4);\n\n      Hinv4 : p3st_exec_inv_body rfv4 e2wfullv4 e2weltv4 }.\n\n  Definition p3st_epochs_inv_body\n             (fepochv eepochv d2efullv e2wfullv w2dfullv stallv: fullType type (SyntaxKind Bool))\n             (d2eeltv: fullType type (SyntaxKind d2eElt))\n             (e2weltv: fullType type (SyntaxKind e2wElt))\n             (stalledv: fullType type (SyntaxKind d2eElt)) :=\n    (fepochv = eepochv -> w2dfullv = false) /\\ (w2dfullv = false -> fepochv = eepochv) /\\\n    (fepochv <> eepochv -> w2dfullv = true) /\\ (w2dfullv = true -> fepochv <> eepochv) /\\\n\n    (* fepoch: w2d and {d2e, e2w} *)\n    (w2dfullv = true ->\n     ((d2efullv = true -> evalExpr (d2eEpoch _ d2eeltv) = fepochv) /\\\n      (e2wfullv = true -> evalExpr (d2eEpoch _ (evalExpr (e2wDecInst _ e2weltv))) = fepochv))) /\\\n    (d2efullv = true -> e2wfullv = true ->\n     evalExpr (d2eEpoch _ (evalExpr (e2wDecInst _ e2weltv))) = fepochv ->\n     evalExpr (d2eEpoch _ d2eeltv) = fepochv) /\\\n     \n    (* w2d and stalled *)\n    (w2dfullv = true -> stallv = false) /\\ (stallv = true -> w2dfullv = false) /\\\n    (fepochv = eepochv -> stallv = true ->\n     ((d2efullv = true -> evalExpr (d2eEpoch _ d2eeltv) = fepochv) /\\\n      (e2wfullv = true -> evalExpr (d2eEpoch _ (evalExpr (e2wDecInst _ e2weltv))) = fepochv))) /\\\n\n    (* eepoch: w2d and {d2e, e2w} *)\n    (d2efullv = true -> evalExpr (d2eEpoch _ d2eeltv) = eepochv -> w2dfullv = false) /\\\n    (e2wfullv = true -> evalExpr (d2eEpoch _ (evalExpr (e2wDecInst _ e2weltv))) = eepochv ->\n     w2dfullv = false).\n\n  Record p3st_epochs_inv (o: RegsT) : Prop :=\n    { fepochv5 : fullType type (SyntaxKind Bool);\n      Hfepochv5 : M.find \"fEpoch\"%string o = Some (existT _ _ fepochv5);\n\n      d2eeltv5 : fullType type (SyntaxKind d2eElt);\n      Hd2eeltv5 : M.find \"d2e\"--\"elt\"%string o = Some (existT _ _ d2eeltv5);\n      d2efullv5 : fullType type (SyntaxKind Bool);\n      Hd2efullv5 : M.find \"d2e\"--\"full\"%string o = Some (existT _ _ d2efullv5);\n\n      (* NOTE: Don't remove w2dElt even if it's not used in the invariant body. *)\n      w2deltv5 : fullType type (SyntaxKind (w2dElt addrSize));\n      Hw2deltv5 : M.find \"w2d\"--\"elt\"%string o = Some (existT _ _ w2deltv5);\n      w2dfullv5 : fullType type (SyntaxKind Bool);\n      Hw2dfullv5 : M.find \"w2d\"--\"full\"%string o = Some (existT _ _ w2dfullv5);\n\n      e2weltv5 : fullType type (SyntaxKind e2wElt);\n      He2weltv5 : M.find \"e2w\"--\"elt\"%string o = Some (existT _ _ e2weltv5);\n      e2wfullv5 : fullType type (SyntaxKind Bool);\n      He2wfullv5 : M.find \"e2w\"--\"full\"%string o = Some (existT _ _ e2wfullv5);\n\n      stallv5 : fullType type (SyntaxKind Bool);\n      Hstallv5 : M.find \"stall\"%string o = Some (existT _ _ stallv5);\n      stalledv5 : fullType type (SyntaxKind d2eElt);\n      Hstalledv5 : M.find \"stalled\"%string o = Some (existT _ _ stalledv5);\n\n      eepochv5 : fullType type (SyntaxKind Bool);\n      Heepochv5 : M.find \"eEpoch\"%string o = Some (existT _ _ eepochv5);\n      \n      Hinv5 : p3st_epochs_inv_body fepochv5 eepochv5 d2efullv5 e2wfullv5 w2dfullv5 stallv5\n                                   d2eeltv5 e2weltv5 stalledv5 }.\n\n  Definition p3st_pc_inv_body\n             (fepochv eepochv d2efullv e2wfullv w2dfullv stallv: fullType type (SyntaxKind Bool))\n             (pcv: fullType type (SyntaxKind (Pc addrSize)))\n             (d2eeltv: fullType type (SyntaxKind d2eElt))\n             (e2weltv: fullType type (SyntaxKind e2wElt))\n             (stalledv: fullType type (SyntaxKind d2eElt)) :=\n    (* pc: d2e *)\n    (d2efullv = true -> evalExpr (d2eEpoch _ d2eeltv) = fepochv ->\n     evalExpr (d2eNextPc _ d2eeltv) = pcv) /\\\n    (* pc: e2w *)\n    (e2wfullv = true ->\n     ((d2efullv = true ->\n       evalExpr (d2eEpoch _ (evalExpr (e2wDecInst _ e2weltv))) = evalExpr (d2eEpoch _ d2eeltv) ->\n       evalExpr (d2eNextPc _ (evalExpr (e2wDecInst _ e2weltv))) = evalExpr (d2eCurPc _ d2eeltv)) /\\\n      (d2efullv = false ->\n       evalExpr (d2eEpoch _ (evalExpr (e2wDecInst _ e2weltv))) = fepochv ->\n       evalExpr (d2eNextPc _ (evalExpr (e2wDecInst _ e2weltv))) = pcv))) /\\\n    (* pc: stalled *)\n    (stallv = true ->\n     ((e2wfullv = true -> evalExpr (d2eNextPc _ stalledv) =\n                          evalExpr (d2eCurPc _ (evalExpr (e2wDecInst _ e2weltv)))) /\\\n      (e2wfullv = false -> d2efullv = true ->\n       evalExpr (d2eNextPc _ stalledv) = evalExpr (d2eCurPc _ d2eeltv)) /\\\n      (e2wfullv = false -> d2efullv = false -> evalExpr (d2eNextPc _ stalledv) = pcv))).\n\n  Record p3st_pc_inv (o: RegsT) : Prop :=\n    { pcv6 : fullType type (SyntaxKind (Pc addrSize));\n      Hpcv6 : M.find \"pc\"%string o = Some (existT _ _ pcv6);\n      fepochv6 : fullType type (SyntaxKind Bool);\n      Hfepochv6 : M.find \"fEpoch\"%string o = Some (existT _ _ fepochv6);\n\n      d2eeltv6 : fullType type (SyntaxKind d2eElt);\n      Hd2eeltv6 : M.find \"d2e\"--\"elt\"%string o = Some (existT _ _ d2eeltv6);\n      d2efullv6 : fullType type (SyntaxKind Bool);\n      Hd2efullv6 : M.find \"d2e\"--\"full\"%string o = Some (existT _ _ d2efullv6);\n\n      w2dfullv6 : fullType type (SyntaxKind Bool);\n      Hw2dfullv6 : M.find \"w2d\"--\"full\"%string o = Some (existT _ _ w2dfullv6);\n\n      e2weltv6 : fullType type (SyntaxKind e2wElt);\n      He2weltv6 : M.find \"e2w\"--\"elt\"%string o = Some (existT _ _ e2weltv6);\n      e2wfullv6 : fullType type (SyntaxKind Bool);\n      He2wfullv6 : M.find \"e2w\"--\"full\"%string o = Some (existT _ _ e2wfullv6);\n\n      stallv6 : fullType type (SyntaxKind Bool);\n      Hstallv6 : M.find \"stall\"%string o = Some (existT _ _ stallv6);\n      stalledv6 : fullType type (SyntaxKind d2eElt);\n      Hstalledv6 : M.find \"stalled\"%string o = Some (existT _ _ stalledv6);\n\n      eepochv6 : fullType type (SyntaxKind Bool);\n      Heepochv6 : M.find \"eEpoch\"%string o = Some (existT _ _ eepochv6);\n      \n      Hinv6 : p3st_pc_inv_body fepochv6 eepochv6 d2efullv6 e2wfullv6 w2dfullv6 stallv6\n                               pcv6 d2eeltv6 e2weltv6 stalledv6 }.\n\n  #[local] Hint Unfold p3st_pinit_inv_body\n       p3st_scoreboard_waw_inv_body p3st_raw_inv_body\n       p3st_decode_inv_body p3st_stalled_inv_body\n       p3st_exec_inv_body p3st_epochs_inv_body\n       p3st_pc_inv_body : InvDefs.\n\n  Ltac p3st_inv_old :=\n    repeat match goal with\n           | [H: p3st_pinit_inv _ |- _] => destruct H\n           | [H: p3st_scoreboard_waw_inv _ |- _] => destruct H\n           | [H: p3st_raw_inv _ |- _] => destruct H\n           | [H: p3st_decode_inv _ |- _] => destruct H\n           | [H: p3st_stalled_inv _ |- _] => destruct H\n           | [H: p3st_exec_inv _ |- _] => destruct H\n           | [H: p3st_epochs_inv _ |- _] => destruct H\n           | [H: p3st_pc_inv _ |- _] => destruct H\n           end;\n    kinv_red.\n\n  Ltac p3st_inv_new :=\n    econstructor; (* let's prove that the invariant holds for the next state *)\n    try (findReify; (reflexivity || eassumption); fail);\n    kregmap_clear; (* for improving performance *)\n    kinv_red; (* unfolding invariant definitions *)\n    repeat (* cheaper than \"intuition\" *)\n      (match goal with\n       | [ |- _ /\\ _ ] => split\n       end);\n    try eassumption; intros; try reflexivity;\n    intuition kinv_simpl; intuition idtac.\n\n  Ltac d2e_abs_tac :=\n    try rewrite Hd2eOpType in *;\n    try rewrite Hd2eDst in *;\n    try rewrite Hd2eAddr in *;\n    try rewrite Hd2eByteEn in *;\n    try rewrite Hd2eVal1 in *;\n    try rewrite Hd2eVal2 in *;\n    try rewrite Hd2eRawInst in *;\n    try rewrite Hd2eCurPc in *;\n    try rewrite Hd2eNextPc in *;\n    try rewrite Hd2eEpoch in *;\n    try rewrite He2wDecInst in *;\n    try rewrite He2wVal in *;\n    intuition idtac.\n\n  Ltac p3st_inv_tac := p3st_inv_old; p3st_inv_new; d2e_abs_tac.\n\n  Lemma p3st_pinit_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_pinit_inv n.\n  Proof. (* SKIP_PROOF_ON\n    induction 2; intros.\n\n    - p3st_inv_old.\n      unfold getRegInits, fst, p3stInl, ProcThreeStInl.p3stInl, projT1.\n      p3st_inv_new; simpl in *; kinv_simpl.\n\n    - kinvert.\n      + mred.\n      + mred.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        END_SKIP_PROOF_ON *) apply cheat.\n  Qed.\n\n  Lemma p3st_epochs_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_epochs_inv n.\n  Proof. (* SKIP_PROOF_ON\n    induction 2; intros.\n\n    - p3st_inv_old.\n      unfold getRegInits, fst, p3stInl, ProcThreeStInl.p3stInl, projT1.\n      p3st_inv_new; simpl in *; kinv_simpl.\n\n    - (* pose proof (p3st_pinit_inv_ok' H H0). *)\n      kinvert.\n      + mred.\n      + mred.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac;\n          try (destruct x0, eepochv5; intuition idtac; fail).\n        rewrite H13 in H3; exfalso; eapply negb_eq_false; eauto.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        rewrite H3 in H2; exfalso; eapply negb_eq_false; eauto.\n      + kinv_dest_custom p3st_inv_tac.\n        rewrite H3 in H2; exfalso; eapply negb_eq_false; eauto.\n        END_SKIP_PROOF_ON *) apply cheat.\n  Qed.\n\n  Lemma p3st_pc_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_pc_inv n.",
      "suffix": "\n\n  Lemma p3st_scoreboard_waw_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_scoreboard_waw_inv n.\n  Proof. (* SKIP_PROOF_ON\n    induction 2.\n\n    - p3st_inv_old.\n      unfold getRegInits, p3stInl, ProcThreeStInl.p3stInl, projT1.\n      p3st_inv_new; simpl in *; kinv_simpl.\n\n    - kinvert.\n      + mred.\n      + mred.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac; try (find_if_inside; intuition idtac; fail);\n          try (simpl in H7; rewrite H7 in H11; rewrite H11 in H12; discriminate);\n          try (simpl in H7; rewrite H7 in H11; rewrite H11 in H6; discriminate).\n      + kinv_dest_custom p3st_inv_tac; try (rewrite e in H2; inv H2; fail);\n          try (rewrite e in H8; inv H8; fail).\n      + kinv_dest_custom p3st_inv_tac; try (find_if_inside; intuition idtac; fail);\n          try (simpl in H7; rewrite H7 in H11; rewrite H11 in H12; discriminate);\n          try (simpl in H7; rewrite H7 in H11; rewrite H11 in H6; discriminate).\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac;\n          try (apply eq_sym, orb_true_iff in Heqic; destruct Heqic;\n               try (kinv_simpl; find_if_inside; intuition idtac)).\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac; try (find_if_inside; intuition idtac; fail).\n      + kinv_dest_custom p3st_inv_tac; try (find_if_inside; intuition idtac; fail).\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac; try (find_if_inside; intuition idtac; fail).\n      + kinv_dest_custom p3st_inv_tac; try (find_if_inside; intuition idtac; fail).\n        END_SKIP_PROOF_ON *) apply cheat.\n  Qed.\n  \n  Lemma p3st_raw_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_raw_inv n.\n  Proof. (* SKIP_PROOF_ON\n    induction 2; intros.\n\n    - p3st_inv_old.\n      unfold getRegInits, fst, p3stInl, ProcThreeStInl.p3stInl, projT1.\n      p3st_inv_new; simpl in *; kinv_simpl.\n\n    - pose proof (p3st_scoreboard_waw_inv_ok' H H0).\n      kinvert.\n      + mred.\n      + mred.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac; try (rewrite e in H7; inv H7; fail);\n          try (rewrite e in H8; inv H8; fail);\n          try (rewrite e in H9; inv H9; fail).\n        * simpl in H9; rewrite H9 in H3; unfold LdSrcK in *; rewrite H3 in H5; discriminate.\n        * simpl in H9; rewrite H9 in H3; unfold LdSrcK in *; rewrite H3 in H5; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold LdSrcK in *; rewrite H10 in H5; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold LdSrcK in *; rewrite H10 in H5; discriminate.\n      + kinv_dest_custom p3st_inv_tac; try (rewrite e in H7; inv H7; fail);\n          try (rewrite e in H8; inv H8; fail);\n          try (rewrite e in H9; inv H9; fail).\n        * simpl in H9; rewrite H9 in H3; unfold StSrcK in *; rewrite H3 in H5; discriminate.\n        * simpl in H9; rewrite H9 in H3; unfold StVSrcK in *; rewrite H3 in H12; discriminate.\n        * simpl in H9; rewrite H9 in H3; unfold StSrcK in *; rewrite H3 in H5; discriminate.\n        * simpl in H9; rewrite H9 in H3; unfold StVSrcK in *; rewrite H3 in H12; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold StSrcK in *; rewrite H10 in H5; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold StVSrcK in *; rewrite H10 in H12; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold StSrcK in *; rewrite H10 in H5; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold StVSrcK in *; rewrite H10 in H12; discriminate.\n      + kinv_dest_custom p3st_inv_tac; try (rewrite e in H7; inv H7; fail);\n          try (rewrite e in H8; inv H8; fail);\n          try (rewrite e in H9; inv H9; fail).\n        * simpl in H9; rewrite H9 in H3; unfold Src1K in *; rewrite H3 in H5; discriminate.\n        * simpl in H9; rewrite H9 in H3; unfold Src2K in *; rewrite H3 in H16; discriminate.\n        * simpl in H9; rewrite H9 in H3; unfold Src1K in *; rewrite H3 in H5; discriminate.\n        * simpl in H9; rewrite H9 in H3; unfold Src2K in *; rewrite H3 in H16; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold Src1K in *; rewrite H10 in H5; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold Src2K in *; rewrite H10 in H16; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold Src1K in *; rewrite H10 in H5; discriminate.\n        * simpl in H11; rewrite H11 in H10; unfold Src2K in *; rewrite H10 in H16; discriminate.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        END_SKIP_PROOF_ON *) apply cheat.\n  Qed.\n\n  Lemma p3st_decode_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_decode_inv n.\n  Proof. (* SKIP_PROOF_ON\n    induction 2; intros.\n\n    - p3st_inv_old.\n      unfold getRegInits, fst, p3stInl, ProcThreeStInl.p3stInl, projT1.\n      p3st_inv_new; simpl in *; kinv_simpl.\n\n    - pose proof (p3st_pinit_inv_ok' H H0) as HpinitInv.\n      pose proof (p3st_raw_inv_ok' H H0).\n      kinvert.\n      + mred.\n      + mred.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac; discriminate.\n      + kinv_dest_custom p3st_inv_tac; discriminate.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac; try reflexivity; try (rewrite e in H1; inv H1; fail).\n      + kinv_dest_custom p3st_inv_tac; try reflexivity; try (rewrite e in H1; inv H1; fail).\n      + kinv_dest_custom p3st_inv_tac; try reflexivity; try (rewrite e in H1; inv H1; fail).\n      + kinv_dest_custom p3st_inv_tac; try reflexivity; try (rewrite e in H1; inv H1; fail).\n      + kinv_dest_custom p3st_inv_tac; try (simpl; intuition idtac).\n      + kinv_dest_custom p3st_inv_tac; try (simpl; intuition idtac).\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac;\n          try (find_if_inside; [exfalso; intuition auto|intuition idtac]; fail).\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac;\n          try (find_if_inside; [exfalso; intuition auto|intuition idtac]; fail).\n      + kinv_dest_custom p3st_inv_tac.\n        END_SKIP_PROOF_ON *) apply cheat.\n  Qed.\n  \n  Lemma p3st_stalled_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_stalled_inv n.\n  Proof. (* SKIP_PROOF_ON\n    induction 2; intros.\n\n    - p3st_inv_old.\n      unfold getRegInits, fst, p3stInl, ProcThreeStInl.p3stInl, projT1.\n      p3st_inv_new; simpl in *; kinv_simpl.\n\n    - pose proof (p3st_pinit_inv_ok' H H0).\n      pose proof (p3st_decode_inv_ok' H H0).\n      kinvert.\n      + mred.\n      + mred.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac; discriminate.\n      + kinv_dest_custom p3st_inv_tac; discriminate.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        END_SKIP_PROOF_ON *) apply cheat.\n  Qed.\n\n  Lemma p3st_exec_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_exec_inv n.\n  Proof. (* SKIP_PROOF_ON\n    induction 2; intros.\n\n    - p3st_inv_old.\n      unfold getRegInits, fst, p3stInl, ProcThreeStInl.p3stInl, projT1.\n      p3st_inv_new; simpl in *; kinv_simpl.\n\n    - pose proof (p3st_decode_inv_ok' H H0).\n      pose proof (p3st_raw_inv_ok' H H0).\n      kinvert.\n      + mred.\n      + mred.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        simpl; rewrite <-H11, <-H9; reflexivity.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        * find_if_inside; [elim H20; auto|].\n          find_if_inside; [elim H21; auto|].\n          intuition idtac.\n        * find_if_inside; [elim H20; auto|].\n          find_if_inside; [elim H21; auto|].\n          intuition idtac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        END_SKIP_PROOF_ON *) apply cheat.\n  Qed.\n\n  Lemma p3st_inv_ok:\n    forall o,\n      reachable o p3stInl ->\n      p3st_pinit_inv o /\\\n      p3st_scoreboard_waw_inv o /\\ p3st_raw_inv o /\\ p3st_decode_inv o /\\\n      p3st_stalled_inv o /\\ p3st_exec_inv o /\\ p3st_epochs_inv o /\\ p3st_pc_inv o.\n  Proof.\n    intros; inv H; inv H0.\n    repeat split.\n    - eapply p3st_pinit_inv_ok'; eauto.\n    - eapply p3st_scoreboard_waw_inv_ok'; eauto.\n    - eapply p3st_raw_inv_ok'; eauto.\n    - eapply p3st_decode_inv_ok'; eauto.\n    - eapply p3st_stalled_inv_ok'; eauto.\n    - eapply p3st_exec_inv_ok'; eauto.\n    - eapply p3st_epochs_inv_ok'; eauto.\n    - eapply p3st_pc_inv_ok'; eauto.\n  Qed.\n\nEnd Invariants.\n\n#[global] Hint Unfold p3st_scoreboard_waw_inv_body p3st_raw_inv_body\n     p3st_decode_inv_body p3st_stalled_inv_body\n     p3st_exec_inv_body p3st_epochs_inv_body p3st_pc_inv_body : InvDefs.\n\n",
      "theorem": "Lemma p3st_pc_inv_ok':\n    forall init n ll,\n      init = initRegs (getRegInits p3stInl) ->\n      Multistep p3stInl init n ll ->\n      p3st_pc_inv n.",
      "ground_truth": "Proof. (* SKIP_PROOF_ON\n    induction 2; intros.\n\n    - p3st_inv_old.\n      unfold getRegInits, fst, p3stInl, ProcThreeStInl.p3stInl, projT1.\n      p3st_inv_new; simpl in *; kinv_simpl.\n\n    - pose proof (p3st_epochs_inv_ok' H H0).\n      kinvert.\n      + mred.\n      + mred.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        rewrite H10 in H7; intuition idtac.\n      + kinv_dest_custom p3st_inv_tac.\n        rewrite H10 in H7; intuition idtac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n      + kinv_dest_custom p3st_inv_tac.\n        END_SKIP_PROOF_ON *) apply cheat.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 32,
      "prefix": "From mathcomp\n     Require Import all_ssreflect.\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\nSection using_finset_lib.\n  From mathcomp\n       Require Import finset.\n  Variable M : finType.\n\n  Lemma demorgan_1 (A B C : {set M}):\n    (A :&: B) :|: C = (A :|: C) :&: (B :|: C).",
      "suffix": "\n\n  About orb_andl.\n  \n  Lemma demorgan_2 (A B C : {set M}):\n    (A :|: B) :&: C = (A :&: C) :|: (B :&: C).\n  Proof.\n    apply/setP => x.\n    rewrite !inE.\n    rewrite -andb_orl.\n      by [].\n  Qed.\n  \nEnd using_finset_lib.",
      "theorem": "Lemma demorgan_1 (A B C : {set M}):\n    (A :&: B) :|: C = (A :|: C) :&: (B :|: C).",
      "ground_truth": "Proof.\n    apply/setP => x.\n    rewrite !inE.\n    rewrite -orb_andl.\n      by [].\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 33,
      "prefix": "Require Import Bool Peano_dec Vector List String.\nRequire Import Lib.CommonTactics Lib.StringEq Lib.Word Lib.FMap Lib.StringEq Lib.ilist Lib.Struct Lib.Indexer.\n\nRequire Import FunctionalExtensionality. (* for appendAction_assoc *)\nRequire Import Eqdep. (* for signature_eq *)\n\nSet Implicit Arguments.\nSet Asymmetric Patterns.\n\n(* `Vec n` is effectively a map from bit vectors of length\n   `n` to elements of `A` *)\nInductive Vec (A: Type): nat -> Type :=\n| Vec0: A -> Vec A 0\n| VecNext n: Vec A n -> Vec A n -> Vec A (S n).\n\nFixpoint replicate (A: Type) (v: A) n :=\n  match n with\n  | 0 => Vec0 v\n  | S m => VecNext (replicate v m) (replicate v m)\n  end.\n\nInductive Kind :=\n| Bool    : Kind\n| Bit     : nat -> Kind\n| Vector  : Kind -> nat -> Kind\n| Struct  : forall n, Vector.t (Attribute Kind) n -> Kind\n| Array   : Kind -> nat -> Kind.\n\nFixpoint type (t: Kind): Type :=\n  match t with\n  | Bool => bool\n  | Bit n => word n\n  | Vector nt n => word n -> type nt\n  | Struct n ks =>\n    forall i: Fin.t n,\n      Vector.nth (Vector.map (fun p => type (attrType p)) ks) i\n  | Array nt n => Fin.t n -> type nt\n  end.\n\nInductive FullKind: Type :=\n| SyntaxKind: Kind -> FullKind\n| NativeKind (t: Type) (c: t) : FullKind.\n\nSection Vector_dec.\n  Variables (A: Type) (n: nat).\n  Variable decA: forall a1 a2: A, {a1 = a2} + {a1 <> a2}.\n\n  Lemma decA_true_iff_sumbool:\n    forall a1 a2,\n      (if decA a1 a2 then true else false) = true <-> a1 = a2.\n  Proof.\n    intros; destruct (decA a1 a2); intuition congruence.\n  Qed.\n\n  Definition Vector_dec:\n    forall v1 v2: Vector.t A n, {v1 = v2} + {v1 <> v2} :=\n    Vector.eq_dec _ _ decA_true_iff_sumbool _.\n\nEnd Vector_dec.\n\nLemma vector_0_nil A: forall ls: Vector.t A 0, Vector.nil A = ls.\nProof.\n  intros; apply Vector.case0; reflexivity.\nDefined.\n\nDefinition structHd (k: Kind): Attribute Kind :=\n  match k with\n  | Struct _ Vector.nil => Build_Attribute \"FAIL\" (Bit 0)\n  | Struct _ (Vector.cons attr _ _) => attr\n  | _ => Build_Attribute \"FAIL\" (Bit 0)\n  end.\n\nDefinition structTl (k: Kind): Kind :=\n  match k with\n  | Struct _ Vector.nil => Bit 0\n  | Struct _ (Vector.cons _ _ tl) => Struct tl\n  | _ => Bit 0\n  end.\n\nLemma structHd_ok: forall k1 k2, k1 = k2 -> structHd k1 = structHd k2.\nProof.\n  intros; destruct k1, k2; try (inversion H || simpl; reflexivity).\nDefined.\n\nLemma struct_eq_hd:\n  forall n (t1 t2: Vector.t _ n),\n    Struct t1 = Struct t2 -> structHd (Struct t1) = structHd (Struct t2).\nProof. intros; exact (structHd_ok H). Defined.\n\nLemma structTl_ok: forall k1 k2, k1 = k2 -> structTl k1 = structTl k2.\nProof.\n  intros; destruct k1, k2; try (inversion H || simpl; reflexivity).\nDefined.\n\nLemma struct_eq_tl:\n  forall n (t1 t2: Vector.t _ n),\n    Struct t1 = Struct t2 -> structTl (Struct t1) = structTl (Struct t2).\nProof. intros; exact (structTl_ok H). Defined.\n\nLemma struct_eq_inv:\n  forall n (t t1: Vector.t _ n), Struct t1 = Struct t -> t1 = t.\nProof.\n  induction t; intros.\n  - symmetry; apply vector_0_nil.\n  - rewrite (VectorSpec.eta t1) in *.\n    pose proof (struct_eq_hd H).\n    pose proof (struct_eq_tl H).\n    simpl in *.\n    apply IHt in H1; subst.\n    reflexivity.\nDefined.\n\nFixpoint decKind (k1 k2: Kind) : {k1 = k2} + {k1 <> k2}.\n  refine match k1, k2 return {k1 = k2} + {k1 <> k2} with\n         | Bool, Bool => left eq_refl\n         | Bit n, Bit m =>\n           match PeanoNat.Nat.eq_dec n m with\n           | left l => left match l in _ = Y return Bit n = Bit Y with\n                            | eq_refl => eq_refl\n                            end\n           | right r => right _\n           end\n         | Vector k1 n1, Vector k2 n2 =>\n           match PeanoNat.Nat.eq_dec n1 n2 with\n           | left l => match decKind k1 k2 with\n                       | left kl => left match l in _ = Y, kl in _ = kY\n                                               return Vector k1 n1 = Vector kY Y with\n                                         | eq_refl, eq_refl => eq_refl\n                                         end\n                       | right kr => right _\n                       end\n           | right r => right _\n           end\n         | Struct n1 l1, Struct n2 l2 =>\n           match PeanoNat.Nat.eq_dec n1 n2 with\n           | left l =>\n             match l in _ = Y return\n                   forall l2: Vector.t _ Y,\n                     {Struct l1 = Struct l2} + {Struct l1 <> Struct l2} with\n             | eq_refl =>\n               fun l2 =>\n                 (fix help n l1 :=\n                    match l1 in Vector.t _ n'\n                          return forall l2: Vector.t _ n',\n                        {Struct l1 = Struct l2} + {Struct l1 <> Struct l2} with\n                    | Vector.nil => fun l2 => left (f_equal (@Struct 0) (vector_0_nil l2))\n                    | Vector.cons h n'' t =>\n                      fun l2 => _\n                    end) n1 l1 l2\n             end l2\n           | right r => right _\n           end\n         | Array k1 n1, Array k2 n2 =>\n           match PeanoNat.Nat.eq_dec n1 n2 with\n           | left l => match decKind k1 k2 with\n                       | left kl => left match l in _ = Y, kl in _ = kY\n                                               return Array k1 n1 = Array kY Y with\n                                         | eq_refl, eq_refl => eq_refl\n                                         end\n                       | right kr => right _\n                       end\n           | right r => right _\n           end\n         | _, _ => right _\n         end;\n    try (clear decKind;\n         abstract (intro; try inversion H; try inversion H0; destruct_existT; congruence)).\n\n  generalize t (help _ t); clear help t.\n  apply (Vector.caseS\n           (fun n (l2: Vector.t (Attribute Kind) (S n)) =>\n              forall t1, (forall t2: Vector.t (Attribute Kind) n,\n                             {Struct t1 = Struct t2} + {Struct t1 <> Struct t2}) ->\n                         {Struct (Vector.cons _ h n t1) = Struct l2}\n                         + {Struct (Vector.cons _ h n t1) <> Struct l2})).\n  intros.\n  destruct h, h0.\n  destruct (decKind attrType attrType0).\n  - destruct (string_dec attrName attrName0).\n    + destruct (H t).\n      * left; do 2 f_equal.\n        { congruence. }\n        { exact (struct_eq_inv e1). }\n      * clear decKind; right; abstract (intro; inversion H0; destruct_existT; congruence).\n    + clear decKind; right; abstract (intro; injection H0; intros; destruct_existT; congruence).\n  - clear decKind; right; abstract (intro; injection H0; intros; destruct_existT; congruence).\nDefined.\n\nLemma kind_eq: forall k, decKind k k = left eq_refl.\nProof.\n  intros; destruct (decKind k k).\n  - rewrite UIP_refl with (p:= e); auto.\n  - elim n; auto.\nQed.\n\nInductive ConstT: Kind -> Type :=\n| ConstBool: bool -> ConstT Bool\n| ConstBit n: word n -> ConstT (Bit n)\n| ConstVector k n: Vec (ConstT k) n -> ConstT (Vector k n)\n| ConstStruct n (ls: Vector.t _ n): ilist (fun a => ConstT (attrType a)) ls -> ConstT (Struct ls)\n| ConstArray k n: Vector.t (ConstT k) n -> ConstT (Array k n).\n\nInductive ConstFullT: FullKind -> Type :=\n| SyntaxConst k: ConstT k -> ConstFullT (SyntaxKind k)\n| NativeConst t (c c': t): ConstFullT (NativeKind c).\n\nCoercion ConstBool : bool >-> ConstT.\nCoercion ConstBit : word >-> ConstT.\n\nFixpoint vector_repeat A n (a: A) :=\n  match n return Vector.t A n with\n  | 0 => Vector.nil A\n  | S m => Vector.cons A a m (@vector_repeat A m a)\n  end.\n\nFixpoint getDefaultConst (k: Kind): ConstT k :=\n  match k with\n    | Bool => ConstBool false\n    | Bit n => ConstBit (wzero _)\n    | Vector k n => ConstVector (replicate (getDefaultConst k) n)\n    | Struct n ls =>\n      ConstStruct ((fix help n (ls: Vector.t _ n) :=\n                      match ls return ilist (fun a => ConstT (attrType a)) ls with\n                        | Vector.nil => inil _\n                        | Vector.cons x m xs => icons x (getDefaultConst (attrType x)) (help m xs)\n                      end) n ls)\n    | Array k n => ConstArray (vector_repeat n (getDefaultConst k))\n  end.\n\nFixpoint evalConstStruct n (vs: Vector.t _ n) (ils: ilist (fun a => type (attrType a)) vs) {struct ils}: type (Struct vs) :=\n  match vs in Vector.t _ k return ilist (fun a => type (attrType a)) vs -> type (Struct vs) with\n  | Vector.nil => fun ils0 i0 => Fin.case0 _ i0\n  | Vector.cons a1 n1 vs1 =>\n    fun ils1 i1 =>\n      match ils1 in ilist _ (Vector.cons a n2 vs2)\n            return forall i2: Fin.t (S n2),\n          Vector.nth\n            (Vector.map (fun p => type (attrType p)) (Vector.cons _ a n2 vs2)) i2 with\n      | inil => idProp\n      | icons t3 n3 vs3 b ils3 =>\n        fun k =>\n          match k as k4 in Fin.t (S n4) return\n                forall (vs4: Vector.t _ n4),\n                  type (Struct vs4) ->\n                  (Vector.nth (Vector.map (fun p => type (attrType p))\n                                          (Vector.cons _ t3 n4 vs4)) k4)\n          with\n          | Fin.F1 s5 => fun _ _ => b\n          | Fin.FS s5 f5 => fun vs5 f => f f5\n          end vs3 (@evalConstStruct _ _ ils3)\n      end i1\n  end ils.\n\nFixpoint getDefaultConstNative (k: Kind): type k :=\n  match k return type k with\n  | Bool => false\n  | Bit n => wzero _\n  | Vector k n => fun _ => getDefaultConstNative k\n  | Struct n attrs =>\n    fun i =>\n      ilist_to_fun _ ((fix help n (ls: Vector.t _ n) :=\n                         match ls return ilist (fun a => type (attrType a)) ls with\n                         | Vector.nil => inil _\n                         | Vector.cons x _ xs =>\n                           icons x (getDefaultConstNative (attrType x)) (help _ xs)\n                         end) n attrs) i\n  | Array k n => fun _ => getDefaultConstNative k\n  end.\n\nDefinition getDefaultConstFull (k: FullKind): ConstFullT k :=\n  match k with\n    | SyntaxKind k' => SyntaxConst (getDefaultConst k')\n    | NativeKind t c => NativeConst c c\n  end.\n\nRecord SignatureT :=\n  { arg: Kind;\n    ret: Kind\n  }.\n\nDefinition SignatureT_dec: forall (s1 s2: SignatureT), {s1 = s2} + {s1 <> s2}.\nProof.\n  decide equality.\n  apply decKind.\n  apply decKind.\nDefined.\n\nLemma signature_eq: forall sig, SignatureT_dec sig sig = left eq_refl.\nProof.\n  intros; destruct (SignatureT_dec sig sig).\n  - rewrite UIP_refl with (p:= e); auto.\n  - elim n; auto.\nQed.\n\nInductive UniBoolOp: Set :=\n| NegB: UniBoolOp.\n\nInductive BinBoolOp: Set :=\n| AndB: BinBoolOp\n| OrB: BinBoolOp.\n\nInductive UniBitOp: nat -> nat -> Set :=\n| Inv n: UniBitOp n n\n| Neg n: UniBitOp n n\n| ConstExtract n1 n2 n3: UniBitOp (n1 + n2 + n3) n2 (* LSB : n1, MSB : n3 *)\n| Trunc n1 n2: UniBitOp (n1 + n2) n1 (* LSB : n1 *)\n| ZeroExtendTrunc n1 n2: UniBitOp n1 n2\n| SignExtendTrunc n1 n2: UniBitOp n1 n2\n| TruncLsb n1 n2 : UniBitOp (n1 + n2) n2. (* MSB : n2 *)\n\nInductive BinSign := SignSS | SignSU | SignUU.\n\nInductive BinBitOp: nat -> nat -> nat -> Set :=\n| Add n: BinBitOp n n n\n| Sub n: BinBitOp n n n\n| Mul n: BinSign -> BinBitOp n n n\n| Div n: bool -> BinBitOp n n n\n| Rem n: bool -> BinBitOp n n n\n| Band n: BinBitOp n n n\n| Bor n: BinBitOp n n n\n| Bxor n: BinBitOp n n n\n| Sll n m: BinBitOp n m n\n| Srl n m: BinBitOp n m n\n| Sra n m: BinBitOp n m n\n| Concat n1 n2: BinBitOp n1 n2 (n2 + n1). (* MSB : n1, LSB : n2 *)\n\nInductive BinBitBoolOp: nat -> nat -> Set :=\n| Lt n: BinBitBoolOp n n\n| Slt n: BinBitBoolOp n n.\n\nSection Phoas.\n  Variable ty: Kind -> Type.\n  Definition fullType k := match k with\n                           | SyntaxKind k' => ty k'\n                           | NativeKind k' _ => k'\n                           end.\n\n  Definition FieldKind {n} (ls: Vector.t (Attribute Kind) n)\n             (i: Fin.t n) :=\n    Vector.nth (Vector.map (@attrType _) ls) i.\n\n  Inductive Expr: FullKind -> Type :=\n  | Var k: fullType k -> Expr k\n  | Const k: ConstT k -> Expr (SyntaxKind k)\n  | UniBool: UniBoolOp -> Expr (SyntaxKind Bool) -> Expr (SyntaxKind Bool)\n  | BinBool: BinBoolOp -> Expr (SyntaxKind Bool) -> Expr (SyntaxKind Bool) -> Expr (SyntaxKind Bool)\n  | UniBit n1 n2: UniBitOp n1 n2 -> Expr (SyntaxKind (Bit n1)) -> Expr (SyntaxKind (Bit n2))\n  | BinBit n1 n2 n3: BinBitOp n1 n2 n3 ->\n                     Expr (SyntaxKind (Bit n1)) -> Expr (SyntaxKind (Bit n2)) ->\n                     Expr (SyntaxKind (Bit n3))\n  | BinBitBool n1 n2: BinBitBoolOp n1 n2 ->\n                      Expr (SyntaxKind (Bit n1)) -> Expr (SyntaxKind (Bit n2)) ->\n                      Expr (SyntaxKind Bool)\n  | ITE k: Expr (SyntaxKind Bool) -> Expr k -> Expr k -> Expr k\n  | Eq k: Expr (SyntaxKind k) -> Expr (SyntaxKind k) -> Expr (SyntaxKind Bool)\n  | ReadIndex i k: Expr (SyntaxKind (Bit i)) ->\n                   Expr (SyntaxKind (Vector k i)) -> Expr (SyntaxKind k)\n  | ReadField n (ls: Vector.t _ n) (i: Fin.t n):\n      Expr (SyntaxKind (Struct ls)) -> Expr (SyntaxKind (FieldKind ls i))\n  | BuildVector n k: Vec (Expr (SyntaxKind n)) k -> Expr (SyntaxKind (Vector n k))\n  | BuildStruct n (attrs: Vector.t _ n):\n      ilist (fun a => Expr (SyntaxKind (attrType a))) attrs -> Expr (SyntaxKind (Struct attrs))\n  | UpdateVector i k: Expr (SyntaxKind (Vector k i)) ->\n                      Expr (SyntaxKind (Bit i)) -> Expr (SyntaxKind k) ->\n                      Expr (SyntaxKind (Vector k i))\n  | ReadArrayIndex i k sz: Expr (SyntaxKind (Bit i)) ->\n                           Expr (SyntaxKind (Array k (S sz))) ->\n                           Expr (SyntaxKind k)\n  | BuildArray n k:\n      Vector.t (Expr (SyntaxKind n)) k -> Expr (SyntaxKind (Array n k))\n  | UpdateArray k sz i: Expr (SyntaxKind (Array k (S sz))) ->\n                        Expr (SyntaxKind (Bit i)) ->\n                        Expr (SyntaxKind k) ->\n                        Expr (SyntaxKind (Array k (S sz))).\n\n  Inductive BitFormat :=\n  | Binary\n  | Decimal\n  | Hex.\n\n  Definition FullBitFormat := (nat * BitFormat)%type.\n\n  Inductive Disp: Type :=\n  | DispBool: FullBitFormat -> Expr (SyntaxKind Bool) -> Disp\n  | DispBit: FullBitFormat -> forall n, Expr (SyntaxKind (Bit n)) -> Disp\n  | DispStruct n: (Vector.t FullBitFormat n) ->\n                  forall ls, Expr (SyntaxKind (@Struct n ls)) -> Disp\n  | DispArray: FullBitFormat -> forall n k, Expr (SyntaxKind (Array n k)) -> Disp.\n\n  Inductive ActionT (lretT: Kind) : Type :=\n  | MCall (meth: string) s:\n      Expr (SyntaxKind (arg s)) ->\n      (ty (ret s) -> ActionT lretT) ->\n      ActionT lretT\n  | Let_ lretT': Expr lretT' -> (fullType lretT' -> ActionT lretT) -> ActionT lretT\n  | ReadNondet:\n      forall k, (fullType k -> ActionT lretT) -> ActionT lretT\n  | ReadReg (r: string):\n      forall k, (fullType k -> ActionT lretT) -> ActionT lretT\n  | WriteReg (r: string) k:\n      Expr k -> ActionT lretT -> ActionT lretT\n  | IfElse: Expr (SyntaxKind Bool) -> forall k,\n                                        ActionT k ->\n                                        ActionT k ->\n                                        (ty k -> ActionT lretT) ->\n                                        ActionT lretT\n  | Assert_: Expr (SyntaxKind Bool) -> ActionT lretT -> ActionT lretT\n  | Displ: list Disp -> ActionT lretT -> ActionT lretT\n  | Return: Expr (SyntaxKind lretT) -> ActionT lretT.\n\n  Section StructUpdate.\n    \n    Lemma nth_map_transparent {A B} (f: A -> B) {n} v (p1 p2: Fin.t n) (eq: p1 = p2):\n      Vector.nth (Vector.map f v) p1 = f (Vector.nth v p2).\n    Proof.\n      subst p2; induction p1.\n      - revert n v; refine (@caseS _ _ _); now simpl.\n      - revert n v p1 IHp1; refine (@caseS _  _ _); now simpl.\n    Defined.\n\n    Fixpoint getFinList n: Vector.t (Fin.t n) n :=\n      match n with\n      | 0 => Vector.nil _\n      | S m => Vector.cons _ Fin.F1 _ (Vector.map (fun x => Fin.FS x) (getFinList m))\n      end.\n\n    Fixpoint zipVector (A: Type) B n (va: Vector.t A n): Vector.t B n -> Vector.t (A * B) n :=\n      match va in Vector.t _ n return Vector.t B n -> Vector.t (A * B) n\n      with\n      | Vector.nil => fun _ => Vector.nil _\n      | Vector.cons a n' va' =>\n        fun vb => match vb in Vector.t _ n2 return Vector.t A (pred n2) ->\n                                                   Vector.t (A * B) n2 with\n                  | Vector.nil => fun _ => Vector.nil _\n                  | Vector.cons b n3 vb' =>\n                    fun va' => Vector.cons _ (a, b) _ (zipVector va' vb')\n                  end va'\n      end.\n\n    Definition getVectorFin (A: Type) n (ls: Vector.t A n) :=\n      zipVector ls (getFinList n).\n\n    Definition getIlistExpr' n (ls: Vector.t (Attribute Kind) n)\n               (e: Expr (SyntaxKind (Struct ls))):\n      ilist@{Set Type}\n           (fun i : Attribute Kind * Fin.t n =>\n              Expr (SyntaxKind (attrType (Vector.nth ls (snd i)))))\n           (zipVector ls (getFinList n)) :=\n      imap_list _ (fun i => match @nth_map_transparent _ _ (@attrType _) _\n                                                       ls (snd i) (snd i) eq_refl\n                                  in _ = Y\n                                  return Expr (SyntaxKind Y)\n                            with\n                            | eq_refl => ReadField (snd i) e\n                            end) (zipVector ls (getFinList n)).\n    \n    Lemma Vector_in_cons (A: Type) (P: A -> Prop) (h: A) n (ls: Vector.t A n):\n      (forall a, Vector.In a (Vector.cons A h n ls) -> P a) ->\n      forall x, Vector.In x ls -> P x.\n    Proof.\n      intros pf x in_pf; apply pf.\n      apply Vector.In_cons_tl; assumption.\n    Defined.\n\n    Section Vec.\n      Section VIn.\n        Variable A: Type.\n        Inductive vIn : A -> forall (n : nat), Vector.t A n -> Prop :=\n          In_cons_hd : forall a (m : nat) (v : Vector.t A m), vIn a (Vector.cons A a m v)\n        | In_cons_tl : forall a (m : nat) (x : A) (v : Vector.t A m),\n            vIn a v -> vIn a (Vector.cons A x m v).\n\n        Lemma vIn_In: forall (a: A) n vs, @vIn a n vs <-> @Vector.In _ a n vs.\n        Proof.\n          intros.\n          split; intros.\n          - induction H.\n            + apply Vector.In_cons_hd.\n            + apply Vector.In_cons_tl; auto.\n          - induction H.\n            + constructor.\n            + constructor; auto.\n        Defined.\n\n        Fixpoint VIn (a: A) n (l: Vector.t A n) : Prop :=\n          match l with\n          | Vector.nil => False\n          | Vector.cons b n' ls' => a = b \\/ VIn a ls'\n          end.\n\n        Lemma VIn_In: forall (a: A) n vs, @VIn a n vs <-> @Vector.In _ a n vs.\n        Proof.\n          intros.\n          split; intros.\n          - induction vs.\n            + simpl in *.\n              exfalso; auto.\n            + simpl in H.\n              destruct H; subst; constructor; auto.\n          - induction H; simpl; auto.\n        Defined.\n\n        Lemma in_cons: forall n (ls: Vector.t A n) a b,\n            Vector.In a (Vector.cons _ b _ ls) -> a = b \\/ Vector.In a ls.\n        Proof.\n          intros.\n          apply VIn_In in H.\n          destruct H.\n          left; assumption.\n          right; apply VIn_In; assumption.\n        Defined.\n\n        Lemma Vector_In_nil : forall a, ~ Vector.In a (Vector.nil A).\n        Proof.\n          unfold not; intros.\n          apply VIn_In in H.\n          simpl in H.\n          assumption.\n        Defined.\n      End VIn.\n\n      Variables A B: Type.\n\n      Lemma in_zip2: forall n a b (la: Vector.t A n) (lb: Vector.t B n),\n          Vector.In (a, b) (zipVector la lb) -> Vector.In b lb.\n      Proof.\n        induction la; intros.\n        - rewrite <- vector_0_nil with (ls := lb) in H.\n          simpl in H.\n          apply Vector_In_nil in H.\n          exfalso; auto.\n        - specialize (IHla (Vector.tl lb)).\n          rewrite Vector.eta with (v := lb) in H.\n          simpl in H.\n          apply in_cons in H.\n          destruct H.\n          + rewrite Vector.eta with (v := lb).\n            inv H.\n            apply Vector.In_cons_hd.\n          + specialize (IHla H).\n            rewrite Vector.eta with (v := lb).\n            econstructor; eauto.\n      Defined.\n    End Vec.\n\n    Section Overall.\n      Section Imap_change_vec.\n        Variable A: Set.\n        Variable B: Set.\n        Variable f: A -> Type.\n        Variable g: B -> Type.\n        Variable h: A -> B.\n        Fixpoint imap_change_vec n (ls: Vector.t A n):\n          ilist f ls -> (forall a, Vector.In a ls -> f a = g (h a)) -> ilist g (Vector.map h ls)\n          := match ls in Vector.t _ n\n                   return ilist f ls -> (forall a, Vector.In a ls -> f a = g (h a)) ->\n                          ilist g (Vector.map h ls)\n             with\n             | Vector.nil => fun _ _ => inil _\n             | Vector.cons h0 n0 ls0 =>\n               fun ila pf =>\n                 icons (h h0) match pf _ (Vector.In_cons_hd _ _) in _ = Y return Y with\n                              | eq_refl => ilist_hd' ila\n                              end (imap_change_vec (ilist_tl' ila) (Vector_in_cons _ pf))\n             end.\n      End Imap_change_vec.\n\n      Section Map.\n        Variable A B C: Type.\n        Variable f: B -> C.\n\n        Lemma map_zip n (la: Vector.t A n):\n          forall (lb: Vector.t B n),\n            Vector.map fst (zipVector la lb) = la.\n        Proof.\n          induction la; intros; auto.\n          specialize (IHla (Vector.tl lb)).\n          rewrite Vector.eta with (v := lb).\n          simpl.\n          f_equal; auto.\n        Defined.\n\n        Lemma in_zip_map n (la: Vector.t A n):\n          forall (lb: Vector.t B n) a c,\n            Vector.In (a, c) (zipVector la (Vector.map f lb)) ->\n            exists b, c = f b /\\ Vector.In (a, b) (zipVector la lb).\n        Proof.\n          induction la; intros; auto.\n          - apply Vector_In_nil in H; exfalso; auto.\n          - rewrite Vector.eta with (v := lb) in H.\n            simpl in H.\n            apply in_cons in H.\n            destruct H.\n            + inversion H; subst.\n              exists (Vector.hd lb).\n              split.\n              * reflexivity.\n              * rewrite Vector.eta with (v := lb).\n                simpl.\n                apply Vector.In_cons_hd.\n            + rewrite Vector.eta with (v := lb).\n              specialize (IHla _ _ _ H).\n              destruct IHla as [b [ceq vin]].\n              simpl.\n              exists b.\n              split; auto.\n              apply Vector.In_cons_tl; auto.\n        Defined.\n      End Map.\n\n      Variable A: Set.\n      Variable f: A -> Type.\n\n      Lemma in_eq n ls:\n        (forall a : A * Fin.t n,\n            Vector.In a (zipVector ls (getFinList n)) ->\n            (fun i : A * Fin.t n => f (Vector.nth ls (snd i))) a = f (fst a)).\n      Proof.\n        induction ls; intros; destruct a.\n        - apply Fin.case0; assumption.\n        - simpl in H.\n          cbv [fst snd].\n          apply in_cons in H.\n          destruct H.\n          + inversion H; subst.\n            reflexivity.\n          + apply in_zip_map in H.\n            dest; subst.\n            apply IHls in H0.\n            apply H0.\n      Defined.\n\n      Definition elim_fin n (ls: Vector.t A n)\n                 (il: ilist@{Set Type} (fun i: (A * Fin.t n) => f (Vector.nth ls (snd i)))\n                           (zipVector ls (getFinList n))): ilist@{Set Type} f ls :=\n        match map_zip ls (getFinList n) in _ = Y return _ Y with\n        | eq_refl => imap_change_vec f (@fst A (Fin.t n)) il (in_eq ls)\n        end.\n    End Overall.\n\n    Definition getIlistExpr n (ls: Vector.t (Attribute Kind) n)\n               (e: Expr (SyntaxKind (Struct ls))):\n      ilist@{Set Type} (fun a => Expr (SyntaxKind (attrType a))) ls :=\n      elim_fin _ _ (getIlistExpr' e).\n\n    Definition updStruct n (ls: Vector.t (Attribute Kind) n) (e: Expr (SyntaxKind (Struct ls)))\n               (i: Fin.t n)\n               (v: Expr (SyntaxKind (Vector.nth (Vector.map (@attrType _) ls) i))):\n      Expr (SyntaxKind (Struct ls)) :=\n      BuildStruct\n        (replace_Index (getIlistExpr e) i\n                       (match @nth_map_transparent _ _ (@attrType _) _ ls i i eq_refl\n                              in _ = Y return Expr (SyntaxKind Y) with\n                        | eq_refl => v\n                        end)).\n  End StructUpdate.\n\nEnd Phoas.\n\nDefinition Action (retTy : Kind) := forall ty, ActionT ty retTy.\nDefinition MethodT (sig : SignatureT) := forall ty, ty (arg sig) -> ActionT ty (ret sig).\n\nInductive RegInitValue :=\n| RegInitCustom: sigT ConstFullT -> RegInitValue\n| RegInitDefault: FullKind -> RegInitValue.\n\nDefinition RegInitT := Attribute RegInitValue.\nDefinition DefMethT := Attribute (sigT MethodT).\n\nDefinition filterDm (dms: list DefMethT) (filt: string) :=\n  filter (fun dm => if string_dec (attrName dm) filt then false else true) dms.\n\nDefinition filterDms (dms: list DefMethT) (filt: list string) :=\n  filter (fun dm => if string_in (attrName dm) filt then false else true) dms.\n\nDefinition Void := Bit 0.\n\nRecord PrimitiveModule :=\n  { pm_name: string;\n    pm_regInits: list RegInitT;\n    pm_rules: list (Attribute (Action Void));\n    pm_methods: list DefMethT }.\n\nInductive Modules: Type :=\n| PrimMod (prim: PrimitiveModule): Modules\n| Mod (regs: list RegInitT)\n      (rules: list (Attribute (Action Void)))\n      (dms: list DefMethT): Modules\n| ConcatMod (m1 m2: Modules): Modules.\n\nFixpoint getRules m :=\n  match m with\n  | PrimMod prim => prim.(pm_rules)\n  | Mod _ rules _ => rules\n  | ConcatMod m1 m2 => getRules m1 ++ getRules m2\n  end.\n\nFixpoint getRegInits m :=\n  match m with\n  | PrimMod prim => prim.(pm_regInits)\n  | Mod regs _ _ => regs\n  | ConcatMod m1 m2 => getRegInits m1 ++ getRegInits m2\n  end.\n\nFixpoint getDefsBodies (m: Modules): list DefMethT :=\n  match m with\n  | PrimMod prim => prim.(pm_methods)\n  | Mod _ _ meths => meths\n  | ConcatMod m1 m2 => (getDefsBodies m1) ++ (getDefsBodies m2)\n  end.\n\nDefinition getDefs m: list string := namesOf (getDefsBodies m).\n\nLemma getDefs_in:\n  forall ma mb k,\n    In k (getDefs (ConcatMod ma mb)) ->\n    In k (getDefs ma) \\/ In k (getDefs mb).\nProof.\n  unfold getDefs, namesOf; intros.\n  simpl in *; rewrite map_app in H.\n  apply in_app_or; auto.\nQed.\n\nLemma getDefs_in_1:\n  forall ma mb k,\n    In k (getDefs ma) -> In k (getDefs (ConcatMod ma mb)).\nProof.\n  unfold getDefs, namesOf; intros.\n  simpl in *; rewrite map_app.\n  apply in_or_app; auto.\nQed.\n\nLemma getDefs_in_2:\n  forall ma mb k,\n    In k (getDefs mb) -> In k (getDefs (ConcatMod ma mb)).\nProof.\n  unfold getDefs, namesOf; intros.\n  simpl in *; rewrite map_app.\n  apply in_or_app; auto.\nQed.\n\nLemma getDefs_app:\n  forall ma mb,\n    getDefs (ConcatMod ma mb) = getDefs ma ++ getDefs mb.\nProof.\n  intros.\n  unfold getDefs; simpl.\n  unfold namesOf; rewrite map_app; reflexivity.\nQed.\n\nSection AppendAction.\n  Variable ty: Kind -> Type.\n\n  Fixpoint appendAction {retT1 retT2} (a1: ActionT ty retT1)\n           (a2: ty retT1 -> ActionT ty retT2): ActionT ty retT2 :=\n    match a1 with\n      | MCall name sig ar cont => MCall name sig ar (fun a => appendAction (cont a) a2)\n      | Let_ _ ar cont => Let_ ar (fun a => appendAction (cont a) a2)\n      | ReadNondet k cont => ReadNondet k (fun a => appendAction (cont a) a2)\n      | ReadReg reg k cont => ReadReg reg k (fun a => appendAction (cont a) a2)\n      | WriteReg reg _ e cont => WriteReg reg e (appendAction cont a2)\n      | IfElse ce _ ta fa cont => IfElse ce ta fa (fun a => appendAction (cont a) a2)\n      | Assert_ ae cont => Assert_ ae (appendAction cont a2)\n      | Displ ls cont => Displ ls (appendAction cont a2)\n      | Return e => Let_ e a2\n    end.\n\n  Lemma appendAction_assoc:\n    forall {retT1 retT2 retT3}\n           (a1: ActionT ty retT1) (a2: ty retT1 -> ActionT ty retT2)\n           (a3: ty retT2 -> ActionT ty retT3),\n      appendAction a1 (fun t => appendAction (a2 t) a3) = appendAction (appendAction a1 a2) a3.\n  Proof.\n    induction a1; simpl; intuition idtac; f_equal; try extensionality x; eauto.\n  Qed.\n\nEnd AppendAction.\n\nSection GetCalls.\n  Definition typeUT (k: Kind): Type := unit.\n  Definition fullTypeUT := fullType typeUT.\n  Definition getUT (k: FullKind): fullTypeUT k :=\n    match k with\n      | SyntaxKind _ => tt\n      | NativeKind t c => c\n    end.\n\n  Fixpoint getCallsA_Sig {k} (a: ActionT typeUT k): list (string * SignatureT) :=\n    match a with\n      | MCall m s _ c => (m, s) :: (getCallsA_Sig (c tt))\n      | Let_ fk e c => getCallsA_Sig\n                         (c match fk as fk' return fullType typeUT fk' with\n                              | SyntaxKind _ => tt\n                              | NativeKind _ c' => c'\n                            end)\n      | ReadNondet fk c => getCallsA_Sig\n                             (c match fk as fk' return fullType typeUT fk' with\n                                | SyntaxKind _ => tt\n                                | NativeKind _ c' => c'\n                                end)\n      | ReadReg _ fk c => getCallsA_Sig\n                            (c match fk as fk' return fullType typeUT fk' with\n                                 | SyntaxKind _ => tt\n                                 | NativeKind _ c' => c'\n                               end)\n      | WriteReg _ _ _ c => getCallsA_Sig c\n      | IfElse _ _ aT aF c =>\n        (getCallsA_Sig aT) ++ (getCallsA_Sig aF)\n                           ++ (getCallsA_Sig (c tt))\n      | Assert_ _ c => getCallsA_Sig c\n      | Displ ls c => getCallsA_Sig c\n      | Return _ => nil\n    end.\n\n  Fixpoint getCallsA {k} (a: ActionT typeUT k): list string :=\n    match a with\n      | MCall m _ _ c => m :: (getCallsA (c tt))\n      | Let_ fk e c => getCallsA\n                         (c match fk as fk' return fullType typeUT fk' with\n                              | SyntaxKind _ => tt\n                              | NativeKind _ c' => c'\n                            end)\n      | ReadNondet fk c => getCallsA\n                            (c match fk as fk' return fullType typeUT fk' with\n                                 | SyntaxKind _ => tt\n                                 | NativeKind _ c' => c'\n                               end)\n      | ReadReg _ fk c => getCallsA\n                            (c match fk as fk' return fullType typeUT fk' with\n                                 | SyntaxKind _ => tt\n                                 | NativeKind _ c' => c'\n                               end)\n      | WriteReg _ _ _ c => getCallsA c\n      | IfElse _ _ aT aF c =>\n        (getCallsA aT) ++ (getCallsA aF)\n                       ++ (getCallsA (c tt))\n      | Assert_ _ c => getCallsA c\n      | Displ ls c => getCallsA c\n      | Return _ => nil\n    end.\n\n  Lemma getCallsA_Sig_getCallsA k (a: ActionT typeUT k):\n    map fst (getCallsA_Sig a) = getCallsA a.\n  Proof.\n    induction a; auto; simpl; try f_equal; firstorder idtac.\n    rewrite ?map_app; congruence.\n  Qed.\n\n  Lemma getCallsA_appendAction:\n    forall {retK1} (a1: ActionT typeUT retK1)\n           {retK2} (a2: typeUT retK1 -> ActionT typeUT retK2),\n      getCallsA (appendAction a1 a2) =\n      getCallsA a1 ++ getCallsA (a2 tt).\n  Proof.\n    induction a1; simpl; intros; auto.\n    - f_equal; auto.\n    - do 2 rewrite <-app_assoc.\n      f_equal; f_equal; auto.\n  Qed.\n\n  Definition getCallsRule (r: Attribute (Action (Bit 0)))\n  : list string :=\n    getCallsA (attrType r typeUT).\n\n  Definition getCallsRule_Sig (r: Attribute (Action (Bit 0))) :=\n    getCallsA_Sig (attrType r typeUT).\n\n  Lemma getCallsRule_Sig_getCallsRule r:\n    map fst (getCallsRule_Sig r) = getCallsRule r.\n  Proof.\n    unfold getCallsRule_Sig, getCallsRule.\n    rewrite getCallsA_Sig_getCallsA.\n    auto.\n  Qed.\n\n  Fixpoint getCallsR (rl: list (Attribute (Action (Bit 0))))\n  : list string :=\n    match rl with\n      | nil => nil\n      | r :: rl' => (getCallsA (attrType r typeUT)) ++ (getCallsR rl')\n    end.\n\n  Fixpoint getCallsR_Sig (rl: list (Attribute (Action (Bit 0)))) :=\n    match rl with\n      | nil => nil\n      | r :: rl' => (getCallsA_Sig (attrType r typeUT)) ++ (getCallsR_Sig rl')\n    end.\n\n  Lemma getCallsR_Sig_getCallsR r:\n    map fst (getCallsR_Sig r) = getCallsR r.\n  Proof.\n    induction r; auto; simpl.\n    rewrite map_app.\n    rewrite IHr.\n    rewrite getCallsA_Sig_getCallsA.\n    auto.\n  Qed.\n\n  Definition getCallsDm (dm: DefMethT): list string :=\n    getCallsA (projT2 (attrType dm) typeUT tt).\n\n  Definition getCallsDm_Sig (dm: DefMethT) :=\n    getCallsA_Sig (projT2 (attrType dm) typeUT tt).\n\n  Lemma getCallsDm_Sig_getCallsDm r:\n    map fst (getCallsDm_Sig r) = getCallsDm r.\n  Proof.\n    unfold getCallsDm_Sig, getCallsDm.\n    rewrite getCallsA_Sig_getCallsA.\n    auto.\n  Qed.\n\n  Fixpoint getCallsM (ms: list DefMethT): list string :=\n    match ms with\n      | nil => nil\n      | m :: ms' => (getCallsA ((projT2 (attrType m)) typeUT tt))\n                      ++ (getCallsM ms')\n    end.\n\n  Fixpoint getCallsM_Sig (ms: list DefMethT) :=\n    match ms with\n      | nil => nil\n      | m :: ms' => (getCallsA_Sig ((projT2 (attrType m)) typeUT tt))\n                      ++ (getCallsM_Sig ms')\n    end.\n\n  Lemma getCallsM_Sig_getCallsM r:\n    map fst (getCallsM_Sig r) = getCallsM r.\n  Proof.\n    induction r; simpl; auto.\n    rewrite map_app, IHr, getCallsA_Sig_getCallsA.\n    auto.\n  Qed.\n\n  Lemma getCallsM_implies_getCallsDm s ms:\n    In s (getCallsM ms) -> exists dm, In dm ms /\\ In s (getCallsDm dm).\n  Proof.\n    induction ms; intros; simpl in *.\n    - intuition.\n    - apply in_app_or in H.\n      destruct H.\n      + exists a.\n        intuition.\n      + specialize (IHms H).\n        destruct IHms.\n        destruct H0.\n        exists x.\n        intuition.\n  Qed.\n\n  Lemma getCallsM_app: forall ms1 ms2, getCallsM (ms1 ++ ms2) = getCallsM ms1 ++ getCallsM ms2.\n  Proof.\n    induction ms1; intros; [reflexivity|].\n    simpl; rewrite IHms1; apply app_assoc.\n  Qed.\n\n  Lemma getCallsR_app: forall ms1 ms2, getCallsR (ms1 ++ ms2) = getCallsR ms1 ++ getCallsR ms2.\n  Proof.\n    induction ms1; intros; [reflexivity|].\n    simpl; rewrite IHms1; apply app_assoc.\n  Qed.\n\n  Definition getCalls m := getCallsR (getRules m) ++ getCallsM (getDefsBodies m).\n\n  Definition getCalls_Sig m := getCallsR_Sig (getRules m) ++ getCallsM_Sig (getDefsBodies m).\n\n  Lemma getCalls_Sig_getCalls m:\n    map fst (getCalls_Sig m) = getCalls m.\n  Proof.\n    unfold getCalls_Sig, getCalls.\n    rewrite map_app, getCallsR_Sig_getCallsR, getCallsM_Sig_getCallsM.\n    auto.\n  Qed.\n\n  Lemma getCalls_in:\n    forall ma mb k,\n      In k (getCalls (ConcatMod ma mb)) ->\n      In k (getCalls ma) \\/ In k (getCalls mb).\n  Proof.\n    unfold getCalls; intros.\n    apply in_app_or in H; destruct H.\n    - simpl in H; rewrite getCallsR_app in H.\n      apply in_app_or in H; destruct H.\n      + left; apply in_or_app; auto.\n      + right; apply in_or_app; auto.\n    - simpl in H; rewrite getCallsM_app in H.\n      apply in_app_or in H; destruct H.\n      + left; apply in_or_app; auto.\n      + right; apply in_or_app; auto.\n  Qed.\n\n  Lemma getCalls_in_1:\n    forall ma mb k,\n      In k (getCalls ma) -> In k (getCalls (ConcatMod ma mb)).\n  Proof.\n    unfold getCalls; intros.\n    apply in_or_app; apply in_app_or in H; destruct H.\n    - left; simpl; rewrite getCallsR_app.\n      apply in_or_app; auto.\n    - right; simpl; rewrite getCallsM_app.\n      apply in_or_app; auto.\n  Qed.\n\n  Lemma getCalls_in_2:\n    forall ma mb k,\n      In k (getCalls mb) -> In k (getCalls (ConcatMod ma mb)).\n  Proof.\n    unfold getCalls; intros.\n    apply in_or_app; apply in_app_or in H; destruct H.\n    - left; simpl; rewrite getCallsR_app.\n      apply in_or_app; auto.\n    - right; simpl; rewrite getCallsM_app.\n      apply in_or_app; auto.\n  Qed.\n\n  Lemma getCalls_subList_1:\n    forall m1 m2, SubList (getCalls m1 ++ getCalls m2) (getCalls (ConcatMod m1 m2)).\n  Proof.\n    unfold SubList; intros.\n    apply in_app_or in H; destruct H.\n    - apply getCalls_in_1; auto.\n    - apply getCalls_in_2; auto.\n  Qed.\n\n  Lemma getCalls_subList_2:\n    forall m1 m2, SubList (getCalls (ConcatMod m1 m2)) (getCalls m1 ++ getCalls m2).\n  Proof.\n    unfold SubList; intros.\n    apply getCalls_in in H; destruct H; apply in_or_app; auto.\n  Qed.\n\n  Lemma getCallsR_SubList:\n    forall ra rb,\n      SubList ra rb ->\n      SubList (getCallsR ra) (getCallsR rb).\n  Proof.\n    induction ra; simpl; intros.\n    - apply SubList_nil.\n    - apply SubList_cons_inv in H; dest.\n      apply SubList_app_3; auto.\n      clear -H; induction rb; simpl; [inv H|].\n      inv H.\n      + apply SubList_app_1, SubList_refl.\n      + apply SubList_app_2; auto.\n  Qed.\n\n  Lemma getCallsM_SubList:\n    forall ra rb,\n      SubList ra rb ->\n      SubList (getCallsM ra) (getCallsM rb).\n  Proof.\n    induction ra; simpl; intros.\n    - apply SubList_nil.\n    - apply SubList_cons_inv in H; dest.\n      apply SubList_app_3; auto.\n      clear -H; induction rb; simpl; [inv H|].\n      inv H.\n      + apply SubList_app_1, SubList_refl.\n      + apply SubList_app_2; auto.\n  Qed.\n\n  Lemma module_structure_indep_getCalls:\n    forall ma mb,\n      SubList (getRules ma) (getRules mb) ->\n      SubList (getDefsBodies ma) (getDefsBodies mb) ->\n      SubList (getCalls ma) (getCalls mb).\n  Proof.\n    intros.\n    unfold getCalls.\n    apply SubList_app_3.\n    - apply SubList_app_1.\n      apply getCallsR_SubList; auto.\n    - apply SubList_app_2.\n      apply getCallsM_SubList; auto.\n  Qed.\n\n  Definition DefCallSub (impl spec: Modules) :=\n    SubList (getDefs spec) (getDefs impl) /\\\n    SubList (getCalls spec) (getCalls impl).\n\n  Lemma DefCallSub_refl:\n    forall m, DefCallSub m m.\n  Proof.\n    intros; split; apply SubList_refl.\n  Qed.\n  #[local] Hint Immediate DefCallSub_refl.\n\n  Lemma DefCallSub_modular:\n    forall m1 m2 m3 m4,\n      DefCallSub m1 m3 ->\n      DefCallSub m2 m4 ->\n      DefCallSub (ConcatMod m1 m2) (ConcatMod m3 m4).\n  Proof.\n    unfold DefCallSub, SubList; intros; dest; split; intros.\n    - specialize (H e); specialize (H0 e); specialize (H1 e); specialize (H2 e).\n      apply getDefs_in in H3; destruct H3.\n      + apply getDefs_in_1; auto.\n      + apply getDefs_in_2; auto.\n    - specialize (H e); specialize (H0 e); specialize (H1 e); specialize (H2 e).\n      apply getCalls_in in H3; destruct H3.\n      + apply getCalls_in_1; auto.\n      + apply getCalls_in_2; auto.\n  Qed.\n\nEnd GetCalls.\n\nSection NoInternalCalls.\n  Fixpoint isLeaf {retT} (a: ActionT typeUT retT) (cs: list string) :=\n    match a with\n    | MCall name _ _ cont => (negb (string_in name cs)) && (isLeaf (cont tt) cs)\n    | Let_ _ ar cont => isLeaf (cont (getUT _)) cs\n    | ReadNondet k cont => isLeaf (cont (getUT _)) cs\n    | ReadReg reg k cont => isLeaf (cont (getUT _)) cs\n    | WriteReg reg _ e cont => isLeaf cont cs\n    | IfElse ce _ ta fa cont => (isLeaf ta cs) && (isLeaf fa cs) && (isLeaf (cont tt) cs)\n    | Assert_ ae cont => isLeaf cont cs\n    | Displ ls cont => isLeaf cont cs\n    | Return e => true\n    end.\n\n  Definition noCallDm (dm: DefMethT) (tgt: DefMethT) :=\n    isLeaf (projT2 (attrType dm) typeUT tt) (attrName tgt :: nil).\n\n  Fixpoint noCallsDms (dms: list DefMethT) (calls: list string) :=\n    match dms with\n    | nil => true\n    | dm :: dms' =>\n      if isLeaf (projT2 (attrType dm) typeUT tt) calls\n      then noCallsDms dms' calls\n      else false\n    end.\n\n  Fixpoint noCallsRules (rules: list (Attribute (Action Void)))\n           (calls: list string) :=\n    match rules with\n    | nil => true\n    | r :: rules' =>\n      if isLeaf (attrType r typeUT) calls\n      then noCallsRules rules' calls\n      else false\n    end.\n\n  Definition noCalls (m: Modules) (calls: list string) :=\n    (noCallsRules (getRules m) calls)\n      && (noCallsDms (getDefsBodies m) calls).\n\n  Definition noInternalCalls (m: Modules) :=\n    noCalls m (getDefs m).\n\nEnd NoInternalCalls.\n\nDefinition getExtDefsBodies (m: Modules) :=\n  filter (fun dm => negb (string_in (attrName dm) (getCalls m))) (getDefsBodies m).\n\nDefinition getExtDefs (m: Modules) :=\n  filter (fun d => negb (string_in d (getCalls m))) (getDefs m).\n\nDefinition getExtCalls (m: Modules) :=\n  filter (fun c => negb (string_in c (getDefs m))) (getCalls m).\n\nDefinition getIntDefs (m: Modules) :=\n  filter (fun d => string_in d (getCalls m)) (getDefs m).\n\nDefinition getIntCalls (m: Modules) :=\n  filter (fun c => string_in c (getDefs m)) (getCalls m).\n\nDefinition getExtMeths (m: Modules) := getExtDefs m ++ getExtCalls m.\nDefinition getIntMeths (m: Modules) := getIntDefs m ++ getIntCalls m.\n\nLemma getExtDefs_getDefs:\n  forall m, SubList (getExtDefs m) (getDefs m).\nProof.\n  unfold SubList, getExtDefs; intros.\n  apply filter_In in H; dest; auto.\nQed.\n\nLemma getExtCalls_getCalls:\n  forall m, SubList (getExtCalls m) (getCalls m).\nProof.\n  unfold SubList, getExtCalls; intros.\n  apply filter_In in H; dest; auto.\nQed.\n\nLemma getExtMeths_meths:\n  forall m, SubList (getExtMeths m) (getDefs m ++ getCalls m).\nProof.\n  intros; apply SubList_app_3.\n  - apply SubList_app_1, getExtDefs_getDefs.\n  - apply SubList_app_2, getExtCalls_getCalls.\nQed.\n\nLemma getIntDefs_getDefs:\n  forall m, SubList (getIntDefs m) (getDefs m).\nProof.\n  unfold SubList, getIntDefs; intros.\n  apply filter_In in H; dest; auto.\nQed.\n\nLemma getIntCalls_getCalls:\n  forall m, SubList (getIntCalls m) (getCalls m).\nProof.\n  unfold SubList, getIntCalls; intros.\n  apply filter_In in H; dest; auto.\nQed.\n\nLemma getIntMeths_meths:\n  forall m, SubList (getIntMeths m) (getDefs m ++ getCalls m).\nProof.\n  intros; apply SubList_app_3.\n  - apply SubList_app_1, getIntDefs_getDefs.\n  - apply SubList_app_2, getIntCalls_getCalls.\nQed.\n\nLemma getIntCalls_getExtCalls_disj:\n  forall m, DisjList (getIntCalls m) (getExtCalls m).\nProof.\n  unfold getIntCalls, getExtCalls; intros.\n  apply DisjList_logic; intros.\n  apply filter_In in H; apply filter_In in H0; dest.\n  rewrite H2 in H1; discriminate.\nQed.\n\nLemma getIntDefs_getExtDefs_disj:\n  forall m, DisjList (getIntDefs m) (getExtDefs m).",
      "suffix": "\n\nLemma getCalls_flattened:\n  forall m,\n    getCalls (Mod (getRegInits m) (getRules m) (getDefsBodies m)) =\n    getCalls m.\nProof. reflexivity. Qed.\n\nLemma getDefs_flattened:\n  forall m,\n    getDefs (Mod (getRegInits m) (getRules m) (getDefsBodies m)) =\n    getDefs m.\nProof. reflexivity. Qed.\n\nLemma getExtDefs_in:\n  forall m1 m2 s,\n    In s (getExtDefs (ConcatMod m1 m2)) ->\n    In s (getExtDefs m1) \\/ In s (getExtDefs m2).\nProof.\n  unfold getExtDefs; intros.\n  apply filter_In in H; dest.\n  apply negb_true_iff, eq_sym in H0.\n  apply string_in_dec_not_in in H0.\n  rewrite getDefs_app in H; apply in_app_or in H; destruct H.\n  - left; apply filter_In; split; auto.\n    apply negb_true_iff.\n    remember (string_in _ _) as sin; destruct sin; auto.\n    apply string_in_dec_in in Heqsin.\n    elim H0; apply getCalls_in_1; auto.\n  - right; apply filter_In; split; auto.\n    apply negb_true_iff.\n    remember (string_in _ _) as sin; destruct sin; auto.\n    apply string_in_dec_in in Heqsin.\n    elim H0; apply getCalls_in_2; auto.\nQed.\n\nLemma getExtCalls_in:\n  forall m1 m2 s,\n    In s (getExtCalls (ConcatMod m1 m2)) ->\n    In s (getExtCalls m1) \\/ In s (getExtCalls m2).\nProof.\n  unfold getExtCalls; intros.\n  apply filter_In in H; dest.\n  apply negb_true_iff, eq_sym in H0.\n  apply string_in_dec_not_in in H0.\n  apply getCalls_in in H; destruct H.\n  - left; apply filter_In; split; auto.\n    apply negb_true_iff.\n    remember (string_in _ _) as sin; destruct sin; auto.\n    apply string_in_dec_in in Heqsin.\n    elim H0; rewrite getDefs_app; apply in_or_app; auto.\n  - right; apply filter_In; split; auto.\n    apply negb_true_iff.\n    remember (string_in _ _) as sin; destruct sin; auto.\n    apply string_in_dec_in in Heqsin.\n    elim H0; rewrite getDefs_app; apply in_or_app; auto.\nQed.\n\nLemma getExtMeths_in:\n  forall m1 m2 s,\n    In s (getExtMeths (ConcatMod m1 m2)) ->\n    In s (getExtMeths m1) \\/ In s (getExtMeths m2).\nProof.\n  unfold getExtMeths; intros.\n  apply in_app_or in H; destruct H.\n  - apply getExtDefs_in in H; destruct H.\n    + left; apply in_or_app; auto.\n    + right; apply in_or_app; auto.\n  - apply getExtCalls_in in H; destruct H.\n    + left; apply in_or_app; auto.\n    + right; apply in_or_app; auto.\nQed.\n\n#[global] Hint Unfold pm_rules pm_regInits pm_methods\n     getRules getRegInits getDefs getCalls getDefsBodies\n     getExtDefsBodies getExtDefs getExtCalls getExtMeths\n     getIntDefs getIntCalls getIntMeths.\n\n(** Notations *)\n\nDeclare Scope kami_struct_scope.\nNotation \"name :: ty\" := {| attrName := name; attrType := ty |} : kami_struct_scope.\nDelimit Scope kami_struct_scope with struct.\n\nDeclare Scope kami_scope.\nNotation \"m1 ++ m2\" := (ConcatMod m1 m2) : kami_scope.\nDelimit Scope kami_scope with kami.\n",
      "theorem": "Lemma getIntDefs_getExtDefs_disj:\n  forall m, DisjList (getIntDefs m) (getExtDefs m).",
      "ground_truth": "Proof.\n  unfold getIntDefs, getExtDefs; intros.\n  apply DisjList_logic; intros.\n  apply filter_In in H; apply filter_In in H0; dest.\n  rewrite H2 in H1; discriminate.\nQed."
    },
    {
      "split": "train-sft",
      "index": 34,
      "prefix": "(** Copyright (c) 2015-2023 George M. Van Treeck.\n    Rights granted under the Creative Commons\n    Attribution License.\n    This software uses The Coq Proof Assistance,\n    Copyright (c) 1999-2022  The Coq Development Team\n    Rights granted under\n    GNU Lesser General Public License Version 2.1. *)\n\nRequire Import Arith PeanoNat Lia Field Bool Sumbool List.\n\nRequire Import Rdefinitions Raxioms RIneq Rfunctions R_Ifp.\n\nSection EuclideanRelations.\n\n(**\n   This file contains defintions and proofs for set operations,\n   list opertations, the ruler measure, operations on lists of\n   real numbers, and finally sections with proofs of volume,\n   Minkowski ditances/Lp norms, etc.\n*)\n(*\n   The definitions, lemmas, and proofs of the set operations,\n   lists, ruler measure, volume, Minkowski distance, etc. are\n   all in one file, because I wanted this file to be easy to\n   use by just loading this one file and everything works\n   without any special setup of load and import paths.\n*)\n\n(** ==================================================== *)\n(** This section has generic set definitions and proofs. *)\n\n(** Allow sets of any type. *)\nVariable A : Type.\n(** Equality of instances of a type is decideable. *)\nHypothesis eq_dec : forall x y : A, {x = y}+{x <> y}.\n\n(** Member of the set. *)\nFixpoint set_member (a:A) (x: list A) : bool :=\n    match x with\n    | nil => false\n    | a1 :: x1 => if (eq_dec a a1) then true else set_member a x1\n    end.\n\n(** Append a list of sets. *)\nFixpoint lists_appended (l: list (list A)) : list A :=\n    match l with\n    | nil => nil\n    | a::x => a++(lists_appended x)\n    end.\n\n(** Return a list with the duplicates removed. *)\nFixpoint uniques(x: list A) : list A :=\n    match x with\n    | nil => nil\n    | a1 :: x1 =>\n        if set_member a1 x1 then\n             uniques x1 else a1 :: uniques x1\n    end.\n\n(** Union of a list of sets. *)\nDefinition union (l: list (list A)) : list A :=\n    uniques (lists_appended l).\n\n(** Return a list of the duplicates. *)\nFixpoint dups(x: list A) : list A :=\n    match x with\n    | nil => nil\n    | a1 :: x1 =>\n        if set_member a1 x1 then\n             a1 :: dups x1 else dups x1\n    end.\n\n(** Duplicates in a list of sets. *)\nDefinition duplicates (l: list (list A)) : list A :=\n    dups (lists_appended l).\n\n(** Intersection is the duplicates sets with non-unique\n    duplicates removed. *)\nDefinition intersection (l: list (list A)) : list A :=\n    uniques (duplicates l).\n\n(** Difference between a set of uniques, nd, and dups, d. *)\nFixpoint diff_dups (nd d: list A) : list A :=\n    match nd with\n    | nil => nil\n    | a1 :: x1 =>\n        if set_member a1 d then\n             diff_dups x1 d else a1 :: diff_dups x1 d\n    end.\n\n(** Difference between a list of sets. *)\nDefinition diff (l: list (list A)) : list A :=\n    diff_dups (union l) (intersection l).\n\n(** Sum the cardinals of a list of sets. *)\nFixpoint list_lengths_summed (l: list (list A)) : nat :=\n    match l with\n    | nil => 0\n    | a::x => length a + (list_lengths_summed x)\n    end.\n\n(** The cardinal of an appended set is equal to sum of\n    the cardinals of each set. *)\nLemma cardinal_lists_appended_eq_list_lengths_summed :\n    forall (l: list (list A)),\n    length (lists_appended l) = list_lengths_summed l.\nProof.\n  intros.\n  induction l. reflexivity.\n  assert (app_l_lists : forall (x: list A) (y: list (list A)),\n      lists_appended (x::y) = x++(lists_appended y)).\n      intros. induction y. reflexivity. reflexivity.\n  rewrite app_l_lists.\n  assert (summed_lists : forall (x: list A) (y: list (list A)),\n      list_lengths_summed (x::y) = length x + list_lengths_summed y).\n      intros. induction y. reflexivity. reflexivity.\n  rewrite summed_lists.\n  rewrite app_length.\n  lia.\nQed.\n\n(** The length of a list is equal to length of the duplicate elements\n   plus the unique elements. *)\nLemma set_mem_in_duplicates_or_union : forall (a0: A) (l: list A),\n    length l = length ((dups l) ++ (uniques l)).\nProof.\n  intros.\n  induction l. reflexivity. simpl.\n  induction set_member. simpl. inversion IHl. reflexivity.\n  assert (length (dups l ++ a :: uniques l) =\n          length (a::nil) + length (dups l ++ uniques l)).\n      simpl. rewrite -> app_length. simpl.\n      assert (forall n: nat, S n = n + 1).\n          intros. lia.\n      rewrite -> H. rewrite -> Nat.add_assoc. rewrite <- app_length.\n      rewrite <- H. reflexivity.\n  rewrite -> H. simpl. inversion IHl. reflexivity.\nQed.\n\n(** The cardinal of a list of sets is equal to the cardinal of\n    the union plus duplicates of that list of sets. *)\nLemma card_app_eq_card_union_plus_dups :\n    forall (a: A) (l: list (list A)),\n    length (lists_appended l) = length (duplicates l ++ union l).\nProof.\n  intros. unfold duplicates. unfold union.\n  apply set_mem_in_duplicates_or_union. assumption.\nQed.\n\n(** The sum of the cardinal of sets equals the\n    cardinal of the union plus the cardinal of the duplicates. *)\nTheorem sum_eq_uniques_plus_duplicates :\n    forall (a: A) (l: list (list A)),\n    list_lengths_summed l = length (duplicates l) + length (union l).\nProof.\n  intros. rewrite <- cardinal_lists_appended_eq_list_lengths_summed.\n  rewrite <- app_length.\n  apply card_app_eq_card_union_plus_dups. assumption.\nQed.\n\n\n(** The size (cardinal) of the union set is less than and\n    equal to the sum of set sizes. *)\nTheorem union_sum_inequality :\n    forall (a: A) (l: list (list A)),\n    length (union l) <= list_lengths_summed l.\nProof.\n  intros.\n  rewrite -> sum_eq_uniques_plus_duplicates.\n  apply Nat.le_add_l. assumption.\nQed.\n\n(** End of generic set operations and proofs. *)\n\n(** ==================================================== *)\n(** Start of generic operations on lists. *)\n\n(** default value returned when no set member found. *)\nVariable default_element: A.\n\n(** Definition of an empty set. *)\nDefinition empty_list : list A := nil.\n\n(** Returns the element at position i in the list. *)\nFixpoint list_mem (i:nat) (l:list A) {struct l} : A :=\n    match i, l with\n    | O, _ => default_element\n    | S m, nil => default_element\n    | S m, h::t => list_mem m t\n    end.\n\n(** End of generic operations on lists. *)\n\n(** ================================================================ *)\n(** Start of generic operations and proofs for lists of\n    real numbers *)\n\nLocal Open Scope nat_scope.\nLocal Open Scope R_scope.\nLocal Open Scope list_scope.\n\n(** If two natural numbers are equal then they are also equal\n    as real numbers *)\nLemma eq_INR : forall (m n: nat), (m = n)%nat -> INR m = INR n.",
      "suffix": "\n\n(** Return a list of n number of real values, initialized\n    to 0. *)\nFixpoint rlist (n : nat) (r: R) : list R :=\n  match n with\n  | O => nil\n  | S n' => r:: (rlist n' r)\n  end.\n\n(** Returns the element at position i in the list. *)\nFixpoint list_rmem (i:nat) (l:list R) {struct l} : R :=\n    match i, l with\n    | O, _ => 0\n    | S m, Datatypes.nil => 0\n    | S m, h::t => list_rmem m t\n    end.\n\n(** list_list_rmem returns the ith list of real numbers in list l. *)\nDefinition list_list_rmem (i: nat) (l: list (list R)) :\n    list R := nth i l nil.\n\n(** Raise a real number, r, to the n-th power. *)\nFixpoint Rpow (r: R) (n: nat) : R :=\n    match n with\n        | 0%nat => 1\n        | S n' =>(r * Rpow r n')\n    end.\n\n(** x >= 0, n >= 1 -> x^{n} >= 0. *)\nHypothesis Rpow_ge_0 :\n    forall (x: R) (n: nat), x >= 0 -> Rpow x n >= 0.\n\n(** r1^n * r2^n = (r1 * r2)^n *)\nHypothesis pow_distributes : forall (r1 r2: R) (n: nat),\n    (Rpow r1 n) * (Rpow r2 n) = Rpow (r1 * r2) n.\n\n(** f(x) = f(y) -> x = y applied to power functions *)\nHypothesis pow_eq_args : forall (r1 r2: R) (n: nat),\n    Rpow r1 n = Rpow r2 n -> r1 = r2.\n\n(** f(x) <= f(y) -> x <= y applied to power functions *)\nHypothesis pow_le_args : forall (r1 r2: R) (n: nat),\n    Rpow r1 n <= Rpow r2 n -> r1 <= r2.\n\n(** f(x) >= f(y) -> x >= y applied to power functions *)\nHypothesis pow_ge_args : forall (r1 r2: R) (n: nat),\n    Rpow r1 n >= Rpow r2 n -> r1 >= r2.\n\n(** Assume that if real number, r, exists then that number is\n    the n-th root some other real number, r'. *)\nHypothesis nth_root_exists :\n    forall (r: R) (n: nat), exists (r': R), r = (Rpow r' n).\n\n(** Two sets of real values are equal if all the elements\n    at the same positions are also equal. *)\nInductive eq_list_R : list R -> list R -> Prop :=\n  | eq_list_R_nil : eq_list_R Datatypes.nil Datatypes.nil\n  | eq_list_R_cons : forall (i: nat) (l1 l2: list R),\n      list_rmem i l1 = list_rmem i l2 -> eq_list_R l1 l2.\n\n(** Lists with same real values at same positions are equal. *)\nHypothesis eq_list_R_is_eq : forall (l1 l2: list R),\n    eq_list_R l1 l2 -> l1 = l2.\n\n(** Reflexivity on lists of real values. *)\nLemma list_refl : forall (x y: list R), x = y -> y = x.\nProof. intros. apply eq_sym ; assumption. Qed.\n\n(** Sum a list of real numbers. *)\nFixpoint sum_list (l: list R) : R :=\n    match l with\n      | Datatypes.nil => 0\n      | a::l' => a + (sum_list l')\n    end.\n\n(** Raise each member of a list of real numbers to\n    the n^th power . *)\nFixpoint pow_list (l: list R) (n: nat) : list R :=\n  match l with\n    | Datatypes.nil => Datatypes.nil\n    | a::l' => (Rpow a n)::(pow_list l' n)\n  end.\n\n(** Specification of pow_list. *)\nHypothesis pow_list_spec : forall (i n: nat) (a: R) (l: list R),\n    (list_rmem i l) = a <-> list_rmem i (pow_list l n) = Rpow a n.\n\n(** Multiply each member of a list of real numbers by the number, r. *)\nFixpoint mult_list (l: list R) (r: R) : list R :=\n    match l with\n      | Datatypes.nil => Datatypes.nil\n      | a::l' => (a*r)::(mult_list l' r)\n    end.\n\n(** Specification of mult_list. *)\nHypothesis mult_list_spec : forall (i: nat) (a r: R) (l: list R),\n    (list_rmem i l) = a <-> list_rmem i (mult_list l r) = a * r.\n\n(** r * (a1 + a2 + ... + an) = (a1*r) + (a2*r) + ... + (an*r). *)\nHypothesis mult_distributes_over_sum_list :\n    forall (l: list R) (r: R),\n    (sum_list l) * r = sum_list(mult_list l r).\n\n(** The Cartesian product of a list of numbers. *)\nFixpoint cartesian_product (l: list R) : R :=\n    match l with\n        | Datatypes.nil => 1\n        | hd::tl => hd * cartesian_product tl\n    end.\n\n(** a^n = a_1 * ... * a_n, where a_1 = ... = a_n = a *)\nHypothesis Rpow_eq_carteian_paroduct :\n  forall (a: R) (i n: nat) (l: list R),\n  n = length l /\\ list_rmem i l = a <->\n    Rpow a n = cartesian_product l.\n\n(** r^n * (a1 * a2 * ... * an) = (a1*r) * (a2*r) * ... * (an*r). *)\nHypothesis pow_distributes_over_cartesian_product :\n    forall (l: list R) (r: R) (n: nat), n = length l ->\n    (cartesian_product l) * Rpow r n = cartesian_product (mult_list l r).\n\n(* Binomial coefficitnt, n Choose k at a time:\n   n_Choose_k = n!/(k!(n-k)!). *)\nDefinition n_Choose_k (k n: nat) : R :=\n  INR (fact(n))/(INR ((fact(k))* (fact(n-k)))).\n\n(* Binomial expansion term *)\nDefinition binom_term (x y: R) (k n: nat) : R :=\n  n_Choose_k k n * Rpow x (n - k) * Rpow y k.\n\n(* List of binomial terms. *)\n(** Raise each member of a list of real numbers to\n    the n^th power . *)\nFixpoint binomial_term_list (l: list R) (x y: R) (k n: nat) :\n  list R :=\n  match l with\n    | Datatypes.nil => Datatypes.nil\n    | a::l' =>\n     (binom_term x y k n)::(binomial_term_list l' x y (k + 1) n)\n  end.\n\n(** Specification of a list of n number of binomial terms. *)\nHypothesis binomial_term_list_spec :\n    forall (a x y: R) (i k n: nat) (l: list R),\n    (list_rmem i l) = a <->\n    list_rmem i (binomial_term_list l x y k n) =\n        binom_term x y k n.\n\n(** Partially expanded binomial terms,\n    x^n + n_Choose_k (n,1)x^(n-k)y^k + y^n. *)\nHypothesis binomial_expansion_equiv :\n    forall (x y: R) (n: nat) (l: list R),\n    sum_list (binomial_term_list l x y 0%nat n) =\n        Rpow x n + Rpow y n +\n           sum_list (binomial_term_list l x y 1%nat (n-1)).\n\n(** Lower order binomial terms, for x y >= 0 :\n    n_Choose_k (n,1)x^(n-k)y^ >= 0. *)\nHypothesis lower_order_binomial_terms :\n    forall (x y: R) (n: nat) (l: list R),\n    x = 0 /\\ x > 0 /\\ y = 0 /\\ y > 0 ->\n    sum_list (binomial_term_list l x y 1%nat (n-1)) >= 0.\n\nDefinition binomial_expansion (x y: R) (n: nat) : list R :=\n    binomial_term_list (rlist n 0%R) x y 0%nat n.\n\nHypothesis binomial_eq :\n    forall (x y: R) (n: nat),\n    Rpow (x + y) n = sum_list (binomial_expansion x y n).\n\n\n(** End of generic operations and proofs on lists of real numbers *)\n\n(** ==================================================== *)\n(** Start of definitions and proofs for the Ruler Measure *)\n\n(** list_list_mem returns the ith list in list l. *)\nDefinition list_list_mem (i: nat) (l: list (list A)) :\n    list A := nth i l nil.\n\n(** The ruler measure definition is in terms of the\n    floor function. The Coq starndard library does not\n    have a real-valued version of the floor function.\n    Therefore, the first step is define the floor\n    function and prove some properties about the floor\n    function. *)\n\n(** Define the floor function as the integer part of\n    a real-valued number. *)\nDefinition R_floor (x: R) : R := IZR (Int_part x).\n\n(** The following lemmas about integer and fractional\n    parts of a real number are used to prove properties\n    of the R_floor function. *)\n\n(** A real number is the sum of it's whole integer part\n    plus the fractional part. *)\nLemma r_eq_ip_plus_frac :\n    forall r: R, r = IZR (Int_part r) + frac_part r.\nProof.\n  intros. unfold Int_part. unfold frac_part.\n  unfold Int_part. apply eq_sym ; trivial. apply Rplus_minus.\nQed.\n\n(** 0 <= r - floor r < 1. That is, a real number minus the\n    integer part is equal to the size of the fractional part. *)\nLemma r_minus_floor_ge_0_lt_1 : forall r: R,\n    r - R_floor r >= 0 /\\ r - R_floor r < 1.\nProof.\n  intros. unfold R_floor.\n  assert (r = IZR (Int_part r) + frac_part r).\n    apply r_eq_ip_plus_frac.\n  apply (Rplus_eq_compat_l\n    (- IZR (Int_part r)) (r) (IZR (Int_part r) + frac_part r)) in H.\n  rewrite -> (Rplus_comm (- IZR (Int_part r)) r) in H.\n  rewrite <- (Rplus_assoc\n    (-IZR (Int_part r)) (IZR (Int_part r)) (frac_part r) ) in H.\n  rewrite -> (Rplus_comm (- IZR (Int_part r))\n    (IZR (Int_part r))) in H.\n  rewrite -> (Rplus_opp_r (IZR (Int_part r))) in H.\n  rewrite -> (Rplus_0_l (frac_part r)) in H.\n  assert (frac_part r >= 0 /\\ frac_part r < 1).\n  apply base_fp. decompose [and] H0.\n  assumption.\nQed.\n\n(** If r >= 0 then |r| >= 0. *)\nLemma ge_0_abs_ge_0 : forall r: R, r >= 0 -> Rabs r >= 0.\nProof.\n  intros; unfold Rabs; case (Rcase_abs r); intro.\n  absurd (r >= 0). exact (Rlt_not_ge r 0 r0). assumption. assumption.\nQed.\n\n(** 0 <= |r - floor r| < 1. *)\nLemma abs_r_minus_floor_ge_0_lt_1 : forall r: R,\n    Rabs (r - R_floor r) >= 0 /\\ Rabs(r - R_floor r) < 1.\nProof.\n  intros. unfold R_floor.\n  assert (r - IZR (Int_part r) >= 0 /\\ r - IZR (Int_part r) < 1).\n    apply r_minus_floor_ge_0_lt_1. decompose [and] H.\n  split. revert H0. apply ge_0_abs_ge_0.\n  assert (r - IZR (Int_part r) >= 0 ->\n    Rabs (r - IZR (Int_part r))= r - IZR (Int_part r)).\n  apply Rabs_right with (r := r - IZR (Int_part r)).\n  rewrite -> H2. assumption. assumption.\nQed.\n\n(** 0 <= |floor r - r| < 1. *)\nLemma abs_floor_minus_r_ge_0_lt_1 : forall r: R,\n    Rabs (R_floor r - r) >= 0 /\\ Rabs(R_floor r - r) < 1.\nProof.\n  intros. rewrite (Rabs_minus_sym (R_floor r) r).\n  apply abs_r_minus_floor_ge_0_lt_1.\nQed.\n\n(** This lemma is missing from the standard library, RIneq.v. *)\nLemma R_lt_mult_lt : forall r r1 r2 : R,\n     0 < r -> r1 < r2 -> r * r1 < r * r2.\nProof. intros. apply Rmult_lt_compat_l. assumption. assumption. Qed.\n\n(**\n   Now the ruler measure convergence proof follows:\n*)\n\n(** The exact size of a interval. *)\nDefinition exact_size (a b: R) : R := Rabs (b - a).\n\n(** The number of subintervals with size, c. *)\nDefinition subintervals (a b c: R) : R :=\n  R_floor (exact_size a b / c).\n\n(** M is the ruler measure, subintervals * c. *)\nDefinition M (a b c: R) : R := (subintervals a b c) * c.\n\n(** Used for rewriting between M and subintervals. *)\nLemma subintervals_times_c_eq_measure :\n    forall a b c: R, c > 0 ->\n    M a b c = (subintervals a b c) * c.\nProof. intros. unfold M. reflexivity. Qed.\n\n(** Let r := subintervals in 0 <= |floor r - r| < 1. *)\nLemma subintervals_div_c_le_size : forall a b c: R,\n    c > 0 ->\n    Rabs(subintervals a b c - (exact_size a b) / c) < 1.\nProof.\n  intros. unfold subintervals.\n  apply abs_floor_minus_r_ge_0_lt_1.\nQed.\n\n(** |M - s| < |c|}. *)\nLemma abs_M_minus_s_lt_abs_c : forall a b c: R,\n    c > 0 ->\n    Rabs((M a b c) - exact_size a b) < Rabs c.\nProof.\n  intros. unfold M. unfold subintervals.\n  assert (Rabs(R_floor(exact_size a b / c) -\n      (exact_size a b) / c) < 1).\n    apply subintervals_div_c_le_size.\n    assumption.\n  apply R_lt_mult_lt with (r := Rabs c)\n    (r1 := Rabs (R_floor (exact_size a b / c) - exact_size a b / c))\n    (r2 := 1) in H0.\n  rewrite -> (Rmult_1_r (Rabs c)) in H0.\n  rewrite <- (Rabs_mult (c)\n    (R_floor (exact_size a b / c) - (exact_size a b / c))) in H0.\n  unfold Rminus in H0.\n  rewrite -> (Rmult_plus_distr_l (c)\n    (R_floor (exact_size a b / c))\n    (- (exact_size a b / c))) in H0.\n  unfold Rdiv at 2 in H0.\n  rewrite -> (Rmult_comm c (R_floor (exact_size a b / c))) in H0.\n  rewrite -> (Ropp_mult_distr_r_reverse (c)\n    (exact_size a b * / c)) in H0.\n  rewrite <- (Rmult_assoc (c) (exact_size a b) (/ c)) in H0.\n  rewrite -> (Rmult_comm c (exact_size a b)) in H0.\n  rewrite -> (Rmult_assoc (exact_size a b) (c) (/ c)) in H0.\n  rewrite -> (Rinv_r c) in H0.\n  rewrite -> (Rmult_1_r (exact_size a b)) in H0.\n  assumption.\n  apply Rgt_not_eq.\n  apply H.\n  assert (c <> 0).\n  apply Rgt_not_eq.\n  apply H.\n  revert H1.\n    apply Rabs_pos_lt.\nQed.\n\n(** Epsilon-delta proof. limit c->0,\n    0 < |c - 0| < delta => |M - s| < epsilon. *)\nLemma M_minus_exact_size_lt_epsilon :\n    forall a b c delta epsilon: R,\n    c > 0 /\\ 0 < delta /\\ 0 < epsilon /\\ delta = epsilon /\\\n    0 < Rabs (c - 0) < delta ->\n    Rabs(M a b c - exact_size a b) < epsilon.\nProof.\n  intros. decompose [and] H.\n  assert (Rabs (c - 0) = Rabs c).\n  simple apply f_equal_R.\n  simple apply Rminus_0_r.\n  rewrite -> H5 in H6.\n  assert (Rabs(M a b c - exact_size a b) < Rabs c).\n    apply abs_M_minus_s_lt_abs_c. assumption.\n  rewrite H3 in H6. revert H6. revert H7.\n  apply Rlt_trans with\n    (r1 := Rabs (M a b c - exact_size a b))\n    (r2 := Rabs c)\n    (r3 := epsilon).\nQed.\n\n(** Defintion of a Epsilon-delta proof for ruler measure, M. *)\nHypothesis limit_x_Lim1_f_x_eq_Lim2 :\n    forall (a b x Lim1 Lim2 delta epsilon:R)\n        (f: R->R->R->R) (g: R->R),\n    0 < delta /\\ 0 < epsilon /\\ g delta = epsilon /\\\n    Rabs (x - Lim1) < delta /\\\n    Rabs(f a b x - Lim2) < epsilon ->\n    f a b x = Lim2.\n\n(* The function relating delta to epsilon to prove\n   convergence. *)\nDefinition delta_eq_epsilon(d: R) : R := d.\n\n(** Epsilon-delta proof. limit c->0,\n    0 < |x - 0| < delta, |M - s| < epsilon -> M = s. *)\nLemma limit_c_0_M_eq_exact_size :\n    forall (a b c Lim1 Lim2 delta epsilon:R)\n        (f: R->R->R->R) (g: R->R),\n    c > 0 /\\\n    f = M /\\ g = delta_eq_epsilon /\\\n    Lim1 = 0 /\\ Lim2 = exact_size a b /\\\n    0 < delta /\\ 0 < epsilon /\\ delta = epsilon /\\\n    Rabs (c - Lim1) < delta /\\\n    Rabs(M a b c - Lim2) < epsilon ->\n    M a b c = exact_size a b.\nProof.\n  intros. decompose [and] H.\n  rewrite <- H2. rewrite <- H4.\n  apply limit_x_Lim1_f_x_eq_Lim2 with (Lim1 := Lim1) (Lim2 := Lim2)\n      (delta := delta) (epsilon := epsilon) (g := g).\n  split. assumption. split. assumption.\n  split.\n  rewrite -> H1. unfold delta_eq_epsilon. assumption.\n  split. assumption.\n  rewrite -> H2. assumption.\nQed.\n\n(** End RulerMeasure. *)\n\n(** ======================================= *)\n(**\n  Now the definitions and theorems about volume and distance.\n*)\n\n(** An Epsilon-delta definition for c^n used in\n    lemma lim_power_c_to_n_eq_c. *)\nHypothesis limit_c_Lim1_f_c_eq_Lim2 :\n    forall (c Lim1 Lim2 delta epsilon:R),\n    0 < delta /\\ 0 < epsilon /\\ delta = epsilon /\\\n    Rabs (c - Lim1) < delta /\\\n    Rabs(c - Lim2) < epsilon ->\n    c = 0.\n\n(** An Epsilon-delta definition for c^n used in\n    lemma lim_power_c_to_n_eq_c. *)\nHypothesis limit_c_Lim1_f_c_n_eq_Lim2 :\n    forall (c Lim1 Lim2 delta epsilon:R) (n: nat)\n        (f: R->nat->R) (g: R->R),\n    0 < delta /\\ 0 < epsilon /\\ g delta = epsilon /\\\n    Rabs (c - Lim1) < delta /\\\n    Rabs(f c n - Lim2) < epsilon ->\n    f c n = 0.\n\n(** This lemma is used in the proof of the next lemma. *)\nLemma lim_c_to_n_eq_0 :\n    forall (c Lim1 Lim2 delta epsilon:R) (n: nat)\n        (f: R->nat->R) (g: R->R),\n    c > 0 /\\\n    f = Rpow /\\ g = delta_eq_epsilon /\\\n    Lim1 = 0 /\\ Lim2 = 0 /\\\n    0 < delta /\\ 0 < epsilon /\\ delta = epsilon /\\\n    Rabs (c - Lim1) < delta /\\\n    Rabs ((Rpow c n) - Lim2) < epsilon ->\n    Rpow c n = 0.\nProof.\n  intros. decompose [and] H.\n  rewrite <- H2.\n  apply limit_c_Lim1_f_c_n_eq_Lim2 with (Lim1 := Lim1) (Lim2 := Lim2)\n      (delta := delta) (epsilon := epsilon) (g := g).\n  split. assumption. split. assumption.\n  split. rewrite -> H1. unfold delta_eq_epsilon. assumption.\n  split. assumption.\n  rewrite -> H2. assumption. \nQed.\n\n(** This lemma is used in the volume proofs. *)\nLemma lim_c_to_n_eq_lim_c :\n    forall (c Lim1 Lim2 delta epsilon:R) (n: nat)\n        (f: R->nat->R) (g: R->R),\n    c > 0 /\\\n    f = Rpow /\\ g = delta_eq_epsilon /\\\n    Lim1 = 0 /\\ Lim2 = 0 /\\\n    0 < delta /\\ 0 < epsilon /\\ delta = epsilon /\\\n    Rabs (c - Lim1) < delta /\\\n    Rabs ((Rpow c n) - Lim2) < epsilon ->\n    Rpow c n = c.\nProof.\n  intros. decompose [and] H.\n  assert (Lim1 = Lim2). rewrite -> H3. rewrite -> H4. trivial.\n  assert (c = 0).\n  apply limit_c_Lim1_f_c_eq_Lim2 with (Lim1 := Lim1) (Lim2 := Lim2)\n      (delta := delta) (epsilon := epsilon).\n  split. assumption. split. assumption.\n  split. assumption. split. assumption.\n  rewrite <- H9. rewrite <- H7. assumption.\n  assert (Rpow c n = 0).\n  apply lim_c_to_n_eq_0 with (Lim1 := Lim1) (Lim2 := Lim2)\n      (delta := delta) (epsilon := epsilon) (f := f) (g := g).\n  split. assumption. split. assumption.\n  split. assumption. split. assumption.\n  split. assumption. split. assumption.\n  split. assumption. split. assumption.\n  split. assumption. assumption.\n  rewrite <- H11 in H12. assumption.\nQed.\n\n(** The Euclidean volume (length/area/volume) theorem:\n    v, is the length of a real-valued interval in:\n    {}a_1, b_1],...,[a_n, b_n]}, where:\n    v_c = cartesian_product p => v = cartesian_product(i=1 to n) s_i /\\\n    v = v_{m} - v_{0} /\\\n    s_i = b_i - a_i. *)\nTheorem Euclidean_volume :\n    forall (i n: nat)\n        (c Lim1 Lim2 delta epsilon v v_c v_a v_b a_i b_i: R)\n        (f: R->R->R->R) (g: R->R) (p s: list R),\n    (* ruler based definitions *)\n    c > 0 /\\\n    f = M /\\ g = delta_eq_epsilon /\\\n    Lim1 = 0 /\\ Lim2 = 0 /\\\n    0 < delta /\\ 0 < epsilon /\\ delta = epsilon /\\\n    Rabs (c - Lim1) < delta /\\\n    Rabs ((Rpow c n) - Lim2) < epsilon /\\\n    Rabs (M a_i b_i c - exact_size a_i b_i) < epsilon /\\\n    n = length s /\\ length p = n /\\\n    (* The length of each domain interval, exact_size a_i b_i,\n       is assinged to a member of s. *)\n    list_rmem i s = exact_size a_i b_i /\\\n    (* The number of subintervals in each domain interval,\n       subintervals a_i b_i c, is assinged to a member of p. *)\n    list_rmem i p = subintervals a_i b_i c /\\\n    (* Volume, v, is the length of the range interval, [v_a,v_b]. *)\n    v = exact_size v_a v_b /\\\n    (* Countable n-volume, v_c, is the number of subintervals\n       (infinitesimals) in the range interval, [v_a,v_b]. *)\n    v_c = subintervals v_a v_b c /\\\n    (* The definition of countable n-volume as the Cartesian product\n       of the number of members in each countable domain set. *)\n    v_c = cartesian_product p ->\n    v = cartesian_product s.\nProof.\n  intros. intros. decompose [and] H.\n  (* Show that each domain interval length, s_i = |b_i - a_i|,\n     corresponds to a set of p_i number of size c subintervals. *)\n  apply mult_list_spec with (l := p)\n      (a := subintervals a_i b_i c) (r := c) in H14.\n  rewrite <- subintervals_times_c_eq_measure in H14.\n  rewrite -> limit_c_0_M_eq_exact_size with\n      (a := a_i) (b := b_i) (c := c) (Lim1 := Lim1)\n      (g := g) (delta := delta) (epsilon := epsilon)\n      (Lim2 := exact_size a_i b_i) (f := M) in H14.\n  rewrite <- H13 in H14.\n  (* Show that the list, s, of domain interval lengths corresponds\n     to the list, p, of the number of size c subintervals. *)\n  apply eq_list_R_cons with  (l1 := mult_list p c) (l2 := s) in H14.\n  apply eq_list_R_is_eq in H14.\n  (* Show that the Cartesian product of the number of size c\n     subintervals equals the product of interval lengths. *)\n  assert (cartesian_product (mult_list p c) = cartesian_product s).\n    rewrite -> H14.\n    reflexivity.\n  (* Show that multiplying both sides of countable volume\n     by c^{n}, maintains the equivalence relation. *)\n  assert (v_c * (Rpow c n) = (cartesian_product p) * (Rpow c n)).\n    rewrite <- H18.\n    reflexivity.\n  (* Show that (cartesian_product p) * Rpow c n =\n     cartesian_product s *)\n  assert ((cartesian_product p) * Rpow c n =\n          cartesian_product (mult_list p c)).\n    apply pow_distributes_over_cartesian_product.\n    symmetry. assumption.\n    rewrite -> H17 in H20.\n  (* Show that v_c * Rpow c n = cartesian_product s *)\n  rewrite <- H19 in H20.\n  (* Show that lim c->0 (v_c * Rpow c n) = lim c->0 (v_c * c) *)\n  assert (Rpow c n = c).\n    apply lim_c_to_n_eq_lim_c with (c := c) (Lim1 := Lim1)\n      (Lim2 := Lim2) (g := g) (delta := delta)\n      (epsilon := epsilon) (f := Rpow).\n    split. assumption. split. reflexivity.\n    split. assumption. split. assumption.\n    split. assumption. split. assumption.\n    split. assumption. split. assumption.\n    split. assumption. assumption.\n    rewrite -> H21 in H20.\n  (* Show that lim c->0 v_c * c = v *)\n  rewrite -> H16 in H20.\n  rewrite <- subintervals_times_c_eq_measure in H20.\n  rewrite -> limit_c_0_M_eq_exact_size with\n      (a := v_a) (b := v_b) (c := c) (Lim1 := Lim1)\n      (g := g) (delta := delta) (epsilon := epsilon)\n      (Lim2 := exact_size v_a v_b) (f := M) in H20.\n  rewrite <- H15 in H20.\n  assumption.\n  (* Clean up hypothoses *)\n  split. assumption. split. reflexivity.\n  split. assumption. split. assumption.\n  split. reflexivity. split. assumption. split. assumption.\n  split. assumption. split. assumption.\n  apply M_minus_exact_size_lt_epsilon with\n    (a := v_a) (b := v_b) (c := c) \n    (delta := delta) (epsilon := epsilon).\n  split. assumption. split. assumption. split. assumption.\n  split. assumption. split.\n  assert (Rabs (c - 0) = Rabs c).\n  simple apply f_equal_R.\n  simple apply Rminus_0_r.\n  assert (Rabs c = c).\n  apply Rabs_right. intuition.\n  rewrite -> H22.\n  rewrite -> H23.\n  assumption.\n  rewrite <- H3.\n  assumption.\n  assumption.\n  split. assumption. split. reflexivity. split. assumption.\n  split. assumption. split. reflexivity. split. assumption.\n  split. assumption. split. assumption. split. assumption.\n  assumption.\n  assumption.\nQed.\n\n(** The sum of (Euclidean) volumes (length/area/volume) theorem:\n    v_c = sum_list(v_c_j_list) ->\n    cartesian_product s = sum_list(v_j_list) /\\\n      list_rmem i v_j_list = cartesian_product s_i.\n*)\nTheorem sum_of_volumes :\n    forall (i j m n: nat)\n        (c Lim1 Lim2 delta epsilon v v_c v_a v_b a_i b_i a_i_j b_i_j\n          v_j v_c_j v_a_i v_b_i: R)\n        (f: R->R->R->R) (g: R->R)\n        (p s p_i s_i v_j_list v_c_j_list: list R),\n    (* ruler based definitions *)\n    c > 0 /\\\n    f = M /\\ g = delta_eq_epsilon /\\\n    Lim1 = 0 /\\ Lim2 = 0 /\\\n    0 < delta /\\ 0 < epsilon /\\ delta = epsilon /\\\n    Rabs (c - Lim1) < delta /\\\n    Rabs ((Rpow c n) - Lim2) < epsilon /\\\n    Rabs ((Rpow c m) - Lim2) < epsilon /\\\n    Rabs (M a_i b_i c - exact_size a_i b_i) < epsilon /\\\n    Rabs (M a_i_j b_i_j c - exact_size a_i_j b_i_j) < epsilon /\\\n    Rabs (M v_a v_b c - exact_size v_a v_b) < epsilon /\\\n    Rabs (M v_a_i v_b_i c - exact_size v_a_i v_b_i) < epsilon /\\\n    n = length s /\\ length p = n /\\\n    n = length s_i /\\ length p_i = n /\\\n    m = length v_c_j_list /\\ m = length v_j_list /\\\n    (* The length of each domain interval, exact_size a_i b_i,\n       is assinged to a member of s. *)\n    list_rmem i s = exact_size a_i b_i /\\\n    (* The number of subintervals in each domain interval,\n       subintervals a_i b_i c, is assinged to a member of p. *)\n    list_rmem i p = subintervals a_i b_i c /\\\n    (* The length of each domain interval, exact_size a_i_j b_i_j,\n       is assinged to a member of s_i. An always true case is\n       m = 1 => exact_size a_i_j b_i_j = exact_size a_i b_i. *)\n    list_rmem j s_i = exact_size a_i_j b_i_j /\\\n    (* The number of subintervals in each domain interval,\n        subintervals a_i_j b_i_j c, is assinged to a member of p_i.\n        An always true case is\n        m = 1 => subintervals a_i b_i = subintervals a_i b_i. *)\n    list_rmem j p_i = subintervals a_i_j b_i_j c /\\\n    (* Volume, v, is the length of the range interval, [v_a,v_b]. *)\n    v = exact_size v_a v_b /\\\n    (* Subvolume, v_j, is the length of the range interval,\n        [v_a_i,v_b_i]. *)\n    v_j = exact_size v_a_i v_b_i /\\\n    list_rmem i v_j_list = v_j /\\\n    (* Countable n-volume, v_c, is the number of subintervals\n       (infinitesimals) in the range interval, [v_a,v_b]. *)\n    v_c = subintervals v_a v_b c /\\\n    v_c = cartesian_product p /\\\n    (* Countable sub-n-volume, v_c_j, is the number of subintervals\n       (infinitesimals) in the range interval, [v_a_i,v_b_i]. *)\n    v_c_j = subintervals v_a_i v_b_i c /\\\n    v_c_j = cartesian_product p_i /\\\n    list_rmem i v_c_j_list = v_c_j /\\\n    v_c = sum_list(v_c_j_list) ->\n    cartesian_product s = sum_list(v_j_list) /\\\n      list_rmem i v_j_list = cartesian_product s_i.\nProof.\n  intros. intros. decompose [and] H.\n  assert(v = cartesian_product s).\n    apply Euclidean_volume with (c := c) (Lim1 := Lim1) (Lim2 := Lim2)\n          (delta := delta) (epsilon := epsilon) (f := f) (g := g)\n          (i := i) (n := n)\n          (a_i := a_i) (b_i := b_i) (p := p) (s := s)\n          (v_c := v_c) (v := v) (v_a := v_a) (v_b := v_b).\n    tauto.\n  assert(v_j = cartesian_product s_i).\n  (* Show that each domain interval length, s_i = |b_i - a_i|,\n     corresponds to a set of p_i number of size c subintervals. *)\n    apply Euclidean_volume with (c := c) (Lim1 := Lim1) (Lim2 := Lim2)\n          (delta := delta) (epsilon := epsilon) (f := f) (g := g)\n          (i := j) (n := n)\n          (a_i := a_i_j) (b_i := b_i_j) (p := p_i) (s := s_i)\n          (v_c := v_c_j) (v := v_j) (v_a := v_a_i) (v_b := v_b_i).\n    tauto.\n  (* Show that the lim c -> 0 v_c * c =\n      exact_size v_b_i - v_a_i. *)\n  assert (v_c * c = subintervals v_a v_b c * c).\n      apply Rmult_eq_compat_r with (r := c)\n          (r1 := v_c)\n          (r2 := subintervals v_a v_b c).\n      assumption.\n  rewrite <- subintervals_times_c_eq_measure in H36.\n  rewrite -> limit_c_0_M_eq_exact_size with\n      (a := v_a) (b := v_b) (c := c) (Lim1 := Lim1)\n      (g := g) (delta := delta) (epsilon := epsilon)\n      (Lim2 := exact_size v_a v_b) (f := M) in H36.\n  rewrite <- H25 in H36.\n  (* Show that the lim c -> 0 v_c_j * c =\n      exact_size v_b_i - v_a_i. *)\n  assert (v_c_j * c = subintervals v_a_i v_b_i c * c).\n      apply Rmult_eq_compat_r with (r := c)\n          (r1 := v_c_j)\n          (r2 := subintervals v_a_i v_b_i c).\n      assumption.\n  rewrite <- subintervals_times_c_eq_measure in H37.\n  rewrite -> limit_c_0_M_eq_exact_size with\n      (a := v_a_i) (b := v_b_i) (c := c) (Lim1 := Lim1)\n      (g := g) (delta := delta) (epsilon := epsilon)\n      (Lim2 := exact_size v_a_i v_b_i) (f := M) in H37.\n  rewrite <- H26 in H37.\n  (* Show that v_c * c = sumlist v_c_j_list * c. *)\n  assert (v_c * c = sum_list v_c_j_list * c).\n      apply Rmult_eq_compat_r with (r := c)\n          (r1 := v_c)\n          (r2 := sum_list v_c_j_list).\n      assumption.\n  rewrite -> H36 in H38.\n  rewrite -> mult_distributes_over_sum_list in H38.\n  (* Show that lim c -> 0 list_rmem i v_c_j_list * c =\n            v_c_j * c. *)\n  apply mult_list_spec with (l := v_c_j_list)\n      (a := v_c_j) (r := c) in H32.\n  rewrite -> H37 in H32.\n  assert (list_rmem i v_j_list = v_j). assumption.\n  rewrite <- H32 in H27.\n  apply eq_list_R_cons with  (l1 := v_j_list)\n            (l2 := mult_list v_c_j_list c) in H27.\n  apply eq_list_R_is_eq in H27.\n  rewrite <- H27 in H38.\n  rewrite -> H33 in H38.\n  split. assumption.\n  rewrite -> H35 in H39.\n  assumption.\n  tauto. assumption.\n  split. assumption. split. reflexivity. split. assumption.\n  split. assumption. split. reflexivity. split. assumption.\n  tauto. assumption.\nQed.\n\n(** ================================================================ *)\n\nTheorem Minkowski_distance :\n    forall (i j m n: nat)\n        (c Lim1 Lim2 delta epsilon v v_c v_a v_b a_i b_i a_i_j b_i_j\n          v_j v_c_j v_a_i v_b_i d_c d_c_i d d_i: R)\n        (f: R->R->R->R) (g: R->R)\n        (p s p_i s_i v_j_list v_c_j_list: list R),\n    (* ruler based definitions *)\n    c > 0 /\\\n    f = M /\\ g = delta_eq_epsilon /\\\n    Lim1 = 0 /\\ Lim2 = 0 /\\\n    0 < delta /\\ 0 < epsilon /\\ delta = epsilon /\\\n    Rabs (c - Lim1) < delta /\\\n    Rabs ((Rpow c n) - Lim2) < epsilon /\\\n    Rabs ((Rpow c m) - Lim2) < epsilon /\\\n    Rabs (M a_i b_i c - exact_size a_i b_i) < epsilon /\\\n    Rabs (M a_i_j b_i_j c - exact_size a_i_j b_i_j) < epsilon /\\\n    Rabs (M v_a v_b c - exact_size v_a v_b) < epsilon /\\\n    Rabs (M v_a_i v_b_i c - exact_size v_a_i v_b_i) < epsilon /\\\n    n = length s /\\ length p = n /\\\n    n = length s_i /\\ length p_i = n /\\\n    m = length v_c_j_list /\\ m = length v_j_list /\\\n    (* The length of each domain interval, exact_size a_i b_i,\n       is assinged to a member of s. *)\n    list_rmem i s = exact_size a_i b_i /\\\n    d = exact_size a_i b_i /\\\n    (* The number of subintervals in each domain interval,\n       subintervals a_i b_i c, is assinged to a member of p. *)\n    list_rmem i p = subintervals a_i b_i c /\\\n    d_c = subintervals a_i b_i c /\\\n    (* The length of each domain interval, exact_size a_i_j b_i_j,\n       is assinged to a member of s_i. An always true case is\n       m = 1 => exact_size a_i_j b_i_j = exact_size a_i b_i. *)\n    list_rmem j s_i = exact_size a_i_j b_i_j /\\\n    d_i = exact_size a_i_j b_i_j /\\\n    (* The number of subintervals in each domain interval,\n        subintervals a_i_j b_i_j c, is assinged to a member of p_i.\n        An always true case is\n        m = 1 => subintervals a_i b_i = subintervals a_i b_i. *)\n    list_rmem j p_i = subintervals a_i_j b_i_j c /\\\n    d_c_i = subintervals a_i_j b_i_j c /\\\n    (* Volume, v, is the length of the range interval, [v_a,v_b]. *)\n    v = exact_size v_a v_b /\\\n    (* Subvolume, v_j, is the length of the range interval,\n        [v_a_i,v_b_i]. *)\n    v_j = exact_size v_a_i v_b_i /\\\n    list_rmem i v_j_list = v_j /\\\n    (* Countable n-volume, v_c, is the number of subintervals\n       (infinitesimals) in the range interval, [v_a,v_b]. *)\n    v_c = subintervals v_a v_b c /\\\n    v_c = cartesian_product p /\\\n    (* Countable sub-n-volume, v_c_j, is the number of subintervals\n       (infinitesimals) in the range interval, [v_a_i,v_b_i]. *)\n    v_c_j = subintervals v_a_i v_b_i c /\\\n    v_c_j = cartesian_product p_i /\\\n    list_rmem i v_c_j_list = v_c_j /\\\n    v_c = sum_list(v_c_j_list) /\\\n    v_c = sum_list(v_c_j_list) ->\n    Rpow d n = sum_list(v_j_list) /\\\n      list_rmem i v_j_list = Rpow d_i n.\nProof.\n  intros. intros. decompose [and] H.\n  assert (cartesian_product s = sum_list(v_j_list) /\\\n      list_rmem i v_j_list = cartesian_product s_i).\n    apply sum_of_volumes with (c := c) (Lim1 := Lim1) (Lim2 := Lim2)\n      (delta := delta) (epsilon := epsilon) (f := f) (g := g)\n      (i := i) (j := j) (n := n) (m := m)\n      (a_i := a_i) (b_i := b_i) (p := p) (s := s)\n      (v_c := v_c) (v := v) (v_a := v_a) (v_b := v_b)\n      (a_i_j := a_i_j) (b_i_j := b_i_j) (p_i := p_i) (s_i := s_i)\n      (v_c_j := v_c_j) (v_j := v_j) (v_a_i := v_a_i) (v_b_i := v_b_i)\n      (v_c_j_list := v_c_j_list).\n    tauto.\n  assert(Rpow d n = cartesian_product s).\n    apply Rpow_eq_carteian_paroduct with\n      (a := d) (i := i) (n := n) (l := s).\n    split. assumption.\n    rewrite -> H21. symmetry. assumption.\n    rewrite <- H40 in H38.\n  assert(Rpow d_i n = cartesian_product s_i).\n    apply Rpow_eq_carteian_paroduct with\n      (a := d_i) (i := j) (n := n) (l := s_i).\n    split. assumption. \n    rewrite -> H26. assumption.\n    rewrite <- H41 in H38.\n    assumption.\nQed.\n\n\n(** ================================================================ *)\n\n(** forall a >= 0, b >= 0 => a <= a + b. *)\nHypothesis R_le_plus_r :\n    forall (a b: R), a >= 0 /\\ b >= 0 -> a <= a + b.\n\n(** forall a >= 0, b >= 0 => a + b >= 0. *)\nHypothesis Rsum_ge_0 :\n    forall (a b: R), a >= 0 /\\ b >= 0 -> a + b >= 0.\n\n(** forall a >= 0, b >= 0 => a * b >= 0. *)\nHypothesis Rtimes_ge_0 :\n    forall (a b: R), a >= 0 /\\ b >= 0 -> a * b >= 0.\n\n(** The distance inequality proof should be expressed as:\n    forall v_a, v_b >= 0, n >= 1:\n    (v_a + v_b)^{1/n) <= v_a^{1/n} + v_b^{1/n}.\n    This inequality is used in deriving the metric space triangle\n    inequality.\n    But, the Coq definition for the type, R, is such that it is not\n    possible to construct an n-th root function. For example, given,\n    d^n = v <-> d = v^{1/n_, it is difficult to express and compute\n    the value for d, where the values of v and n are known.\n    Therefore, the inequality proof here stops at the step before\n    taking the n-th root of both sides of the inequality. *)\nTheorem distance_inequality :\n    forall (n: nat) (d_a d_b: R),\n    d_a = 0 /\\ d_a > 0 /\\ d_b = 0 /\\ d_b > 0 ->\n    Rpow d_a n + Rpow d_b n <= Rpow (d_a + d_b) n.\nProof.\n  intros. decompose [and] H.\n  rewrite -> binomial_eq.\n  unfold binomial_expansion.\n  rewrite -> binomial_expansion_equiv.\n  assert (forall (a b: R), a >= 0 /\\ b >= 0 -> a <= a + b).\n    intros. decompose [and] H3.\n    apply R_le_plus_r. assumption.\n  apply H3 with (a := Rpow d_a n + Rpow d_b n)\n(b := sum_list (binomial_term_list (rlist n 0) d_a d_b 1 (n - 1))).\n  split.\n  apply Rsum_ge_0 with (a := Rpow d_a n) (b := Rpow d_b n).\n  split.\n  apply Rpow_ge_0 with (x := d_a) (n := n). intuition.\n  apply Rpow_ge_0 with (x := d_b) (n := n). intuition.\n  apply lower_order_binomial_terms.\n  split. assumption. split. assumption. split. assumption.\n  assumption.\nQed.\n\nTheorem distance_sum_inequality :\n    forall (n: nat) (d_a d_b: R) (p1 p2 p3: list R),\n    d_a = 0 /\\ d_a > 0 /\\ d_b = 0 /\\ d_b > 0 /\\\n    d_a = sum_list (pow_list p1 n) /\\\n    d_b = sum_list (pow_list p2 n) ->\n    Rpow (sum_list (pow_list p1 n)) n +\n      Rpow (sum_list (pow_list p2 n)) n <=\n    Rpow (sum_list (pow_list p1 n) + sum_list (pow_list p2 n)) n.\nProof.\n  intros. decompose [and] H.\n  rewrite <- H4.\n  rewrite <- H6.\n  apply distance_inequality.\n  split. assumption. split. assumption.\n  split. assumption. assumption.\nQed.\n\n(** ================================================================ *)\n\n(* Metric space properties *)\n\n(* Symmetry: d(v,w) = d(w,v).\n   From the Euclidean (smallest) and Manhattan (largest)\n   distance proofs, all d(x,y): d(x,y) = (x^n + y^n)^{1/n),\n   where 1 <= n <= 2.\n   Therefore, d(u,v)^n = u^n + y^n /\\ d(v,u)^n = v^n + u^n,\n   which implies that d(v,u) = d(u,v). *)\nTheorem symmetry :\n    forall (n: nat) (u v w d_u_w d_u_v d_v_w d_w_w d_w_v d_v_u: R),\n    Rpow d_u_v n = Rpow u n + Rpow v n /\\\n    Rpow d_v_u n = Rpow v n + Rpow u n\n    -> d_u_v = d_v_u.\nProof.\n  intros. decompose [and] H.\n  assert (Rpow u n + Rpow v n = Rpow v n + Rpow u n).\n    intuition.\n  rewrite -> H2 in H0.\n  rewrite <- H1 in H0.\n  apply pow_eq_args in H0.\n  assumption.\nQed.\n\n(* Metric space triangle inequality,\n   d(u,w) <= d(u,v) + d(v,w) <->\n   d(u,w)^n <= (d(u,v) + d(v,w))^n. *)\nTheorem riangle_inequality :\n    forall (n: nat) (u v w d_u_w d_u_v d_v_w d_w_w d_w_v d_v_u: R),\n    u >= 0 /\\ v >= 0 /\\ w >= 0 /\\\n    d_u_w = 0 /\\ d_u_w > 0 /\\\n    d_u_v = 0 /\\ d_u_v > 0 /\\ d_v_w = 0 /\\ d_v_w > 0 ->\n    Rpow d_u_v n = Rpow u n + Rpow v n /\\\n    Rpow d_v_w n = Rpow v n + Rpow w n /\\\n    Rpow d_u_w n = Rpow u n + Rpow w n ->\n    d_u_w <= d_u_v + d_v_w.\nProof.\n  intros. decompose [and] H.\n  assert (Rpow u n + Rpow w n <=\n            Rpow u n + Rpow w n + (Rpow v n + Rpow v n)).\n    assert (forall (a b: R), a >= 0 /\\ b >= 0 -> a <= a + b).\n      intros. decompose [and] H9.\n      apply R_le_plus_r. assumption.\n    apply H9 with (a := Rpow u n + Rpow w n)\n        (b := Rpow v n + Rpow v n).\n  split. apply Rsum_ge_0 with (a := Rpow u n) (b := Rpow w n).\n  split. apply Rpow_ge_0. assumption.\n    apply Rpow_ge_0. assumption.\n    apply Rsum_ge_0. split.\n    apply Rpow_ge_0. assumption.\n    apply Rpow_ge_0. assumption.\n  assert (Rpow u n + Rpow w n + (Rpow v n + Rpow v n) =\n    (Rpow u n + Rpow v n) + (Rpow v n + Rpow w n)).\n    field.\n  rewrite -> H11 in H9.\n  decompose [and] H0.\n  rewrite <- H12 in H9.\n  rewrite <- H14 in H9.\n  rewrite <- H15 in H9.\n  assert (Rpow d_u_v n + Rpow d_v_w n <= Rpow (d_u_v + d_v_w) n).\n  apply distance_inequality.\n  split. assumption. split. assumption. split. assumption.\n  assumption.\n  assert (Rpow d_u_w n <= Rpow (d_u_v + d_v_w) n).\n  apply Rle_trans with (r1 := Rpow d_u_w n)\n    (r2 := Rpow d_u_v n + Rpow d_v_w n)\n    (r3 := Rpow (d_u_v + d_v_w) n).\n  assumption.\n  assumption.\n  apply pow_le_args in H16.\n  assumption.\nQed.\n\n(* Non-negativity: d(u,w) >= 0, where for all d(u,w) in R,\n   there exists [v_a, v_b] such that d(u,w) = |v_a - v_b|. *)\nTheorem non_negativity :\n    forall (u v_a v_b d_u_w: R),\n    d_u_w = exact_size v_a v_b ->\n    d_u_w >= 0.\nProof.\n  intros.\n  rewrite -> H.\n  unfold exact_size.\n  apply Rle_ge with  (r1 := 0) (r2 := Rabs (v_b - v_a)).\n  apply Rabs_pos.\nQed.\n\n(* a_v = f(v) *)\nVariable a_u a_v a_w: R.\n\n(* f(x) = f(y) <=> x = y *)\nHypothesis exact_size_eq_exact_size :\n  forall (a_u a_v a_w: R),\n  exact_size a_u a_w = exact_size a_u a_v -> a_w = a_v.\n\n(* Identity of Indiscernibles: d(w,w) = 0, where for\n   all d(u,w) in R, there exists [a_u,a_w] such that\n   d(u,w) = |a_u - a_w|, a_u = f(u) and a_w = f(w).\n   And so on for d(u,v) and d(v,w). *)\nTheorem identity_of_indisceunibles :\n  (* from the triange inequality proof: *)\n    forall (d_u_w d_u_v d_v_w d_w_w a_u a_v a_w: R),\n    d_u_w = exact_size a_u a_w /\\\n    d_u_v = exact_size a_u a_v /\\\n    d_v_w = exact_size a_v a_w /\\\n    d_w_w = exact_size a_w a_w /\\\n    d_u_w < d_u_v + d_v_w /\\\n    d_u_w = d_u_v + d_v_w /\\\n    (* from the non-negativity proof, there exists: *)\n    d_u_v = 0 /\\ d_v_w = 0\n    -> d_w_w = 0.\nProof.\n  intros. decompose [and] H.\n  assert (d_u_w = 0).\n  rewrite -> H6 in H5.\n  rewrite -> H8 in H5.\n  rewrite Rplus_0_r with (r := 0) in H5.\n  assumption.\n  rewrite <- H6 in H7.\n  rewrite -> H0 in H7.\n  rewrite -> H2 in H7.\n  apply exact_size_eq_exact_size in H7.\n  rewrite <- H7 in H1.\n  rewrite <- H1 in H3.\n  rewrite -> H8 in H3.\n  assumption.\nQed.\n\nEnd EuclideanRelations.",
      "theorem": "Lemma eq_INR : forall (m n: nat), (m = n)%nat -> INR m = INR n.",
      "ground_truth": "Proof.\n  induction 1; intros; apply @eq_refl.\nQed."
    },
    {
      "split": "train-sft",
      "index": 35,
      "prefix": "(**\n----\n_This file is part of_\n\n----\n*** A Formal Definition of JML in Coq #<br/># and its Application to Runtime Assertion Checking\nPh.D. Thesis by Hermann Lehner\n----\nOnline available at #<a href=\"http://jmlcoq.info/\">jmlcoq.info</a>#\n\nAuthors:\n  - Hermann Lehner\n  - David Pichardie (Bicolano)\n  - Andreas Kaegi (Syntax Rewritings, Implementation of ADTs)\n\nCopyright 2011 Hermann Lehner\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n----\n*)\n\nFrom JML Require Export JMLRac2.\nFrom Coq Require Import List.\nFrom JML Require Import Stack.\nFrom Coq Require Import ListSet.\nFrom Coq Require Import Bool.\nFrom Coq Require Import ZArith.\nFrom Coq Require Import Relation_Operators.\nFrom JML Require Import ListHelpers.\nFrom Coq Require Import Classical.\nFrom Coq Require Import DecidableType.\nFrom Coq Require Import FSetInterface.\nFrom Coq Require Import FSetProperties.\nFrom Coq Require Import FSetEqProperties.\nFrom Coq Require Import FSetFacts.\nFrom Coq Require Import Sumbool.\nFrom Coq Require Import Lia.\n\nImport Dom.\nImport Prog.\nImport JmlNotations.\nImport METHODSPEC.\nImport TYPESPEC.\n\nModule LocSetProp := Properties LocSet.\nImport LocSetProp.\nModule LocSetPropEq := EqProperties LocSet.\nImport LocSetPropEq.\nModule LocSetFacts := Facts LocSet.\nImport LocSetFacts.\n\nOpen Scope jml_scope.\n\n(** * The JML Runtime Assertion Checker Rac3\nThis module describes the runtime assertions checks for suported JML-Level 0 constructs *)\n\nModule Rac3 <: JML.\n\n(** ** Implementation of the JML Frame for Rac3 *)\n\n  Declare Module LocDict: DICT \n    with Definition Key := (* pivot *) Location\n    with Definition Val := (* dg *) LocSet.t.\n\n\n  Declare Module Backlinks : DICT \n    with Definition Key := (* field *) Location\n    with Definition Val := LocDict.t.\n\n\n\nDefinition StaticDGs (p : Program) (f : Location) : list Location :=\n  match f with\n  | Heap.InstanceField obj fsig =>\n    match findField p fsig with\n    | Some f =>\n      let dgs := FIELD.dataGroups f in\n      let dgs_static := filter (fun dg => negb (DATA_GROUP.isDynamic dg)) dgs in\n      let dgfsig := flat_map DATA_GROUP.dataGroups dgs_static in\n      map (Heap.InstanceField obj) dgfsig\n    | _ => []\n    end\n  | _ => []\n  end.\n\nLemma StaticDGs_Correct:\nforall p field_am dg_am,\nIn dg_am (StaticDGs p field_am) <-> direct_FieldInDg_static p field_am dg_am.\nProof.\nintuition.\n unfold StaticDGs in H.\n case_eq field_am; intros; subst; try inversion H.\n case_eq (findField p f); intros; rewrite H0 in H; try inversion H.\n apply in_map_iff in H.\n destruct H as [dg_fsig H].\n destruct H.\n apply in_flat_map in H1.\n destruct H1 as [dg H1].\n destruct H1.\n apply filter_In in H1.\n destruct H1.\n split with o dg_fsig o f f0 dg; auto.\n case_eq (DATA_GROUP.isDynamic dg); intros.\n  rewrite H4 in H3; inversion H3.\n  \n  trivial.\n  \n destruct H.\n unfold StaticDGs.\n rewrite H0.\n rewrite H2.\n apply in_map_iff.\n exists dg_fsig.\n rewrite <- H1.\n split; auto.\n apply in_flat_map.\n exists dg.\n rewrite filter_In.\n split.\n  split.\n   trivial.\n   \n   rewrite H4.\n   simpl; trivial.\n   \n  trivial.\nQed.\n\n\nFixpoint option_list2list {A : Type} (l: list (option A)) : list A :=\nmatch l with\n| nil => nil\n| (h::t) =>\n    match h with\n    | Some a => (a :: option_list2list t)\n    | _ => option_list2list t\n    end\n end.\n\nLemma some_list_list:\nforall {A : Type} (l : list (option A)) x,\nIn (Some x) l <-> In x (option_list2list l).\nProof.\ninduction l.\n simpl.\n tauto.\n \n intros.\n simpl.\n split; intro.\n  destruct H.\n   rewrite H.\n   auto with *.\n   \n   rewrite IHl in H.\n   destruct a.\n    auto with *.\n    \n    trivial.\n    \n  case_eq a.\n   intros.\n   rewrite H0 in H.\n   simpl in H.\n   destruct H.\n    rewrite H.\n    tauto.\n    \n    right.\n    rewrite IHl; trivial.\n    \n   intros.\n   right.\n   rewrite IHl.\n   rewrite H0 in H.\n   trivial.\nQed.\n\nDeclare Module FsigDec : DecidableType with Definition t := FieldSignature\n\t                                with Definition eq := eq (A := FieldSignature).\n\nDefinition DynamicDGs (p : Program) (f_fsig : FieldSignature) (pivot : Location) : list Location :=\n  match pivot with\n  | Heap.InstanceField pivot_obj pivot_fsig =>\n    match findField p pivot_fsig with\n    | Some pivot_f =>\n      let dgs_dyn := filter (fun dg => DATA_GROUP.isDynamic dg) (FIELD.dataGroups pivot_f) in\n                let dgs_f_target := filter (fun dg => \n                  match DATA_GROUP.pivotTarget dg with\n                  | Some (FieldDg fsig) => if FsigDec.eq_dec fsig f_fsig then true else false\n                  | _ => false\n                  end        \n                  ) dgs_dyn in\n                let dg_fsig := flat_map DATA_GROUP.dataGroups dgs_f_target in\n                map (Heap.InstanceField pivot_obj) dg_fsig\n      | _ => []\n    end\n  | _ => []\n  end.\n\nLemma DynamicDGs_Correct:\nforall p h f_obj f_fsig pivot dg,\nHeap.get h pivot = Some (Ref f_obj) ->\n(In dg (DynamicDGs p f_fsig pivot) <-> direct_FieldInDg_dynamic p h (Heap.InstanceField f_obj f_fsig) dg pivot).\nProof.\nintuition.\n unfold DynamicDGs in H0.\n case_eq pivot; intros; rewrite H1 in H0; try inversion H0.\n rename o into pivot_obj.\n rename f into pivot_fsig.\n case_eq (findField p pivot_fsig); intros; rewrite H2 in H0; try inversion H0.\n rename f into pivot_f.\n  apply in_map_iff in H0.\n  destruct H0 as (dg_fsig, H0).\n  destruct H0.\n  apply in_flat_map in H3.\n  destruct H3 as (dgt, H3).\n  destruct H3.\n  apply filter_In in H3.\n  destruct H3.\n  apply filter_In in H3.\n  destruct H3.\n  case_eq (DATA_GROUP.pivotTarget dgt); intros; rewrite H7 in H5.\n   case_eq d; intros.\n   rewrite H8 in H5.\n   rewrite H8 in H7.\n   clear d H8.\n   case_eq (FsigDec.eq_dec fsig f_fsig); intros.\n    unfold FsigDec.eq in e.\n    rewrite e in H7.\n    clear H5 H8.\n    clear fsig e.\n    split\n     with pivot_obj dg_fsig f_obj f_fsig pivot_obj pivot_fsig pivot_f dgt;\n     trivial.\n     auto.\n     \n     rewrite <- H1; trivial.\n     \n    rewrite H8 in H5; inversion H5.\n    \n   inversion H5.\n   \n inversion H0.\n unfold DynamicDGs.\n rewrite H3.\n rewrite H5.\n inversion H2.\n rewrite <- H16.\n  \n   apply in_map_iff.\n   exists dg_fsig.\n   split.\n    rewrite <- H10; auto.\n    \n    apply in_flat_map.\n    exists dg0.\n    rewrite filter_In.\n    split.\n     split.\n      rewrite filter_In.\n      split.\n       trivial.\n       \n       trivial.\n       \n      rewrite H8.\n    destruct FsigDec.eq_dec.\n     trivial.\n     \n     elim n.\n     auto.\n     \n   trivial.\nQed.\n\nDefinition PivotTargets (p : Program) (pivot : Location) : list FieldSignature :=\n  match pivot with \n  | Heap.InstanceField pivot_obj pivot_fsig =>\n    match findField p pivot_fsig with\n    | Some pivot_f =>\n      let dgs_dyn := filter (fun dg => DATA_GROUP.isDynamic dg) (FIELD.dataGroups pivot_f) in\n      let fsigs_option := (map (fun dg => match (DATA_GROUP.pivotTarget dg) with \n                                                            | Some (FieldDg fsig) => Some fsig\n                                                            | _ => None end) dgs_dyn) in\n       option_list2list fsigs_option\n    | _ => []\n    end\n  | _ => []\n  end.\n\nLemma PivotTargets_Correct:\nforall p h f_fsig f_obj pivot,\nHeap.get h pivot = Some (Ref f_obj) ->\n(In f_fsig (PivotTargets p pivot) <-> exists dg, direct_FieldInDg_dynamic p h (Heap.InstanceField f_obj f_fsig) dg pivot).\nProof.\nintuition.\n unfold PivotTargets in H0.\n case_eq pivot; intros; rewrite H1 in H0; try inversion H0.\n rename o into pivot_obj.\n rename f into pivot_fsig.\n case_eq (findField p pivot_fsig); intros; rewrite H2 in H0; try inversion H0.\n apply some_list_list in H0.\n apply in_map_iff in H0.\n destruct H0 as (dg, H0).\n destruct H0.\n case_eq (DATA_GROUP.pivotTarget dg); intros; rewrite H4 in H0.\n  case_eq d; intros; rewrite H5 in H0.\n  apply filter_In in H3.\n  destruct H3.\n  generalize DATA_GROUP.dataGroups_not_nil.\n  intro.\n  specialize H7 with dg.\n  case_eq (DATA_GROUP.dataGroups dg); intros.\n   elim H7; trivial.\n   \n   exists (Heap.InstanceField pivot_obj f0).\n   split with pivot_obj f0 f_obj f_fsig pivot_obj pivot_fsig f dg; trivial.\n    rewrite <- H1; trivial.\n    \n    inversion H0.\n    rewrite H10 in H5.\n    rewrite <- H5.\n    trivial.\n    \n    rewrite H8.\n    auto with *.\n    \n     inversion H0.\n   \n destruct H0 as (dg, H0).\n inversion H0.\n unfold PivotTargets.\n rewrite H3.\n rewrite H5.\n  \n  apply some_list_list.\n   apply in_map_iff.\n   exists dg0.\n   rewrite H8.\n   inversion H2.\n   split;auto.\n   apply filter_In.\n   split.\n   trivial.\n   trivial.\nQed.\n\nLemma PivotTargets_not_nil:\nforall p pivot,\nPivotField p pivot ->\nexists fsig , In fsig (PivotTargets p pivot).\nProof.\nintros.\ninversion H.\nunfold PivotTargets.\nrewrite H0.\nrewrite H1.\ncase_eq (DATA_GROUP.pivotTarget dg);intros.\n destruct d.\n exists fsig0.\n apply some_list_list.\n apply in_map_iff.\n exists dg.\n rewrite H4.\n split; trivial.\n apply filter_In.\n tauto.\nunfold DATA_GROUP.isDynamic in H3.\nrewrite H4 in H3.\ninversion H3.\nQed.\n\n\n  Definition set_backlink (bl :Backlinks.t) (f : Location) (pivot : Location) (dgs: LocSet.t) : Backlinks.t :=\n    match Backlinks.get bl f with\n    | None => \n      Backlinks.update bl f (LocDict.singleton pivot dgs)\n    | Some amdict => \n      let amdict' := LocDict.update amdict pivot dgs in \n      Backlinks.update bl f amdict'\n    end.\n\n  Definition remove_backlink (bl : Backlinks.t) (f : Location) (pivot: Location) : Backlinks.t :=\n    match Backlinks.get bl f with\n    | None => bl\n    | Some amdict =>\n      let amdict' := LocDict.remove amdict pivot in\n      Backlinks.update bl f amdict'\n    end.\n\n  Definition get_backlinks (bl : Backlinks.t) (f: Location) : LocDict.t :=\n  match Backlinks.get bl f with\n  | None => LocDict.empty\n  | Some am => am\n  end.\n\nModule Adds <: ADDS.\n\n  Record t_rec : Type := make {\n    backlinks: Backlinks.t\n  }.\n\n  Definition t := t_rec.\n\nEnd Adds.\n\nModule FrameAdds := Rac2.FrameAdds.\n\nModule Frame := Rac2.Frame.\nDeclare Module State : STATE \n  with Module Frame := Frame \n  with Module Adds := Adds.\n\nModule Notations.\n\n  Declare Scope rac3_scope.\n  Delimit Scope rac3_scope with rac3.\n\n  Open Scope rac3_scope.\n\n  Notation \"st '@h'\" := (State.h st) (at level 1, left associativity): rac3_scope.\n  Notation \"st '@fr'\" := (State.fr st) (at level 1, left associativity) : rac3_scope.\n  Notation \"st '@adds'\" := (State.adds st) (at level 1, left associativity) : rac3_scope.\n  Notation \"st '@bl'\" := (Adds.backlinks st@adds) (at level 1, left associativity) : rac3_scope.\n\n  Notation \"st '[h' ':=' h ']'\" := (State.set_h st h) (at level 1, left associativity): rac3_scope.\n  Notation \"st '[fr' ':=' fr ']'\" := (State.set_fr st fr) (at level 1, left associativity) : rac3_scope.\n  Notation \"st '[adds' ':=' adds ']'\" := (State.set_adds st adds) (at level 1, left associativity) : rac3_scope.\n  Notation \"st '[bl' ':=' bl ']'\" := (st[adds := Adds.make bl]) (at level 1, left associativity) : rac3_scope.\n  Notation \"[ h , fr , adds ]\" := (State.build h fr adds) : rac3_scope.\n\nEnd Notations.\n\n\nImport Sem.Notations.\nImport Rac1.Notations.\nImport Rac2.Notations.\nImport Notations.\n\nOpen Scope nat_scope.\n\n(** A new JML Frame is initialized with the assignable locations from the caller *)\nDefinition NewFrame (m : Method) (p : ParamDict.t) (st : State.t) : Frame.t :=\n  let adds := FrameAdds.make ((LocSet.empty,LocSetAll)::st@fr@assignables) (ObjSet.empty::st@fr@fresh) (st@h , p) VarDict.empty in\n  Frame.build m p adds.\n\nInductive DGTree :=  DGNode (am : Location) (dgs: list DGTree).\n\nSection correct_dgtree_ind.\nVariables (P : DGTree ->  Prop) (Q : list DGTree ->  Prop).\nHypotheses\n   (H : forall (a : Location) (l : list DGTree), Q l ->  P (DGNode a l))\n   (H0 : Q nil)\n   (H1 : forall (t : DGTree),\n         P t -> forall (l : list DGTree ), Q l ->  Q (cons t l)).\n\nFixpoint DGTree_ind2 (t : DGTree) : P t :=\n match t as x return P x with\n    DGNode a l =>\n      H a l ((fix l_ind (l' : list DGTree) : Q l' :=\n                     match l' as x return Q x with\n                     | nil => H0\n                     | cons t1 tl => H1 t1 (DGTree_ind2 t1) tl (l_ind tl)\n                     end) l)\n end.\nEnd correct_dgtree_ind.\n\nInductive InDG (dg : Location) (tree : DGTree) : Prop :=\n| InDG_base: \n  forall kids,\n  tree = (DGNode dg kids) ->\n  InDG dg tree\n| InDG_step:\n  forall kids f tree',\n  tree = (DGNode f kids) ->\n  dg <> f ->\n  In tree' kids ->\n  InDG dg tree' ->\n  InDG dg tree.\n\nFixpoint InDGTree (dg : Location) (tree : DGTree) : bool :=\nmatch tree with\n| DGNode f kids =>\n  if LocDec.eq_dec dg f then true\n  else fold_right (fun tree' => (orb (InDGTree dg tree'))) false kids\nend.\n\nDefinition DGSubTree (t1 t2: DGTree) : Prop :=\nforall a,\nInDG a t1 -> InDG a t2.\n\nLemma fold_right_andb:\nforall (A : Type) (l : list A) f,\nfold_right (fun elem b => (f elem) && b) true l = true <-> (forall elem, In elem l -> f elem = true).\nProof.\nsplit; intros.\n induction l.\n  inversion H0.\n  \n  simpl in H0.\n  simpl in H.\n  rewrite andb_true_iff in H.\n  destruct H.\n  destruct H0.\n   rewrite <- H0; trivial.\n   \n   apply IHl; trivial.\n   \n induction l.\n  simpl; trivial.\n  \n  simpl.\n  rewrite andb_true_iff.\n  split.\n   apply H.\n   auto with *.\n   \n   apply IHl.\n   intros.\n   apply H.\n   auto with *.\nQed.\n\nLemma fold_right_orb:\nforall (A : Type) (l : list A) f,\nfold_right (fun elem b => (f elem) || b) false l = true <-> (exists elem, In elem l /\\ f elem = true).\nProof.\nsplit;intros.\ninduction l.\n simpl in H.\n discriminate H.\n \n simpl in H.\n apply orb_prop in H.\n destruct H.\n  exists a.\n  auto with *.\n  \n  apply IHl in H.\n  destruct H.\n  exists x.\n  intuition auto with datatypes.\n\n destruct H as (elem, H).\n destruct H.\n induction l.\n  inversion H.\n  \n  simpl.\n  apply orb_true_intro.\n  destruct H.\n   left.\n   rewrite H.\n   trivial.\n   \n   right.\n   apply IHl.\n   trivial.\nQed.\n\nLemma LocSet_fold_orb:\nforall f s,  LocSet.fold (fun e b => (f e) || b) s false = true <-> exists e, LocSet.In e s /\\ f e = true.\nProof.\nintros.\nrewrite LocSet.fold_1.\nrewrite <- fold_left_rev_right.\nrewrite fold_right_orb.\nsplit; intros.\n destruct H as (e, H).\n rewrite <- in_rev in H.\n exists e.\n destruct H.\n split.\n  apply LocSet.elements_2.\n  unfold LocSet.E.eq.\n  clear H0.\n  induction (LocSet.elements s).\n   inversion H.\n   \n   simpl in H.\n   destruct H.\n    apply InA_cons_hd.\n    auto.\n    \n    apply InA_cons_tl.\n    apply IHl; trivial.\n    \n  trivial.\n  \n destruct H as (e, H).\n exists e.\n split.\n  destruct H.\n  rewrite <- in_rev.\n  apply LocSet.elements_1 in H.\n  unfold LocSet.E.eq in H.\n  induction H.\n   left; auto.\n   \n   right.\n   trivial.\n   \n  tauto.\nQed.\n\nLemma fold_right_union:\nforall e l,\nLocSet.In e (fold_right LocSet.union LocSet.empty l) \n<->\nexists s, In s l /\\ LocSet.In e s.\nProof.\ninduction l.\n intuition.\n  simpl in H.\n  apply LocSet.empty_1 in H.\n  tauto.\n  \n  destruct H.\n  tauto.\n  \n simpl.\n intuition.\n  apply LocSet.union_1 in H1.\n  destruct H1.\n   exists a.\n   split; tauto.\n   \n   apply H in H1.\n   destruct H1.\n   exists x.\n   split; tauto.\n   \n  destruct H1.\n  destruct H1.\n  destruct H1.\n   apply LocSet.union_2.\n   rewrite H1.\n   trivial.\n   \n   apply LocSet.union_3.\n   apply H0.\n   exists x.\n   tauto.\nQed.\n\nLemma In_InA: \nforall x l,\nInA LocSet.E.eq x l <-> In x l.\nProof.\nintros.\ninduction l.\nsimpl.\nintuition.\ninversion H.\nsimpl.\nintuition.\ninversion H1.\nsubst.\nleft.\nauto.\nsubst.\nright.\napply H;trivial.\nQed.\n\nLemma InDGTree_Correct:\nforall tree dg,\nInDG dg tree <-> InDGTree dg tree = true.\nProof.\nsplit;intros.\ninduction H.\n subst.\n simpl.\n case_eq (LocDec.eq_dec dg dg); intro; trivial.\n elim n; trivial.\n \n unfold InDGTree.\n rewrite H.\n destruct LocDec.eq_dec; trivial.\nfold InDGTree.\n apply fold_right_orb.\n exists tree'.\n tauto.\n\ngeneralize dg H.\nclear dg H.\nelim tree using\n DGTree_ind2\n  with\n    (Q := fun kids =>\n          forall dg tree',\n          In tree' kids -> InDGTree dg tree' = true -> InDG dg tree').\n intros.\n unfold InDGTree in H0.\n case_eq (LocDec.eq_dec dg a).\n  intros.\n  apply InDG_base with l.\n  unfold LocDec.eq in e.\n  rewrite e.\n  trivial.\n  \n  intros.\n  unfold LocDec.eq in n.\n  rewrite H1 in H0.\n  apply fold_right_orb in H0.\n  destruct H0 as (tree', H0).\n  destruct H0.\n  apply InDG_step with l a tree'; trivial.\n  apply H; trivial.\n  \n intros.\n inversion H.\n \n intros.\n simpl in H1.\n destruct H1.\n  rewrite <- H1.\n  rewrite <- H1 in H2.\n  apply H; trivial.\n  \n  apply H0; trivial.\nQed.\n\n\nDefinition FieldOfNode (n : DGTree) : LocSet.elt :=\nmatch n with\n| DGNode f _ => f\nend.\n\nInductive ValidDGTree (p : Program) (bl : Backlinks.t) (ep : LocSet.t) \n                 (f : Location) (m : LocSet.t) : DGTree -> Prop :=\n| ValidDGTree_def:\n  forall  dg dgs ad f'list f'list',\n  dg = DGNode f dgs ->\n  get_backlinks bl f = ad ->\n  (LocSet.elements (fold_right (LocSet.union) \n        LocSet.empty \n        (LocDict.filter ad (fun f'' => ~ LocSet.In f'' ep))))  \n        +++ (StaticDGs p f) = f'list' ->\n  filter (fun f'' => LocSet.mem f'' m) f'list' = f'list ->\n  length dgs = length f'list ->\n  (forall n f'' f' dgs', \n    n < length dgs ->\n    nth n  f'list f'' = f' ->\n    nth n dgs (DGNode f'' []) = dgs' ->\n    ValidDGTree p bl ep f' (LocSet.remove f' m) dgs') ->\n  ValidDGTree p bl ep f m dg.\n\nLemma ValidDGTree_func: forall p bl ep tree f m,\nValidDGTree p bl ep f m tree ->\nforall tree',\nValidDGTree p bl ep f m tree' -> \ntree = tree'.\nProof.\nintros p bl ep tree.\nelim tree using\n DGTree_ind2\n  with\n    (Q := fun kids =>\n          forall k f m,\n          In k kids ->\n          ValidDGTree p bl ep f (LocSet.remove f m) k ->\n          forall k', ValidDGTree p bl ep f (LocSet.remove f m) k' -> eq k k').\n intros.\n inversion H0.\n inversion H1.\n rewrite H9.\n inversion H2.\n rewrite H18 in H.\n assert (eq dgs dgs0).\n  rewrite H3 in H10.\n  rewrite <- H10 in H11.\n  rewrite H4 in H11.\n  rewrite <- H11 in H12.\n  rewrite H5 in H12.\n  rewrite <- H12 in H13.\n  rewrite <- H12 in H14.\n  rewrite <- H6 in H13.\n  clear a l H0 tree' H1 dg ad f'list' H2 H3 H4 H5 H8 dg0 ad0 f'list0 f'list'0\n   H9 H10 H11 H12 H15 H17 H18.\n  assert\n   (forall n f'',\n    (nth n dgs (DGNode f'' nil)) = (nth n dgs0 (DGNode f'' nil))).\n   intros.\n   case_eq (Nat.compare n (length dgs)); intros.\n    assert (le (length dgs) n).\n     rewrite nat_compare_Eq in H0.\n     lia.\n     \n     generalize H1; intro.\n     apply nth_overflow with (d := DGNode f'' nil) in H1.\n     rewrite <- H13 in H2.\n     apply nth_overflow with (d := DGNode f'' nil) in H2.\n     rewrite H1; rewrite H2; trivial.\n     \n    rewrite <- nat_compare_lt in H0.\n    apply H with (nth n f'list f'') m.\n     apply nth_In; trivial.\n     \n     apply H7 with n f''; trivial.\n     \n     apply H14 with n f''; trivial.\n     rewrite H13; trivial.\n     \n    assert (le (length dgs) n).\n     rewrite <- nat_compare_gt in H0.\n     lia.\n     \n     generalize H1; intro.\n     apply nth_overflow with (d := DGNode f'' nil) in H1.\n     rewrite <- H13 in H2.\n     apply nth_overflow with (d := DGNode f'' nil) in H2.\n     rewrite H1; rewrite H2; trivial.\n     \n   clear p bl ep tree H f m f'list H6 H7 H14.\n   symmetry  in H13.\n   generalize dgs0, H13, H0.\n   clear dgs0 H13 H0.\n   induction dgs.\n    intros.\n    destruct dgs0; trivial.\n    inversion H13.\n    \n    intros.\n    destruct dgs0.\n     inversion H13.\n     \n     assert (eq a d).\n      destruct a.\n      specialize H0 with O am.\n      simpl in H0; trivial.\n      \n      assert (eq dgs dgs0).\n       apply IHdgs.\n        auto.\n        \n        intros.\n        specialize H0 with (S n) f''.\n        simpl in H0; trivial.\n        \n       rewrite H; rewrite H1; trivial.\n       \n  rewrite H16; trivial.\n  \n intros.\n inversion H.\n \n intros.\n simpl in H1.\n destruct H1.\n  rewrite <- H1.\n  rewrite <- H1 in H2.\n  apply H with f (LocSet.remove f m); trivial.\n  \n  apply H0 with f m; trivial.\nQed.\n\nLemma ValidDGTree_exists: forall p bl ep m,\nforall f, exists dg, ValidDGTree p bl ep f m dg.\nProof.\nintros p bl ep m.\nassert (exists n , n = LocSet.cardinal m).\nexists (LocSet.cardinal m);trivial.\ndestruct H as [n H].\ngeneralize n m H.\nclear m n H.\ninduction n.\n\n intros.\n set (ad := get_backlinks bl f).\n set\n  (f'list' :=\n    (LocSet.elements (fold_right (LocSet.union) LocSet.empty (LocDict.filter ad (fun f'' => ~ LocSet.In f'' ep))))  +++ (StaticDGs p f)).\n exists (DGNode f nil).\n apply\n  ValidDGTree_def\n   with (dgs := nil) (ad := ad) (f'list' := f'list') (f'list := nil); \n  trivial.\n  induction f'list'.\n   simpl; trivial.\n   \n   simpl.\n   symmetry  in H.\n   rewrite <- LocSetProp.cardinal_Empty in H.\n   replace (LocSet.mem a m) with false .\n    trivial.\n    \n    case_eq (LocSet.mem a m); intro; trivial.\n    apply LocSet.mem_2 in H0.\n    unfold LocSet.Empty in H.\n    destruct H with a; trivial.\n    \n  intros.\n  simpl in H0.\n  inversion H0.\n  \n intros.\n set (ad := get_backlinks bl f).\n set\n  (f'list' :=\n    (LocSet.elements (fold_right (LocSet.union) LocSet.empty (LocDict.filter ad (fun f'' => ~ LocSet.In f'' ep))))  +++ (StaticDGs p f)).\n set (f'list := filter (fun f'' => LocSet.mem f'' m) f'list').\n set (dgsEx := (exists dgs, length dgs = length f'list /\\ forall n f'' f' dgs', n < length dgs ->\n    nth n  f'list f'' = f' ->\n    nth n dgs (DGNode f'' []) = dgs' ->\n    ValidDGTree p bl ep f' (LocSet.remove f' m) dgs')).\nunfold ad in f'list'.\n\n elim classic with dgsEx; intros.\n  destruct H0 as (dgs, H0).\n  clear dgsEx.\n  destruct H0.\n  exists (DGNode f dgs).\n  apply\n   ValidDGTree_def\n    with (dgs := dgs) (ad := ad) (f'list' := f'list') (f'list := f'list);\n   trivial.\n  \n  elim H0.\nunfold dgsEx.\n  apply not_all_not_ex.\n  intro.\n  clear H0 dgsEx.\n  induction f'list'.\n   specialize H1 with (nil (A:=DGTree)).\n   destruct H1.\n   split.\n    trivial.\n    \n    intros.\n    inversion H0.\n    \n   apply IHf'list'.\n   clear IHf'list'.\n   intro.\n   intro.\n   case_eq (LocSet.mem a m); intro.\n    specialize IHn with (m := LocSet.remove a m).\n    destruct IHn with a.\n     apply eq_add_S.\n     rewrite H.\n     symmetry .\n     apply LocSetProp.remove_cardinal_1.\n     apply LocSet.mem_2; trivial.\n     apply H1 with (cons x n0).\n     split.\n      unfold f'list.\n      simpl.\n      rewrite H2.\n      simpl.\n      lia.\n      \n      destruct H0.\n      intros.\n      unfold f'list in H6.\n      simpl in H6.\n      rewrite H2 in H6.\n      case_eq n1; intros.\n       simpl in H7.\n       rewrite H8 in H7.\n       simpl in H6.\n       rewrite H8 in H6.\n       rewrite <- H6.\n       rewrite <- H7.\n       trivial.\n       \n       simpl in H7.\n       apply H4 with n2 f''.\n        rewrite H8 in H5.\n        simpl in H5.\n        auto with *.\n        \n        rewrite H8 in H6.\n        simpl in H6.\n        trivial.\n        \n        rewrite H8 in H7.\n        trivial.\n\n    apply H1 with n0.\n    unfold f'list.\n    simpl.\n    rewrite H2.\n    trivial.\nQed.\n\nLemma ValidDGTree_1:\nforall p bl ep f m dg,\nValidDGTree p bl ep f m dg ->\nexists dgs, dg = DGNode f dgs.\nProof.\nintros.\ninversion H.\nexists dgs.\ntrivial.\nQed.\n\nLemma ValidDGTree_EqualSets:\nforall p bl ep n f tree  s1 s2 ,\ns1 [=] s2 ->\nn = LocSet.cardinal s1 ->\nValidDGTree p bl ep f s1 tree ->\nValidDGTree p bl ep f s2 tree.\nProof.\nintros p bl ep.\ninduction n.\n intros.\n inversion H1.\n symmetry  in H0.\n apply LocSetProp.cardinal_Empty in H0.\n assert (f'list = []).\n  clear H4 H7 H6.\n  generalize f'list, H5.\n  clear f'list H5.\n  induction f'list'.\n   intros.\n   simpl in H5.\n   auto.\n   \n   intros.\n   simpl in H5.\n   assert (LocSet.mem a s1 = false).\n    unfold LocSet.Empty in H0.\n    specialize H0 with a.\n    apply LocSetPropEq.mem_3; trivial.\n    \n    rewrite H4 in H5.\n    intros.\n    apply IHf'list'.\n    trivial.\n    \n  rewrite H9 in H5.\n  rewrite H9 in H7.\n  apply ValidDGTree_def with dgs ad [] f'list'; trivial.\n   assert (LocSet.Empty s2).\n    unfold LocSet.Empty.\n    intros.\n    unfold LocSet.Empty in H0.\n    unfold LocSet.Equal in H.\n    intro.\n    apply H in H10.\n    elim H0 with a; trivial.\n    \n    clear H4 H5 H6 H7 H9.\n    induction f'list'.\n     simpl; trivial.\n     \n     assert (LocSet.mem a s2 = false).\n      apply LocSetPropEq.mem_3; trivial.\n      \n      simpl.\n      rewrite H4.\n      trivial.\n      \n   rewrite H6.\n   rewrite H9.\n   trivial.\n   \n   intros.\n   rewrite H6 in H10.\n   rewrite H9 in H10.\n   simpl in H10; inversion H10.\n   \n intros.\n inversion H1.\n apply ValidDGTree_def with dgs ad f'list f'list'; trivial.\n  generalize f'list, H5.\n  clear f'list H4 H5 H6 H7.\n  induction f'list'.\n   simpl.\n   trivial.\n   \n   simpl.\n   intros.\n   case_eq (LocSet.mem a s1); intros.\n    rewrite H4 in H5.\n    rewrite H in H4.\n    rewrite H4.\n    destruct f'list.\n     inversion H5.\n     \n     specialize IHf'list' with f'list.\n     rewrite IHf'list'.\n      inversion H5.\n      trivial.\n      \n      inversion H5; trivial.\n      \n    rewrite H4 in H5.\n    rewrite H in H4.\n    rewrite H4.\n    rewrite IHf'list' with f'list; trivial.\n    \n  intros.\n  specialize IHn with f' dgs' (LocSet.remove f' s1) (LocSet.remove f' s2).\n  case_eq (LocSet.mem f' s1); intros.\n   apply IHn.\n    apply LocSetProp.Equal_remove; trivial.\n    \n    apply eq_add_S.\n    rewrite H0.\n    symmetry .\n    apply LocSetPropEq.remove_cardinal_1; trivial.\n    \n    apply H7 with n0 f''; trivial.\n    \n   assert (LocSet.mem f' s1 = true).\n    generalize nth_In.\n    intros.\n    assert (In f' f'list).\n     rewrite <- H10.\n     apply H13.\n     rewrite <- H6.\n     trivial.\n     \n     rewrite <- H5 in H14.\n     clear H4.\n     generalize f'list, H5.\n     clear f'list H5 H10 H6 H7.\n     induction f'list'.\n      intros.\n      simpl in *.\n      inversion H14.\n      \n      intros.\n      simpl in H5.\n      case_eq (LocSet.mem a s1); intros.\n       rewrite H4 in H5.\n       simpl in H14.\n       rewrite H4 in H14.\n       case_eq (LocDec.eq_dec a f').\n        intros.\n        unfold LocDec.eq in e.\n        rewrite <- e.\n        trivial.\n        \n        intros.\n        simpl in H14.\n        destruct H14.\n         elim n1.\n         unfold LocDec.eq.\n         trivial.\n         \n         destruct f'list.\n          inversion H5.\n          \n          apply IHf'list' with f'list in H7; trivial.\n          inversion H5.\n          trivial.\n          \n       rewrite H4 in H5.\n       simpl in H14.\n       rewrite H4 in H14.\n       apply IHf'list' with f'list in H14; trivial.\n       \n    rewrite H12 in H13.\n    inversion H13.\nQed.\n\nParameter BuildDGTree: Program -> Backlinks.t -> (* excluded pivots *) LocSet.t -> (* field *) Location -> LocSet.t -> DGTree.\nAxiom BuildDGTree_def: forall p bl ep f tree m,\nValidDGTree p bl ep f m tree <-> BuildDGTree p bl ep f m  = tree.\n\nDefinition FieldInDg_rac3 (p : Program) (bl : Backlinks.t) \n      ((* excluded pivots *) ep : LocSet.t) (f : Location) \n      (dg : Location) : bool :=\n  InDGTree dg (BuildDGTree p bl ep f (LocSetAll \\ (LocSet.singleton f))).\n\n\nDefinition CorrectBacklink (p : Program) (st : State.t) (f dg pivot : Location) : Prop :=\ndirect_FieldInDg_dynamic p st@h f dg pivot\n<->\nexists ams,  LocDict.get (get_backlinks st@bl f) pivot = Some ams /\\ LocSet.In dg ams.\n\nDefinition CorrectBacklinks (p : Program) (st : State.t) : Prop :=\nforall f dg pivot , CorrectBacklink p st f dg pivot.\n\nLemma LocDict_get_some:\nforall bl f pivot ams,\nLocDict.get (get_backlinks bl f) pivot = Some ams ->\nexists ad, Backlinks.get bl f = Some ad.\nProof.\nintros.\nunfold get_backlinks in H.\ncase_eq (Backlinks.get bl f);intros.\nexists v;trivial.\nrewrite H0 in H.\nrewrite LocDict.get_empty in H.\ninversion H.\nQed.\n\nInductive EqualAssignables (a1 a2: list (LocSet.t * LocSet.t)) :=\nEqualAssignables_def:\nlength a1 = length a2 ->\n(forall n a,\n  fst (nth n  a1 a) [=] fst (nth n  a2 a) /\\\n  snd (nth n  a1 a) [=] snd (nth n  a2 a)) ->\nEqualAssignables a1 a2.\n\nInductive EqualFresh (f1 f2: stack ObjSet.t) :=\nEqualFresh_def:\nlength f1 = length f2 ->\n(forall n d,\n  (nth n  f1 d) [[=]] (nth n  f2 d)) ->\nEqualFresh f1 f2.\n\nInductive CorrespondingFrame : Rac2.Frame.t -> Frame.t -> Prop :=\n| CorrespondingFrame_def:\n  forall fr_rac2 fr_rac3,\n  fr_rac2@params         = fr_rac3@params ->\n  fr_rac2@vars           = fr_rac3@vars ->\n  fr_rac2@pc             = fr_rac3@pc ->\n  fr_rac2@ret            = fr_rac3@ret ->\n  fr_rac2@pre            = fr_rac3@pre ->\n  fr_rac2@quants         = fr_rac3@quants ->\n  EqualFresh fr_rac2@fresh fr_rac3@fresh ->\n  EqualAssignables fr_rac2@assignables fr_rac3@assignables -> \n  CorrespondingFrame fr_rac2 fr_rac3.\n\nInductive CorrespondingState (p : Program): Rac2.State.t -> State.t -> Prop :=\n| CorrespondingState_def:\n  forall st_rac2 st_rac3,\n  CorrespondingFrame st_rac2@fr%rac2 st_rac3@fr ->\n  st_rac2@h%rac2 = st_rac3@h ->\n  CorrectBacklinks p st_rac3 ->\n  CorrespondingState p st_rac2 st_rac3.\n\nLemma nil_length:\nforall A (l : list A),\n0 = length l -> l = nil.\nProof.\nintuition.\nunfold length in H.\ndestruct l;trivial.\ninversion H.\nQed.\n\nLemma FieldInDg_rac_EqualSets:\nforall p h s1 f dg,\nRac2.FieldInDg_rac p h s1 f dg ->\nforall s2,\ns1 [=] s2 ->\nRac2.FieldInDg_rac p h s2 f dg.\nProof.\nintros p h s1 f dg H.\ninduction H; intros.\n apply Rac2.FieldInDg_rac_step with dg'.\n  apply IHFieldInDg_rac1; trivial.\n  \n  apply IHFieldInDg_rac2; trivial.\n  \n apply Rac2.FieldInDg_rac_static; trivial.\n \n apply Rac2.FieldInDg_rac_dynamic with pivot; trivial.\n intro.\n elim H0.\n apply H1; trivial.\n \n apply Rac2.FieldInDg_rac_same; trivial.\nQed.\n\n(* field in rac as in second refinement, but terminating *)\nInductive FieldInDg_rac2 (p : Program) (h : Heap.t) (ep : LocSet.t) (s : LocSet.t): (* field *) Location -> (* dg *) Location -> Prop :=\n  | FieldInDg_rac2_static : forall f dg dg',\n    direct_FieldInDg_static p f dg' ->\n    ~ LocSet.In dg' s ->\n    FieldInDg_rac2 p h ep (LocSet.add dg' s) dg' dg ->\n    FieldInDg_rac2 p h ep s f dg\n  | FieldInDg_rac2_dynamic : forall f dg pivot dg',\n    direct_FieldInDg_dynamic p h f dg' pivot ->\n    ~ LocSet.In pivot ep ->\n    ~ LocSet.In dg' s ->\n    FieldInDg_rac2 p h ep (LocSet.add dg' s) dg' dg ->\n    FieldInDg_rac2 p h ep s f dg\n  | FieldInDg_rac2_base : forall f dg, \n    f = dg ->\n    FieldInDg_rac2 p h ep s f dg.\n\nLemma FieldInDg_rac2_Correct:\nforall p h ep1 ep2 f dg,\nep1 [=] ep2 ->\n(Rac2.FieldInDg_rac p h ep1 f dg \n<->\nFieldInDg_rac2 p h ep2 (LocSet.singleton f) f dg).\nAdmitted. (* Pen and paper proof *)\n\nLemma FieldInDg_rac2_EqualSet:\nforall p h ep s1 f dg,\nFieldInDg_rac2 p h ep s1 f dg -> \nforall s2, s1 [=] s2 ->\nFieldInDg_rac2 p h ep s2 f dg.",
      "suffix": "\n\nLemma LocSet_remove_diff_remove_add:\nforall x y e,\nLocSet.In e x ->\nx \\ (y \\ {e})  [=] LocSet.add e (x \\ y).\nProof.\nsplit; intros.\n case_eq (MP.FM.eq_dec e a); intros.\n  apply LocSet.add_1; trivial.\n  \n  apply LocSet.add_2.\n  apply LocSet.diff_3.\n   apply LocSet.diff_1 in H0; trivial.\n   \n   apply LocSet.diff_2 in H0.\n   intro; elim H0.\n   apply LocSet.remove_2; trivial.\n   \n case_eq (MP.FM.eq_dec e a); intros.\n  unfold LocDec.eq in e0; subst.\n  apply LocSet.diff_3; trivial.\n  apply LocSet.remove_1; trivial.\n  \n  apply LocSet.add_3 in H0; trivial.\n  apply LocSet.diff_3.\n   apply LocSet.diff_1 in H0; trivial.\n   \n   apply LocSet.diff_2 in H0.\n   intro; elim H0.\n   apply LocSet.remove_3 in H2; trivial.\nQed.\n\nLemma LocSet_diff_remove_diff_add:\nforall x y e,\n(x \\ y) \\ {e} [=] x \\ (LocSet.add e y).\nProof.\nsplit; intros.\n apply LocSet.diff_3.\n  apply LocSet.remove_3 in H.\n  apply LocSet.diff_1 in H.\n  trivial.\n  \n  intro.\n  apply LocSet.add_3 in H0.\n   apply LocSet.remove_3 in H.\n   apply LocSet.diff_2 in H.\n   elim H; trivial.\n   \n   intro.\n   unfold LocSet.E.eq in H1.\n   rewrite H1 in H.\n   apply LocSet.remove_1 in H.\n    elim H.\n    \n    trivial.\n    \n apply LocSet.remove_2.\n  intro.\n  unfold LocSet.E.eq in H0.\n  rewrite H0 in H.\n  apply LocSet.diff_2 in H.\n  elim H.\n  apply LocSet.add_1.\n  trivial.\n  \n  apply LocSet.diff_3.\n   apply LocSet.diff_1 in H.\n   trivial.\n   \n   apply LocSet.diff_2 in H.\n   intro; elim H.\n   apply LocSet.add_2.\n   trivial.\nQed.\n\nLemma FieldInDg_rac3_Correct:\nforall p ep st f dg ,\nCorrectBacklinks p st ->\n(FieldInDg_rac2 p st@h ep (LocSet.singleton f) f dg \n<->\nFieldInDg_rac3 p st@bl ep f dg = true).\nProof.\nsplit;intros.\n unfold FieldInDg_rac3 in *.\n apply InDGTree_Correct.\n induction H0.\n  elim\n   ValidDGTree_exists\n    with p st@bl ep (LocSetAll \\ s) f; \n   trivial.\n  intro tree.\n  intro.\n  replace (BuildDGTree p st@bl ep f (LocSetAll \\ s)) with tree .\n   destruct tree.\n   inversion H3.\n   assert (In dg' f'list').\n    rewrite <- H6.\n    apply in_or_app.\n    right.\n    apply StaticDGs_Correct; trivial.\n    \n    assert (In dg' f'list).\n     clear H6.\n     generalize f'list, H7, H11.\n     clear f'list H7 H11 H8 H9.\n     assert (LocSet.mem dg' (LocSetAll \\ s) = true).\n      rewrite LocSetPropEq.diff_mem.\n      apply andb_true_iff.\n      split.\n       apply LocSet.mem_1.\n       apply LocSetAll_def.\n       \n       apply negb_true_iff.\n       apply LocSetPropEq.mem_3; trivial.\n       \n      induction f'list'.\n       intros.\n       inversion H11.\n       \n       intros.\n       simpl in H11.\n       destruct H11.\n        subst.\n        simpl.\n        rewrite H6.\n        simpl; left; trivial.\n        \n        simpl in H7.\n        case_eq (LocSet.mem a (LocSetAll \\ s)); intros; rewrite H9 in H7.\n         destruct f'list.\n          inversion H7.\n          \n          specialize IHf'list' with f'list.\n          inversion H7.\n          rewrite H13.\n          apply IHf'list' in H13.\n           auto with *.\n           \n           trivial.\n           \n         apply IHf'list'.\n          trivial.\n          \n          trivial.\n     \n     apply in_nth with (d:=f) in H12.\n      destruct H12 as [n H12].\n      destruct H12.\n      inversion H4.\n      set (tree' := nth n dgs0 (DGNode f [])).\n      specialize H9 with n f dg' tree'.\n      case_eq (LocDec.eq_dec dg f); intros.\n       unfold LocDec.eq in e.\n       apply InDG_base with dgs0.\n       rewrite e; trivial.\n       \n       apply InDG_step with dgs0 f tree'; trivial.\n        unfold tree'.\n        apply nth_In.\n        rewrite H8; trivial.\n        \n        assert (BuildDGTree p st@bl ep dg' (LocSetAll \\ (LocSet.add dg' s)) = tree').\n         rewrite <- BuildDGTree_def.\n         apply\n          ValidDGTree_EqualSets\n           with\n             (n := LocSet.cardinal ((LocSetAll \\ s) \\ {dg'}))\n             (s1 := (LocSetAll \\ s) \\ {dg'}); trivial.\n             \n             apply LocSet_diff_remove_diff_add.\n             \n          apply H9; trivial.\n          rewrite H8; trivial.\n          \n         rewrite <- H17.\n         trivial.\n\n   symmetry .\n   apply BuildDGTree_def; trivial.\n\n  elim\n   ValidDGTree_exists\n    with p st@bl ep (LocSetAll \\ s) f; \n   trivial.\n  intro tree.\n  intro.\n  replace (BuildDGTree p st@bl ep f (LocSetAll \\ s)) with tree .\n  destruct tree.\n   inversion H4.\n   assert (In dg' f'list').\n    rewrite <- H7.\n    apply in_or_app.\n    left.\n    unfold CorrectBacklinks in H.\n    unfold CorrectBacklink in H.\n    unfold get_backlinks in H6.\n    rewrite H in H0.\n    destruct H0 as [amd H0].\n    destruct H0.\n    rewrite <- In_InA.\n    apply LocSet.elements_1.\n    apply fold_right_union.\n    elim LocDict_get_some with st@bl f pivot amd;trivial.\n    intros.\n    rewrite H13 in H6.\n    rewrite <- H6.\n    exists amd.\n    split;trivial.\n    apply LocDict.filter_1.\n    exists pivot.\n    unfold get_backlinks in H0.\n    rewrite H13 in H0.\n    tauto.\n\n    assert (In dg' f'list).\n     clear H7.\n     generalize f'list, H8, H12.\n     clear f'list H8 H12 H9 H10.\n     assert (LocSet.mem dg' (LocSetAll \\ s) = true).\n      rewrite LocSetPropEq.diff_mem.\n      apply andb_true_iff.\n      split.\n       apply LocSet.mem_1.\n       apply LocSetAll_def.\n       \n       apply negb_true_iff.\n       apply LocSetPropEq.mem_3; trivial.\n       \n      induction f'list'.\n       intros.\n       inversion H12.\n       \n       intros.\n       simpl in H12.\n       destruct H12.\n        subst.\n        simpl.\n        rewrite H7.\n        simpl; left; trivial.\n        \n        simpl in H8.\n        case_eq (LocSet.mem a (LocSetAll \\ s)); intros; rewrite H10 in H8.\n         destruct f'list.\n          inversion H8.\n          \n          specialize IHf'list' with f'list.\n          inversion H8.\n          rewrite H14.\n          apply IHf'list' in H14.\n           auto with *.\n           \n           trivial.\n           \n         apply IHf'list'.\n          trivial.\n          \n          trivial.\n          \n     apply in_nth with (d := f) in H13.\n      destruct H13 as [n H13].\n      destruct H13.\n      inversion H4.\n      set (tree' := nth n dgs0 (DGNode f [])).\n      specialize H10 with n f dg' tree'.\n      case_eq (LocDec.eq_dec dg f); intros.\n       unfold LocDec.eq in e.\n       apply InDG_base with dgs0.\n       rewrite e; trivial.\n       \n       apply InDG_step with dgs0 f tree'; trivial.\n        unfold tree'.\n        apply nth_In.\n        rewrite H9; trivial.\n        \n        assert (BuildDGTree p st@bl ep dg' (LocSetAll \\ (LocSet.add dg' s)) = tree').\n         rewrite <- BuildDGTree_def.\n         apply\n          ValidDGTree_EqualSets\n           with\n             (n := LocSet.cardinal ((LocSetAll \\ s) \\ {dg'}))\n             (s1 := (LocSetAll \\ s) \\ {dg'}); trivial.\n             \n             apply LocSet_diff_remove_diff_add.\n             \n          apply H10; trivial.\n          rewrite H9; trivial.\n          \n         rewrite <- H23.\n         trivial.\n      \n   symmetry .\n   apply BuildDGTree_def; trivial.\n\n  assert(exists tree, BuildDGTree p st@bl ep f (LocSetAll \\s) = tree).\n  exists (BuildDGTree p st@bl ep f (LocSetAll \\s)).\n  trivial.\n  destruct H1 as [tree H1].\n  apply BuildDGTree_def in H1.\n  replace (BuildDGTree p st@bl ep f (LocSetAll \\s)) with tree.\n  inversion H1.\n  apply InDG_base with dgs.\n  rewrite <- H0.\n  trivial.\n  symmetry.\n  apply BuildDGTree_def;trivial.\n\napply FieldInDg_rac2_EqualSet with (LocSetAll \\ (LocSetAll \\ (LocSet.singleton f))).\nunfold FieldInDg_rac3 in *.\napply InDGTree_Correct in H0.\nassert\n (exists tree, BuildDGTree p st@bl ep f (LocSetAll \\ LocSet.singleton f) = tree).\n exists (BuildDGTree p st@bl ep f (LocSetAll \\ LocSet.singleton f)).\n trivial.\n \n destruct H1 as (tree, H1).\n rewrite H1 in H0.\n apply BuildDGTree_def in H1.\n induction H1.\n destruct H0.\n  rewrite H0 in H1.\n  inversion H1.\n  apply FieldInDg_rac2_base.\n  trivial.\n  \n  rewrite H0 in H1.\n  inversion H1.\n  apply in_nth with (d := DGNode f []) in H9.\n  destruct H9 as (n, H9).\n  destruct H9.\n  set (f' := nth n f'list f).\n  assert (In f' f'list).\n   apply nth_In.\n   rewrite <- H5.\n   rewrite <- H13; trivial.\n   assert (LocSet.In f' m).\n    clear H3.\n    generalize f'list, H4, f', H14.\n    clear f'list H4 f' H14 H5 H6 H7.\n    induction f'list'.\n     intros.\n     simpl in H4.\n     rewrite <- H4 in H14.\n     inversion H14.\n     \n     intros.\n     simpl in H4.\n     case_eq (LocSet.mem a m); intros; rewrite H3 in H4.\n      destruct f'list.\n       inversion H4.\n       \n       simpl in H14.\n       destruct H14.\n        rewrite <- H5.\n        inversion H4.\n        rewrite <- H7.\n        apply LocSet.mem_2; trivial.\n        \n        apply IHf'list' with f'list.\n         inversion H4; trivial.\n         \n         trivial.\n         \n      apply IHf'list' with f'list; trivial.\n      \n    specialize H6 with n f f' tree'.\n    specialize H7 with n f f' tree'.\n    assert (In f' f'list').\n     rewrite <- H4 in H14.\n     rewrite filter_In in H14.\n     destruct H14; trivial.\n     \n     rewrite <- H3 in H16.\n     apply in_app_or in H16.\n     destruct H16.\n      unfold CorrectBacklinks in H.\n      unfold CorrectBacklink in H.\n      apply In_InA in H16.\n      apply LocSet.elements_2 in H16.\n      apply fold_right_union in H16.\n      destruct H16 as (ams, H16).\n      rewrite LocDict.filter_1 in H16.\n      destruct H16.\n      destruct H16 as (pivot, H16).\n      destruct H16.\n      apply FieldInDg_rac2_dynamic with pivot f'; trivial.\n       rewrite H.\n       exists ams.\n       split;trivial.\n         rewrite H2;trivial.\n\n       intro.\n       apply LocSet.diff_2 in H19.\n       elim H19;trivial.\n\n       apply FieldInDg_rac2_EqualSet with (LocSetAll \\ (m \\ {f'})).\n        rewrite <- H13 in H7.\n        apply H7; trivial.\n        \n        apply LocSet_remove_diff_remove_add.\n        apply LocSetAll_def.\n        \n      apply StaticDGs_Correct in H16.\n      apply FieldInDg_rac2_static with f'; trivial.\n       intro.\n       apply LocSet.diff_2 in H17.\n       elim H17; trivial.\n       \n       apply FieldInDg_rac2_EqualSet with (LocSetAll \\ (m \\ {f'})).\n        rewrite <- H13 in H7.\n        apply H7; trivial.\n        \n        apply LocSet_remove_diff_remove_add.\n        apply LocSetAll_def.\n\n  split; intros.\n   apply LocSet.diff_2 in H1.\n   assert (LocSet.In a LocSetAll).\n    apply LocSetAll_def.\n    \n    assert (~ LocSet.In a (LocSetAll \\ {f})).\n     intro; elim H1.\n     apply remove_diff_singleton; trivial.\n     \n     apply LocSet.singleton_2.\n     unfold LocSet.E.eq.\n     case_eq (MP.FM.eq_dec f a); intros.\n      auto.\n      \n      elim H3.\n      apply LocSet.remove_2.\n       trivial.\n       \n       trivial.\n       \n   apply LocSet.diff_3.\n    apply LocSetAll_def.\n    \n    intro.\n    apply LocSet.diff_2 in H2.\n    elim H2; trivial.\nQed.\n\n\nDefinition St3to2 (st: State.t) : Rac2.State.t :=\nRac2.State.build st@h st@fr Rac2.Adds.singleton.\n\n(** Postpone this ... *)\nDeclare Module AnnotationTable : ANNOTATION_TABLE State.\n\nModule Assignables <: ASSIGNABLES State.\t\n\n  Lemma NewFrame_Correct: forall p m param st_rac2 st_rac3 fr'_rac2 fr'_rac3,\n  CorrespondingState p st_rac2 st_rac3 ->\n  fr'_rac2 = Rac2.NewFrame m param st_rac2 ->\n  fr'_rac3 = NewFrame m param st_rac3 ->\n  CorrespondingState p st_rac2[fr:=fr'_rac2]%rac2 st_rac3[fr:=fr'_rac3].\n  Proof.\nintuition.\ndestruct H.\nsplit.\n rewrite H0.\n rewrite H1.\n unfold NewFrame.\n unfold Rac2.NewFrame.\n destruct H.\n split; trivial.\n  simpl.\n  rewrite H2.\n  trivial.\n  \n  simpl.\n  split.\n   destruct H9.\n   simpl.\n   rewrite e.\n   trivial.\n   \n   destruct H9.\n   simpl.\n   destruct n.\n    intros.\n    apply ObjSet.eq_refl.\n    \n    trivial.\n    \n  simpl.\n  split.\n   destruct H10.\n   simpl.\n   rewrite e.\n   trivial.\n   \n   destruct H10.\n   simpl.\n   destruct n.\n    intros.\n    split; simpl; apply LocSet.eq_refl.\n    \n    specialize a with (n := n).\n    trivial.\n    \n simpl; trivial.\n \n unfold CorrectBacklinks.\n intros.\n split; intros.\n  unfold CorrectBacklinks in H3.\n  simpl.\n  apply H3.\n  rewrite H1 in H4.\n  unfold NewFrame in H4.\n  simpl in H4; trivial.\n  \n  unfold CorrectBacklinks in H3.\n  simpl in H4.\n  apply H3 in H4.\n  rewrite H1.\n  unfold NewFrame.\n  simpl.\n  trivial.\nQed.\n\n  Definition Assignable (p : Program) (bl : Backlinks.t) (f : Location) (a : LocSet.t * LocSet.t) : bool :=\n      LocSet.fold\n         (fun dg b => (FieldInDg_rac3 p bl (fst a) f dg) || b)\n         (snd a)\n         false.\n\n  Definition FieldUpdateCheck (p : Program) (loc : Location) (st : State.t): Prop :=\n  forall n,\n  (n < length st@fr@assignables)%nat ->\n       (exists m, \n        (m <= n /\\ m < length st@fr@fresh)%nat /\\ LocSet.In loc (ObjSet2LocSet (nth m st@fr@fresh ObjSet.empty)))\n    \\/\n        Assignable p st@bl loc (nth n st@fr@assignables (LocSet.empty,LocSet.empty)) = true.\n\n  Lemma FieldUpdateCheck_Correct:\n    forall am p st_rac2 st_rac3,\n    CorrespondingState p st_rac2 st_rac3 ->\n    ( Rac2.Assignables.FieldUpdateCheck p am st_rac2 <-> FieldUpdateCheck p am st_rac3).\nProof.\nintros.\ndestruct H.\nrename H1 into Hcorr.\ninversion H.\nclear H H1 H2 H3 H4 H5 H6.\nsubst.\nrename H8 into H6.\nrename H7 into H5.\nrename H0 into H7.\nunfold FieldUpdateCheck.\nunfold Rac2.Assignables.FieldUpdateCheck.\nintuition.\n  destruct (H n).  \n  inversion H6.\n  rewrite H1.\n  trivial.\n  left.\n  destruct H1 as (m0, H1).\n  destruct H1.\n \n   exists m0.\n   split.\n   inversion H5.\n   rewrite <- H3.\n   trivial.\n   rewrite ObjSet2LocSet_def in H2 |- * .\n   unfold LocInObjSet in H2 |- *.\n   destruct am; trivial.\n   inversion H5.\n   unfold ObjSet.Equal in H4.\n   apply ObjSet.mem_1.\n   apply ObjSet.mem_2 in H2.\n   apply H4.\n   trivial.\n   inversion H5.\n   unfold ObjSet.Equal in H4.\n   apply ObjSet.mem_1.\n   apply ObjSet.mem_2 in H2.\n   apply H4.\n   trivial.\n\n  right.\n  unfold Assignable.\n  apply LocSet_fold_orb.\n  destruct H1.\n  destruct H1.\n  inversion H6.  \n  specialize H4 with n (LocSet.empty, LocSet.empty).\n  unfold LocSet.Equal in H4.\n  destruct H4.  \n  exists x.\n  split; [apply H8; trivial|].\n  rewrite <- FieldInDg_rac3_Correct; trivial.\n  rewrite <- FieldInDg_rac2_Correct with (ep1 := fst (nth n st_rac2 @fr%rac2 @assignables (LocSet.empty, LocSet.empty) )); trivial.\n  rewrite <- H7;trivial.\n    \n destruct H with n.\n\n  inversion H6.\n  rewrite <- H1.\n  trivial.\n  \n  left.\n  destruct H1 as (m0, H1).\n  destruct H1.\n \n   exists m0.\n   split.\n   inversion H5.\n   rewrite H3.\n   trivial.\n   rewrite ObjSet2LocSet_def in H2 |- * .\n   unfold LocInObjSet in H2 |- *.\n   destruct am; trivial.\n   inversion H5.\n   unfold ObjSet.Equal in H4.\n   apply ObjSet.mem_1.\n   apply ObjSet.mem_2 in H2.\n   rewrite H4.\n   trivial.\n   inversion H5.\n   unfold ObjSet.Equal in H4.\n   apply ObjSet.mem_1.\n   apply ObjSet.mem_2 in H2.\n   rewrite H4.\n   trivial.\n\n  right.\n  unfold Assignable in H1.\n  apply LocSet_fold_orb in H1.\n\n  inversion H6.\n  specialize H3 with n (LocSet.empty, LocSet.empty).\n  unfold LocSet.Equal in H3.\n  destruct H3.\n  destruct H1.\n  exists x.\n  destruct H1.\n  split; [apply H4; trivial|].\n  rewrite  FieldInDg_rac2_Correct with (ep2 := fst (nth n st_rac3 @fr@assignables (LocSet.empty, LocSet.empty) )); trivial.\n  rewrite H7;trivial.    \n  rewrite  FieldInDg_rac3_Correct; trivial.\nQed.\n\n  Definition AssignablePivotTargets ( p : Program) (bl : Backlinks.t) (pivot : Location) (a : LocSet.t * LocSet.t) : LocSet.t :=\n    list2LocSet (\n      filter\n        (fun f => \n\t   match LocDict.get (get_backlinks bl f) pivot with\n\t   | Some dgs => if LocSet.fold (fun dg b => (Assignable p bl dg a) || b) dgs false  then true else false\n\t   | None => false\n           end)\n        (Backlinks.keys bl)).\n\n  Lemma AssignablePivotTargets_Correct:\n    forall p  st  a1 a2 pivot,\n    CorrectBacklinks p st ->\n    (fst a1) [=] (fst a2) ->\n    (snd a1) [=] (snd a2) ->\n    Rac2.AssignablePivotTargets p st@h pivot a1   [=]\n    AssignablePivotTargets p st@bl pivot a2.\n  Proof.\nintros.\nunfold CorrectBacklinks in H.\nsplit; intros.\n destruct a1.\n destruct a2.\n simpl in *.\n rewrite Rac2.AssignablePivotTargets_def in H2.\n destruct H2 as (dg', H2).\n destruct H2.\n destruct H3 as (dg, H3).\n destruct H3.\n unfold AssignablePivotTargets.\n apply list2LocSet_1.\n apply filter_In.\n apply H in H2.\n destruct H2 as (dgs, H2).\n destruct H2.\n split.\n  apply Backlinks.keys_1.\n  intro.\n  apply LocDict_get_some in H2.\n  destruct H2.\n  rewrite H2 in H6.\n  inversion H6.\n  \n  rewrite H2.\n  case_eq\n   (LocSet.fold\n      (fun (elem : LocSet.elt) (b : bool) =>\n       Assignable p st @bl elem (t1, t2) || b) dgs false); \n   intro.\n   trivial.\n   \n   rewrite <- not_true_iff_false in H6.\n   rewrite LocSet_fold_orb in H6.\n   elim H6.\n   clear H6.\n   exists dg'.\n   split; trivial.\n   unfold Assignable.\n   simpl.\n   rewrite LocSet_fold_orb.\n   exists dg.\n   split; trivial.\n    rewrite <- H1; trivial.\n    \n    rewrite <- FieldInDg_rac3_Correct.\n     rewrite <- FieldInDg_rac2_Correct with (ep1 := t); trivial.\n     \n     auto with *.\n     \n destruct a1.\n destruct a2.\n simpl in *.\n rewrite Rac2.AssignablePivotTargets_def.\n unfold AssignablePivotTargets in H2.\n apply list2LocSet_1 in H2.\n apply filter_In in H2.\n destruct H2 as (H', H2).\n case_eq (LocDict.get (get_backlinks st @bl a) pivot); intros.\n  rewrite H3 in H2.\n  case_eq\n   (LocSet.fold\n      (fun (dg : LocSet.elt) (b : bool) =>\n       Assignable p st @bl dg (t1, t2) || b) v false); \n   intros.\n   apply LocSet_fold_orb in H4.\n   destruct H4.\n   destruct H4.\n   exists x.\n   split.\n    apply H.\n    exists v.\n    auto.\n    \n    unfold Assignable in H5.\n    apply LocSet_fold_orb in H5.\n    simpl in H5.\n    destruct H5 as (dg, H5).\n    exists dg.\n    rewrite H1.\n    rewrite FieldInDg_rac2_Correct with (ep2 := t1); trivial.\n    rewrite FieldInDg_rac3_Correct; trivial.\n    destruct H5.\n    auto.\n    \n   rewrite H4 in H2.\n   inversion H2.\n   \n  rewrite H3 in H2.\n  inversion H2.\nQed.\n\n  Definition SavePreState (p : Program) \n                          (bl : Backlinks.t) \n                          (pivot : Location)\n                          (assignable: LocSet.t * LocSet.t) : (LocSet.t * LocSet.t) :=\n  if LocSet.mem pivot (fst assignable) then\n    assignable\n  else\n    let fields := AssignablePivotTargets p bl pivot assignable in\n    (LocSet.add pivot (fst assignable), LocSet.union fields (snd assignable)).\n\n  Lemma SavePreState_same:\n  forall p st pivot a3 a2,\n  CorrectBacklinks p st ->\n  (fst a2) [=] (fst a3) ->\n  (snd a2) [=] (snd a3) ->\n  (fst (Rac2.SavePreState p st@h pivot a2) [=] fst (SavePreState p st@bl pivot a3) /\\\n  snd (Rac2.SavePreState p st@h pivot a2) [=] snd (SavePreState p st@bl pivot a3)).\n  Proof.\nintros.\nunfold SavePreState.\nunfold Rac2.SavePreState.\ncase_eq (LocSet.mem pivot (fst a2 )); case_eq (LocSet.mem pivot (fst a3 )); intros;\n try rewrite <- not_true_iff_false in H2;\n try rewrite <- not_true_iff_false in H3; try apply LocSet.mem_2 in H2;\n try apply LocSet.mem_2 in H3.\n tauto.\n \n elim H2.\n apply LocSet.mem_1.\n rewrite <- H0.\n trivial.\n \n elim H3.\n apply LocSet.mem_1.\n rewrite H0.\n trivial.\n \n split; split; simpl.\n  intros.\n  apply add_iff in H4.\n  destruct H4.\n   apply LocSet.add_1.\n   trivial.\n   \n   apply LocSet.add_2.\n   rewrite <- H0; trivial.\n   \n  intros.\n  apply add_iff in H4.\n  destruct H4.\n   apply LocSet.add_1.\n   trivial.\n   \n   apply LocSet.add_2.\n   rewrite H0; trivial.\n   \n  intros.\n  rewrite <- AssignablePivotTargets_Correct with (a1 := a2); auto with *.\n  apply LocSet.union_1 in H4.\n  destruct H4.\n   apply LocSet.union_2; trivial.\n   \n   apply LocSet.union_3.\n   rewrite <- H1; trivial.\n   \n  intros.\n  rewrite AssignablePivotTargets_Correct with (a2 := a3); auto with *.\n  apply LocSet.union_1 in H4.\n  destruct H4.\n   apply LocSet.union_2; trivial.\n   \n   apply LocSet.union_3.\n   rewrite H1; trivial.\nQed.\n\n  (* Don't bother for now, just assume that this function yields the same assignable locations than in the semantics.*)\n  Parameter EvalAssignableClause : Program -> Class -> Method -> State.t -> LocSet.t.\n  Parameter EvalAssignableClause_def : \n    forall p c m st_rac2 st_rac3,\n    CorrespondingState p st_rac2 st_rac3 ->\n    (EvalAssignableClause p c m st_rac3 [=] Rac2.Assignables.EvalAssignableClause p c m st_rac2).\n\n  Definition MethodCallAction (p : Program) (c : Class) (m : Method) (st : State.t) : State.t :=\n  let ams := EvalAssignableClause p c m st in\n  st[fr:=st@fr[assignables :+ (LocSet.empty, ams)]].\n\n  Lemma MethodCallAction_Correct:\n    forall p c m st_rac2 st_rac2' st_rac3 st_rac3',\n    CorrespondingState p st_rac2 st_rac3 ->\n    Rac2.Assignables.MethodCallAction p c m st_rac2 = st_rac2' ->\n    MethodCallAction p c m st_rac3 = st_rac3' ->\n    CorrespondingState p st_rac2' st_rac3'.\nProof.\nintuition.\ninversion H.\nsubst.\nunfold MethodCallAction.\nunfold Rac2.Assignables.MethodCallAction.\nsplit; simpl.\n destruct H2.\n split; simpl; trivial.\n split.\n  destruct H9.\n  unfold replace_top.\n  destruct fr_rac2@assignables; destruct fr_rac3@assignables;trivial.\n  \n  destruct H9.\n  intros.\n  unfold replace_top.\n  destruct fr_rac2@assignables; destruct fr_rac3@assignables;trivial.\n  inversion e.\n  inversion e.\n  destruct n.\n  simpl.\n  split.\n  apply LocSet.eq_refl.\n  rewrite EvalAssignableClause_def with (st_rac2 := st_rac2);trivial.\n  apply LocSet.eq_refl.\n    simpl.\n    specialize a with (S n) a0.\n    simpl in a.\n    trivial.\n    \n trivial.\n \n unfold CorrectBacklinks.\n simpl.\n trivial.\nQed.\n\n(** Add all fields of a newly created object to the list of fresh locations, as well\nto the assignable list *)\n\n  Definition NewObjectAction (p : Program) (obj : Object) (st : State.t) : State.t :=\n    st[fr:=st@fr[fresh :+ obj]].\n\n\n  Lemma NewObjectAction_Correct:\n    forall p l st_rac2 st_rac2' st_rac3 st_rac3',\n    CorrespondingState p st_rac2 st_rac3 ->\n    NewObjectAction p l st_rac3 = st_rac3' ->\n    Rac2.Assignables.NewObjectAction p l st_rac2 = st_rac2' ->\n    CorrespondingState p st_rac2' st_rac3'.\n  Proof.\nintuition.\nsubst.\ninversion H.\nsplit; trivial.\nsubst.\nsimpl in *.\ndestruct H0.\nsplit; simpl; trivial.\nsubst.\nunfold apply_top.\ndestruct H8.\ndestruct fr_rac2 @fresh; destruct fr_rac3 @fresh.\n split.\n  trivial.\n  \n  trivial.\n  \n inversion e.\n \n inversion e.\n \n split; simpl.\n  trivial.\n  \n  intros.\n  destruct n.\n   specialize e0 with 0 d.\n   simpl in e0.\n   unfold ObjSet.Equal in * |- *.\nsplit;intros.\ncase_eq(ObjDec.eq_dec l a);intros.\napply ObjSet.add_1;trivial.\napply ObjSet.add_2;trivial.\napply ObjSet.add_3 in H8;trivial.\nrewrite <- e0;trivial.\ncase_eq(ObjDec.eq_dec l a);intros.\napply ObjSet.add_1;trivial.\napply ObjSet.add_2;trivial.\napply ObjSet.add_3 in H8;trivial.\nrewrite e0;trivial.\n   \n   specialize e0 with (S n) d.\n   simpl in e0.\n   trivial.\nQed.\n\n(** Upon method return, add all freshly created locations to the list of fresh locations from the caller *)\n\n  Definition MethodReturnAction (p : Program) (st_c : State.t) (st : State.t) : State.t :=\n    st_c[fr:=st@fr[fresh :\\/ (peekd st_c@fr@fresh ObjSet.empty)][assignables := pop st_c@fr@assignables]].\n    \n\n  Lemma MethodReturnAction_Correct:\n    forall p st_rac2 st_rac2_c st_rac2_c' st_rac3 st_rac3_c st_rac3_c',\n    CorrespondingState p st_rac2_c st_rac3_c ->\n    CorrespondingState p st_rac2 st_rac3 ->\n    Rac2.Assignables.MethodReturnAction p st_rac2_c st_rac2 = st_rac2_c' ->\n    MethodReturnAction p st_rac3_c st_rac3 = st_rac3_c' ->\n    CorrespondingState p st_rac2_c' st_rac3_c'.\n  Proof.\nintuition.\nsubst.\nunfold MethodReturnAction.\nunfold Rac2.Assignables.MethodReturnAction.\ninversion H.\ninversion H1.\ninversion H0.\ninversion H16.\nsplit; trivial.\nsplit; simpl; trivial.\n\n  unfold apply_top.\n  destruct H27.\n  destruct st_rac2 @fr%rac2 @fresh ; destruct  st_rac3 @fr @fresh;trivial.\n      split;simpl;trivial.\n    inversion e.\ninversion e.\n    split;simpl.\n    trivial.\n    intros.\n    destruct n.\nspecialize e0 with O d.\nsimpl in e0.\n destruct H12.\n unfold peekd.\n destruct st_rac2_c @fr@fresh%rac2; destruct  st_rac3_c @fr @fresh ; simpl;trivial.\n apply UnionEqual.\n apply ObjSet.eq_refl.\n trivial.\n inversion e1.\ninversion e1.\nspecialize e2 with O d.\nsimpl in e2.\napply  UnionEqual;trivial.\nspecialize e0 with (S n) d.\nsimpl in e0.\ntrivial.\n destruct H13.\n split.\n  unfold pop.\n  destruct st_rac2_c @fr%rac2 @assignables;\n   destruct st_rac3_c @fr @assignables; trivial.\n   inversion e.\n   \n   inversion e.\n   \n   simpl in e.\n   auto.\n   \n  intros.\n  unfold pop.\n  destruct st_rac2_c @fr%rac2 @assignables;\n   destruct st_rac3_c @fr @assignables; trivial.\n   inversion e.\n   \n   inversion e.\n   \n   specialize a with (S n) a0.\n   simpl in a.\n   trivial.\nQed.\n\nDefinition RemoveBacklinks (p : Program) (pivot : Location) (st : State.t) : Backlinks.t :=\n  match Heap.get st@h pivot with\n  | Some (Ref obj) => \n    fold_right (fun f bl => remove_backlink bl (Heap.InstanceField obj f) pivot) st@bl (PivotTargets p pivot)\n  | _ => st@bl\n  end.\n\nDefinition SetBacklinks (p : Program) (pivot : Location) (v : Value) (bl : Backlinks.t) : Backlinks.t :=\nmatch v with\n| Ref obj => \n    fold_right (fun f bl' => set_backlink bl' (Heap.InstanceField obj f) pivot (list2LocSet (DynamicDGs p f pivot))) bl (PivotTargets p pivot)\n| _ => bl\nend.\n\nLemma get_remove_old_f_uncompat:\nforall f p pivot st, \n(forall f_obj f_fsig , f <> Heap.InstanceField f_obj f_fsig) ->\nget_backlinks st@bl f = get_backlinks (RemoveBacklinks p pivot st) f.\nProof.\nintros.\ndestruct f.\n unfold RemoveBacklinks.\n destruct (Heap.get st @h pivot); trivial.\n destruct v; trivial.\n induction (PivotTargets p pivot); trivial.\n simpl.\n unfold remove_backlink at 1.\n destruct Backlinks.get.\n  simpl.\n  unfold get_backlinks.\n  rewrite Backlinks.get_update_old; trivial.\n  intuition.\n  inversion H0; trivial.\n  \n  trivial.\n  \n elim H with o f.\n trivial.\n \n unfold RemoveBacklinks.\n destruct (Heap.get st @h pivot); trivial.\n destruct v; trivial.\n induction (PivotTargets p pivot); trivial.\n simpl.\n unfold remove_backlink at 1.\n destruct Backlinks.get.\n  simpl.\n  unfold get_backlinks.\n  rewrite Backlinks.get_update_old; trivial.\n  intuition.\n  inversion H0; trivial.\n  \n  trivial.\nQed.\n\nLemma get_set_old_f_uncompat:\nforall f p pivot bl v, \n(forall f_obj f_fsig , f <> Heap.InstanceField f_obj f_fsig) ->\nget_backlinks bl f = get_backlinks (SetBacklinks p pivot v bl) f.\nProof.\nintros.\ndestruct f.\n unfold SetBacklinks.\n destruct v; trivial.\n induction (PivotTargets p pivot); trivial.\n simpl.\n unfold set_backlink at 1.\n destruct Backlinks.get.\n  simpl.\n  unfold get_backlinks.\n  rewrite Backlinks.get_update_old; trivial.\n  intuition.\n  inversion H0; trivial.\n  \n  unfold get_backlinks.\n  rewrite Backlinks.get_update_old; trivial.\n  intuition.\n  inversion H0; trivial.\n  \n elim H with o f.\n trivial.\n \n unfold SetBacklinks.\n destruct v; trivial.\n induction (PivotTargets p pivot); trivial.\n simpl.\n unfold set_backlink at 1.\n destruct Backlinks.get.\n  simpl.\n  unfold get_backlinks.\n  rewrite Backlinks.get_update_old; trivial.\n  intuition.\n  inversion H0; trivial.\n  \n  unfold get_backlinks.\n  rewrite Backlinks.get_update_old; trivial.\n  intuition.\n  inversion H0; trivial.\n Qed.\n\n\nLemma get_remove_old:\nforall p loc pivot st x f,\npivot <> loc ->\n(LocDict.get (get_backlinks st@bl f) pivot = Some x <->\nLocDict.get (get_backlinks  (RemoveBacklinks p loc st) f) pivot = Some x).\nProof.\nsplit;intros.\nunfold RemoveBacklinks.\ncase_eq (Heap.get st @h loc); intros; trivial.\ndestruct v; trivial.\ninduction (PivotTargets p loc).\n simpl; trivial.\n \n simpl.\n unfold remove_backlink at 1.\n case_eq\n  (Backlinks.get\n     (fold_right\n        (fun (f0 : FieldSignature) (bl : Backlinks.t) =>\n         remove_backlink bl (Heap.InstanceField o f0) loc) \n        st @bl l) (Heap.InstanceField o a)); intros.\n  simpl.\n  unfold get_backlinks.\n  case_eq (eq_dec (Heap.InstanceField o a) f); intros.\n   rewrite <- e.\n   rewrite Backlinks.get_update_same.\n   unfold get_backlinks in IHl.\n   rewrite e in H2.\n   rewrite H2 in IHl.\n   rewrite LocDict.get_remove_old; auto.\n   \n   rewrite Backlinks.get_update_old; trivial.\n   \n  case_eq (eq_dec (Heap.InstanceField o a) f); intros.\n   rewrite e in H2.\n   unfold get_backlinks in IHl.\n   rewrite H2 in IHl.\n   rewrite LocDict.get_empty in IHl.\n   inversion IHl.\n   \n   trivial.\n\nunfold RemoveBacklinks in H0.\ncase_eq (Heap.get st @h loc); intros; trivial.\nrewrite H1 in H0.\ndestruct v; trivial.\ninduction (PivotTargets p loc).\n simpl; trivial.\n \n simpl in H0.\n unfold remove_backlink at 1 in H0.\n case_eq\n  (Backlinks.get\n     (fold_right\n        (fun (f0 : FieldSignature) (bl : Backlinks.t) =>\n         remove_backlink bl (Heap.InstanceField o f0) loc) \n        st @bl l) (Heap.InstanceField o a)); intros.\n  rewrite H2 in H0.\n  simpl in * |- *.\n  unfold get_backlinks in H0.\n  case_eq (eq_dec (Heap.InstanceField o a) f); intros.\n   rewrite <- e in H0.\n   rewrite Backlinks.get_update_same in H0.\n   unfold get_backlinks in IHl.\n   rewrite e in H2.\n   rewrite H2 in IHl.\n   rewrite LocDict.get_remove_old in H0; auto.\n   \n   rewrite Backlinks.get_update_old in H0; trivial.\n   \n   apply IHl.\n   trivial.\n   apply IHl.\n   rewrite H2 in H0.\n   trivial.\n   rewrite H1 in H0.\n   trivial.\nQed.\n\nLemma get_set_old:\nforall p loc pivot bl x f v,\npivot <> loc ->\n(LocDict.get (get_backlinks bl f) pivot = Some x <->\nLocDict.get (get_backlinks  (SetBacklinks p loc v bl) f)\n  pivot = Some x).\nProof.\nsplit; intros.\n unfold SetBacklinks.\n destruct v; trivial.\n induction (PivotTargets p loc).\n  simpl; trivial.\n  \n  simpl.\n  unfold set_backlink at 1.\n  case_eq\n   (Backlinks.get\n      (fold_right\n         (fun (f0 : FieldSignature) (bl' : Backlinks.t) =>\n          set_backlink bl' (Heap.InstanceField o f0) loc\n            (list2LocSet (DynamicDGs p f0 loc))) bl l) \n      (Heap.InstanceField o a)); intros.\n   simpl.\n   unfold get_backlinks.\n   case_eq (eq_dec (Heap.InstanceField o a) f); intros.\n    rewrite <- e.\n    rewrite Backlinks.get_update_same.\n    unfold get_backlinks in IHl.\n    rewrite e in H1.\n    rewrite H1 in IHl.\n    rewrite LocDict.get_update_old; auto.\n    \n    rewrite Backlinks.get_update_old; trivial.\n    \n   case_eq (eq_dec (Heap.InstanceField o a) f); intros.\n    rewrite e in H1.\n    unfold get_backlinks in IHl.\n    rewrite H1 in IHl.\n    rewrite LocDict.get_empty in IHl.\n    inversion IHl.\n    \n    unfold LocDict.singleton.\n    unfold get_backlinks.\n    rewrite Backlinks.get_update_old; trivial.\n    \n unfold SetBacklinks in H0.\n destruct v; trivial.\n induction (PivotTargets p loc).\n  simpl; trivial.\n  \n  simpl in H0.\n  unfold set_backlink at 1 in H0.\n  case_eq\n   (Backlinks.get\n      (fold_right\n         (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n          set_backlink bl' (Heap.InstanceField o f) loc\n            (list2LocSet (DynamicDGs p f loc))) bl l) \n      (Heap.InstanceField o a)); intros.\n   rewrite H1 in H0.\n   simpl in H0.\n   unfold get_backlinks in H0.\n   case_eq (eq_dec (Heap.InstanceField o a) f); intros.\n    rewrite <- e in H0.\n    rewrite Backlinks.get_update_same in H0.\n    unfold get_backlinks in IHl.\n    rewrite e in H1.\n    rewrite H1 in IHl.\n    rewrite LocDict.get_update_old in H0; auto.\n    \n    rewrite Backlinks.get_update_old in H0; trivial.\n    apply IHl.\n    trivial.\n    \n   rewrite H1 in H0.\n   unfold get_backlinks in H0.\n   case_eq (eq_dec (Heap.InstanceField o a) f); intros.\n    rewrite e in H0.\n    rewrite Backlinks.get_update_same in H0.\n    unfold LocDict.singleton in H0.\n    rewrite LocDict.get_update_old in H0.\n     rewrite LocDict.get_empty in H0.\n     inversion H0.\n     \n     auto.\n     \n    rewrite Backlinks.get_update_old in H0.\n     apply IHl.\n     trivial.\n     \n     trivial.\nQed.\n\nLemma get_remove_none:\nforall p st obj f pivot dg,\nCorrectBacklink p st (Heap.InstanceField obj f) dg pivot ->\nPivotField p pivot ->\n   ~ (exists locs,  LocDict.get\n       (get_backlinks (RemoveBacklinks p pivot st) (Heap.InstanceField obj f))\n       pivot = Some locs /\\ (LocSet.In dg locs)).\nProof.\nunfold CorrectBacklink.\nintros.\nunfold RemoveBacklinks.\ncase_eq (Heap.get st@h pivot);intros.\ndestruct v.\nintro.\nrewrite <- H in H2.\ninversion H2.\nrewrite H6 in H1.\ninversion H1.\nintro.\nrewrite <- H in H2.\ninversion H2.\nrewrite H6 in H1.\ninversion H1.\ncase_eq (ObjDec.eq_dec o obj).\n intros.\n rewrite e.\n rewrite e in H1.\n clear o e H2.\n elim\n  classic\n   with\n     (exists dg,\n      direct_FieldInDg_dynamic p st @h (Heap.InstanceField obj f) dg pivot).\n  intros.\n  generalize H2; intro.\n  rewrite <- PivotTargets_Correct in H3; trivial.\n  induction (PivotTargets p pivot).\n   inversion H3.\n   \n   simpl in H3.\n   destruct H3.\n    clear IHl.\n    rewrite H3.\n    clear a H3.\n    simpl.\n    unfold get_backlinks.\n    unfold remove_backlink at 1.\n    case_eq\n     (Backlinks.get\n        (fold_right\n           (fun (f0 : FieldSignature) (bl : Backlinks.t) =>\n            remove_backlink bl (Heap.InstanceField obj f0) pivot) \n           st @bl l) (Heap.InstanceField obj f)).\n     intros.\n     simpl.\n     rewrite Backlinks.get_update_same.\n     rewrite LocDict.get_remove_none.\n     intro.\n     destruct H4.\n     destruct H4.\n     inversion H4.\n     \n     intros.\n     rewrite H3.\n     intro.\n     rewrite LocDict.get_empty in H4.\n     destruct H4.\n     destruct H4.\n     inversion H4.\n     \n    simpl.\n    case_eq (FsigDec.eq_dec a f).\n     intros.\n     rewrite e.\n     unfold get_backlinks.\n     unfold remove_backlink at 1.\n     case_eq\n      (Backlinks.get\n         (fold_right\n            (fun (f0 : FieldSignature) (bl : Backlinks.t) =>\n             remove_backlink bl (Heap.InstanceField obj f0) pivot) \n            st @bl l) (Heap.InstanceField obj f)).\n      simpl.\n      intros.\n      rewrite Backlinks.get_update_same.\n      rewrite LocDict.get_remove_none.\n      intro.\n      destruct H6.\n      destruct H6.\n      inversion H6.\n      \n      intro.\n      rewrite H5.\n      intro.\n      rewrite LocDict.get_empty in H6.\n      destruct H6.\n      destruct H6.\n      inversion H6.\n      \n     intros.\n     unfold get_backlinks.\n     unfold remove_backlink at 1.\n     case_eq\n      (Backlinks.get\n         (fold_right\n            (fun (f0 : FieldSignature) (bl : Backlinks.t) =>\n             remove_backlink bl (Heap.InstanceField obj f0) pivot) \n            st @bl l) (Heap.InstanceField obj a)).\n      intros.\n      simpl.\n      rewrite Backlinks.get_update_old.\n       apply IHl.\n       trivial.\n       \n       intro.\n       elim n.\n       inversion H6; trivial.\n       \n      intro.\n      apply IHl.\n      trivial.\n      \n  intros.\n  intro.\n  elim H2.\n  exists dg.\n  apply H.\n  rewrite <- PivotTargets_Correct in H2.\n   induction (PivotTargets p pivot).\n    simpl.\n    intros.\n    destruct H3 as [ams H3].\n    exists ams.\n    trivial.\n    \n    intros.\n    simpl in H3.\n    unfold remove_backlink at 1 in H3.\n    case_eq\n     (Backlinks.get\n        (fold_right\n           (fun (f : FieldSignature) (bl : Backlinks.t) =>\n            remove_backlink bl (Heap.InstanceField obj f) pivot) \n           st @bl l) (Heap.InstanceField obj a)); intros; \n     rewrite H4 in H3.\n     simpl in H3.\n     simpl in H2.\n     assert (a <> f).\n      intro.\n      elim H2.\n      left; trivial.\n      \n      unfold get_backlinks in H3.\n      rewrite Backlinks.get_update_old in H3.\n       apply IHl.\n        intro.\n        elim H2.\n        right.\n        trivial.\n        \n        trivial.\n        \n       intro.\n       elim H5.\n       inversion H6.\n       trivial.\n       \n     apply IHl.\n      intro.\n      elim H2.\n      right; trivial.\n      \n      trivial.\n      \n   trivial.\n   \n intros.\n assert (~ direct_FieldInDg_dynamic p st @h (Heap.InstanceField obj f) dg pivot).\n  intro.\n  inversion H3.\n  inversion H5.\n  rewrite H7 in H1.\n  inversion H1.\n  rewrite <- H18 in H20.\n  elim n.\n  symmetry.\n  trivial.\n  \n  rewrite H in H3.\n  intro.\n  elim H3.\n  induction (PivotTargets p pivot).\n   simpl in H4.\n   trivial.\n   \n   apply IHl.\n   clear IHl.\n   simpl in H4.\n   unfold remove_backlink at 1 in H4.\n   case_eq\n    (Backlinks.get\n       (fold_right\n          (fun (f : FieldSignature) (bl : Backlinks.t) =>\n           remove_backlink bl (Heap.InstanceField o f) pivot) \n          st @bl l) (Heap.InstanceField o a)); intros; \n    rewrite H5 in H4.\n    simpl.\n    unfold get_backlinks in H4.\n    rewrite Backlinks.get_update_old in H4.\n     trivial.\n     \n     intro.\n     elim n.\n     inversion H6; trivial.\n     \n    trivial.\n    intro.\nrewrite <- H in H2.\ninversion H2.\nrewrite H6 in H1.\ninversion H1.\nintro.\nrewrite <- H in H2.\ninversion H2.\nrewrite H6 in H1.\ninversion H1.\nQed.\n\n\nLemma SetRemoveBacklinks_Correct:\nforall p loc st st' f dg pivot v cn um loc_obj loc_fsig,\nPivotField p loc ->\nloc = Heap.InstanceField loc_obj loc_fsig ->\nHeap.typeof st@h loc_obj = Some (Heap.ObjectObject cn um) ->\ndefined_field p cn loc_fsig ->\nassign_compatible p st@h v (FIELDSIGNATURE.type (snd loc_fsig)) ->\nst' = st[h := (Heap.update st@h loc v)]\n              [bl := (SetBacklinks p loc v (RemoveBacklinks p loc st))] ->\nCorrectBacklink p st f dg pivot ->\nCorrectBacklink p st' f dg pivot.\nProof.\nunfold CorrectBacklink.\nintros.\nrewrite H4.\nsimpl.\nclear H4.\nrename H5 into H4.\nsplit; intros.\n inversion H5.\n case_eq (LocSet.E.eq_dec pivot_loc loc); intros.\n  intros.\n  rewrite e in H18.\n  rewrite H18 in H5.\n  rewrite H18 in H9.\n  set (h' := Heap.update (State.h st) pivot v).\n  assert (Heap.Compat (State.h st) pivot).\n   rewrite H18 in H0.\n   rewrite H0.\n   apply Heap.CompatObject with cn um; trivial.\n   \n   generalize H9; intros.\n   rewrite Heap.get_update_same in H21; trivial.\n   inversion H21.\n   fold h' in H5.\n   fold h' in H9.\n   rewrite H18.\n   exists (list2LocSet (DynamicDGs p field_fsig pivot)).\n   generalize H9; intro.\n   apply PivotTargets_Correct with (p := p) (f_fsig := field_fsig) in H9.\n   destruct H9.\n   rewrite <- H7 in H24.\n   assert (ex (fun dg => direct_FieldInDg_dynamic p h' f dg pivot)).\n    exists dg; trivial.\n    unfold SetBacklinks.\n    apply H24 in H25.\n    clear H9 H24.\n    rewrite H7.\n    induction (PivotTargets p pivot).\n     inversion H25.\n     \n     split.\n      case_eq (FsigDec.eq_dec a field_fsig); intros.\n       simpl in H25.\n       destruct H25.\n        clear IHl.\n        rewrite H24.\n        simpl.\n        unfold set_backlink at 1.\n        simpl.\n        destruct Backlinks.get.\n         unfold get_backlinks.\n         rewrite Backlinks.get_update_same.\n         rewrite LocDict.get_update_same.\n         trivial.\n         \n         unfold get_backlinks.\n         rewrite Backlinks.get_update_same.\n         unfold LocDict.singleton.\n         rewrite LocDict.get_update_same.\n         trivial.\n         \n        rewrite e0.\n        simpl.\n        unfold set_backlink at 1.\n        simpl.\n        destruct Backlinks.get.\n         unfold get_backlinks.\n         rewrite Backlinks.get_update_same.\n         rewrite LocDict.get_update_same.\n         trivial.\n         \n         unfold get_backlinks.\n         rewrite Backlinks.get_update_same.\n         unfold LocDict.singleton.\n         rewrite LocDict.get_update_same.\n         trivial.\n         \n       simpl in H25.\n       destruct H25.\n        elim n; trivial.\n        \n        simpl.\n        unfold set_backlink at 1.\n        destruct Backlinks.get.\n         unfold get_backlinks.\n         rewrite Backlinks.get_update_old.\n          apply IHl.\n          trivial.\n          \n          intro.\n          inversion H25.\n          elim n; trivial.\n          \n         unfold get_backlinks.\n         rewrite Backlinks.get_update_old.\n          apply IHl.\n          trivial.\n          \n          intro.\n          inversion H25.\n          elim n; trivial.\n          \n      apply list2LocSet_1.\n      rewrite DynamicDGs_Correct with (h := h') (f_obj := field_obj); trivial.\n      rewrite <- H7; trivial.\n      \n  rewrite Heap.get_update_old in H9.\n   destruct H4.\n   elim H4.\n    intros.\n    exists x.\n    split; trivial.\n     clear H4 H20.\n     destruct H21.\n     apply get_remove_old with (p := p) (loc := loc) in H4.\n      apply get_set_old with (p := p) (loc := loc) (v := v) in H4; trivial.\n      rewrite <- H18; trivial.\n      \n      rewrite <- H18; trivial.\n      \n     tauto.\n     \n    split\n     with\n       dg_obj\n       dg_fsig\n       field_obj\n       field_fsig\n       pivot_obj\n       pivot_fsig\n       pivot_f\n       dg0; trivial.\n    \n   rewrite <- H18; auto.\n   \n case_eq (LocSet.E.eq_dec pivot loc); intros.\n  rewrite <- e in H5.\n  rewrite <- e.\n  rewrite <- e in H0.\n  rewrite <- e in H.\n  clear loc e H6.\n  destruct f.\n   rewrite <- get_set_old_f_uncompat in H5.\n    rewrite <- get_remove_old_f_uncompat in H5.\n     apply H4 in H5.\n     inversion H5.\n     inversion H7.\n     \n     intros; intro; inversion H6.\n     \n    intros; intro; inversion H6.\n   unfold SetBacklinks in H5.\n   inversion H3.\n    rewrite <- H6 in H5.\n    elim get_remove_none with p st o f pivot dg; trivial.\n    \n    rewrite <- H8 in H5.\n    case_eq (ObjDec.eq_dec o obj).\n     intros.\n     rewrite e.\n     rewrite e in H5.\n     repeat rewrite e in H4.\n     clear o e H10.\n     elim classic with (In f (PivotTargets p pivot)).\n      intros.\n      induction (PivotTargets p pivot).\n       inversion H10.\n       \n       simpl in H10.\n       destruct H10.\n        clear IHl.\n        rewrite H10 in H5.\n        simpl in H5.\n        unfold set_backlink at 1 in H5.\n        case_eq\n         (Backlinks.get\n            (fold_right\n               (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n                set_backlink bl' (Heap.InstanceField obj f) pivot\n                  (list2LocSet (DynamicDGs p f pivot)))\n               (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj f));\n         intros; rewrite H11 in H5.\n         simpl.\n         unfold get_backlinks in H5.\n         rewrite Backlinks.get_update_same in H5.\n         rewrite LocDict.get_update_same in H5.\n         destruct H5.\n         destruct H5.\n         inversion H5.\n         rewrite <- H14 in H12.\n         apply list2LocSet_1 in H12.\n         rewrite\n          DynamicDGs_Correct\n           with\n             (h := Heap.update (State.h st) pivot (Ref obj))\n             (f_obj := obj) in H12.\n          trivial.\n          \n          apply Heap.get_update_same.\n          rewrite H0.\n          apply Heap.CompatObject with cn um; trivial.\n          \n         unfold LocDict.singleton in H5.\n         unfold get_backlinks in H5.\n         rewrite Backlinks.get_update_same in H5.\n         rewrite LocDict.get_update_same in H5.\n         destruct H5.\n         destruct H5.\n         inversion H5.\n         rewrite <- H14 in H12.\n         apply list2LocSet_1 in H12.\n         rewrite\n          DynamicDGs_Correct\n           with\n             (h := Heap.update (State.h st) pivot (Ref obj))\n             (f_obj := obj) in H12.\n          trivial.\n          \n          apply Heap.get_update_same.\n          rewrite H0.\n          apply Heap.CompatObject with cn um; trivial.\n          \n        case_eq (FsigDec.eq_dec a f).\n         intros.\n         rewrite e in H5.\n         clear IHl.\n         clear a e H11.\n         simpl in H5.\n         unfold set_backlink at 1 in H5.\n         case_eq\n          (Backlinks.get\n             (fold_right\n                (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n                 set_backlink bl' (Heap.InstanceField obj f) pivot\n                   (list2LocSet (DynamicDGs p f pivot)))\n                (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj f));\n          intros; rewrite H11 in H5.\n          unfold get_backlinks in H5.\n          rewrite Backlinks.get_update_same in H5.\n          rewrite LocDict.get_update_same in H5.\n          destruct H5.\n          destruct H5.\n          inversion H5.\n          rewrite <- H14 in H12.\n          apply list2LocSet_1 in H12.\n          rewrite\n           DynamicDGs_Correct\n            with\n              (h := Heap.update (State.h st) pivot (Ref obj))\n              (f_obj := obj) in H12.\n           trivial.\n           \n           apply Heap.get_update_same.\n           rewrite H0.\n           apply Heap.CompatObject with cn um; trivial.\n           \n          unfold LocDict.singleton in H5.\n          unfold get_backlinks in H5.\n          rewrite Backlinks.get_update_same in H5.\n          rewrite LocDict.get_update_same in H5.\n          destruct H5.\n          destruct H5.\n          inversion H5.\n          rewrite <- H14 in H12.\n          apply list2LocSet_1 in H12.\n          rewrite\n           DynamicDGs_Correct\n            with\n              (h := Heap.update (State.h st) pivot (Ref obj))\n              (f_obj := obj) in H12.\n           trivial.\n           \n           apply Heap.get_update_same.\n           rewrite H0.\n           apply Heap.CompatObject with cn um; trivial.\n           \n         intros.\n         simpl in H5.\n         unfold set_backlink at 1 in H5.\n         case_eq\n          (Backlinks.get\n             (fold_right\n                (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n                 set_backlink bl' (Heap.InstanceField obj f) pivot\n                   (list2LocSet (DynamicDGs p f pivot)))\n                (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj a));\n          intros; rewrite H12 in H5.\n          unfold get_backlinks in H5.\n          rewrite Backlinks.get_update_old in H5.\n           apply IHl; trivial.\n           \n           intro.\n           inversion H13.\n           elim n; trivial.\n           \n          unfold LocDict.singleton in H5.\n          unfold get_backlinks in H5.\n          rewrite Backlinks.get_update_old in H5.\n           apply IHl; trivial.\n           \n           intro.\n           inversion H13.\n           elim n; trivial.\n           \n      intros.\n      induction (PivotTargets p pivot).\n       simpl in H5.\n       intros.\n       elim get_remove_none with p st obj f pivot dg; trivial.\n       \n       simpl in H5.\n       unfold set_backlink at 1 in H5.\n       case_eq\n        (Backlinks.get\n           (fold_right\n              (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n               set_backlink bl' (Heap.InstanceField obj f) pivot\n                 (list2LocSet (DynamicDGs p f pivot)))\n              (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj a));\n        intros; rewrite H11 in H5.\n        simpl in H5.\n        unfold get_backlinks in H5.\n        rewrite Backlinks.get_update_old in H5.\n         apply IHl; trivial.\n         intro; elim H10; auto with *.\n         \n         intro; elim H10.\n         inversion H12.\n         auto with *.\n         \n        unfold get_backlinks in H5.\n        rewrite Backlinks.get_update_old in H5.\n         apply IHl; trivial.\n         intro; elim H10; auto with *.\n         \n         intro; elim H10.\n         inversion H12.\n         auto with *.\n         \n     intros.\n     induction (PivotTargets p pivot).\n      simpl in H5.\n      elim get_remove_none with p st o f pivot dg; trivial.\n      \n      simpl in H5.\n      unfold set_backlink at 1 in H5.\n      case_eq\n       (Backlinks.get\n          (fold_right\n             (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n              set_backlink bl' (Heap.InstanceField obj f) pivot\n                (list2LocSet (DynamicDGs p f pivot)))\n             (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj a));\n       intros; rewrite H11 in H5.\n       simpl in H5.\n       unfold get_backlinks in H5.\n       rewrite Backlinks.get_update_old in H5.\n        apply IHl; trivial.\n        \n        intro; elim n.\n        inversion H12; trivial.\n        \n       unfold get_backlinks in H5.\n       rewrite Backlinks.get_update_old in H5.\n        apply IHl; trivial.\n        \n        intro; elim n.\n        inversion H12; trivial.\n        \n    rewrite <- H8 in H5.\n    case_eq (ObjDec.eq_dec o obj).\n     intros.\n     rewrite e.\n     rewrite e in H5.\n     repeat rewrite e in H4.\n     clear o e H10.\n     elim classic with (In f (PivotTargets p pivot)).\n      intros.\n      induction (PivotTargets p pivot).\n       inversion H10.\n       \n       simpl in H10.\n       destruct H10.\n        clear IHl.\n        rewrite H10 in H5.\n        simpl in H5.\n        unfold set_backlink at 1 in H5.\n        case_eq\n         (Backlinks.get\n            (fold_right\n               (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n                set_backlink bl' (Heap.InstanceField obj f) pivot\n                  (list2LocSet (DynamicDGs p f pivot)))\n               (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj f));\n         intros; rewrite H11 in H5.\n         simpl.\n         unfold get_backlinks in H5.\n         rewrite Backlinks.get_update_same in H5.\n         rewrite LocDict.get_update_same in H5.\n         destruct H5.\n         destruct H5.\n         inversion H5.\n         rewrite <- H14 in H12.\n         apply list2LocSet_1 in H12.\n         rewrite\n          DynamicDGs_Correct\n           with\n             (h := Heap.update (State.h st) pivot (Ref obj))\n             (f_obj := obj) in H12.\n          trivial.\n          \n          apply Heap.get_update_same.\n          rewrite H0.\n          apply Heap.CompatObject with cn um; trivial.\n          \n         unfold LocDict.singleton in H5.\n         unfold get_backlinks in H5.\n         rewrite Backlinks.get_update_same in H5.\n         rewrite LocDict.get_update_same in H5.\n         destruct H5.\n         destruct H5.\n         inversion H5.\n         rewrite <- H14 in H12.\n         apply list2LocSet_1 in H12.\n         rewrite\n          DynamicDGs_Correct\n           with\n             (h := Heap.update (State.h st) pivot (Ref obj))\n             (f_obj := obj) in H12.\n          trivial.\n          \n          apply Heap.get_update_same.\n          rewrite H0.\n          apply Heap.CompatObject with cn um; trivial.\n          \n        case_eq (FsigDec.eq_dec a f).\n         intros.\n         rewrite e in H5.\n         clear IHl.\n         clear a e H11.\n         simpl in H5.\n         unfold set_backlink at 1 in H5.\n         case_eq\n          (Backlinks.get\n             (fold_right\n                (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n                 set_backlink bl' (Heap.InstanceField obj f) pivot\n                   (list2LocSet (DynamicDGs p f pivot)))\n                (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj f));\n          intros; rewrite H11 in H5.\n          unfold get_backlinks in H5.\n          rewrite Backlinks.get_update_same in H5.\n          rewrite LocDict.get_update_same in H5.\n          destruct H5.\n          destruct H5.\n          inversion H5.\n          rewrite <- H14 in H12.\n          apply list2LocSet_1 in H12.\n          rewrite\n           DynamicDGs_Correct\n            with\n              (h := Heap.update (State.h st) pivot (Ref obj))\n              (f_obj := obj) in H12.\n           trivial.\n           \n           apply Heap.get_update_same.\n           rewrite H0.\n           apply Heap.CompatObject with cn um; trivial.\n           \n          unfold LocDict.singleton in H5.\n          unfold get_backlinks in H5.\n          rewrite Backlinks.get_update_same in H5.\n          rewrite LocDict.get_update_same in H5.\n          destruct H5.\n          destruct H5.\n          inversion H5.\n          rewrite <- H14 in H12.\n          apply list2LocSet_1 in H12.\n          rewrite\n           DynamicDGs_Correct\n            with\n              (h := Heap.update (State.h st) pivot (Ref obj))\n              (f_obj := obj) in H12.\n           trivial.\n           \n           apply Heap.get_update_same.\n           rewrite H0.\n           apply Heap.CompatObject with cn um; trivial.\n           \n         intros.\n         simpl in H5.\n         unfold set_backlink at 1 in H5.\n         case_eq\n          (Backlinks.get\n             (fold_right\n                (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n                 set_backlink bl' (Heap.InstanceField obj f) pivot\n                   (list2LocSet (DynamicDGs p f pivot)))\n                (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj a));\n          intros; rewrite H12 in H5.\n          unfold get_backlinks in H5.\n          rewrite Backlinks.get_update_old in H5.\n           apply IHl; trivial.\n           \n           intro.\n           inversion H13.\n           elim n; trivial.\n           \n          unfold LocDict.singleton in H5.\n          unfold get_backlinks in H5.\n          rewrite Backlinks.get_update_old in H5.\n           apply IHl; trivial.\n           \n           intro.\n           inversion H13.\n           elim n; trivial.\n           \n      intros.\n      induction (PivotTargets p pivot).\n       simpl in H5.\n       intros.\n       elim get_remove_none with p st obj f pivot dg; trivial.\n       \n       simpl in H5.\n       unfold set_backlink at 1 in H5.\n       case_eq\n        (Backlinks.get\n           (fold_right\n              (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n               set_backlink bl' (Heap.InstanceField obj f) pivot\n                 (list2LocSet (DynamicDGs p f pivot)))\n              (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj a));\n        intros; rewrite H11 in H5.\n        simpl in H5.\n        unfold get_backlinks in H5.\n        rewrite Backlinks.get_update_old in H5.\n         apply IHl; trivial.\n         intro; elim H10; auto with *.\n         \n         intro; elim H10.\n         inversion H12.\n         auto with *.\n         \n        unfold get_backlinks in H5.\n        rewrite Backlinks.get_update_old in H5.\n         apply IHl; trivial.\n         intro; elim H10; auto with *.\n         \n         intro; elim H10.\n         inversion H12.\n         auto with *.\n         \n     intros.\n     induction (PivotTargets p pivot).\n      simpl in H5.\n      elim get_remove_none with p st o f pivot dg; trivial.\n      \n      simpl in H5.\n      unfold set_backlink at 1 in H5.\n      case_eq\n       (Backlinks.get\n          (fold_right\n             (fun (f : FieldSignature) (bl' : Backlinks.t) =>\n              set_backlink bl' (Heap.InstanceField obj f) pivot\n                (list2LocSet (DynamicDGs p f pivot)))\n             (RemoveBacklinks p pivot st) l) (Heap.InstanceField obj a));\n       intros; rewrite H11 in H5.\n       simpl in H5.\n       unfold get_backlinks in H5.\n       rewrite Backlinks.get_update_old in H5.\n        apply IHl; trivial.\n        \n        intro; elim n.\n        inversion H12; trivial.\n        \n       unfold get_backlinks in H5.\n       rewrite Backlinks.get_update_old in H5.\n        apply IHl; trivial.\n        \n        intro; elim n.\n        inversion H12; trivial.\n        \n    rewrite <- H7 in H5.\n    elim get_remove_none with p st o f pivot dg; trivial.\n    \n   rewrite <- get_set_old_f_uncompat in H5.\n    rewrite <- get_remove_old_f_uncompat in H5.\n     apply H4 in H5.\n     inversion H5.\n     inversion H7.\n     \n     intros; intro; inversion H6.\n     \n    intros; intro; inversion H6.\n    \n  destruct H5.\n  destruct H5.\n  apply get_set_old in H5.\n   apply get_remove_old in H5.\n    destruct H4.\n    assert\n     (ex\n        (fun ams  =>\n         and\n           (eq\n              (LocDict.get (get_backlinks (Adds.backlinks (State.adds st)) f)\n                 pivot) (Some ams)) (LocSet.In dg ams))).\n     exists x; auto.\n     \n     apply H8 in H9.\n     inversion H9.\n     split\n      with\n        dg_obj\n        dg_fsig\n        field_obj\n        field_fsig\n        pivot_obj\n        pivot_fsig\n        pivot_f\n        dg0; trivial.\n     rewrite Heap.get_update_old.\n      trivial.\n      \n      auto.\n      \n    trivial.\n    \n   trivial.\nQed.\n\n\nDefinition FieldUpdateAction (p : Program) (pivot : Location) (v : Value) (st : State.t) : State.t :=\n    if (isPivot p pivot) then\n       let bl1 := RemoveBacklinks p pivot st in\n       let bl' := SetBacklinks p pivot v bl1 in\n        st[fr := st@fr[assignables := map (SavePreState p st@bl pivot) st@fr@assignables]][bl := bl']\n    else\n      st.\n\n\nLemma not_isPivot_direct_FieldInDg:\nforall p h f dg pivot loc v,\nisPivot p loc = false ->\n(direct_FieldInDg_dynamic p h f dg pivot <->\ndirect_FieldInDg_dynamic p (Heap.update h loc v) f dg pivot).\nProof.\nintros.\napply not_true_iff_false in H.\nrewrite isPivot_PivotField in H.\nsplit; intro.\n destruct H0.\n split\n  with dg_obj dg_fsig field_obj field_fsig pivot_obj pivot_fsig pivot_f dg;\n  trivial.\n case_eq (eq_dec loc pivot_loc); intros.\n  rewrite e in H.\n  elim H.\n  split with pivot_fsig pivot_obj pivot_f dg; trivial.\n  \n  rewrite Heap.get_update_old; trivial.\n  \n destruct H0.\n split\n  with dg_obj dg_fsig field_obj field_fsig pivot_obj pivot_fsig pivot_f dg;\n  trivial.\n case_eq (eq_dec loc pivot_loc); intros.\n  rewrite e in H.\n  elim H.\n  split with pivot_fsig pivot_obj pivot_f dg; trivial.\n  \n  rewrite Heap.get_update_old in H3; trivial.\nQed.\n\n  Lemma FieldUpdateAction_Correct:\n    forall p loc st_rac2 v st_rac2' st_rac3 st_rac3' cn um loc_obj loc_fsig,\n    loc = Heap.InstanceField loc_obj loc_fsig ->\n    Heap.typeof st_rac3@h loc_obj = Some (Heap.ObjectObject cn um) ->\n    defined_field p cn loc_fsig ->\n    assign_compatible p st_rac3@h v (FIELDSIGNATURE.type (snd loc_fsig)) ->\n    CorrespondingState p st_rac2 st_rac3 ->\n    FieldUpdateAction p loc v st_rac3 = st_rac3' ->\n    Rac2.Assignables.FieldUpdateAction p loc v st_rac2 = st_rac2' ->\n    CorrespondingState p \n      st_rac2'[h:=Heap.update st_rac2@h loc v]%rac2\n      st_rac3'[h:=Heap.update st_rac3@h loc v].\nProof.\nintuition.\nunfold FieldUpdateAction in H4.\nunfold Rac2.Assignables.FieldUpdateAction in H5.\ncase_eq (isPivot p loc); intros; rewrite H6 in H5;rewrite H6 in H4.\n inversion H3.\n subst.\n split; simpl.\n\n  inversion H7.\n  subst.\n  split; simpl; trivial.\n  destruct H14.\n  split.\n   repeat rewrite map_length.\n   trivial.\n   \n   intros.\n   case_eq (Nat.compare n (length st_rac3 @fr @assignables )).\n    intros.\n    rewrite nat_compare_Eq in H14.\n    repeat rewrite nth_overflow.\n     auto with *.\n     \n     rewrite map_length.\n     lia.\n     \n     rewrite map_length.\n     lia.\n     \n    intros.\n    apply nat_compare_lt in H14.\n    generalize H14; intros.\n    rewrite <- e in H15.\n    repeat\n     rewrite\n      (nth_indep\n         (map (Rac2.SavePreState p st_rac2 @h%rac2 (Heap.InstanceField loc_obj loc_fsig))\n            st_rac2 @fr%rac2 @assignables) a0\n         (Rac2.SavePreState p st_rac2 @h%rac2 (Heap.InstanceField loc_obj loc_fsig) a0)).\n     repeat\n      rewrite\n       (nth_indep\n          (map (SavePreState p st_rac3 @bl (Heap.InstanceField loc_obj loc_fsig)) st_rac3 @fr @assignables) a0\n          (SavePreState p st_rac3 @bl (Heap.InstanceField loc_obj loc_fsig) a0)).\n      rewrite map_nth.\n      rewrite map_nth.\n      destruct a with n a0.\n      repeat rewrite H8.\n\n      apply SavePreState_same; trivial.\n      \n      rewrite map_length; trivial.\n      \n     rewrite map_length; trivial.\n     \n    intros.\n    rewrite <- nat_compare_gt in H14.\n    repeat rewrite nth_overflow.\n     auto with *.\n     \n     rewrite map_length.\n     lia.\n     \n     rewrite map_length.\n     lia.\n     \n  rewrite H8.\n  trivial.\n  \n  unfold CorrectBacklinks in H9 |- *.\n  unfold CorrectBacklink in H9 |- *.\n  intros.\n  simpl.\n  set (st' := st_rac3[h :=(Heap.update st_rac3 @h (Heap.InstanceField loc_obj loc_fsig) v)]\n[bl := (SetBacklinks p (Heap.InstanceField loc_obj loc_fsig) v\n           (RemoveBacklinks p (Heap.InstanceField loc_obj loc_fsig) st_rac3))]).\n  replace (Heap.update st_rac3 @h (Heap.InstanceField loc_obj loc_fsig) v) with st'@h.\n  replace ((SetBacklinks p (Heap.InstanceField loc_obj loc_fsig) v\n           (RemoveBacklinks p (Heap.InstanceField loc_obj loc_fsig) st_rac3))) with st'@bl.\n  apply SetRemoveBacklinks_Correct with (Heap.InstanceField loc_obj loc_fsig) st_rac3 v cn um loc_obj loc_fsig ;trivial.\n  apply isPivot_PivotField;trivial.\n  unfold CorrectBacklink.\n  trivial.\ntrivial.\ntrivial.\n split; simpl.\n  destruct H.\n  subst; trivial.\n  \n  destruct H3.\n  trivial.\n\n  destruct H3.\n  rewrite H7.\n  trivial.\n  \n  destruct H3.\n  destruct H3.\n  unfold CorrectBacklinks in H8 |- *.\n  unfold CorrectBacklink in H8 |- *.\n  simpl.\n  rewrite <- H4.\n  intros.\n  rewrite <- not_isPivot_direct_FieldInDg.\n   trivial.\n   \n   trivial.\nQed.\n\nLemma CorrectBacklinks_new:\nforall st p cn um obj h' ,\nHeap.new st@h p (Heap.ObjectObject cn um) = Some (obj, h') ->\n(CorrectBacklinks p st <-> CorrectBacklinks p st [h := h']).\nProof.\nintuition.\n intros.\n unfold CorrectBacklinks.\n unfold CorrectBacklink.\n intros.\n destruct H0 with f dg pivot.\n simpl in *.\n intuition.\n  apply H1.\n  clear H1 H2.\n  inversion H3.\n  split\n   with dg_obj dg_fsig field_obj field_fsig pivot_obj pivot_fsig pivot_f dg0;\n   trivial.\n  assert (pivot_obj <> obj).\n   intro.\n   rewrite H15 in H4.\n   apply\n    Rac2.new_object_field_not_ref\n     with (fsig := pivot_fsig) (loc := pivot) (r := field_obj) \n    in H; trivial.\n   elim H; trivial.\n   \n   rewrite <- H5.\n   symmetry .\n   apply Heap.new_object_no_change with p cn um obj; trivial.\n   intros.\n   rewrite H4.\n   intro.\n   inversion H16.\n   elim H15; trivial.\n   \n  clear H3 H2.\n  inversion H4.\n  split\n   with dg_obj dg_fsig field_obj field_fsig pivot_obj pivot_fsig pivot_f dg0;\n   trivial.\n  assert (pivot_obj <> obj).\n   intro.\n   rewrite H15 in H3.\n   apply Heap.new_fresh_location in H.\n   assert (~Heap.Compat st @h pivot).\n    intro.\n    destruct H16.\n     inversion H3.\n     \n     inversion H3.\n     rewrite H18 in H16.\n     rewrite H in H16.\n     inversion H16.\n     \n     inversion H3.\n     \n    apply Heap.get_uncompat in H16.\n    rewrite H5 in H16.\n    inversion H16.\n    \n   rewrite <- H5.\n   apply Heap.new_object_no_change with p cn um obj; trivial.\n   intros.\n   rewrite H3.\n   intro.\n   inversion H16.\n   elim H15; trivial.\n   \n unfold CorrectBacklinks.\n unfold CorrectBacklink.\n intros.\n destruct H0 with f dg pivot.\n simpl in *.\n intuition.\n  apply H1.\n  clear H1 H2.\n  inversion H3.\n  split\n   with dg_obj dg_fsig field_obj field_fsig pivot_obj pivot_fsig pivot_f dg0;\n   trivial.\n  assert (pivot_obj <> obj).\n   intro.\n   rewrite H15 in H4.\n   apply Heap.new_fresh_location in H.\n   assert (~Heap.Compat st @h pivot).\n    intro.\n    destruct H16.\n     inversion H4.\n     \n     inversion H4.\n     rewrite H18 in H16.\n     rewrite H in H16.\n     inversion H16.\n     \n     inversion H4.\n     \n    apply Heap.get_uncompat in H16.\n    rewrite H5 in H16.\n    inversion H16.\n    \n   rewrite <- H5.\n   apply Heap.new_object_no_change with p cn um obj; trivial.\n   intros.\n   rewrite H4.\n   intro.\n   inversion H16.\n   elim H15; trivial.\n   \n  clear H3 H2.\n  inversion H4.\n  split\n   with dg_obj dg_fsig field_obj field_fsig pivot_obj pivot_fsig pivot_f dg0;\n   trivial.\n  assert (pivot_obj <> obj).\n   intro.\n   rewrite H15 in H3.\n   apply\n    Rac2.new_object_field_not_ref\n     with (fsig := pivot_fsig) (loc := pivot) (r := field_obj) \n    in H; trivial.\n   elim H; trivial.\n   \n   rewrite <- H5.\n   symmetry .\n   apply Heap.new_object_no_change with p cn um obj; trivial.\n   intros.\n   rewrite H3.\n   intro.\n   inversion H16.\n   elim H15; trivial.\nQed.\n\nEnd Assignables.\n\nEnd Rac3.\n",
      "theorem": "Lemma FieldInDg_rac2_EqualSet:\nforall p h ep s1 f dg,\nFieldInDg_rac2 p h ep s1 f dg -> \nforall s2, s1 [=] s2 ->\nFieldInDg_rac2 p h ep s2 f dg.",
      "ground_truth": "Proof.\nintros p h ep s1 f dg H.\ninduction H.\n intros.\n apply FieldInDg_rac2_static with dg'; trivial.\n  intro; elim H0.\n  apply H2.\n  trivial.\n  \n  apply IHFieldInDg_rac2.\n  auto with *.\n  \n intros.\n apply FieldInDg_rac2_dynamic with pivot dg'; trivial.\n  intro; elim H1.\n  apply H3.\n  trivial.\n  \n  apply IHFieldInDg_rac2.\n  auto with *.\n  \n intros.\n apply FieldInDg_rac2_base; trivial.\nQed."
    },
    {
      "split": "train-sft",
      "index": 36,
      "prefix": "(*\n  Consider two binary relations\n    step1 : X -> X -> Prop\n    step2 : Y -> Y -> Prop\n  such that\n  - step2 is deterministic (step2_det)\n  - one step in step1 is simulated by a positive number of steps in step2 (fstep)\n  - halting in step1 is simulated by termination in step2 (fstop)\n  - step1 admits existential successor decision (step1_intro)\n\n  Then, strong normalization in step1 is transported to (terminates_transport)\n  and reflected by (terminates_reflection) strong normalization in step 2.\n*)\n\nRequire Import Relations Transitive_Closure.\n\nSection Preliminaries.\n\n  (* configuration space and step repation *)\n  Context {X : Type} (step : X -> X -> Prop).\n\n  (* halting *)\n  Definition stuck s := forall t, ~ step s t.\n\n  (* eventual termination *)\n  Definition terminates s := exists t, clos_refl_trans X step s t /\\ stuck t.\n\n  Fact terminates_extend {s t} : clos_refl_trans X step s t -> terminates t -> terminates s.\n  Proof.\n    intros ? [u [??]]. exists u. eauto using clos_refl_trans.\n  Qed.\n\n  Lemma clos_trans_clos_refl_trans s t : clos_trans _ step s t -> clos_refl_trans _ step s t.\n  Proof.\n    intros H. now induction H; eauto using clos_refl_trans.\n  Qed.\n\nEnd Preliminaries.\n\nSection Deterministic_simulation.\n\n  (* configuration spaces *)\n  Context {X Y : Type}.\n\n  (* step functions *)\n  Context {step1 : X -> X -> Prop} {step2 : Y -> Y -> Prop}.\n\n  (* configuration encoding *)\n  Context {sync : X -> Y -> Prop}.\n\n  (* determinism of step2 *)\n  Context (step2_det : forall s' t1' t2', step2 s' t1' -> step2 s' t2' -> t1' = t2').\n  Arguments step2_det {s' t1' t2'}.\n\n  (* step simulation wrt. encoding *)\n  Context (fstep : forall s t s', step1 s t -> sync s s' ->\n                     exists t', clos_trans Y step2 s' t' /\\ sync t t').\n  Arguments fstep {s t s'}.\n\n  (* halting simulation wrt. encoding *)\n  Context (fstop : forall s s', stuck step1 s -> sync s s' -> terminates step2 s').\n  Arguments fstop {s s'}.\n\n  (* propositional progress/halting decision *)\n  Context (step1_intro : forall s, (exists t, step1 s t) \\/ stuck step1 s).\n\n  (* transport of reachability by structural induction on transitive closure *)\n  Lemma clos_refl_trans_transport {s s' t} :\n    sync s s' -> clos_refl_trans _ step1 s t ->\n    exists t', sync t t' /\\ clos_refl_trans _ step2 s' t'.\n  Proof using fstep.\n    intros Hss' Hst. apply clos_rt_rt1n in Hst.\n    revert s' Hss'. induction Hst as [|??? Hxy Hyz IH].\n    - intros s' ?. exists s'. now split; [|apply rt_refl].\n    - intros s' Hxs'. destruct (fstep Hxy Hxs') as [y' [Hs'y' Hyy']].\n      destruct (IH _ Hyy') as [t' [? Hy't']].\n      exists t'. split; [|eapply rt_trans; [apply clos_trans_clos_refl_trans|]]; eassumption.\n  Qed.\n\n  (* transport of termination by transport of reachability *)\n  Lemma terminates_transport {s s'} :\n    sync s s' -> terminates step1 s -> terminates step2 s'.",
      "suffix": "\n\n  (* terminating configurations are accessible\n     note that (Acc R^-1 s) means s is strongly normalizing for R in a constructive setting *)\n  Lemma terminating_Acc {s} : terminates step2 s -> Acc (fun y x => step2 x y) s.\n  Proof using step2_det.\n    intros [t [Hst%clos_rt_rt1n Ht]].\n    induction Hst as [|??? Hxy Hyz IH]; constructor.\n    - now intros y ?%Ht.\n    - intros y' Hxy'. rewrite <- (step2_det Hxy Hxy'). now apply IH.\n  Qed.\n\n  (* reflection of termination by well-founded induction on transitive closure using\n     Lemma Acc_clos_trans A R x : Acc R x -> Acc (clos_trans A R) x\n     from the Coq standard library *)\n  Lemma terminates_reflection {s s'} : sync s s' -> terminates step2 s' -> terminates step1 s.\n  Proof using step2_det step1_intro fstep.\n    intros Hss' Hs'%terminating_Acc%(Acc_clos_trans Y).\n    revert s Hss'. induction Hs' as [s' _ IH].\n    intros s. destruct (step1_intro s) as [[t Hst] | Hs].\n    - intros [t' [Hs't' Htt']]%(fstep Hst).\n      apply (terminates_extend _ (t := t)); [now apply rt_step|].\n      eapply (IH t'); [|now apply Htt'].\n      clear Htt' IH. induction Hs't'; eauto using clos_trans.\n    - intros _. exists s. eauto using clos_refl_trans.\n  Qed.\n\nEnd Deterministic_simulation.\n",
      "theorem": "Lemma terminates_transport {s s'} :\n    sync s s' -> terminates step1 s -> terminates step2 s'.",
      "ground_truth": "Proof using fstop fstep.\n    intros Hss' [t [Hst Ht]].\n    destruct (clos_refl_trans_transport Hss' Hst) as [t' [Htt' Hs't']].\n    apply (terminates_extend _ Hs't').\n    eapply fstop; eassumption.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 37,
      "prefix": "Require Import Bool String List Arith.Peano_dec Lia.\nRequire Import Lib.FMap Lib.Struct Lib.CommonTactics Lib.Indexer Lib.StringAsList Lib.StringEq.\nRequire Import Kami.Syntax Kami.Semantics Kami.SemFacts Kami.RefinementFacts Kami.Renaming Kami.Wf.\n\nRequire Import FunctionalExtensionality.\nRequire Import Compare_dec.\n\nSet Implicit Arguments.\nSet Asymmetric Patterns.\n\nLocal Ltac Tauto.intuition_solver ::= auto with exfalso bool zarith.\n\nSection SpecializeModule.\n  Variable m: Modules.\n  Variable i: nat.\n\n  Fixpoint makeNoDup (l: list string) :=\n    match l with\n    | nil => nil\n    | h :: t => let nt := makeNoDup t in\n                if string_in h nt then nt else h :: nt\n    end.\n\n  Lemma makeNoDup_NoDup: forall l, NoDup (makeNoDup l).\n  Proof.\n    induction l; [auto|].\n    simpl; remember (string_in a (makeNoDup l)) as sin; destruct sin; [auto|].\n    apply string_in_dec_not_in in Heqsin.\n    constructor; auto.\n  Qed.\n\n  Lemma makeNoDup_SubList_1: forall l, SubList (makeNoDup l) l.\n  Proof.\n    induction l; simpl; intros.\n    - apply SubList_refl.\n    - destruct (string_in _ _).\n      + apply SubList_cons_right; auto.\n      + unfold SubList; intros.\n        inv H; [left; auto|right; auto].\n  Qed.\n\n  Lemma makeNoDup_SubList_2: forall l, SubList l (makeNoDup l).\n  Proof.\n    induction l; simpl; intros.\n    - apply SubList_refl.\n    - remember (string_in a (makeNoDup l)) as ain; destruct ain.\n      + apply string_in_dec_in in Heqain.\n        apply SubList_cons; auto.\n      + apply SubList_cons; [left; auto|].\n        apply SubList_cons_right; auto.\n  Qed.\n\n  Definition spDom := makeNoDup ((namesOf (getRegInits m))\n                                   ++ (namesOf (getRules m))\n                                   ++ (namesOf (getDefsBodies m))\n                                   ++ (getCalls m)).\n\n  Lemma spDom_regs:\n    SubList (namesOf (getRegInits m)) spDom.\n  Proof.\n    unfold spDom.\n    eapply SubList_trans; [|apply makeNoDup_SubList_2].\n    apply SubList_app_1, SubList_refl.\n  Qed.\n\n  Lemma spDom_rules:\n    SubList (namesOf (getRules m)) spDom.\n  Proof.\n    unfold spDom.\n    eapply SubList_trans; [|apply makeNoDup_SubList_2].\n    apply SubList_app_2, SubList_app_1, SubList_refl.\n  Qed.\n\n  Lemma spDom_defs:\n    SubList (getDefs m) spDom.\n  Proof.\n    unfold spDom.\n    eapply SubList_trans; [|apply makeNoDup_SubList_2].\n    do 2 apply SubList_app_2.\n    apply SubList_app_1, SubList_refl.\n  Qed.\n\n  Lemma spDom_calls:\n    SubList (getCalls m) spDom.\n  Proof.\n    unfold spDom.\n    eapply SubList_trans; [|apply makeNoDup_SubList_2].\n    do 3 apply SubList_app_2.\n    apply SubList_refl.\n  Qed.\n\n  Lemma spDom_getExtMeths:\n    SubList (getExtMeths m) spDom.\n  Proof.\n    intros; eapply SubList_trans; [apply getExtMeths_meths|].\n    apply SubList_app_3.\n    - eapply SubList_trans; [|apply makeNoDup_SubList_2].\n      do 2 apply SubList_app_2.\n      apply SubList_app_1, SubList_refl.\n    - eapply SubList_trans; [|apply makeNoDup_SubList_2].\n      do 3 apply SubList_app_2.\n      apply SubList_refl.\n  Qed.\n\n  Definition spf := fun e => e __ i.\n\n  Lemma spf_onto: forall a1 a2, spf a1 = spf a2 -> a1 = a2.\n  Proof.\n    unfold spf; intros.\n    rewrite withIndex_eq in H.\n    eapply append_same; eauto.\n  Qed.\n\n  Lemma spf_in: forall a l, In (spf a) (map spf l) -> In a l.\n  Proof.\n    induction l; simpl; intros; [auto|].\n    destruct H.\n    - left; apply spf_onto; auto.\n    - auto.\n  Qed.\n\n  Lemma spf_NoDup: forall l, NoDup l -> NoDup (map spf l).\n  Proof.\n    induction l; simpl; intros; [auto|].\n    inv H; constructor; auto.\n    intro; elim H2; apply spf_in; auto.\n  Qed.\n\n  Definition spImg := map spf spDom.\n\n  Lemma sp_lengthEq: length spDom = length spImg.\n  Proof. unfold spImg; rewrite map_length; auto. Qed.\n\n  Lemma spImg_NoDup: NoDup spImg.\n  Proof.\n    unfold spImg.\n    assert (NoDup spDom) by apply makeNoDup_NoDup.\n    apply spf_NoDup; auto.\n  Qed.\n\n  Definition specializer := bijective spDom spImg.\n  Definition specializeMod := renameModules specializer m.\n\n  Hypothesis (HdisjDomImg: forall i, ~ (In i spDom /\\ In i spImg)).\n\n  Lemma specializer_bijective:\n    forall x, specializer (specializer x) = x.\n  Proof.\n    intros; apply bijectiveCorrect; auto.\n    - apply sp_lengthEq.\n    - apply makeNoDup_NoDup.\n    - apply spImg_NoDup.\n  Qed.\n\n  Lemma specializer_dom:\n    forall k, In k spDom -> specializer k = spf k.\n  Proof.\n    intros; unfold specializer.\n    assert (length spDom = length spImg) by apply sp_lengthEq.\n    assert (NoDup spDom) by apply makeNoDup_NoDup.\n    assert (NoDup spImg) by apply spImg_NoDup.\n    unfold spImg in *.\n\n    induction spDom; simpl; intros; [inv H|].\n    simpl in *.\n    inv H0; inv H1; inv H2.\n    assert (forall i, ~ (In i l /\\ In i (map spf l))).\n    { intros; intro Hx; elim (HdisjDomImg i0); intuition. }\n\n    destruct H; subst.\n    - bijective_correct_tac.\n    - specialize (IHl H0 H H4 H6 H7).\n      bijective_correct_tac.\n      exfalso; elim (HdisjDomImg (spf a)); intuition.\n  Qed.\n\n  Lemma specializer_dom_list:\n    forall l, SubList l spDom -> map specializer l = map spf l.\n  Proof.\n    induction l; simpl; intros; auto.\n    f_equal.\n    - apply specializer_dom.\n      apply H; left; auto.\n    - apply IHl.\n      eapply SubList_cons_inv; eauto.\n  Qed.\n\n  Lemma specializer_map:\n    forall {A} (mp: M.t A),\n      M.KeysSubset mp spDom ->\n      renameMap specializer mp = renameMap spf mp.\n  Proof.\n    intros; M.mind mp; auto.\n\n    unfold specializer, renameMap.\n    rewrite M.F.P.fold_add; auto.\n    - rewrite M.F.P.fold_add; auto.\n      + f_equal.\n        * apply M.KeysSubset_add_2 in H1.\n          apply specializer_dom; auto.\n        * apply H.\n          eapply M.KeysSubset_add_1; eauto.\n      + apply renameAdd_transpose_neqkey.\n        apply spf_onto.\n    - apply renameAdd_transpose_neqkey.\n      intros.\n      rewrite <-specializer_bijective with (x:= s1).\n      rewrite <-specializer_bijective with (x:= s2).\n      unfold specializer.\n      rewrite H2; auto.\n  Qed.\n\nEnd SpecializeModule.\n\nSection SpecializeFacts.\n\n  Lemma spDom_concatMod_1:\n    forall m1 m2, SubList (spDom m1) (spDom (m1 ++ m2)%kami).\n  Proof.\n    unfold SubList, spDom; intros.\n    apply makeNoDup_SubList_1 in H.\n    apply makeNoDup_SubList_2; simpl.\n    unfold namesOf in *.\n    repeat rewrite map_app.\n    Opaque getCalls.\n    repeat (apply in_app_or in H; destruct H).\n    - apply in_or_app; left.\n      apply in_or_app; left; auto.\n    - apply in_or_app; right.\n      apply in_or_app; left.\n      apply in_or_app; left; auto.\n    - apply in_or_app; right.\n      apply in_or_app; right.\n      apply in_or_app; left.\n      apply in_or_app; left; auto.\n    - apply in_or_app; right.\n      apply in_or_app; right.\n      apply in_or_app; right.\n      apply getCalls_in_1; auto.\n      Transparent getCalls.\n  Qed.\n\n  Lemma spDom_concatMod_2:\n    forall m1 m2, SubList (spDom m2) (spDom (m1 ++ m2)%kami).\n  Proof.\n    unfold SubList, spDom; intros.\n    apply makeNoDup_SubList_1 in H.\n    apply makeNoDup_SubList_2; simpl.\n    unfold namesOf in *.\n    repeat rewrite map_app.\n    Opaque getCalls.\n    repeat (apply in_app_or in H; destruct H).\n    - apply in_or_app; left.\n      apply in_or_app; right; auto.\n    - apply in_or_app; right.\n      apply in_or_app; left.\n      apply in_or_app; right; auto.\n    - apply in_or_app; right.\n      apply in_or_app; right.\n      apply in_or_app; left.\n      apply in_or_app; right; auto.\n    - apply in_or_app; right.\n      apply in_or_app; right.\n      apply in_or_app; right.\n      apply getCalls_in_2; auto.\n      Transparent getCalls.\n  Qed.\n\n  Lemma spDom_in:\n    forall m1 m2 s,\n      In s (spDom (m1 ++ m2)%kami) ->\n      In s (spDom m1) \\/ In s (spDom m2).\n  Proof.\n    unfold spDom; intros.\n    apply makeNoDup_SubList_1 in H.\n    Opaque getCalls.\n    repeat (apply in_app_or in H; destruct H).\n    - simpl in H; unfold RegInitT in H; rewrite namesOf_app in H.\n      apply in_app_or in H; destruct H.\n      + left; apply makeNoDup_SubList_2.\n        apply in_or_app; left; auto.\n      + right; apply makeNoDup_SubList_2.\n        apply in_or_app; left; auto.\n    - simpl in H; rewrite namesOf_app in H.\n      apply in_app_or in H; destruct H.\n      + left; apply makeNoDup_SubList_2.\n        apply in_or_app; right.\n        apply in_or_app; left; auto.\n      + right; apply makeNoDup_SubList_2.\n        apply in_or_app; right.\n        apply in_or_app; left; auto.\n    - simpl in H; unfold DefMethT in H; rewrite namesOf_app in H.\n      apply in_app_or in H; destruct H.\n      + left; apply makeNoDup_SubList_2.\n        do 2 (apply in_or_app; right).\n        apply in_or_app; left; auto.\n      + right; apply makeNoDup_SubList_2.\n        do 2 (apply in_or_app; right).\n        apply in_or_app; left; auto.\n    - simpl in H; apply getCalls_in in H; destruct H.\n      + left; apply makeNoDup_SubList_2.\n        do 3 (apply in_or_app; right); auto.\n      + right; apply makeNoDup_SubList_2.\n        do 3 (apply in_or_app; right); auto.\n        Transparent getCalls.\n  Qed.\n  \n  Lemma spf_neq: forall a b i j, i <> j -> spf i a <> spf j b.\n  Proof. intros; apply withIndex_neq; auto. Qed.\n\n  Lemma renameAction_ActionEquiv:\n    forall ty1 ty2 {retT} (ta: ActionT ty1 retT) (ua: ActionT ty2 retT),\n      ActionEquiv ta ua ->\n      forall f,\n        ActionEquiv (renameAction f ta) (renameAction f ua).\n  Proof.\n    induction 1; simpl; intros; try (constructor; auto).\n  Qed.\n  \n  Lemma renameRules_RulesEquiv:\n    forall ty1 ty2 rules,\n      RulesEquiv ty1 ty2 rules ->\n      forall f,\n        RulesEquiv ty1 ty2 (renameRules f rules).\n  Proof.\n    induction rules; simpl; intros; [constructor|].\n    destruct a; constructor.\n    - inv H; intros; apply renameAction_ActionEquiv; auto.\n    - inv H; apply IHrules; auto.\n  Qed.\n\n  Lemma renameMeths_MethsEquiv:\n    forall ty1 ty2 meths,\n      MethsEquiv ty1 ty2 meths ->\n      forall f,\n        MethsEquiv ty1 ty2 (renameMeths f meths).\n  Proof.\n    induction meths; simpl; intros; [constructor|].\n    destruct a; constructor.\n    - unfold MethEquiv; inv H; destruct_existT; intros; apply renameAction_ActionEquiv; auto.\n    - inv H; apply IHmeths; auto.\n  Qed.\n\n  Lemma renameAction_MethEquiv:\n    forall ty1 ty2 meth,\n      MethEquiv ty1 ty2 meth ->\n      forall f, \n        MethEquiv ty1 ty2 (renameMeth f meth).\n  Proof.\n    intros.\n    destruct meth.\n    unfold MethEquiv.\n    intros.\n    specialize (H arg1 arg2).\n    simpl in *.\n    apply renameAction_ActionEquiv; auto.\n  Qed.\n  \n  Lemma renameModules_ModEquiv:\n    forall ty1 ty2 m,\n      ModEquiv ty1 ty2 m ->\n      forall f,\n        ModEquiv ty1 ty2 (renameModules f m).\n  Proof.\n    induction m; simpl; intros.\n    - inv H; simpl in *.\n      constructor; simpl.\n      + apply renameRules_RulesEquiv; auto.\n      + apply renameMeths_MethsEquiv; auto.\n    - inv H; simpl in *.\n      constructor; simpl.\n      + apply renameRules_RulesEquiv; auto.\n      + apply renameMeths_MethsEquiv; auto.\n    - apply ModEquiv_split in H; dest.\n      apply ModEquiv_modular; auto.\n  Qed.\n  \n  Lemma specializeMod_ModEquiv:\n    forall ty1 ty2 i m,\n      ModEquiv ty1 ty2 m ->\n      ModEquiv ty1 ty2 (specializeMod m i).\n  Proof.\n    intros; apply renameModules_ModEquiv; auto.\n  Qed.\n\n  Lemma specializer_validRegsAction:\n    forall m (regs: list RegInitT) {retT} (a: ActionT type retT) i,\n        ValidRegsAction (namesOf regs) a ->\n        ValidRegsAction (map (specializer m i) (namesOf regs))\n                        (renameAction (specializer m i) a).\n  Proof.\n    induction 1; simpl; intros; try (constructor; auto; fail).\n    - constructor; auto; apply in_map; auto.\n    - constructor; auto; apply in_map; auto.\n  Qed.\n\n  Lemma specializer_validRegsRules:\n    forall m (regs: list RegInitT) rules,\n      SubList rules (getRules m) ->\n      forall i,\n        ValidRegsRules type (namesOf regs) rules ->\n        ValidRegsRules type (namesOf (renameListAttr (specializer m i) regs))\n                       (renameRules (specializer m i) rules).\n  Proof.\n    induction rules; simpl; intros; [constructor|].\n    inv H0; destruct a as [rn rb]; simpl in *.\n    constructor.\n    - apply IHrules; auto.\n      eapply SubList_cons_inv; eauto.\n    - intros; rewrite renameListAttr_namesOf.\n      apply specializer_validRegsAction; auto.\n  Qed.\n\n  Lemma specializer_validRegsDms:\n    forall m (regs: list RegInitT) dms,\n      SubList dms (getDefsBodies m) ->\n      forall i,\n        ValidRegsDms type (namesOf regs) dms ->\n        ValidRegsDms type (namesOf (renameListAttr (specializer m i) regs))\n                     (renameMeths (specializer m i) dms).\n  Proof.\n    induction dms; simpl; intros; [constructor|].\n    inv H0; constructor.\n    - apply IHdms; auto.\n      eapply SubList_cons_inv; eauto.\n    - intros; rewrite renameListAttr_namesOf.\n      destruct a as [dmn [dsig dmb]]; simpl in *.\n      apply specializer_validRegsAction; auto.\n  Qed.\n\n  Lemma specializeMod_validRegsModules_weakening:\n    forall m1,\n      ValidRegsModules type m1 ->\n      forall m2 i,\n        SubList (getRules m1) (getRules m2) ->\n        SubList (getDefsBodies m1) (getDefsBodies m2) ->\n        ValidRegsModules type (renameModules (specializer m2 i) m1).\n  Proof.\n    induction m1; simpl; intros.\n    - dest; split.\n      + apply specializer_validRegsRules; auto.\n      + apply specializer_validRegsDms; auto.\n    - dest; split.\n      + apply specializer_validRegsRules; auto.\n      + apply specializer_validRegsDms; auto.\n    - dest; split.\n      + apply IHm1_1; auto.\n        * eapply SubList_app_4; eauto.\n        * eapply SubList_app_4; eauto.\n      + apply IHm1_2; auto.\n        * eapply SubList_app_5; eauto.\n        * eapply SubList_app_5; eauto.\n  Qed.\n\n  Lemma specializeMod_validRegsModules:\n    forall m i,\n      ValidRegsModules type m ->\n      ValidRegsModules type (specializeMod m i).\n  Proof.\n    induction m; intros.\n    - apply specializeMod_validRegsModules_weakening.\n      + assumption.\n      + apply SubList_refl.\n      + apply SubList_refl.\n    - simpl in *; dest; split.\n      + apply specializer_validRegsRules; auto.\n        apply SubList_refl.\n      + apply specializer_validRegsDms; auto.\n        apply SubList_refl.\n    - simpl in *; dest; split.\n      + apply specializeMod_validRegsModules_weakening; eauto.\n        * simpl; apply SubList_app_1, SubList_refl.\n        * simpl; apply SubList_app_1, SubList_refl.\n      + apply specializeMod_validRegsModules_weakening; eauto.\n        * simpl; apply SubList_app_2, SubList_refl.\n        * simpl; apply SubList_app_2, SubList_refl.\n  Qed.\n\n  Lemma renameAction_spDom_weakening:\n    forall f g ty {retT} (aty: ActionT ty retT)\n           regs (Hvr: ValidRegsAction regs aty)\n           au (Hequiv: ActionEquiv aty au),\n      (forall s : string, In s (regs ++ (getCallsA au)) -> f s = g s) ->\n      renameAction f aty = renameAction g aty.\n  Proof.\n    induction 2; simpl; intros; auto.\n    - inv Hvr; destruct_existT.\n      f_equal; auto.\n      + apply H1, in_or_app; right; simpl; tauto.\n      + extensionality v; eapply H0; [auto|].\n        intros; apply H1; apply in_app_or in H2; destruct H2.\n        * apply in_or_app; auto.\n        * apply in_or_app; right; right; eauto.\n    - inv Hvr; destruct_existT; f_equal; extensionality v; eauto.\n    - inv Hvr; destruct_existT; f_equal; extensionality v; eauto.\n    - inv Hvr; destruct_existT.\n      f_equal; [|extensionality v; eauto].\n      apply H1, in_or_app; auto.\n    - inv Hvr; destruct_existT.\n      f_equal; auto.\n      apply H, in_or_app; auto.\n    - inv Hvr; destruct_existT.\n      f_equal.\n      + apply IHHequiv1; intros; auto; apply H1.\n        rewrite app_assoc; apply in_or_app; left; auto.\n      + apply IHHequiv2; intros; auto; apply H1.\n        apply in_app_or in H2; destruct H2.\n        * apply in_or_app; auto.\n        * do 2 (apply in_or_app; right).\n          apply in_or_app; left; auto.\n      + extensionality v.\n        eapply H0; auto.\n        intros; apply H1.\n        apply in_app_or in H2; destruct H2.\n        * apply in_or_app; auto.\n        * do 3 (apply in_or_app; right); eauto.\n    - inv Hvr; destruct_existT.\n      f_equal; auto.\n  Qed.\n\n  Lemma renameModules_spDom_weakening:\n    forall f g m\n           (Hvr: forall ty, ValidRegsModules ty m)\n           (Hequiv: forall ty, ModEquiv ty typeUT m),\n      (forall s, In s (spDom m) -> f s = g s) ->\n      renameModules f m = renameModules g m.\n  Proof.\n    induction m; simpl; intros.\n    - do 2 f_equal.\n      + assert (forall s, In s (namesOf (pm_regInits prim)) -> f s = g s)\n          by (intros; apply H; apply spDom_regs; auto).\n        clear -H0; induction (pm_regInits prim); simpl; auto.\n        f_equal.\n        * unfold renameAttr; f_equal.\n          apply H0; simpl; tauto.\n        * apply IHl; intros; apply H0; simpl; auto.\n      + assert (forall s, In s (namesOf (pm_rules prim)) -> f s = g s)\n          by (intros; apply H; apply spDom_rules; auto).\n        assert (forall s, In s (namesOf (pm_regInits prim) ++ getCallsR (pm_rules prim)) ->\n                          f s = g s).\n        { intros; apply H.\n          apply in_app_or in H1; destruct H1.\n          { apply spDom_regs; auto. }\n          { apply spDom_calls; apply in_or_app; auto. }\n        }\n        assert (forall ty, RulesEquiv ty typeUT (pm_rules prim))\n          by (intros; specialize (Hequiv ty); inv Hequiv; auto).\n        assert (forall ty, ValidRegsRules ty (namesOf (pm_regInits prim)) (pm_rules prim))\n          by (intros; specialize (Hvr ty); dest; auto).\n        clear -H0 H1 H2 H3; induction (pm_rules prim); simpl; auto.\n        f_equal.\n        * destruct a as [an ab]; f_equal.\n          { apply H0; simpl; tauto. }\n          { extensionality ty.\n            specialize (H3 ty); inv H3.\n            apply renameAction_spDom_weakening with\n            (au:= ab typeUT) (regs:= namesOf (pm_regInits prim)).\n            { auto. }\n            { specialize (H2 ty); inv H2; auto. }\n            { intros; apply H1.\n              simpl; rewrite app_assoc; apply in_or_app; auto.\n            }\n          }\n        * apply IHl; intros.\n          { apply H0; simpl; auto. }\n          { apply H1; simpl.\n            apply in_app_or in H; destruct H.\n            { apply in_or_app; auto. }\n            { apply in_or_app; right; apply in_or_app; auto. }\n          }\n          { specialize (H2 ty); inv H2; auto. }\n          { specialize (H3 ty); inv H3; auto. }\n      + assert (forall s, In s (namesOf (pm_methods prim)) -> f s = g s)\n          by (intros; apply H; apply spDom_defs; auto).\n        assert (forall s, In s (namesOf (pm_regInits prim) ++ getCallsM (pm_methods prim)) ->\n                          f s = g s).\n        { intros; apply H.\n          apply in_app_or in H1; destruct H1.\n          { apply spDom_regs; auto. }\n          { apply spDom_calls; apply in_or_app; auto. }\n        }\n        assert (forall ty, MethsEquiv ty typeUT (pm_methods prim))\n          by (intros; specialize (Hequiv ty); inv Hequiv; auto).\n        assert (forall ty, ValidRegsDms ty (namesOf (pm_regInits prim)) (pm_methods prim))\n          by (intros; specialize (Hvr ty); dest; auto).\n        clear -H0 H1 H2 H3; induction (pm_methods prim); simpl; auto.\n        f_equal.\n        * unfold renameMeth; destruct a as [an ab]; f_equal.\n          { apply H0; simpl; tauto. }\n          { f_equal.\n            extensionality ty; extensionality v.\n            specialize (H2 ty); inv H2.\n            specialize (H3 ty); inv H3.\n            simpl; eapply renameAction_spDom_weakening.\n            { eapply H7. }\n            { eapply H5. }\n            { simpl in H1; intros; apply H1.\n              rewrite app_assoc; apply in_or_app; eauto.\n            }\n          }\n        * apply IHl; intros.\n          { apply H0; simpl; auto. }\n          { apply H1; simpl.\n            apply in_app_or in H; destruct H.\n            { apply in_or_app; auto. }\n            { apply in_or_app; right; apply in_or_app; auto. }\n          }\n          { specialize (H2 ty); inv H2; auto. }\n          { specialize (H3 ty); inv H3; auto. }\n\n    - f_equal.\n      + assert (forall s, In s (namesOf regs) -> f s = g s)\n          by (intros; apply H; apply spDom_regs; auto).\n        clear -H0; induction regs; simpl; auto.\n        f_equal.\n        * unfold renameAttr; f_equal.\n          apply H0; simpl; tauto.\n        * apply IHregs; intros; apply H0; simpl; auto.\n      + assert (forall s, In s (namesOf rules) -> f s = g s)\n          by (intros; apply H; apply spDom_rules; auto).\n        assert (forall s, In s (namesOf regs ++ getCallsR rules) -> f s = g s).\n        { intros; apply H.\n          apply in_app_or in H1; destruct H1.\n          { apply spDom_regs; auto. }\n          { apply spDom_calls; apply in_or_app; auto. }\n        }\n        assert (forall ty, RulesEquiv ty typeUT rules)\n          by (intros; specialize (Hequiv ty); inv Hequiv; auto).\n        assert (forall ty, ValidRegsRules ty (namesOf regs) rules)\n          by (intros; specialize (Hvr ty); dest; auto).\n        clear -H0 H1 H2 H3; induction rules; simpl; auto.\n        f_equal.\n        * destruct a as [an ab]; f_equal.\n          { apply H0; simpl; tauto. }\n          { extensionality ty.\n            specialize (H3 ty); inv H3.\n            apply renameAction_spDom_weakening with\n            (au:= ab typeUT) (regs:= namesOf regs).\n            { auto. }\n            { specialize (H2 ty); inv H2; auto. }\n            { intros; apply H1.\n              simpl; rewrite app_assoc; apply in_or_app; auto.\n            }\n          }\n        * apply IHrules; intros.\n          { apply H0; simpl; auto. }\n          { apply H1; simpl.\n            apply in_app_or in H; destruct H.\n            { apply in_or_app; auto. }\n            { apply in_or_app; right; apply in_or_app; auto. }\n          }\n          { specialize (H2 ty); inv H2; auto. }\n          { specialize (H3 ty); inv H3; auto. }\n      + assert (forall s, In s (namesOf dms) -> f s = g s)\n          by (intros; apply H; apply spDom_defs; auto).\n        assert (forall s, In s (namesOf regs ++ getCallsM dms) -> f s = g s).\n        { intros; apply H.\n          apply in_app_or in H1; destruct H1.\n          { apply spDom_regs; auto. }\n          { apply spDom_calls; apply in_or_app; auto. }\n        }\n        assert (forall ty, MethsEquiv ty typeUT dms)\n          by (intros; specialize (Hequiv ty); inv Hequiv; auto).\n        assert (forall ty, ValidRegsDms ty (namesOf regs) dms)\n          by (intros; specialize (Hvr ty); dest; auto).\n        clear -H0 H1 H2 H3; induction dms; simpl; auto.\n        f_equal.\n        * unfold renameMeth; destruct a as [an ab]; f_equal.\n          { apply H0; simpl; tauto. }\n          { f_equal.\n            extensionality ty; extensionality v.\n            specialize (H2 ty); inv H2.\n            specialize (H3 ty); inv H3.\n            simpl; eapply renameAction_spDom_weakening.\n            { eapply H7. }\n            { eapply H5. }\n            { simpl in H1; intros; apply H1.\n              rewrite app_assoc; apply in_or_app; eauto.\n            }\n          }\n        * apply IHdms; intros.\n          { apply H0; simpl; auto. }\n          { apply H1; simpl.\n            apply in_app_or in H; destruct H.\n            { apply in_or_app; auto. }\n            { apply in_or_app; right; apply in_or_app; auto. }\n          }\n          { specialize (H2 ty); inv H2; auto. }\n          { specialize (H3 ty); inv H3; auto. }\n\n    - f_equal.\n      + apply IHm1; intros.\n        { specialize (Hvr ty); dest; auto. }\n        { specialize (Hequiv ty).\n          apply ModEquiv_split in Hequiv; dest; auto.\n        }\n        { apply H; apply spDom_concatMod_1; auto. }\n      + apply IHm2; intros.\n        { specialize (Hvr ty); dest; auto. }\n        { specialize (Hequiv ty).\n          apply ModEquiv_split in Hequiv; dest; auto.\n        }\n        { apply H; apply spDom_concatMod_2; auto. }\n  Qed.\n\nEnd SpecializeFacts.\n\nSection Specializable.\n\n  Fixpoint hasNoIndex (l: list string) :=\n    match l with\n    | nil => true\n    | h :: t =>\n      match index 0 indexSymbol h with\n      | Some _ => false\n      | None => hasNoIndex t\n      end\n    end.\n\n  Lemma hasNoIndex_in:\n    forall l, hasNoIndex l = true ->\n              forall a, In a l -> index 0 indexSymbol a = None.\n  Proof.\n    induction l; simpl; intros; [elim H0|].\n    destruct H0; subst.\n    - destruct (index _ _ _); intuition.\n    - apply IHl; auto.\n      destruct (index _ _ _); intuition.\n  Qed.\n\n  Lemma hasNoIndex_app:\n    forall l1 l2,\n      hasNoIndex l1 = true ->\n      hasNoIndex l2 = true ->\n      hasNoIndex (l1 ++ l2) = true.\n  Proof.\n    induction l1; simpl; intros; auto.\n    destruct (index _ _ _); auto.\n  Qed.\n\n  Lemma hasNoIndex_app_inv:\n    forall l1 l2,\n      hasNoIndex (l1 ++ l2) = true ->\n      hasNoIndex l1 = true /\\ hasNoIndex l2 = true.\n  Proof.\n    induction l1; simpl; intros; auto.\n    destruct (index _ _ _); auto; inv H.\n  Qed.\n\n  Lemma hasNoIndex_makeNoDup:\n    forall l, hasNoIndex l = hasNoIndex (makeNoDup l).\n  Proof.\n    induction l; simpl; auto.\n    remember (string_in a (makeNoDup l)) as al; destruct al; [|simpl; rewrite IHl; auto].\n    apply string_in_dec_in in Heqal.\n    destruct (hasNoIndex (makeNoDup l)).\n    - rewrite (hasNoIndex_in _ IHl); auto.\n      apply makeNoDup_SubList_1; auto.\n    - rewrite IHl; destruct (index _ _ _); auto.\n  Qed.\n\n  Lemma hasNoIndex_SubList:\n    forall l1 l2, SubList l1 l2 -> hasNoIndex l2 = true -> hasNoIndex l1 = true.\n  Proof.\n    induction l1; simpl; intros; auto.\n    apply SubList_cons_inv in H; dest.\n    rewrite hasNoIndex_in with (l:= l2) by assumption.\n    eapply IHl1; eauto.\n  Qed.\n\n  Lemma hasNoIndex_disj_dom_img:\n    forall l,\n      hasNoIndex l = true ->\n      forall i s,\n        In s l ->\n        In s (map (spf i) l) ->\n        False.\n  Proof.\n    induction l; simpl; intros; auto.\n    remember (index 0 indexSymbol a) as idx; destruct idx; [inv H|].\n    destruct H0; [subst|].\n    - destruct H1.\n      + clear -H0.\n        assert (String.length (spf i s) = String.length s) by (rewrite H0; auto).\n        unfold spf in H; rewrite withIndex_eq in H.\n        do 2 rewrite append_length in H; simpl in H.\n        lia.\n      + clear -Heqidx H0.\n        apply in_map_iff in H0; dest; subst.\n        unfold spf in Heqidx; rewrite withIndex_eq in Heqidx.\n        apply eq_sym in Heqidx.\n        apply index_correct3 with (m:= String.length x) in Heqidx.\n        * rewrite substring_append_1 in Heqidx; simpl in Heqidx.\n          rewrite substring_empty in Heqidx; auto.\n        * discriminate.\n        * lia.\n    - destruct H1; [subst|].\n      + clear -H H0; induction l; simpl; intros; auto.\n        simpl in H.\n        remember (index 0 indexSymbol a0) as idx; destruct idx; [inv H|].\n        inv H0; auto.\n        unfold spf in Heqidx; rewrite withIndex_eq in Heqidx.\n        apply eq_sym in Heqidx.\n        apply index_correct3 with (m:= String.length a) in Heqidx.\n        * rewrite substring_append_1 in Heqidx; simpl in Heqidx.\n          rewrite substring_empty in Heqidx; auto.\n        * discriminate.\n        * lia.\n      + eauto.\n  Qed.\n\n  Lemma hasNoIndex_disj_imgs:\n    forall l1 l2,\n      hasNoIndex l1 = true ->\n      hasNoIndex l2 = true ->\n      forall i j s,\n        i <> j ->\n        In s (map (spf i) l1) ->\n        In s (map (spf j) l2) ->\n        False.",
      "suffix": "\n\n  Definition Specializable (m: Modules) := hasNoIndex (spDom m) = true.\n\n  Lemma specializable_concatMod:\n    forall m1 m2,\n      Specializable m1 ->\n      Specializable m2 ->\n      Specializable (m1 ++ m2)%kami.\n  Proof.\n    unfold Specializable, spDom, namesOf; intros.\n    simpl; repeat rewrite map_app.\n    rewrite <-hasNoIndex_makeNoDup in *.\n    match type of H with\n    | hasNoIndex ?i1 = true =>\n      match type of H0 with\n        | hasNoIndex ?i2 = true =>\n          apply hasNoIndex_SubList with (l2 := (i1 ++ i2))\n      end\n    end.\n\n    - Opaque getCalls.\n      repeat apply SubList_app_3.\n      + apply SubList_app_1, SubList_app_1, SubList_refl.\n      + apply SubList_app_2, SubList_app_1, SubList_refl.\n      + apply SubList_app_1, SubList_app_2, SubList_app_1, SubList_refl.\n      + apply SubList_app_2, SubList_app_2, SubList_app_1, SubList_refl.\n      + apply SubList_app_1, SubList_app_2, SubList_app_2, SubList_app_1, SubList_refl.\n      + apply SubList_app_2, SubList_app_2, SubList_app_2, SubList_app_1, SubList_refl.\n      + Transparent getCalls.\n        clear; unfold SubList; intros.\n        apply getCalls_in in H; destruct H.\n        * apply in_or_app; left.\n          do 3 (apply in_or_app; right); auto.\n        * apply in_or_app; right.\n          do 3 (apply in_or_app; right); auto.\n    - apply hasNoIndex_app; auto.\n  Qed.\n\n  Variable (m: Modules).\n  Hypothesis (Hsp: Specializable m).\n\n  Lemma specializable_disj_dom_img:\n    forall i s, ~ (In s (spDom m) /\\ In s (spImg m i)).\n  Proof.\n    unfold spImg; intros; intro Hx; dest.\n    unfold Specializable in H.\n    eapply hasNoIndex_disj_dom_img; eauto.\n  Qed.\n\n  #[local] Hint Immediate specializable_disj_dom_img.\n\n  Lemma specializeMod_regs:\n    forall i,\n      namesOf (getRegInits (specializeMod m i)) = map (spf i) (namesOf (getRegInits m)).\n  Proof.\n    intros; unfold specializeMod.\n    rewrite renameGetRegInits.\n    rewrite renameListAttr_namesOf.\n    apply specializer_dom_list; auto.\n    apply spDom_regs.\n  Qed.\n\n  Lemma specializeMod_rules:\n    forall i,\n      namesOf (getRules (specializeMod m i)) = map (spf i) (namesOf (getRules m)).\n  Proof.\n    intros; unfold specializeMod.\n    rewrite renameGetRules.\n    match goal with\n    | [ |- ?lhs = _ ] =>\n      assert (lhs = map (specializer m i) (namesOf (getRules m)))\n    end.\n    { generalize (getRules m); clear; induction l; simpl; auto.\n      f_equal; auto; destruct a; auto.\n    }\n    rewrite H.\n    apply specializer_dom_list; auto.\n    apply spDom_rules.\n  Qed.\n\n  Lemma specializeMod_defs:\n    forall i,\n      getDefs (specializeMod m i) = map (spf i) (getDefs m).\n  Proof.\n    intros; unfold specializeMod.\n    rewrite renameGetDefs.\n    apply specializer_dom_list; auto.\n    apply spDom_defs.\n  Qed.\n\n  Lemma specializeMod_calls:\n    forall i,\n      getCalls (specializeMod m i) = map (spf i) (getCalls m).\n  Proof.\n    intros; unfold specializeMod.\n    rewrite renameGetCalls.\n    apply specializer_dom_list; auto.\n    apply spDom_calls.\n  Qed.\n\n  Lemma specializeMod_rules_in:\n    forall rn rb i,\n      In (rn :: rb)%struct (getRules m) ->\n      In ((spf i rn) :: (fun ty => Renaming.renameAction (specializer m i) (rb ty)))%struct\n         (getRules (specializeMod m i)).\n  Proof.\n    intros; unfold specializeMod.\n    rewrite renameGetRules.\n    rewrite <-specializer_dom with (m:= m); auto.\n    - apply renameInRules; auto.\n    - apply spDom_rules.\n      apply in_map with (f:= @attrName _) in H; auto.\n  Qed.\n\n  Lemma specializeMod_dom_indexed:\n    forall i s, In s (spDom (specializeMod m i)) ->\n                exists t, s = t __ i.\n  Proof.\n    unfold spDom; intros.\n    apply makeNoDup_SubList_1 in H.\n    apply in_app_or in H; destruct H.\n    - rewrite specializeMod_regs in H; auto.\n      apply in_map_iff in H; dest; subst; eexists; reflexivity.\n    - apply in_app_or in H; destruct H.\n      + rewrite specializeMod_rules in H.\n        apply in_map_iff in H; dest; subst; eexists; reflexivity.\n      + apply in_app_or in H; destruct H.\n        * fold (getDefs (specializeMod m i)) in H.\n          rewrite specializeMod_defs in H.\n          apply in_map_iff in H; dest; subst; eexists; reflexivity.\n        * rewrite specializeMod_calls in H.\n          apply in_map_iff in H; dest; subst; eexists; reflexivity.\n  Qed.\n\n  Lemma specializeMod_regs_NoDup:\n    forall i,\n      NoDup (namesOf (getRegInits m)) ->\n      NoDup (namesOf (getRegInits (specializeMod m i))).\n  Proof.\n    intros; rewrite specializeMod_regs; auto.\n    induction (namesOf (getRegInits m)); [simpl; auto|].\n    inv H; simpl; constructor; auto.\n    intro Hx; elim H2.\n    apply in_map_iff in Hx; dest.\n    apply spf_onto in H; subst; auto.\n  Qed.\n\n  Lemma specializable_disj_regs:\n    forall i j,\n      i <> j ->\n      DisjList (namesOf (getRegInits (specializeMod m i)))\n               (namesOf (getRegInits (specializeMod m j))).\n  Proof.\n    intros; do 2 rewrite specializeMod_regs.\n    unfold DisjList; intros.\n    destruct (in_dec string_dec e (map (spf i) (namesOf (getRegInits m))));\n      destruct (in_dec string_dec e (map (spf j) (namesOf (getRegInits m))));\n      intuition idtac.\n    exfalso.\n    eapply hasNoIndex_disj_imgs\n    with (l1:= namesOf (getRegInits m)) (l2:= namesOf (getRegInits m)); eauto.\n    - unfold Specializable in Hsp.\n      eapply hasNoIndex_SubList; eauto.\n      apply spDom_regs.\n    - unfold Specializable in Hsp.\n      eapply hasNoIndex_SubList; eauto.\n      apply spDom_regs.\n  Qed.\n\n  Lemma specializable_disj_defs:\n    forall i j,\n      i <> j ->\n      DisjList (getDefs (specializeMod m i))\n               (getDefs (specializeMod m j)).\n  Proof.\n    intros; do 2 rewrite specializeMod_defs.\n    unfold DisjList; intros.\n    destruct (in_dec string_dec e (map (spf i) (getDefs m)));\n      destruct (in_dec string_dec e (map (spf j) (getDefs m)));\n      intuition idtac.\n    exfalso.\n    eapply hasNoIndex_disj_imgs with (l1:= getDefs m) (l2:= getDefs m); eauto.\n    - unfold Specializable in Hsp.\n      eapply hasNoIndex_SubList; eauto.\n      apply spDom_defs.\n    - unfold Specializable in Hsp.\n      eapply hasNoIndex_SubList; eauto.\n      apply spDom_defs.\n  Qed.\n\n  Lemma specializable_disj_calls:\n    forall i j,\n      i <> j ->\n      DisjList (getCalls (specializeMod m i))\n               (getCalls (specializeMod m j)).\n  Proof.\n    intros; do 2 rewrite specializeMod_calls.\n    unfold DisjList; intros.\n    destruct (in_dec string_dec e (map (spf i) (getCalls m)));\n      destruct (in_dec string_dec e (map (spf j) (getCalls m)));\n      intuition idtac.\n    exfalso.\n    eapply hasNoIndex_disj_imgs with (l1:= getCalls m) (l2:= getCalls m); eauto.\n    - unfold Specializable in Hsp.\n      eapply hasNoIndex_SubList; eauto.\n      apply spDom_calls.\n    - unfold Specializable in Hsp.\n      eapply hasNoIndex_SubList; eauto.\n      apply spDom_calls.\n  Qed.\n\n  Lemma specializable_noninteracting:\n    forall i j,\n      i <> j ->\n      NonInteracting (specializeMod m i) (specializeMod m j).\n  Proof.\n    unfold NonInteracting; intros.\n    do 2 rewrite specializeMod_calls.\n    do 2 rewrite specializeMod_defs.\n    unfold DisjList; split; intros.\n    - destruct (in_dec string_dec e (map (spf i) (getDefs m)));\n        destruct (in_dec string_dec e (map (spf j) (getCalls m)));\n        intuition idtac.\n      exfalso.\n      eapply hasNoIndex_disj_imgs with (l1:= getDefs m) (l2:= getCalls m); eauto.\n      + unfold Specializable in Hsp.\n        eapply hasNoIndex_SubList; eauto.\n        apply spDom_defs.\n      + unfold Specializable in Hsp.\n        eapply hasNoIndex_SubList; eauto.\n        apply spDom_calls.\n    - destruct (in_dec string_dec e (map (spf i) (getCalls m)));\n        destruct (in_dec string_dec e (map (spf j) (getDefs m)));\n        intuition idtac.\n      exfalso.\n      eapply hasNoIndex_disj_imgs with (l1:= getCalls m) (l2:= getDefs m); eauto.\n      + unfold Specializable in Hsp.\n        eapply hasNoIndex_SubList; eauto.\n        apply spDom_calls.\n      + unfold Specializable in Hsp.\n        eapply hasNoIndex_SubList; eauto.\n        apply spDom_defs.\n  Qed.\n  \nEnd Specializable.\n\nLemma specializeMod_disj_regs_2:\n  forall m1 m2,\n    Specializable m1 ->\n    Specializable m2 ->\n    DisjList (namesOf (getRegInits m1))\n             (namesOf (getRegInits m2)) ->\n    forall i j,\n      DisjList (namesOf (getRegInits (specializeMod m1 i)))\n               (namesOf (getRegInits (specializeMod m2 j))).\nProof.\n  intros; do 2 (rewrite specializeMod_regs; auto).\n  unfold DisjList in *; intros.\n  destruct (in_dec string_dec e (map (spf i) (namesOf (getRegInits m1)))); auto.\n  destruct (in_dec string_dec e (map (spf j) (namesOf (getRegInits m2)))); auto.\n  exfalso.\n  apply in_map_iff in i0; apply in_map_iff in i1; dest.\n  rewrite <-H2 in H4.\n  destruct (string_dec x x0); subst.\n  - specialize (H1 x0); destruct H1; auto.\n  - destruct (dec_eq_nat i j); subst.\n    + apply spf_onto in H4; auto.\n    + apply spf_neq with (a:= x0) (b:= x) in H2; auto.\nQed.\n\nLemma specializeMod_disj_regs_different_indices:\n  forall m1 m2 i j,\n    Specializable m1 -> Specializable m2 ->\n    i <> j ->\n    DisjList (namesOf (getRegInits (specializeMod m1 i)))\n             (namesOf (getRegInits (specializeMod m2 j))).\nProof.\n  intros; do 2 (rewrite specializeMod_regs; auto).\n  unfold DisjList in *; intros.\n  destruct (in_dec string_dec e (map (spf i) (namesOf (getRegInits m1)))); auto.\n  destruct (in_dec string_dec e (map (spf j) (namesOf (getRegInits m2)))); auto.\n  exfalso.\n  apply in_map_iff in i0; apply in_map_iff in i1; dest.\n  rewrite <-H2 in H4.\n  generalize H4; apply spf_neq; auto.\nQed.\n\nLemma specializeMod_disj_defs_different_indices:\n  forall m1 m2 i j,\n    Specializable m1 -> Specializable m2 ->\n    i <> j ->\n    DisjList (getDefs (specializeMod m1 i))\n             (getDefs (specializeMod m2 j)).\nProof.\n  intros; do 2 (rewrite specializeMod_defs; auto).\n  unfold DisjList in *; intros.\n  destruct (in_dec string_dec e (map (spf i) (getDefs m1))); auto.\n  destruct (in_dec string_dec e (map (spf j) (getDefs m2))); auto.\n  exfalso.\n  apply in_map_iff in i0; apply in_map_iff in i1; dest.\n  rewrite <-H2 in H4.\n  generalize H4; apply spf_neq; auto.\nQed.\n\nLemma specializeMod_disj_calls_different_indices:\n  forall m1 m2 i j,\n    Specializable m1 -> Specializable m2 ->\n    i <> j ->\n    DisjList (getCalls (specializeMod m1 i))\n             (getCalls (specializeMod m2 j)).\nProof.\n  intros; do 2 (rewrite specializeMod_calls; auto).\n  unfold DisjList in *; intros.\n  destruct (in_dec string_dec e (map (spf i) (getCalls m1))); auto.\n  destruct (in_dec string_dec e (map (spf j) (getCalls m2))); auto.\n  exfalso.\n  apply in_map_iff in i0; apply in_map_iff in i1; dest.\n  rewrite <-H2 in H4.\n  generalize H4; apply spf_neq; auto.\nQed.\n\nLemma specializable_noninteracting_2:\n  forall m1 m2,\n    Specializable m1 -> Specializable m2 ->\n    forall i j,\n      i <> j ->\n      NonInteracting (specializeMod m1 i) (specializeMod m2 j).\nProof.\n  unfold NonInteracting; intros.\n  do 2 rewrite specializeMod_calls by assumption.\n  do 2 rewrite specializeMod_defs by assumption.\n  unfold DisjList; split; intros.\n  - destruct (in_dec string_dec e (map (spf i) (getDefs m1)));\n      destruct (in_dec string_dec e (map (spf j) (getCalls m2)));\n      intuition idtac.\n    exfalso.\n    eapply hasNoIndex_disj_imgs with (l1:= getDefs m1) (l2:= getCalls m2); eauto.\n    + unfold Specializable in H.\n      eapply hasNoIndex_SubList with (l2:= spDom m1); eauto.\n      apply spDom_defs.\n    + unfold Specializable in H0.\n      eapply hasNoIndex_SubList; eauto.\n      apply spDom_calls.\n  - destruct (in_dec string_dec e (map (spf i) (getCalls m1)));\n      destruct (in_dec string_dec e (map (spf j) (getDefs m2)));\n      intuition idtac.\n    exfalso.\n    eapply hasNoIndex_disj_imgs with (l1:= getCalls m1) (l2:= getDefs m2); eauto.\n    + unfold Specializable in H.\n      eapply hasNoIndex_SubList with (l2:= spDom m1); eauto.\n      apply spDom_calls.\n    + unfold Specializable in H0.\n      eapply hasNoIndex_SubList; eauto.\n      apply spDom_defs.\nQed.\n\nLemma specializeMod_concatMod:\n  forall m1 m2\n         (Hvr1: forall ty, ValidRegsModules ty m1)\n         (Hvr2: forall ty, ValidRegsModules ty m2)\n         (Hequiv1: forall ty, ModEquiv ty typeUT m1)\n         (Hequiv2: forall ty, ModEquiv ty typeUT m2) i,\n    Specializable m1 -> Specializable m2 ->\n    specializeMod (m1 ++ m2)%kami i = ((specializeMod m1 i) ++ (specializeMod m2 i))%kami.\nProof.\n  unfold specializeMod; intros.\n  rewrite renameModulesConcat; f_equal.\n  - apply renameModules_spDom_weakening; auto.\n    intros.\n    rewrite specializer_dom with (m:= (m1 ++ m2)%kami).\n    + rewrite specializer_dom with (m:= m1); auto.\n      apply specializable_disj_dom_img; auto.\n    + apply specializable_disj_dom_img.\n      apply specializable_concatMod; auto.\n    + apply spDom_concatMod_1; auto.\n  - apply renameModules_spDom_weakening; auto.\n    intros.\n    rewrite specializer_dom with (m:= (m1 ++ m2)%kami).\n    + rewrite specializer_dom with (m:= m2); auto.\n      apply specializable_disj_dom_img; auto.\n    + apply specializable_disj_dom_img.\n      apply specializable_concatMod; auto.\n    + apply spDom_concatMod_2; auto.\nQed.\n\n#[global] Hint Immediate specializable_disj_dom_img\n     specializable_disj_regs\n     specializable_disj_defs\n     specializable_disj_calls.\n\nLemma renameAction_specializer_rules:\n  forall regs rules dms i {ty} rn (a: Action Void),\n    In (rn :: a)%struct rules ->\n    Specializable (Mod regs rules dms) ->\n    Wf.ValidRegsAction (namesOf regs) (a ty) ->\n    ActionEquiv (a ty) (a typeUT) ->\n    renameAction (specializer (Mod regs rules dms) i) (a ty) =\n    renameAction (spf i) (a ty).\nProof.\n  intros; apply renameAction_spDom_weakening with (regs:= namesOf regs) (au:= a typeUT); auto.\n  intros; apply specializer_dom; auto.\n  apply in_app_or in H3; destruct H3.\n  - unfold spDom; apply makeNoDup_SubList_2.\n    apply in_or_app; left; auto.\n  - unfold spDom; apply makeNoDup_SubList_2.\n    do 3 (apply in_or_app; right).\n    apply in_or_app; left; simpl.\n\n    clear -H H3; induction rules; [inv H|].\n    inv H.\n    + simpl; apply in_or_app; left; auto.\n    + simpl; apply in_or_app; right; auto.\nQed.\n\nLemma renameAction_specializer_dms:\n  forall regs rules dms i dmn (dm: sigT MethodT) ty v,\n    In (dmn :: dm)%struct dms ->\n    Specializable (Mod regs rules dms) ->\n    Wf.ValidRegsAction (namesOf regs) (projT2 dm ty v) ->\n    ActionEquiv (projT2 dm ty v) (projT2 dm typeUT tt) ->\n    renameAction (specializer (Mod regs rules dms) i) (projT2 dm ty v) =\n    renameAction (spf i) (projT2 dm ty v).\nProof.\n  intros; apply renameAction_spDom_weakening with\n          (regs:= namesOf regs) (au:= projT2 dm typeUT tt); auto.\n  intros; apply specializer_dom; auto.\n  apply in_app_or in H3; destruct H3.\n  - unfold spDom; apply makeNoDup_SubList_2.\n    apply in_or_app; left; auto.\n  - unfold spDom; apply makeNoDup_SubList_2.\n    do 4 (apply in_or_app; right); simpl.\n\n    clear -H H3; induction dms; [inv H|].\n    inv H.\n    + simpl; apply in_or_app; left; auto.\n    + simpl; apply in_or_app; right; auto.\nQed.\n\nSection SpRefinement.\n  Variables ma mb: Modules.\n  Variable i: nat.\n  Hypotheses (HspA: Specializable ma)\n             (HspB: Specializable mb).\n\n  Lemma specialized_1:\n    forall rp,\n      traceRefines rp ma mb ->\n      traceRefines (liftPRename (specializer mb i) (specializer ma i) rp)\n                   (specializeMod ma i) (specializeMod mb i).\n  Proof.\n    intros.\n    eapply renameRefinement.\n    - instantiate (1:= specializer ma i).\n      apply specializer_bijective; auto.\n    - apply specializer_bijective; auto.\n    - instantiate (1:= specializer mb i).\n      apply specializer_bijective; auto.\n    - exact H.\n    - reflexivity.\n  Qed.\n\n  Lemma specialized_2:\n    forall rp,\n      traceRefines (liftPRename (specializer mb i) (specializer ma i) rp) ma mb ->\n      traceRefines rp (specializeMod ma i) (specializeMod mb i).\n  Proof.\n    intros.\n    eapply renameRefinement.\n    - instantiate (1:= specializer ma i).\n      apply specializer_bijective; auto.\n    - apply specializer_bijective; auto.\n    - instantiate (1:= specializer mb i).\n      apply specializer_bijective; auto.\n    - exact H.\n    - unfold liftPRename.\n      extensionality dm.\n      rewrite renameMapFInvG by (intros; apply specializer_bijective; auto).\n      rewrite renameMapFInvG by (intros; apply specializer_bijective; auto).\n      reflexivity.\n  Qed.\n  \nEnd SpRefinement.\n\n",
      "theorem": "Lemma hasNoIndex_disj_imgs:\n    forall l1 l2,\n      hasNoIndex l1 = true ->\n      hasNoIndex l2 = true ->\n      forall i j s,\n        i <> j ->\n        In s (map (spf i) l1) ->\n        In s (map (spf j) l2) ->\n        False.",
      "ground_truth": "Proof.\n    induction l1; simpl; intros; auto.\n    remember (index 0 indexSymbol a) as idx; destruct idx; [inv H|].\n    destruct H2; [subst|].\n    - apply in_map_iff in H3; dest.\n      eapply spf_neq; eauto.\n    - eapply IHl1; eauto.\n  Qed."
    },
    {
      "split": "train-sft",
      "index": 38,
      "prefix": "From Coq Require Import Lia.\nDefinition dec (X: Type) : Type := X + (X -> False).\nDefinition eqdec X := forall x y: X, dec (x = y).\nDefinition decider {X} (p: X -> Type) := forall x, dec (p x).\nDefinition iffT (X Y: Type) : Type := (X -> Y) * (Y -> X).\nNotation \"X <=> Y\" := (iffT X Y) (at level 95, no associativity).\n\n(* We shall use Coq's predefined sigma types but rename the constructors\n   and projections.  We also define the big sigma notation to replace\n   Coq's curly braces notation *)\n\nPrint sigT.\nNotation sig := sigT.\nNotation Sig := existT.\nNotation pi1 := projT1.\nNotation pi2 := projT2.\nNotation \"'Sigma' x .. y , p\" :=\n  (sigT (fun x => .. (sigT (fun y => p%type)) ..))\n    (at level 200, x binder, right associativity,\n     format \"'[' 'Sigma'  '/  ' x  ..  y ,  '/  ' p ']'\")\n    : type_scope.\n\n(*** Eliminator *)\n\nDefinition sig_elim X  (p: X -> Type) (q: sig p -> Type)\n  : (forall x y, q (Sig p x y)) -> forall a, q a\n  := fun e a => match a with Sig _ x y => e x y end.\n\n(* Our eliminator is computationaly equal with \n   Coq's predefined eliminator. *)         \n\nGoal sig_elim = sigT_rect.\nProof.\n  reflexivity.\nQed.\n\n(* In the following we rely on Coq's predefined eliminator\n   as it is used with the destructuring tactics and notations. *) \n\n(*** Certifying Division *)\n\nDefinition div2 :\n  forall x, Sigma y, (x = 2*y) %nat + (x = S (2*y)).\nProof.\n  induction x as [|x [y [IH|IH]]].\n  - exists 0. left. reflexivity.\n  - exists y. right. f_equal. exact IH.\n  - exists (S y). left. lia. \nQed.\n\n(* Note the %nat annotation in the statement of div2.  It is sometimes\n   needed to help with the overloading of \"+\" and \"*\" for numbers\n   and types. *)\n\nSection Div2.\n  Variable F : forall x, Sigma y, (x = 2*y) %nat + (x = S (2*y)).\n  Definition D x := let (n,_) := F x in n.\n  Definition M x := let (_,a) := F x in if a then 0 else 1.\n  Fact Div2 x : x = 2 * D x + M x /\\ M x <= 1.\n  Proof.\n    unfold D, M. destruct (F x) as [n [H|H]]; lia.\n  Qed.\n  (* Note the use of the let and if-then-else notations sugaring matches. *)\nEnd Div2.\n\n(*** Translation Theorems *)\n\nFact trans_eqdec X :\n  eqdec X <=> Sigma f: X -> X -> bool, forall x y, x = y <-> f x y = true.\nProof.\n  split.\n  - intros d.\n    exists (fun x y => if d x y then true else false).\n    intros x y.\n    destruct (d x y) as [H|H]; intuition congruence.\n  - intros [f H] x y. specialize (H x y).\n    destruct (f x y); unfold dec; intuition congruence.\nQed.\n\nFact trans_p_dec X (p: X -> Type) :\n  decider p <=> Sigma f: X -> bool, forall x, p x <=> f x = true.\nProof.\n  split.\n  - intros d.\n    exists (fun x => if d x then true else false).\n    intros x.\n    destruct (d x) as [H|H]; unfold iffT; intuition congruence.\n  - intros [f H] x. specialize (H x).\n    destruct (f x); unfold dec, iffT in *; intuition congruence.\nQed.\n\nFact trans_skolem X Y (p: X -> Y -> Type) :\n  (forall x, Sigma y, p x y) <=> Sigma f: X -> Y, forall x, p x (f x).\nProof.\n  split.\n  - intros F.\n    exists (fun x => let (y,_) := F x in y).\n    intros x. destruct (F x) as [y H]. exact H.\n  - intros [f H] x. exists (f x). apply H.\nQed.\n\n(*** Projections *)\n\nCheck pi1.\nCheck pi2.\n\nFact eta_law X (p: X -> Type) :\n  forall a, a = Sig p (pi1 a) (pi2 a).\nProof.\n  destruct a as [x y]. cbn. reflexivity.\nQed.\n\nFact sig_elim' X  (p: X -> Type) (q: sig p -> Type)\n  : (forall x y, q (Sig p x y)) -> forall a, q a.\nProof.\n  intros e a. rewrite eta_law. apply e.\nQed.\n\nSection Translation.\n  Variables X Y : Type.\n  Variable p: X -> Y -> Type.\n\n  Goal (forall x, Sigma y, p x y) -> Sigma f, forall x, p x (f x).\n  Proof.\n    exact (fun F => Sig (fun f => forall x, p x (f x))\n                   (fun x => pi1 (F x))\n                   (fun x => (pi2 (F x)))).\n  Qed.\n\n  Goal (Sigma f, forall x, p x (f x)) -> forall x, Sigma y, p x y.\n  Proof.\n    exact (fun a x => Sig (p x) (pi1 a x) (pi2 a x)).\n  Qed.\nEnd Translation.\n\nGoal forall X (p: X -> Type),\n    @pi1 X p = sig_elim X p (fun _ => X) (fun x _ => x).\nProof.\n  reflexivity.\nQed.\n\nGoal forall X (p: X -> Type),\n    @pi2 X p = sig_elim X p (fun a => p (pi1 a)) (fun _ y => y).\nProof.\n  reflexivity.\nQed.\n\nFact pi1_injective X (p: X -> Type) x y x' y' :\n  Sig p x y = Sig p x' y' -> x = x'.\nProof.\n  intros H.\n  change x with (pi1 (Sig p x y)).\n  rewrite H. reflexivity.\nQed.\n\nFact pi1_injective_nondep X Y x y x' y' :\n  Sig (fun _: X => Y) x y = Sig _ x' y' -> y = y'.",
      "suffix": "\n\nFail\n  Fact pi2_injective X (p: X -> Type) x y x' y' :\n  Sig p x y = Sig p x' y' -> y = y'.\n\nFact pi2_injective X (p: X -> Type) x y y' :\n  Sig p x y = Sig p x y' -> y = y'.\nProof.\n  (* cannot be shown without assumptions *)\n  intros H.\n  change y with (pi2 (Sig p x y)).\n  change (let z := Sig p x y in pi2 z = y').\n  Fail pattern (Sig p x y).\n  Fail rewrite H. \nAbort.\n\n\n\n\n(*** Dependent Pair Types *)\n\nModule SigmaTypes.\n \n  Inductive sig {X: Type} (p: X -> Type) : Type :=\n  | E : forall x, p x -> sig p.\n  \n  Arguments E {X p}.\n   \n  Definition elim_sig {X: Type} {p: X -> Type} (q: sig p -> Type)\n    : (forall x y, q (E x y)) -> forall a, q a\n    := fun e a => match a with E x y => e x y end.\n\n  Definition pi1 {X: Type} {p: X -> Type}\n    : sig p -> X\n    := fun a => match a with E x _ => x end.\n\n  Definition pi2 {X: Type} {p: X -> Type}\n    : forall a: sig p,  p (pi1 a)\n    := fun a => match a with E x y => y end.\n\n  Goal forall X (p: X -> Type),\n      @pi1 X p = elim_sig (fun _ => X) (fun x y => x).\n  Proof.\n    cbv. reflexivity.\n  Qed.\n\n  Goal forall X (p: X -> Type),\n      @pi2 X p = elim_sig (fun a => p (pi1 a)) (fun x y => y).\n  Proof.\n    reflexivity.\n  Qed.\n\n  Fact eta X (p: X -> Type) :\n    forall a: sig p, E (pi1 a) (pi2 a) = a.\n  Proof.\n    (* cannot be shown with match_sig *)\n    refine (elim_sig _ _).\n    cbn. reflexivity.\n  Qed.\n\n  Definition skolem X Y (p: X -> Y -> Type) :\n    (forall x, sig (p x)) <=> sig (fun f => forall x, p x (f x)).\n  Proof.\n    split.\n    - intros F.\n      refine (E (fun x => pi1 (F x)) _).\n      intros x. exact (pi2 (F x)).\n    - intros a.\n      refine (elim_sig _ _ a).\n      intros f H x. apply (E (f x)). apply H.\n  Qed.\n\n  (* Proof much easier with destruct and exists tactic.\n     Destruct uses automatically derived eliminator *)          \n\n  Definition skolem' X Y (p: X -> Y -> Type) :\n    (forall x, sig (p x)) <=> sig (fun f => forall x, p x (f x)).\n  Proof.\n    split.\n    - intros F. exists (fun x => pi1 (F x)). intros x. exact (pi2 (F x)).\n    - intros [f H] x. exists (f x). apply H.\n  Qed.\n\n  Fact match_sum X Y :\n    forall a: sum X Y, sig (fun x => a = inl x) + sig (fun y => a = inr y).\n  Proof.\n    apply sum_rect.\n    - intros x. left. exists x. reflexivity.\n    - intros y. right. exists y. reflexivity.\n  Qed.    \n\n  Fact pi1_injective X (p: X -> Type) x (c: p x) x' (c': p x') :\n    E x c = E x' c' -> x = x'.\n  Proof.\n  intros H.\n  change x with (pi1 (E x c)).\n  rewrite H. reflexivity.\n  Qed.\n\n  Fail\n    Fact pi2_injective X (p: X -> Type) x (c: p x) x' (c': p x') :\n    E x c = E x' c' -> c = c'.\n  \n  Fact pi2_injective X (p: X -> Type) x (c c': p x) :\n    E x c = E x c' -> c = c'.\n  Proof.\n    (* cannot be shown without assumptions *)\n    intros H.\n    change c with (pi2 (E x c)).\n    Fail pattern (E x c).\n    Fail rewrite H. \n  Abort.\n\nEnd SigmaTypes.\n\n(*** Exercises *)\n\n\n(** Certifying Distance *)\nDefinition distance :\n  forall x y: nat, Sigma z:nat, (x + z = y)%nat + (y + z = x)%nat.\nProof.\n  induction x as [|x IH]; cbn. \n  - intros y. exists y. auto.\n  - destruct y; cbn.\n    + exists (S x). auto.\n    + specialize (IH y) as [z [<-|<-]];\n        exists z; auto.\nQed.\n\nSection Distance.\n  Variable D: forall x y: nat, Sigma z, (x + z = y)%nat + (y + z = x)%nat.\n  \n  Fact D_sub x y :\n      x - y = if pi2 (D x y) then 0 else pi1 (D x y).\n  Proof.\n    destruct (D x y) as [z [<-|<-]]; cbn; lia.\n  Qed.\n\n  Fact D_pi1 x y :\n      pi1 (D x y) = (x - y) + (y - x).\n  Proof.\n    destruct (D x y) as [z [<-|<-]]; cbn; lia.\n  Qed.\n\n  Goal pi1 (D 3 7) = 4.\n  Proof.\n    rewrite D_pi1. reflexivity.\n  Qed.\nEnd Distance.\n\nFact skolem_prop_bool Y (p: bool -> Y -> Prop) :\n  (forall x, exists y, p x y) <=> (exists f, forall x, p x (f x)).\nProof.\n  split.\n  - intros F.\n    destruct (F true) as [y1 H1].\n    destruct (F false) as [y2 H2].\n    exists (fun x: bool => if x then y1 else y2).\n    destruct x; assumption.\n  - intros [f H] x. exists (f x). apply H.\nQed.\n\nFact skolem_prop_prop X (Y: Prop) (p: X -> Y -> Prop) :\n  (forall x, exists y, p x y) <=> (exists f, forall x, p x (f x)).\nProof.\n  split.\n  - intros F.\n    exists (fun x => let (y,_) := F x in y).\n    intros x. destruct (F x) as [y H]. exact H.\n  - intros [f H] x. exists (f x). apply H.\nQed.\n\nModule Ex_eta.\nSection M.\n  Variables (P: Prop) (p: P -> Prop).\n  Definition pi1 (a: ex p) : P :=\n    match a with ex_intro _ x c => x end.\n  Definition pi2 (a: ex p) : p (pi1 a) :=\n    match a with ex_intro _ x c => c end.\n  Goal forall a, a = ex_intro p (pi1 a) (pi2 a).\n  Proof.\n    intros [x a]. reflexivity.\n  Qed.\nEnd M.\nEnd Ex_eta.\n\n\n",
      "theorem": "Fact pi1_injective_nondep X Y x y x' y' :\n  Sig (fun _: X => Y) x y = Sig _ x' y' -> y = y'.",
      "ground_truth": "Proof.\n  intros H.\n  change y with (pi2 (Sig _ x y)).\n  rewrite H. reflexivity.\nQed."
    },
    {
      "split": "train-sft",
      "index": 39,
      "prefix": "(* This File contains some trivial results on sets and natural numbers. ----------------*\n  \n   Note that this file uses the Classical and Classicalchoice modules of the Standard Library \n\n   New Definitions:\n   1. Union_over (S: Ensemble (Ensemble U)): Let S be a collection of sets whose elements \n                                             are of type U. Then (Union_over S) represents the \n                                             Union of all the sets in S. \n\n   Description of some New  Results:\n             1. We prove a Theorem called my_choice to extract a function from a given relation.\n                Proof of this theorem uses Choice axiom from the Classicalchoice module. \n             2. We also prove a theorem strong_induction which is actually  the principle of stro                ng induction on natural numbers. \n             3. Some elementary results on natural number and sets that appear in this file might                already be present in other modules of Standard Library.  They are listed here \n                and renamed only because they are used more often in the proofs of other \n                important results.\n             4. Lemma Disjoint_card: It claims that size of the set A U B equals \n                |A|+|B| whenever A and B are mutually disjoint.\n             5. Lemma Power_set_finite: It claims that Powerset of a finite set is finite.\n             6. Lemma Finite_Union_of_Finite_Sets: It says that (Union_over S) is finite if \n                i) S is finite and ii) every element of S is also finite.       *)\n\n\nRequire Export Ensembles.\nRequire Export Relations_1.\nRequire Export Finite_sets.\nRequire Export Constructive_sets.\nRequire Export Powerset.\nRequire Export Powerset_facts.\nRequire Export Powerset_Classical_facts.\nRequire Export Gt.\nRequire Export Lt.\nRequire Export Le.\nRequire Export Finite_sets_facts.\nRequire Export Image.\nRequire Export Classical.\nRequire Export Arith.\nRequire Export ClassicalChoice.\n\nSection BasicFacts.\n\n \n\n\nDefinition Union_over {U:Type} (S: Ensemble (Ensemble U)): Ensemble U :=\n  fun (x:U)=>  exists s: Ensemble U, In _ S s /\\ In _ s x .\n\n\nTheorem strong_induction: forall P : nat -> Prop,\n                    (forall n : nat, (forall k : nat, (k < n -> P k)) -> P n) ->\n                    forall n : nat, P n.\nProof.    {\n  intros P Strong_IH n. pose (Q:= fun (n: nat)=> forall k:nat, k<= n -> P k). \n  assert (H: Q n).\n  { induction n.\n    { unfold Q. intros. apply Strong_IH. intros. cut (S k0 <= 0).  intro. inversion H1.\n      unfold lt in H0. generalize H. generalize H0. apply le_trans. } \n    { unfold Q in IHn. unfold Q. intros k H0.\n      assert (H1: k < (S n) \\/ k = (S n) ).  apply le_lt_or_eq.  auto.\n      elim H1. unfold lt. intro. apply IHn. auto with arith.\n      intro. rewrite H. apply Strong_IH. intros. apply IHn. unfold lt in H2.\n      generalize H2. auto with arith. }   }\n  unfold Q in H. apply H. auto with arith.   }   Qed.\n\n\nLemma  maps_to_same: forall (U V: Type) (x y: U) (f: U-> V),\n                             f x = f y ->  exists c:V, f x = c /\\ f y = c.\n  Proof. {\n    intros A B x y f H. exists (f x). split. reflexivity. symmetry. assumption. }\n  Qed.\n\n  Check choice.\n\n  (* The following theorem claims that we can get a function from U to V which maps \n     every element x of A to an element f(x)  in B such that R x f(x) .  Provided\n     we are supplied with a relation R which relates every element in A to some element\n     in B : One extra condition we need is B should be non empty *)\n\nTheorem S_choice : forall (U V : Type) (R : U->V->Prop) (A: Ensemble U) (B: Ensemble V),\n   (Inhabited _ B) -> (forall x : U, In _ A x ->  (exists y : V, In _ B y /\\  R x y) )  ->\n   exists f : U->V, (forall x : U, In _ A x -> ( R x (f x) /\\ In _ B (f x))) .\n\nProof.  { intros.\n       \n       destruct H as [y0 F1].\n       pose (R1(x: U) (y:V) := R x y /\\ ( In _ A x -> In _ B y) ).\n       pose (R' (x:U)(y:V):= R1 x y \\/ ~ In _ A x ).\n       Check choice.\n       assert (F2: exists f : U -> V, forall x : U, R' x (f x)).\n       {  apply choice. unfold R'. intro x.\n          elim (classic (In _ A x)). {\n          intros.\n          assert (H2: exists y : V, In V B y /\\ R x y).\n          { auto. } destruct H2 as [y H2].  exists y.\n          left. unfold R1. tauto.  }\n          { intros. exists y0.  tauto. } }\n       destruct F2 as [f F2].\n       exists f.\n       intros x F3. unfold R' in F2.\n       assert(F4: R1 x (f x) \\/ ~ In U A x).\n       { auto.  }\n       elim F4.\n       { intro. unfold R1 in H.\n         tauto.  }\n       { intro. contradiction. }   }    Qed.\n\nTheorem my_choice:  forall (U V : Type) (R : U->V->Prop) (A: Ensemble U),\n   (exists y0:V, True )-> (forall x : U, In _ A x ->  (exists y : V, R x y) )  ->\n   exists f : U->V, (forall x : U, In _ A x ->  R x (f x) ) .\n  Proof.   { intros U V R A.  intros. \n       \n       destruct H as [y0 F1]. \n       pose (R1(x: U) (y:V) := R x y  ).\n       pose (R' (x:U)(y:V):= R1 x y \\/ ~ In _ A x ).\n       Check choice.\n       assert (F2: exists f : U -> V, forall x : U, R' x (f x)).\n       {  apply choice. unfold R'. intro x.\n          elim (classic (In _ A x)). {\n          intros.\n          assert (H2: exists y : V,  R x y).\n          { auto. } destruct H2 as [y H2].  exists y.\n          left. unfold R1. tauto.  }\n          { intros. exists y0.  tauto. } }\n       destruct F2 as [f F2].\n       exists f.\n       intros x F3. unfold R' in F2.\n       assert(F4: R1 x (f x) \\/ ~ In U A x).\n       { auto.  }\n       elim F4.\n       { intro. unfold R1 in H.\n         tauto.  }\n       { intro. contradiction. }   }    Qed. \n\n  \n      \n       \n  (* -----------------  NATURAL NUMBER FACTS -------------------------------------------- *)\n\n\nOpen Scope nat_scope.\n \n Lemma Middle_num: forall (m n: nat), (m <= n /\\ n <  (S m)) ->  n =  m.\n Proof. {  unfold lt. intros.\n         assert (H1: n<= m). { destruct H. generalize H0. auto with arith. }\n         generalize H1. destruct H. generalize H. auto with arith. }\n Qed. \n\n \n Lemma nat_P0: forall n:nat, S n = n+1.\n   Proof. intros. rewrite plus_comm. unfold plus. reflexivity. Qed.  \n\n Lemma nat_P1: forall n m: nat, n<=m <-> ~(n>m).\n  Proof. {  intros.\n         unfold iff.\n         split. { auto with arith. }\n                { unfold gt. unfold lt.\n                  apply or_to_imply.\n                  assert (H1: S m <= n \\/ n <= m).\n                  { induction n.  right. auto with arith.\n                    elim IHn.\n                    {intro. left.  auto. }\n                    { intro.  destruct H. left. auto. right. auto with arith. } }\n                  elim H1.\n                  {intro. left. intro. contradiction. }\n                  {intro. right.   auto. }  }      }  Qed.\n\n\n   \n Lemma nat_P2:  forall n: nat, n>0 -> S (pred n) = n .\n  Proof. { intros. destruct n.  inversion H.  auto with arith. } Qed.\n \n\n Lemma nat_P3: forall n: nat, pred n = n-1.\n  Proof. apply pred_of_minus. Qed. \n  \n Lemma Not_equal_means_lt_or_gt: forall (m n :nat), m<>n-> (m<n)\\/ (m>n).\n Proof.  apply nat_total_order. Qed. \n\n Lemma nat_P4: forall n m p: nat, n<=m -> (n + p <= m + p).\n Proof. intros. auto with arith.  Qed.\n\n Lemma nat_P5: forall n m:nat, ~(n<= m) <-> n>m.\n Proof. { intros.  unfold iff. split.\n        { unfold gt. unfold lt.\n          apply or_to_imply.\n          assert (H1: S m <= n \\/ n <= m).\n           { induction n.  right. auto with arith.\n                    elim IHn.\n                    {intro. left.  auto. }\n                    { intro.  destruct H. left. auto. right. auto with arith. } }\n           elim H1.\n           { intro. right. auto. }\n           { intro. left. intro. contradiction. }   }\n        { auto with arith. } } Qed. \n \n Lemma nat_P6: forall n m: nat, n<=m \\/ m<= n.\n Proof. { intros.  assert (n<=m \\/ ~n <= m). apply classic.\n         elim H.\n         { tauto. }\n         { intro. right.\n           assert (n>m).\n           { apply nat_P5. auto. }\n           unfold gt in H1. unfold lt in H1. eapply le_trans with (m:= S m).\n           auto with arith. auto. } } Qed. \n\n\n\n\n  (* ------------------------------------------------------------------------------------ *)\n  (* --------------NEGATION FACTS ON PROPOSITION AND PREDICATES-------------------------- *)\n  \n Lemma Negation1: forall (A B: Prop), ~(A \\/ B) -> ( ~A /\\ ~B).\n Proof.  apply not_or_and.  Qed.\n \n Lemma Negation2: forall (A B: Prop), ~(A /\\ B) -> (~A \\/ ~B).\n Proof. apply not_and_or.  Qed.\n\n \n Lemma Negation4: forall (P Q: Prop), ~ (P -> Q)-> (P /\\ ~Q).\n Proof. apply imply_to_and. Qed. \n\n Lemma Negation5: forall (P Q R: Prop), ~(P-> Q-> R) -> (P /\\ Q /\\ ~R).\n Proof. { intros. assert(H1: P/\\~(Q-> R)). apply Negation4. assumption.\n         destruct H1.\n         assert (H2: Q/\\ ~R). apply Negation4. assumption.\n         split. assumption. assumption. }\n Qed.\n\n Lemma Negation3: forall (U: Type)(P Q : U-> Prop),\n                    ~(forall x:U, P x -> Q x)-> (exists x:U, P x /\\ ~ Q x).\n Proof. { intros. assert (H1: exists x:U, ~( P x -> Q x)).\n          apply not_all_ex_not. assumption.\n        destruct H1 as [a H1]. exists a.\n        generalize H1. apply imply_to_and. }   Qed.\n\n\n Ltac apply_negation:=\n   match goal with\n         | _:_ |-  ~ (forall n : ?U, ~ ?P n) -> exists n : ?U, ?P n => (apply not_all_not_ex)\n         | _:_ |-  ~ (forall n : ?U, ?P n) -> exists n : ?U, ~ ?P n=> (apply not_all_ex_not)\n         | _:_ |-  ~ (exists n : ?U, ?P n) -> forall n: ?U, ~ ?P n => (apply not_ex_all_not)\n         |_:_ |-  ~ (exists n : ?U, ~ ?P n) -> forall n: ?U, ?P n => (apply not_ex_not_all)\n         |_:_ |-  (exists n : ?U, ~ ?P n) -> ~ (forall n: ?U, ?P n) => (apply ex_not_not_all) \n         |_:_ |-   (forall n: ?U, ~ ?P n) -> ~ (exists n : ?U, ?P n) => (apply all_not_not_ex)\n   end.\n \n \n Lemma Negation6: forall (U: Type) (P:U->Prop ), ~(forall x:U, P x)-> (exists x:U, ~ P x).\n Proof. intro. intro. apply_negation.  Qed.\n\n Lemma Negation7: forall (U:Type) (P:U-> Prop), (exists x:U, ~ P x)-> ~(forall x: U, P x).\n Proof. intros. generalize H. apply_negation.  Qed.\n\n Lemma Negation8: forall (U:Type) (P:U-> Prop), ~ (exists x:U,  P x)-> (forall x: U, ~ P x).",
      "suffix": " \n\n Lemma Negation9:  forall (U:Type) (P:U-> Prop), (forall x: U, ~ P x) -> ~ (exists x:U,  P x).\n\n Proof. intro. intro. apply_negation. Qed. \n \n \n\n(* --------------------------------------------------------------------------------------- *)\n(* ------------------ SET FACTS ---------------------------------------------------------- *) \n\n\n\n\nLemma strict_included_card_less:\n     forall (U: Type)(e1 e2: Ensemble U)(m n:nat),\n       cardinal _ e1 m -> cardinal _ e2 n -> Strict_Included _ e1 e2 -> m < n.\n Proof. {\n   intro U1. intros.\n   apply incl_st_card_lt with (U:=U1)(X:=e1)(Y:=e2).\n   assumption. assumption. assumption. }  Qed.\n\nLemma Included_transitive: forall(U:Type)(e1 e2 e3: Ensemble U),\n                             Included _ e1 e2 -> Included _ e2 e3 -> Included _ e1 e3.\nProof. { intros. unfold Included. intro x.\n       assert (H1: In _ e1 x -> In _ e2 x).\n       apply H. assert (H2: In _ e2 x -> In _ e3 x).\n       apply H0. intro. apply H2. apply H1. assumption. } Qed.\n\nLemma Not_equal_sets: forall(U:Type) (A B: Ensemble U),\n        A<>B -> (exists a:U, In _ A a /\\ ~ In _ B a )\\/ (exists b:U, In _ B b /\\ ~ In _ A b).\n  Proof. { intros. assert (Ha: ~ Same_set _ A B). intro. elim H.\n         apply Extensionality_Ensembles. assumption.\n\n         unfold Same_set in Ha. assert (Hb: ~ Included U A B \\/  ~ Included U B A).\n         apply not_and_or. assumption.\n         elim Hb.\n         intro. left. unfold Included in H0. generalize H0.\n         apply Negation3.\n         intro. right. unfold Included in H0. generalize H0.\n         apply Negation3. }  Qed.\n\nLemma Sets_not_equal: forall(U: Type) (A B: Ensemble U),\n        ( (exists x:U, In _ A x /\\ ~ In _ B x) \\/(exists x:U, ~In _ A x /\\ In _ B x)) -> A<>B.\nProof.  { intros. elim H.\n          { intro;  intro; destruct H0 as [x H0]; rewrite H1 in H0; destruct H0; contradiction. }\n          { intro;  intro; destruct H0 as [x H0]; rewrite H1 in H0; destruct H0; contradiction. }\n           } Qed. \n\n\n\n\nLemma Singleton_card: forall (U:Type) (x: U), cardinal _ (Singleton _ x) 1.\nProof. { intros. \n       assert (H: Singleton U x = Add _ (Empty_set U) x).\n       auto with sets. rewrite H. eapply card_add. auto with sets. auto with sets. }  Qed. \n\nLemma Couple_card_1: forall (U:Type) (x y: U), x=y -> cardinal _ (Couple _ x y) 1.\nProof. { intros. rewrite <- H.\n       assert ( Union U (Singleton U x) (Singleton U x) = Couple U x x).\n       apply Couple_as_union.\n       assert ( Union U (Singleton U x) (Singleton U x) = Singleton U x).\n       apply Union_idempotent. rewrite <- H0. rewrite H1. apply Singleton_card. } Qed. \n\nLemma Couple_card_2: forall (U:Type) (x y: U), x<>y -> cardinal _ (Couple _ x y) 2.\nProof. { intros.\n       assert (H1: Couple U x y = Add _ (Singleton _ x) y).\n       unfold Add. symmetry.   apply Couple_as_union. rewrite H1.\n       eapply card_add. apply Singleton_card. intro.  destruct H0.\n       apply H. reflexivity.  } Qed.\n\n\nLemma Couple_comm: forall (U: Type) (x y: U), Couple _ x y = Couple _ y x.\nProof. { intros.\n       assert (H: Union U (Singleton U x) (Singleton U y) = Couple U x y).\n       apply Couple_as_union.\n       assert (H1: Union U (Singleton U y) (Singleton U x) = Couple U y x ).\n       apply Couple_as_union. rewrite <- H. rewrite <- H1. apply Union_commutative. } Qed. \n\nLemma Disjoint_card: forall (U: Type) (A B: Ensemble U)(m n: nat),\n    (Disjoint _ A B)/\\ (cardinal _ A m) /\\ (cardinal _ B n) -> (cardinal _ (Union _ A B) (m+n) ).\nProof. { intro. intros A0 B0 m.  generalize B0 as B. generalize A0 as A.\n       induction m.\n       (* trivial case here A is empty set. *)\n       { intros. destruct H. destruct H0.\n        assert (H2: A = Empty_set U).\n        { Print cardinal_elim. eapply cardinal_elim with (X:= A) (p:= 0).  auto. }\n        rewrite H2. simpl.\n        assert (Union U (Empty_set U) B = B). auto with sets. rewrite H3. auto. }\n       (* Induction Step *)\n       { intros. destruct H. destruct H0.\n         apply cardinal_invert in H0. clear A0 B0. destruct H0 as [A0 H0].\n         destruct H0 as [a H0].\n         assert (H2: ~ In _ B a).\n         { destruct H. intro.\n           assert ( In _ (Intersection _ A B) a).\n           { Print Intersection. apply Intersection_intro. destruct H0.  rewrite H0.\n             auto with sets. auto. }\n           absurd (In _ (Intersection _ A B) a). auto. auto.  }\n\n         assert (H3: ~ In _ (Union _ A0 B) a).\n         { intro. destruct H0. destruct H4.  destruct H3; contradiction. }\n\n         assert (H4: (Union _ A B) = Add _ ( Union _ A0 B) a).\n         { destruct H0. rewrite H0. unfold Add.\n           cut (Union U (Union U A0 (Singleton U a)) B = Union U B (Union U A0 (Singleton U a))).\n           { intro. rewrite H5.\n           cut (Union U B (Union U A0 (Singleton U a))= Union _ (Union _ B A0) (Singleton _ a)).\n           { intros. rewrite H6. cut (Union _ B A0 = Union _ A0 B).\n             { intro. rewrite H7. reflexivity.  }\n             auto with sets. } auto with sets.  } auto with sets. }\n\n         assert (H5: cardinal _ (Union _ A B) (S (m +n)) ).\n         { rewrite H4. apply card_add. auto.  apply IHm.\n           split.\n           { Print Disjoint.  apply Disjoint_intro. intros. intro.\n             destruct H.\n             absurd ( In _ (Intersection _ A B) x ).\n             { apply H. }\n             { destruct H0. rewrite H0.   apply Intersection_intro.  unfold Add.\n               apply Union_introl. destruct H5; auto. destruct H5; auto. }  } \n           tauto. auto.  }\n\n         apply H5.  }    }  Qed.\n\n\n  Lemma Singleton_P1:  forall (U:Type) (x y: U), In _ (Singleton _ x) y -> x=y.\n  Proof.  intros. auto with sets. Qed.\n\n  Lemma Set_Add_Sub: forall (U:Type) (X: Ensemble U)(x: U), In _ X x -> X = Add _ (Subtract _ X x) x.\n  Proof. { intros. auto with sets. } Qed.\n\n  Lemma Set_Sub_card: forall (U:Type) (X: Ensemble U)(x: U)(n:nat), In _ X x -> cardinal _ X (S n) ->\n                                                             cardinal _ (Subtract _ X x) n.\n  Proof. { intros.\n          assert (H1: X = Add _ (Subtract _ X x) x). auto with sets.\n          assert (H2: exists n':nat, cardinal _ (Subtract _ X x) n').\n          { eapply finite_cardinal.\n            eapply Finite_downward_closed with (A:= X).\n            {  eapply cardinal_finite. exact H0. } { auto with sets. } }\n          \n          destruct H2 as [n' H2].\n          rewrite H1 in H0.\n          assert (H3: cardinal _ (Add _ (Subtract U X x) x) (S n') ).\n          { eauto with sets. eapply card_add. tauto.\n            intro. unfold Subtract in H3. unfold Setminus in H3.\n            unfold In in H3. destruct H3 as [H3 H4].\n            apply H4. apply In_singleton.  }\n\n          assert (H4: S n = S n' ).\n          { eapply cardinal_unicity. exact H0. exact H3. }\n          assert (H5: n=n'). injection  H4. tauto. rewrite H5. auto. }  Qed.  \n\n\n\n    \nHint Resolve Singleton_card Couple_card_1 Couple_card_2 Disjoint_card : sets_card.\nLtac apply_set_equal:= (apply Extensionality_Ensembles; unfold Same_set; split).\n\n\n(*   ------------------------Some Non- Trivial Facts-----------------------------------------   *)\n\n\n\n\n  \n\nLemma Power_set_finite: forall (U: Type)(A: Ensemble U),\n                               Finite _ A -> Finite _ (Power_set _ A).\nProof. { intros U A0 H0. apply finite_cardinal in H0 as H1. destruct H1 as [n0 H1].\n       generalize H1. generalize A0 as A. generalize n0 as n. clear H1 n0 H0 A0. intro n.\n       induction n.\n       (* trivial case when A is empty set *)\n       { intro. intro. \n         pose (Phi:= Empty_set U). \n         assert (H2: A = Phi).\n         { unfold Phi.  apply cardinal_invert with (p:=0) in H1. auto. }\n         assert (H3: Power_set _ A = Singleton _ Phi ).\n         { apply Extensionality_Ensembles. unfold Same_set.\n           split.\n           { rewrite H2.\n           unfold Included. intros. destruct H.\n           assert (X = Phi).\n           { unfold Phi. unfold Phi in H. auto with sets. } \n           Print Singleton. rewrite H0. auto with sets.  } \n           { unfold Included.  intros. destruct H. rewrite H2.\n             assert (H3: Included _ Phi Phi).\n             { auto with sets. } generalize H3. apply Definition_of_Power_set. }  } \n         assert (H4: cardinal _ (Power_set _ A) 1).\n         { rewrite H3. auto with sets_card.  } \n         eapply cardinal_finite with (n:=1). auto. }\n\n       (* Induction step *)\n       { intro. intro.\n         assert (H0: True). trivial. \n         eapply cardinal_invert with (p:= S n) in H1 as H2.\n         destruct H2 as [A0 H2]. destruct H2 as [a H2].  destruct H2 .\n         destruct H2 .\n         pose (PA:= Power_set _ A).\n         pose (PA0 (e: Ensemble U):= In _ PA e /\\ ~ In _ e a).\n         pose (PA0' (e: Ensemble U):= In _ PA e /\\  In _ e a).\n         assert (T0: A0 = Subtract _ A a ).\n         { rewrite H. auto with sets. }\n         assert (H4: PA = Union _ PA0 PA0' ).\n         { apply_set_equal.\n           { unfold Included. intros. elim (classic ( In _ x a)).\n             intro.  apply Union_intror. unfold In.  unfold PA0'. tauto.\n             intro. apply Union_introl. unfold In. unfold PA0. tauto. }\n           { unfold Included. intros. destruct H4.\n             unfold PA0 in H4.  apply H4.  unfold PA0' in H4. apply H4. }  } \n         \n         assert (H5: PA0 = Power_set _ A0).\n         { apply_set_equal. \n           { unfold Included. intros. unfold In in H5. unfold PA0 in H5.\n           apply Definition_of_Power_set.  destruct H5. unfold PA in H5. rewrite H in H5.\n           destruct H5. unfold Add in H5.  unfold Included. intros.\n           unfold Included in H5. apply H5 in H7 as H8. destruct H8. auto.\n           destruct H8. contradiction. }\n           { unfold Included. intros.  unfold In. unfold PA0.\n             destruct H5. unfold PA.  split. rewrite H. unfold Add.\n             apply Definition_of_Power_set.  auto with sets.  intro. apply H2.\n             auto with sets.   } } \n         assert (H6: Finite _ PA0). (* Using the IHn. *)\n         { rewrite H5. apply IHn.  auto. }\n\n         pose (f (e: Ensemble U):= Add _ e a).\n         assert (H7: PA0' = Im _ _ PA0 f).\n         { apply_set_equal.\n           { unfold Included. intro y. intros.  unfold In in H7. unfold PA0' in H7.\n             pose (X0:= Subtract _ y a).\n             apply Im_intro with (x:=X0).\n             { rewrite H5.  apply Definition_of_Power_set.  destruct H7. unfold PA in H7.\n              destruct H7.  unfold Included. intros. unfold X0 in H9.\n              destruct H9.  rewrite T0. unfold Subtract. unfold In. unfold Setminus.\n              split. auto with sets. auto. }\n             unfold f. unfold X0. destruct H7.  auto with sets. }\n           { unfold Included. intro y. intros.  destruct H7. unfold f in H8.\n             unfold In. unfold PA0'.\n             split.\n             { rewrite H8. unfold PA.\n             apply Definition_of_Power_set. unfold Add.  unfold Included. intros.\n             destruct H9.\n             { unfold In in H7. unfold PA0 in H7.\n             destruct H7. unfold PA in H7. destruct H7. auto with sets. } \n             { destruct H9. rewrite H. auto with sets. } } \n             { rewrite H8. auto with sets. }    }  }  \n\n         assert (H8: PA = Power_set _ A).\n         { unfold PA. reflexivity. }\n\n         rewrite <- H8. rewrite H4.\n         apply Union_preserves_Finite. auto.\n         rewrite H7. apply finite_image. auto.   }     }  Qed.  \n\n\nVariable U: Type. \n\n\n   Lemma Union_over_empty: (Union_over  (Empty_set _ )) = (Empty_set U).\n   Proof. { apply Extensionality_Ensembles. unfold Same_set.\n          split.\n          { unfold Included. intros. destruct H. destruct H as [Ha Hb].\n            unfold In in Ha. inversion Ha.  }\n          { unfold Included. intros. destruct H.  }  } Qed.\n\n   Lemma Union_over_P1: forall (L: Ensemble (Ensemble U)) (S: Ensemble U),\n       Union_over ( Add _ L S) = Union _ (Union_over L) S .\n   Proof. { intros.\n            apply Extensionality_Ensembles. unfold Same_set.\n            split.\n            {  unfold Included. intros. unfold In in H.  unfold Union_over in H.\n               unfold Add in H. destruct H as [S1 H].  destruct H as [Ha Hb].\n               destruct Ha.\n               { apply Union_introl. unfold In. unfold Union_over. exists x0;tauto. }\n               { apply Singleton_P1 in H. rewrite H. apply Union_intror. tauto. } }\n            {  unfold Included. intros. unfold In in H. destruct H.\n               { destruct H.  unfold In. unfold Union_over.  exists x0.\n                 unfold In. unfold Add. split. apply Union_introl. tauto. tauto. }\n\n               {  unfold In. unfold Union_over. exists S. split. auto with sets.  tauto. } \n            } \n            \n          } Qed.  \n  \n         \n\n   Lemma Finite_Union_of_Finite_Sets: forall L: Ensemble (Ensemble U),\n       (Finite _ L /\\ (forall S: Ensemble U, In _ L S -> Finite _ S))-> Finite _ (Union_over L).\n   Proof. { intros.\n          assert (H1: exists n: nat, cardinal _ L n).\n          { apply finite_cardinal. tauto. } destruct H1 as [n0 H1 ].\n\n          generalize H.  generalize H1. generalize L. generalize n0 as n. clear L H n0 H1.\n          induction n.\n\n          (* Base case : when |L|= 0, ie L is empty set  *)\n          intros.\n          { assert ( H3: L = Empty_set _ ).  auto with sets.\n            eapply cardinal_elim with (X:= L) (p:= 0) . tauto.\n            rewrite H3. rewrite Union_over_empty. auto with sets. }\n\n          (* Induction Step *)\n          intros L. intros. destruct H as [H2 H3].\n          assert (H4: Inhabited _ L).\n          { eapply cardinal_elim with (X:= L)(p:= (S n)). auto.  }\n          destruct H4 as [S H4].\n\n          pose ( L0:= Subtract _ L S).\n          assert ( L = Add _ L0 S ). unfold L0. auto with sets.\n\n          rewrite H. rewrite Union_over_P1.\n\n          apply Union_preserves_Finite .\n          { eapply IHn. apply Set_Sub_card.  auto. auto.\n            split. eapply Finite_downward_closed with (A:= L). auto.\n            unfold L0. auto with sets. intros. cut (In _ L S0). auto.\n            rewrite H.  auto with sets.  }\n          auto.  } Qed. \n\n\n\n             \n\nEnd BasicFacts.\n\n\n\n\nSection Some_more_facts.\n\n  Ltac apply_equal:= (apply Extensionality_Ensembles; unfold Same_set; split).\n\n  Variable U:Type.\n\nLemma Not_Inh_Empty: forall (U:Type) (A: Ensemble U), ~ Inhabited _ A -> A = Empty_set U.\n    Proof. { intros. Print Inhabited.\n           apply_equal.\n           { unfold Included. intros. absurd (Inhabited _ A). auto.\n             apply Inhabited_intro with (x:=x). auto. }\n           { unfold Included. intros. unfold In in H0. inversion H0. } } Qed. \n\n\n    Lemma Not_Empty_Inh:  forall (U:Type) (A: Ensemble U),  A <> Empty_set U  -> Inhabited _ A .\n    Proof. { intros. elim (classic (Inhabited _ A)). tauto. intro.\n             absurd (A = Empty_set U0). auto. apply Not_Inh_Empty. auto.  } Qed.\n\n   Lemma Union_setminus: forall A B : Ensemble U, Union _ A B = Union _ A (Setminus _ B A).\n   Proof. { intros.  apply_equal.\n          { unfold Included. intros. destruct H. apply Union_introl. auto.\n            elim (classic (In _ A x)).\n            { intro. apply Union_introl. auto. }\n            { intro. apply Union_intror. unfold In. unfold Setminus. tauto. } }\n          { unfold Included. intros. destruct H. apply Union_introl.  auto.\n            destruct H. apply Union_intror. auto. } } Qed.\n   \n   Lemma Included_setminus: forall A B: Ensemble U, Included _ (Setminus _ A B) A.\n   Proof. intros. unfold Included. intros. destruct H. auto.  Qed.\n\n   Lemma Disj_comm: forall A B: Ensemble U, Disjoint _ A B -> Disjoint _ B A.\n   Proof. { intros. Print Disjoint. destruct H. apply Disjoint_intro. intro.\n          cut ( ~ In U (Intersection U A B) x).\n          intros. intro. apply H0. destruct H1. auto with sets. apply H. } Qed. \n   \n\n   Lemma Disj_Setminus: forall A B: Ensemble U, Disjoint _ (Setminus _ A B) B.\n   Proof. { intros. apply Disjoint_intro.  intro. intro. destruct H. destruct H.\n          contradiction. } Qed. \n\n   Lemma Disj_set_inc_disj: forall A B C: Ensemble U, Disjoint _ A B -> Included _ C B ->\n                                                 Disjoint _ A C.\n   Proof. { intros. destruct H. apply Disjoint_intro.  intro. intro. destruct H1.\n          assert (In _ B x).\n          { apply H0. auto. }\n          absurd (In U (Intersection U A B) x).\n          auto. auto with sets. } Qed. \n\n   Lemma Union_over1: forall (E: Ensemble (Ensemble U))(e: Ensemble U), In _ E e ->\n                                                                   Included _ e (Union_over E).\n   Proof. { intros. unfold Included.  intros. unfold In. unfold Union_over.\n            exists e. tauto. } Qed.\n\n   \n\n  \nEnd Some_more_facts.\n                                                                                                                                                                        \n                                                                                                                               \n                                 ",
      "theorem": "Lemma Negation8: forall (U:Type) (P:U-> Prop), ~ (exists x:U,  P x)-> (forall x: U, ~ P x).",
      "ground_truth": "Proof. intro.  intro. apply_negation. Qed."
    },
    {
      "split": "train-sft",
      "index": 40,
      "prefix": "Require Import List OrderedType OrderedTypeAlt OrderedTypeEx.\nImport ListNotations.\n\nFrom Verbatim Require Import ltac.\n\nModule UOT_Facts (U : UsualOrderedType).\n\n  Lemma lt_refl_contra :\n    forall x,\n      ~ U.lt x x.\n  Proof.\n    intros x hl; eapply U.lt_not_eq; eauto; red; auto.\n  Qed.\n  \n  Lemma lt_compare_LT :\n    forall x y,\n      U.lt x y\n      -> exists hl, U.compare x y = LT hl.\n  Proof.\n    intros x y hl.\n    destruct (U.compare x y) as [hl' | he | hl']; eauto.\n    - exfalso.\n      red in he; subst.\n      eapply lt_refl_contra; eauto.\n    - exfalso.\n      eapply U.lt_trans in hl'; eauto.\n      eapply lt_refl_contra; eauto.\n  Qed.\n\n  Lemma eq_compare_EQ :\n    forall x y,\n      (exists heq, U.compare x y = EQ heq) <-> x = y.\n  Proof.\n    unfold U.eq; intros x y; split; [intros hex | intros heq]; subst.\n    - destruct hex; auto.\n    - destruct (U.compare y y).\n      + exfalso; eapply lt_refl_contra; eauto. \n      + red in e; subst; eauto.\n      + exfalso; eapply lt_refl_contra; eauto.\n  Qed.\n\n  Lemma compare_refl :\n    forall x,\n      (exists heq,\n          U.compare x x = EQ heq).",
      "suffix": "\n\nEnd UOT_Facts.\n\nModule Type UsualComparableType.\n\n  Parameter t : Type.\n\n  Parameter compare : t -> t -> comparison.\n\n  Parameter compare_eq :\n    forall x y : t,\n      compare x y = Eq <-> x = y. \n\n  Parameter compare_trans :\n    forall (c : comparison) (x y z : t),\n      compare    x y = c\n      -> compare y z = c\n      -> compare x z = c.\n\nEnd UsualComparableType.\n\nModule UOT_from_UCT (C : UsualComparableType) <: UsualOrderedType.\n\n  Definition t := C.t.\n  \n  Definition eq       := @eq t.\n  Definition eq_refl  := @eq_refl t.\n  Definition eq_sym   := @eq_sym t.\n  Definition eq_trans := @eq_trans t.\n\n  Definition lt (x y : t) : Prop :=\n    match C.compare x y with\n    | Lt => True\n    | _  => False\n    end.\n\n  Lemma lt_trans :\n    forall x y z, lt x y -> lt y z -> lt x z.\n  Proof.\n    unfold lt; intros x y z hlt hlt'.\n    destruct (C.compare x y) eqn:hc  ;\n      destruct (C.compare y z) eqn:hc' ;\n      destruct (C.compare x z) eqn:hc''; auto.\n    - eapply C.compare_trans in hc'; eauto; tc.\n    - eapply C.compare_trans in hc'; eauto; tc.\n  Qed.\n  \n  Lemma lt_not_eq :\n    forall x y, lt x y -> ~ x = y.\n  Proof.\n    unfold lt; intros x y hl heq.\n    apply C.compare_eq in heq.\n    rewrite heq in hl; inv hl.\n  Qed.\n\n  Lemma compare_refl :\n    forall x, C.compare x x = Eq.\n  Proof.\n    intros x; apply C.compare_eq; auto.\n  Qed.\n  \n  Lemma compare_sym :\n    forall x y, C.compare x y = CompOpp (C.compare y x).\n  Proof.\n    intros x y; destruct (C.compare x y) eqn:hc.\n    - apply C.compare_eq in hc; subst.\n      rewrite compare_refl; auto.\n    - destruct (C.compare y x) eqn:hc'; auto.\n      + exfalso; apply C.compare_eq in hc'; subst.\n        rewrite compare_refl in hc; tc.\n      + exfalso; eapply C.compare_trans in hc'; eauto.\n        rewrite compare_refl in hc'; tc.\n    - destruct (C.compare y x) eqn:hc'; auto.\n      + exfalso; apply C.compare_eq in hc'; subst.\n        rewrite compare_refl in hc; tc.\n      + exfalso; eapply C.compare_trans in hc'; eauto.\n        rewrite compare_refl in hc'; tc.\n  Qed.\n\n  Definition compare :\n    forall x y,\n      Compare lt eq x y.\n  Proof.\n    intros x y; destruct (C.compare x y) eqn:hc.\n    - apply EQ; apply C.compare_eq; auto.\n    - apply LT; unfold lt; rewrite hc; auto.\n    - apply GT; unfold lt; rewrite compare_sym in hc.\n      destruct (C.compare y x) eqn:hc'; sis; tc; auto.\n  Defined.\n\n  Definition eq_dec :\n    forall x y : t,\n      {x = y} + {x <> y}.\n  Proof.\n    intros x y; destruct (C.compare x y) eqn:hc.\n    - left; apply C.compare_eq; auto.\n    - right; intros heq; apply C.compare_eq in heq; tc.\n    - right; intros heq; apply C.compare_eq in heq; tc.\n  Defined.\n  \nEnd UOT_from_UCT.\n\nModule Option_as_UOT (E : UsualOrderedType) <: UsualOrderedType.\n\n  Module F := UOT_Facts E.\n\n  Definition t := option E.t.\n\n  Definition eq       := @eq t.\n  Definition eq_refl  := @eq_refl t.\n  Definition eq_sym   := @eq_sym t.\n  Definition eq_trans := @eq_trans t.\n\n  Definition lt o o' :=\n    match o, o' with\n    | None, None     => False\n    | None, Some _   => True\n    | Some _, None   => False\n    | Some x, Some y => E.lt x y\n    end.\n\n  Lemma lt_trans :\n    forall x y z, lt x y -> lt y z -> lt x z.\n  Proof.\n    unfold lt; intros x y z hl hl';\n      destruct x as [x |]; destruct y as [y |]; destruct z as [z |];\n        try contradiction; auto.\n    eapply E.lt_trans; eauto.\n  Qed.\n\n  Lemma lt_not_eq :\n    forall x y,\n      lt x y -> ~ x = y.\n  Proof.\n    intros x y hl heq; destruct x as [x |]; destruct y as [y |]; tc; auto.\n    inv heq; eapply F.lt_refl_contra; eauto. \n  Qed.\n\n  Definition compare (x y : t) : Compare lt eq x y.\n    refine (match x as x' return x = x' -> _ with\n            | None =>\n              fun heq =>\n                match y as y' return y = y' -> _ with\n                | None    => fun heq' => EQ _\n                | Some e' => fun heq' => LT _\n                end (eq_refl y)\n            | Some e =>\n              fun heq =>\n                match y as y' return y = y' -> _ with\n                | None    => fun heq' => GT _\n                | Some e' => fun heq' =>\n                               match E.compare e e' with\n                               | LT hl => LT _\n                               | GT hl => GT _\n                               | EQ he => EQ _\n                               end\n                end (eq_refl y)\n            end (eq_refl x));\n      red; unfold E.eq in *; subst; auto.\n  Defined.\n  \n  Definition eq_dec (x y : t) : {x = y} + {x <> y}.\n    refine (match x as x' return x = x' -> _ with\n            | None =>\n              fun heq =>\n                match y as y' return y = y' -> _ with\n                | None    => fun heq' => left _\n                | Some e' => fun heq' => right _\n                end (eq_refl y)\n            | Some e =>\n              fun heq =>\n                match y as y' return y = y' -> _ with\n                | None    => fun heq' => right _\n                | Some e' => fun heq' =>\n                               match E.eq_dec e e' with\n                               | left he => left _\n                               | right hn => right _\n                               end\n                end (eq_refl y)\n            end (eq_refl x));\n      unfold not, E.eq in *; subst; tc.\n  Defined.\n\nEnd Option_as_UOT.\n\nModule List_as_UOT (E : UsualOrderedType) <: UsualOrderedType.\n\n  Module F := UOT_Facts E.\n\n  Definition t := list E.t.\n\n  Definition eq       := @eq t.\n  Definition eq_refl  := @eq_refl t.\n  Definition eq_sym   := @eq_sym t.\n  Definition eq_trans := @eq_trans t.\n\n  Fixpoint lt xs ys :=\n    match xs, ys with\n    | [], []             => False\n    | [], _ :: _         => True\n    | _ :: _, []         => False\n    | x :: xs', y :: ys' =>\n      match E.compare x y with\n      | LT _ => True\n      | EQ _ => lt xs' ys'\n      | GT _ => False\n      end\n    end.\n\n  Lemma lt_trans_heads_eq :\n    forall x y xs ys zs,\n      lt (x :: xs) (y :: ys)\n      -> lt (y :: ys) (x :: zs)\n      -> y = x.\n  Proof.\n    intros x y xs ys zs hl hl'; red in hl, hl'.\n    destruct (E.compare x y) as [hel | hee | hel];\n      destruct (E.compare y x) as [hel' | hee' | hel'];\n      try contradiction; auto.\n    eapply E.lt_trans in hel'; eauto.\n    exfalso; eapply F.lt_refl_contra; eauto.\n  Qed.\n\n  Lemma lt_inv_cons :\n    forall x xs ys,\n      lt (x :: xs) (x :: ys)\n      -> lt xs ys.\n  Proof.\n    intros x xs ys hl; red in hl.\n    destruct (E.compare x x); try contradiction; auto.\n    exfalso; eapply F.lt_refl_contra; eauto. \n  Qed.\n\n  Lemma lt_trans_heads_lt_or_eq :\n    forall x y z xs ys zs,\n      lt (x :: xs) (y :: ys)\n      -> lt (y :: ys) (z :: zs)\n      -> E.lt x z \\/ z = x.\n  Proof.\n    intros x y z xs ys zs hl hl'; red in hl, hl'.\n    destruct (E.compare x y) as [hel | hee | hel];\n      destruct (E.compare y z) as [hel' | hee' | hel'];\n      try contradiction; auto.\n    - left; eapply E.lt_trans; eauto.\n    - left; red in hee'; subst; auto.\n    - left; red in hee ; subst; auto.\n    - right; red in hee; red in hee'; subst; auto.\n  Qed.\n  \n  Lemma lt_trans :\n    forall xs ys zs,\n      lt xs ys -> lt ys zs -> lt xs zs.\n  Proof.\n    intros xs; induction xs as [| x xs IH];\n      intros ys zs hl hl'; destruct ys as [| y ys]; destruct zs as [| z zs]; try contradiction; auto.\n    red; destruct (E.compare x z) as [hel | hee | hel]; auto.\n    - fold lt; red in hee; subst.\n      assert (heq : y = z) by (eapply lt_trans_heads_eq; eauto); subst.\n      apply lt_inv_cons in hl; apply lt_inv_cons in hl'; eauto.\n    - eapply lt_trans_heads_lt_or_eq in hl'; eauto.\n      destruct hl' as [hl' | ?]; subst.\n      + eapply E.lt_trans in hl'; eauto.\n        eapply E.lt_not_eq; eauto; red; auto.\n      + eapply E.lt_not_eq; eauto; red; auto.\n  Qed.\n  \n  Lemma lt_not_eq :\n    forall xs ys,\n      lt xs ys -> ~ xs = ys.\n  Proof.\n    intros xs; induction xs as [| x xs IH];\n      intros ys hl heq; destruct ys as [| y ys]; tc; inv heq; auto.\n    red in hl; destruct (E.compare y y); tc.\n    - eapply E.lt_not_eq; eauto; red; auto.\n    - eapply IH; eauto. \n  Qed.\n\n  Fixpoint compare (xs ys : list E.t) : Compare lt eq xs ys.\n    refine (match xs as xs' return xs = xs' -> _ with\n            | [] =>\n              fun heq =>\n                match ys as ys' return ys = ys' -> _ with\n                | []     => fun heq' => EQ _\n                | _ :: _ => fun heq' => LT _\n                end (eq_refl ys)\n            | x :: xs' =>\n              fun heq =>\n                match ys as ys' return ys = ys' -> _ with\n                | []       => fun heq' => GT _\n                | y :: ys' => fun heq' =>\n                                match E.compare x y with\n                                | LT hl => LT _\n                                | GT hl => GT _\n                                | EQ he =>\n                                  match compare xs' ys' with\n                                  | LT hl  => LT _\n                                  | GT hl  => GT _\n                                  | EQ he' => EQ _\n                                  end\n                                end\n                end (eq_refl ys)\n            end (eq_refl xs));\n      unfold eq, E.eq in *; try red; subst; auto.\n    - apply F.lt_compare_LT in hl.\n      destruct hl as [hl hc]; rewrite hc; auto.\n    - pose proof (F.compare_refl y) as heq.\n      destruct heq as [heq hc]; rewrite hc; auto.\n    - pose proof (F.compare_refl y) as heq.\n      destruct heq as [heq hc]; rewrite hc; auto.\n    - apply F.lt_compare_LT in hl.\n      destruct hl as [hl hc]; rewrite hc; auto.\n  Defined.\n\n  Fixpoint eq_dec (xs ys : t) : {xs = ys} + {xs <> ys}.\n    refine (match xs as xs' return xs = xs' -> _ with\n            | [] =>\n              fun heq =>\n                match ys as ys' return ys = ys' -> _ with\n                | []     => fun heq' => left _\n                | _ :: _ => fun heq' => right _\n                end (eq_refl ys)\n            | x :: xs' =>\n              fun heq =>\n                match ys as ys' return ys = ys' -> _ with\n                | []       => fun heq' => right _\n                | y :: ys' => fun heq' =>\n                                match E.eq_dec x y with\n                                | left _ =>\n                                  match eq_dec xs' ys' with\n                                  | left _  => left _\n                                  | right _ => right _\n                                  end\n                                | right _ => right _\n                                end\n                end (eq_refl ys)\n            end (eq_refl xs)); tc.\n  Defined.\n\nEnd List_as_UOT.\n\nModule Pair_as_UOT (A : UsualOrderedType) (B : UsualOrderedType) <: UsualOrderedType.\n\n  Module FA := UOT_Facts A.\n  Module FB := UOT_Facts B.\n\n  Definition t := (A.t * B.t)%type.\n\n  Definition eq       := @eq t.\n  Definition eq_refl  := @eq_refl t.\n  Definition eq_sym   := @eq_sym t.\n  Definition eq_trans := @eq_trans t.\n\n  Definition lt x y :=\n    match x, y with\n    | (a, b), (a', b') =>\n      match A.compare a a' with\n      | LT _ => True\n      | GT _ => False\n      | EQ _ =>\n        match B.compare b b' with\n        | LT _ => True\n        | _    => False\n        end\n      end\n    end.\n\n  Lemma lt_trans :\n    forall x y z,\n      lt x y -> lt y z -> lt x z.\n  Proof.\n    unfold lt; intros (a, b) (a', b') (a'', b'') hl hl'.\n    destruct (A.compare a a') as [ha | ha | ha]; try contradiction.\n    - destruct (A.compare a' a'') as [ha' | ha' | ha']; try contradiction.\n      + eapply A.lt_trans in ha'; eauto.\n        apply FA.lt_compare_LT in ha'.\n        destruct ha' as (hl'' & heq); rewrite heq; auto.\n      + red in ha'; subst.\n        apply FA.lt_compare_LT in ha.\n        destruct ha as (hl'' & heq); rewrite heq; auto.\n    - red in ha; subst.\n      destruct (A.compare a' a'') as [ha' | ha' | ha']; try contradiction; auto.\n      destruct (B.compare b b') as [hb | hb | hb]; try contradiction.\n      destruct (B.compare b' b'') as [hb' | hb' | hb']; try contradiction.\n      eapply B.lt_trans in hb'; eauto.\n      apply FB.lt_compare_LT in hb'.\n      destruct hb' as (hl'' & heq); rewrite heq; auto.\n  Qed.\n\n  Lemma lt_not_eq :\n    forall x y,\n      lt x y -> ~ x = y.\n  Proof.\n    unfold lt; intros (a, b) (a', b') hl he; inv he.\n    assert (heq  : a' = a') by auto. \n    apply FA.eq_compare_EQ in heq.\n    destruct heq as (heq & hc); rewrite hc in hl.\n    assert (heq'  : b' = b') by auto. \n    apply FB.eq_compare_EQ in heq'.\n    destruct heq' as (heq' & hc'); rewrite hc' in hl.\n    contradiction.\n  Qed.\n\n  Definition compare (x y : t) : Compare lt eq x y.\n    refine (match x, y with\n            | (a, b), (a', b') =>\n              match A.compare a a' with\n              | LT hl => LT _\n              | GT hl => GT _\n              | EQ he =>\n                match B.compare b b' with\n                | LT hl  => LT _\n                | GT hl  => GT _\n                | EQ he' => EQ _\n                end\n              end\n            end);\n      unfold A.eq, B.eq in *; try red; subst; auto.\n    - apply FA.lt_compare_LT in hl.\n      destruct hl as [hl heq]; rewrite heq; auto.\n    - destruct (FA.compare_refl a') as [heq hc]; rewrite hc. \n      apply FB.lt_compare_LT in hl.\n      destruct hl as [hl hc']; rewrite hc'; auto.\n    - destruct (FA.compare_refl a') as [heq hc]; rewrite hc.\n      apply FB.lt_compare_LT in hl.\n      destruct hl as [hl hc']; rewrite hc'; auto.\n    - apply FA.lt_compare_LT in hl.\n      destruct hl as [hl hc]; rewrite hc; auto.\n  Defined.\n\n  Definition eq_dec (x y : t) : {x = y} + {x <> y}.\n    refine (match x, y with\n            | (a, b), (a', b') =>\n              match A.eq_dec a a' with\n              | left _ =>\n                match B.eq_dec b b' with\n                | left _  => left _\n                | right _ => right _\n                end\n              | right _ => right _\n              end\n            end);\n      unfold A.eq, B.eq in *; tc.\n  Defined.\n\nEnd Pair_as_UOT.\n  \nModule Nat_as_OT_Alt <: OrderedTypeAlt := OrderedType_to_Alt Nat_as_OT.\n",
      "theorem": "Lemma compare_refl :\n    forall x,\n      (exists heq,\n          U.compare x x = EQ heq).",
      "ground_truth": "Proof.\n    intros x; apply eq_compare_EQ; auto. \n  Qed."
    },
    {
      "split": "train-sft",
      "index": 41,
      "prefix": "(* ------------------------------------------------------------------------- *)\n(* General tactics *)\n\nLtac genclear H := generalize H; clear H.\n\nLtac clearall :=\n   repeat\n        match goal with [H : _ |- _ ] => clear H end\n     || match goal with [H : _ |- _ ] => genclear H end. \n\n(* ------------------------------------------------------------------------- *)\n(* Infinite traces *)\n\nSection sec_infseq.\n\nVariable T: Type. \n\nCoInductive infseq : Type := Cons : T -> infseq -> infseq.\n\nDefinition hd (s:infseq) : T := match s with Cons x _ => x end.\n\nDefinition tl (s:infseq) : infseq := match s with Cons _ s => s end.\n\nLemma recons : forall s, Cons (hd s) (tl s) = s.",
      "suffix": "\n\nEnd sec_infseq.\n\nArguments Cons [T] _ _.\nArguments hd [T] _.\nArguments tl [T] _.\nArguments recons [T] _.\n\n(* --------------------------------------------------------------------------- *)\n(* Temporal logic operations *)\n\nSection sec_modal_op_defn.\n\nVariable T : Type.\n\nDefinition now (P: T->Prop) (s: infseq T) : Prop :=\n  match s with Cons x s => P x end.\n\nDefinition next (P: infseq T -> Prop) (s: infseq T) : Prop :=\n  match s with Cons x s => P s end.\n\nDefinition consecutive  (R: T -> T -> Prop) (s: infseq T) : Prop :=\n  match s with Cons x1 (Cons x2 s) => R x1 x2 end. \n\nCoInductive always1 (P: T->Prop) : infseq T -> Prop :=\n  | Always1 : forall x s, P x -> always1 P s -> always1 P (Cons x s).\n\nCoInductive always (P: infseq T->Prop) : infseq T -> Prop :=\n  | Always : forall s, P s -> always P (tl s) -> always P s.\n\nCoInductive weak_until (J P: infseq T->Prop) : infseq T -> Prop :=\n  | W0 : forall s, P s -> weak_until J P s\n  | W_tl : forall s, J s -> weak_until J P (tl s) -> weak_until J P s.\n\nInductive until (J P: infseq T->Prop) : infseq T -> Prop :=\n  | U0 : forall s, P s -> until J P s\n  | U_next : forall x s, J (Cons x s) -> until J P s -> until J P (Cons x s).\n\nCoInductive release (J P: infseq T->Prop) : infseq T -> Prop :=\n  | R0 : forall s, P s -> J s -> release J P s\n  | R_tl : forall s, P s -> release J P (tl s) -> release J P s.\n\nInductive eventually (P: infseq T->Prop) : infseq T -> Prop :=\n  | E0 : forall s, P s -> eventually P s\n  | E_next : forall x s, eventually P s -> eventually P (Cons x s).\n\nDefinition inf_often (P: infseq T->Prop) (s: infseq T) : Prop :=\n  always (eventually P) s.\n\nDefinition continuously (P: infseq T->Prop) (s: infseq T) : Prop :=  \n  eventually (always P) s.\n\n(* temporal logic connectors *)\nDefinition impl_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=\n  fun s => P s -> Q s. \nDefinition and_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=\n  fun s => P s /\\ Q s. \nDefinition or_tl (P Q: infseq T -> Prop) : infseq T -> Prop :=\n  fun s => P s \\/ Q s. \nDefinition not_tl (P : infseq T -> Prop) : infseq T -> Prop := \n  fun s => ~ P s.\n\n(* constants *)\nDefinition True_tl : infseq T -> Prop := fun _ => True.\nDefinition False_tl : infseq T -> Prop := fun _ => False.\n\nEnd sec_modal_op_defn.\n\n#[global] Hint Unfold True_tl False_tl : core.\n\nArguments now [T] _ _.\nArguments next [T] _ _.\nArguments consecutive [T] _ _.\nArguments always [T] _ _.\nArguments always1 [T] _ _.\nArguments eventually [T] _ _.\nArguments weak_until [T] _ _ _.\nArguments until [T] _ _ _.\nArguments release [T] _ _ _.\nArguments inf_often [T] _ _.\nArguments continuously [T] _ _.\n\nArguments impl_tl [T] _ _ _.\nArguments and_tl [T] _ _ _.\nArguments or_tl [T] _ _ _.\nArguments not_tl [T] _ _.\n\nArguments True_tl {T} _.\nArguments False_tl {T} _.\n\nNotation \"A ->_ B\" := (impl_tl A B) (right associativity, at level 90).\nNotation \"A /\\_ B\" := (and_tl A B) (right associativity, at level 80).\nNotation \"A \\/_ B\" := (or_tl A B) (right associativity, at level 85).\nNotation \"~_ A\" := (not_tl A) (right associativity, at level 75).\n\nSection sec_modal_op_lemmas.\n\nVariable T : Type.\n\n(* now facts *)\nLemma now_hd :\n  forall (P : T -> Prop) ex,\n    now P ex ->\n    P (hd ex).\nProof using.\n  now destruct ex.\nQed.\n\n(* always facts *)\n\nLemma always_inv :\n  forall (inv: infseq T -> Prop),\n    (forall x s, inv (Cons x s) -> inv s) -> forall s, inv s -> always inv s.\nProof using.\nintros P invP.\ncofix c.\nintros [x s] Pxs; apply Always; trivial.\napply c; apply invP in Pxs.\nassumption.\nQed.\n\nLemma always_Cons :\n  forall (x: T) (s: infseq T) P,\n  always P (Cons x s) -> P (Cons x s) /\\ always P s.\nProof using.\nintros x s P al. change (P (Cons x s) /\\ always P (tl (Cons x s))). \ndestruct al. split; assumption.\nQed.\n\nLemma always_now :\n  forall (x: T) (s: infseq T) P, always P (Cons x s) -> P (Cons x s).\nProof using.\nintros x s P al. case (always_Cons x s P al); trivial.\nQed.\n\nLemma always_now' :\n  forall (P : infseq T -> Prop) ex,\n    always P ex ->\n    P ex.\nProof using.\n  destruct ex.\n  apply always_now.\nQed.\n\nLemma always_invar :\n  forall (x: T) (s: infseq T) P, always P (Cons x s) -> always P s.\nProof using.\nintros x s P al. case (always_Cons x s P al); trivial.\nQed.\n\nLemma always_tl :\n  forall (s: infseq T) P, always P s -> always P (tl s).\nProof using.\nintros (x, s). simpl. apply always_invar. \nQed.\n\nLemma always_not_false :\n  forall s : infseq T, always (~_ False_tl) s.\nProof using.\ncofix c.\nintros [x s].\napply Always.\n- unfold not_tl, False_tl; auto.\n- apply c.\nQed.\n\nLemma always_true :\n  forall s : infseq T, always True_tl s.\nProof using.\ncofix c.\nintros [x s].\napply Always.\n- unfold True_tl; trivial.\n- apply c.\nQed.\n\nLemma always_and_tl :\n  forall (P Q : infseq T -> Prop),\n    forall s, always P s -> always Q s -> always (P /\\_ Q) s.\nProof using.\nintros P Q.\ncofix c.\nintros s alP alQ.\ndestruct alP.\ndestruct alQ.\napply Always.\n- split; assumption.\n- apply c; assumption.\nQed.\n\nLemma always_always :\n  forall (P : infseq T -> Prop) s,\n    always P s ->\n    always (always P) s.\nProof using.\n  intro P.\n  cofix c.\n  constructor.\n  - auto.\n  - do 2 destruct s.\n    constructor; eauto using always_invar.\nQed.\n\nLemma always_always1 :\n   forall P (s: infseq T), always (now P) s -> always1 P s.\nProof using.\nintros P.\ncofix alwn.\nintros s a; case a; clear a s. intros (x, s); simpl. constructor.\n- assumption.\n- apply alwn; assumption.\nQed.\n\nLemma always1_always :\n   forall P (s: infseq T), always1 P s -> always (now P) s.\nProof using.\nintros P.\ncofix alwn. destruct 1. constructor; simpl.\n- assumption.\n- apply alwn; assumption.\nQed.\n\nLemma always_weak_until :\n  forall (J P : infseq T -> Prop) (s : infseq T), always J s -> weak_until J P s.\nProof using.\nintros J P.\ncofix c.\nintros [x s] alJ.\napply W_tl.\n- apply always_now in alJ. \n  assumption.\n- apply c.\n  apply always_invar in alJ.\n  assumption.\nQed.\n\nLemma always_release :\n  forall (J P : infseq T -> Prop) (s : infseq T), always P s -> release J P s.\nProof using.\nintros J P.\ncofix c.\nintros [x s] al.\napply R_tl.\n- apply always_now in al.\n  assumption.\n- simpl.\n  apply c.\n  apply always_invar in al.\n  assumption.\nQed.\n\nLemma always_inf_often :\n   forall (P: infseq T -> Prop) (s : infseq T), always P s -> inf_often P s.\nProof using.\nintros P. cofix f. intros s a. destruct a. constructor.\n- constructor 1. assumption.\n- apply f. assumption.\nQed.\n\nLemma always_continuously :\n   forall (P: infseq T -> Prop) (s : infseq T), always P s -> continuously P s.\nProof using.\nintros P s alP.\napply E0.\nassumption.\nQed.\n\n(* weak_until and eventually facts *)\n\nLemma weak_until_Cons :\n  forall (x: T) (s: infseq T) J P,\n  weak_until J P (Cons x s) -> P (Cons x s) \\/ (J (Cons x s) /\\ weak_until J P s).\nProof using.\nintros x s J P un. \nchange (P (Cons x s) \\/ (J (Cons x s) /\\ weak_until J P (tl (Cons x s)))).\ndestruct un; intuition.\nQed.\n\nLemma weak_until_always :\n  forall (J J' P : infseq T -> Prop) s,\n    weak_until J P s ->\n    always J' s ->\n    weak_until (J' /\\_ J) P s.\nProof using.\ncofix cf.\nintros J J' P s Hweak Halways.\ndestruct s.\ninversion Hweak.\n- now eauto using W0.\n- inversion Halways.\n  eapply W_tl.\n  + now unfold and_tl.\n  + simpl. now eauto.\nQed.\n\nLemma until_weak_until :\n  forall (J P : infseq T -> Prop) (s : infseq T),\n  until J P s -> weak_until J P s.\nProof using.\nintros J P s un.\ninduction un.\n- apply W0. assumption.\n- apply W_tl; trivial.\nQed.\n\nLemma eventually_Cons :\n  forall (x: T) (s: infseq T) P,\n  eventually P (Cons x s) -> P (Cons x s) \\/ eventually P s.\nProof using.\nintros x s P al. change (P (Cons x s) \\/ eventually P (tl (Cons x s))). case al; auto.\nQed.\n\nLemma eventually_trans :\n  forall (P Q inv: infseq T -> Prop),\n  (forall x s, inv (Cons x s) -> inv s) ->\n  (forall s, inv s -> P s -> eventually Q s) ->\n  forall s, inv s -> eventually P s -> eventually Q s.\nProof using.\nintros P Q inv is_inv PeQ s invs ev. induction ev as [s Ps | x s ev IHev].\n- apply PeQ; assumption.\n- constructor 2. apply IHev. apply is_inv with x; assumption.\nQed.\n\nLemma not_eventually :\n  forall (P : infseq T -> Prop),\n  forall x s, ~ eventually P (Cons x s) -> ~ eventually P s.\nProof using.\nintros P x s evCP evP.\ncontradict evCP.\napply E_next.\nassumption.\nQed.\n\nLemma eventually_next : \n  forall (s: infseq T) P, eventually (next P) s -> eventually P s. \nProof using.\nintros e P ev. induction ev as [(x, s) Ps | x s ev induc_hyp].\n- constructor 2; constructor 1; exact Ps. \n- constructor 2. apply induc_hyp.\nQed.\n\nLemma eventually_always_cumul :\n  forall (s: infseq T) P Q,\n  eventually P s -> always Q s -> eventually (P /\\_ always Q) s.\nProof using.\ninduction 1 as [s Ps | x s evPs induc_hyp]; intro al.\n- constructor 1. split; assumption.\n- constructor 2. apply induc_hyp. eapply always_invar; eauto.\nQed.\n\nLemma eventually_weak_until_cumul :\n  forall (s: infseq T) P J,\n  eventually P s -> weak_until J P s -> eventually (P /\\_ weak_until J P) s.\nProof using.\nintros s P J ev. induction ev as [s Ps | x s evPs induc_hyp].\n- intro un. constructor 1. split; assumption.\n- intro unxs. case (weak_until_Cons _ _ _ _ unxs).\n  * intro Pxs. constructor 1; split; assumption.\n  * intros (_, uns). constructor 2. apply induc_hyp. exact uns.\nQed.\n\nLemma weak_until_eventually :\n  forall (P Q J: infseq T -> Prop),\n  (forall s, J s -> P s -> Q s) ->\n  forall s, J s -> weak_until J Q s -> eventually P s -> eventually Q s.\nProof using.\nintros P Q J impl s Js J_weak_until_Q ev.\ngenclear J_weak_until_Q; genclear Js.\ninduction ev as [s Ps | x s ev induc_hyp].\n- intros Js J_weak_until_Q. constructor 1. apply impl; assumption.\n- intros _ J_weak_until_Q. cut (s = tl (Cons x s)); [idtac | reflexivity].\n  case J_weak_until_Q; clear J_weak_until_Q x.\n  * constructor 1; assumption.\n  * intros (x, s1) _ J_weak_until_Q e; simpl in *.\n    constructor 2. generalize e J_weak_until_Q; clear e x. (* trick: keep J_weak_until_Q!! *)\n    case J_weak_until_Q; clear J_weak_until_Q s1.\n    + clearall. constructor 1; assumption.\n    + intros s2 Js2 _ e J_weak_until_Q2. rewrite e in induc_hyp; clear e.\n      apply induc_hyp; assumption.\nQed.\n\nLemma eventually_or_tl_intror :\n  forall (P Q : infseq T -> Prop) s,\n    eventually Q s ->\n    eventually (P \\/_ Q) s.\nProof using.\n  induction 1; firstorder using E0, E_next.\nQed.\n\nLemma eventually_or_tl_introl :\n  forall (P Q : infseq T -> Prop) s,\n    eventually P s ->\n    eventually (P \\/_ Q) s.\nProof using.\n  induction 1; firstorder using E0, E_next.\nQed.\n\nLemma eventually_or_tl_or :\n  forall (P Q : infseq T -> Prop) s,\n    eventually (P \\/_ Q) s ->\n    eventually P s \\/ eventually Q s.\nProof using.\n  induction 1; firstorder using E0, E_next.\nQed.\n\n(* until facts *)\n\nLemma until_Cons :\n  forall (x: T) (s: infseq T) J P,\n  until J P (Cons x s) -> P (Cons x s) \\/ (J (Cons x s) /\\ until J P s).\nProof using.\nintros x s J P ul.\nchange (P (Cons x s) \\/ (J (Cons x s) /\\ until J P (tl (Cons x s)))). case ul; auto.\nQed.\n\nLemma until_eventually :\n  forall (J P : infseq T -> Prop),\n  forall s, until J P s -> eventually P s.\nProof using.\nintros P J s unP.\ninduction unP.\n- apply E0; assumption.\n- apply E_next; assumption.\nQed.\n\n(* release facts *)\n\nLemma release_Cons :\n  forall (x: T) (s: infseq T) J P,\n  release J P (Cons x s) -> P (Cons x s) /\\ (J (Cons x s) \\/ release J P s).\nProof using.\nintros x s J P rl.\nchange (P (Cons x s) /\\ (J (Cons x s) \\/ release J P (tl (Cons x s)))).\ndestruct rl; intuition.\nQed.\n\n(* inf_often and continuously facts *)\n\nLemma inf_often_invar :\n  forall (x: T) (s: infseq T) P, inf_often P (Cons x s) -> inf_often P s.\nProof using.\nintros x s P; apply always_invar.\nQed.\n\nLemma continuously_invar :\n  forall (x: T) (s: infseq T) P, continuously P (Cons x s) -> continuously P s.\nProof using.\nintros x s P cny.\napply eventually_Cons in cny.\ncase cny; trivial.\nintro alP.\napply E0.\napply always_invar in alP; assumption.\nQed.\n\nLemma continuously_and_tl :\n  forall (P Q : infseq T -> Prop) (s : infseq T),\n  continuously P s -> continuously Q s -> continuously (P /\\_ Q) s.\nProof using.\nintros P Q s cnyP.\ninduction cnyP as [s alP|].\n- intro cnyQ.\n  induction cnyQ.\n  apply E0.\n  apply always_and_tl; trivial.\n  apply E_next.\n  apply IHcnyQ.\n  apply always_invar in alP; assumption.\n- intro cnyQ.\n  apply E_next.\n  apply IHcnyP.\n  apply continuously_invar in cnyQ; assumption.\nQed.\n\nLemma continuously_inf_often : \n  forall (P : infseq T -> Prop) (s : infseq T),\n    continuously P s -> inf_often P s.\nProof using.\nintros P.\ncofix c.\nintros s cnyP.\ninduction cnyP.\n- apply always_inf_often. assumption.\n- apply Always.\n  * apply E_next. destruct s as [s x']. apply always_now in IHcnyP. assumption.\n  * apply IHcnyP.\nQed.\n\n(* monotony *)\n\nLemma now_monotonic :\n  forall (P Q: T -> Prop), \n  (forall x, P x -> Q x) -> forall s, now P s -> now Q s.\nProof using.\nintros P Q PQ (x, s) nP; simpl. apply PQ. assumption.\nQed.\n\nLemma next_monotonic :\n  forall (P Q: infseq T -> Prop),\n  (forall s, P s -> Q s) -> forall s, next P s -> next Q s.\nProof using.\nintros P Q PQ [x s]; apply PQ.\nQed.\n\nLemma consecutive_monotonic :\n  forall (P Q: T -> T -> Prop), \n  (forall x y, P x y -> Q x y) -> forall s, consecutive P s -> consecutive Q s.\nProof using.\nintros P Q PQ (x, (y, s)) nP; simpl. apply PQ. assumption.\nQed.\n\nLemma always_monotonic :\n  forall (P Q: infseq T -> Prop),\n  (forall s, P s -> Q s) -> forall s, always P s -> always Q s.\nProof using.\nintros P Q PQ.  cofix cf. intros(x, s) a. \ngeneralize (always_Cons x s P a); simpl; intros (a1, a2). constructor; simpl.\n- apply PQ. assumption.\n- apply cf. assumption.\nQed.\n\nLemma weak_until_monotonic :\n  forall (P Q J K: infseq T -> Prop),\n  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->\n  forall s, weak_until J P s -> weak_until K Q s.\nProof using.\nintros P Q J K PQ JK.  cofix cf. intros(x, s) un.\ngeneralize (weak_until_Cons x s J P un); simpl. intros [Pxs | (Jxs, uns)].\n- constructor 1; simpl; auto.\n- constructor 2; simpl; auto.\nQed.\n\nLemma until_monotonic :\n  forall (P Q J K: infseq T -> Prop),\n  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->\n  forall s, until J P s -> until K Q s.\nProof using.\nintros P Q J K PQ JK s unJP.\ninduction unJP.\n- apply U0, PQ; assumption.\n- apply U_next.\n  * apply JK; assumption.\n  * assumption.\nQed.\n\nLemma release_monotonic :\n  forall (P Q J K: infseq T -> Prop),\n  (forall s, P s -> Q s) -> (forall s, J s -> K s) ->\n  forall s, release J P s -> release K Q s.\nProof using.\nintros P Q J K PQ JK.\ncofix cf. intros [x s] rl.\ngeneralize (release_Cons x s J P rl); simpl.\nintros [Pxs rlCJP].\ncase rlCJP; intros rlJP.\n- apply R0.\n  * apply PQ; assumption.\n  * apply JK; assumption.\n- apply R_tl.\n  * apply PQ; assumption.\n  * simpl.\n    apply cf. assumption.\nQed.\n\nLemma eventually_monotonic :\n  forall (P Q J: infseq T -> Prop), \n  (forall x s, J (Cons x s) -> J s) ->\n  (forall s, J s -> P s -> Q s) -> \n  forall s, J s -> eventually P s -> eventually Q s.\nProof using.\nintros P Q J is_inv JPQ s Js ev. \napply (eventually_trans P Q J is_inv); try assumption. \nintros; constructor 1. apply JPQ; assumption. \nQed.\n\n(* corollary which turns out to be too weak in practice *)\nLemma eventually_monotonic_simple :\n  forall (P Q: infseq T -> Prop), \n  (forall s, P s -> Q s) -> \n  forall s, eventually P s -> eventually Q s.\nProof using.\nintros P Q PQ s.\napply (eventually_monotonic P Q True_tl); auto.\nQed.\n\nLemma inf_often_monotonic :\n  forall (P Q : infseq T -> Prop),\n  (forall s, P s -> Q s) ->\n  forall s, inf_often P s -> inf_often Q s.\nProof using.\nintros P Q impl.\napply always_monotonic.\napply eventually_monotonic_simple.\nassumption.\nQed.\n\nLemma cumul_eventually_always :\n  forall (P Q : infseq T -> Prop) s,\n    always P s ->\n    eventually Q s ->\n    eventually (P /\\_ Q) s.\nProof using.\n  intros until 1.\n  intro H_eventually.\n  induction H_eventually.\n  - apply E0.\n    destruct s.\n    firstorder using always_Cons.\n  - eauto using E_next, always_invar.\nQed.\n\nLemma cumul_inf_often_always :\n  forall (P Q : infseq T -> Prop) s,\n    always P s ->\n    inf_often Q s ->\n    inf_often (P /\\_ Q) s.\nProof using.\n  intros.\n  eapply always_monotonic\n  with (P := always P /\\_ eventually Q) (Q := eventually (P /\\_ Q)).\n  - intros.\n    unfold and_tl in * |-.\n    firstorder using cumul_eventually_always.\n  - eapply always_and_tl; eauto using always_always.\nQed.\n\n(** This theorem is an analog of eventually_monotonic. *)\nLemma inf_often_monotonic_invar :\n  forall (invariant P Q : infseq T -> Prop),\n    (forall s,\n        invariant s ->\n        P s ->\n        Q s) ->\n    forall ex,\n      always invariant ex ->\n      inf_often P ex ->\n      inf_often Q ex.\nProof using.\n  intros.\n  eapply inf_often_monotonic with (P:=invariant /\\_ P).\n  - intros.\n    unfold and_tl in *; firstorder.\n  - eapply cumul_inf_often_always; eauto.\nQed.\n\nLemma continuously_monotonic :\n  forall (P Q : infseq T -> Prop),\n  (forall s, P s -> Q s) ->\n  forall s, continuously P s -> continuously Q s.\nProof using.\nintros P Q impl.\napply eventually_monotonic_simple.\napply always_monotonic.\nassumption.\nQed.\n\n(* not_tl inside operators *)\n\nLemma not_eventually_always_not :\n  forall (P : infseq T -> Prop) (s : infseq T),\n  ~ eventually P s -> always (~_ P) s.\nProof using.\nintros P.\ncofix c.\nintros s evP.\ndestruct s as [e s].\napply Always.\n* unfold not_tl.\n  intro Pn.\n  case evP.\n  apply E0.\n  assumption.\n* apply c.\n  intro evPn.\n  contradict evP.\n  apply E_next.\n  assumption.\nQed.\n\nLemma always_not_eventually :\n  forall (P : infseq T -> Prop) (s : infseq T),\n  always (~_ P) s -> ~ eventually P s.\nProof using.\nintros P.\nintros s alP evP.\ninduction evP.\n* destruct s as [e s].\n  apply always_Cons in alP.\n  destruct alP as [nP alP].\n  unfold not_tl in nP.\n  contradict nP; assumption.\n* apply always_invar in alP.\n  contradict IHevP; assumption.\nQed.\n\nLemma eventually_not_always :\n  forall (P : infseq T -> Prop) (s : infseq T),\n    eventually (~_ P) s -> ~ always P s.\nProof using.\nintros P s eP alP.\ninduction eP.\n- destruct s as [x s].\n  unfold not_tl in H.\n  contradict H.\n  apply always_Cons in alP.\n  destruct alP as [PC alP].\n  assumption.\n- apply always_invar in alP.\n  contradict IHeP.\n  assumption.\nQed.\n\nLemma weak_until_always_not_always :\n  forall (J P : infseq T -> Prop) (s : infseq T),\n  weak_until J P s -> always (~_ P) s -> always J s.\nProof using.\nintros J P.\ncofix c.\nintros s unJP alP.\ndestruct s as [e s].\napply weak_until_Cons in unJP.\ncase unJP.\n- intro PC.\n  apply always_Cons in alP.\n  destruct alP as [nP alP].\n  unfold not_tl in nP.\n  contradict nP.\n  assumption.\n- intros Jun.\n  destruct Jun as [JC unJPs].\n  apply Always; trivial.\n  apply c; trivial.\n  apply always_invar in alP.\n  assumption.\nQed.\n\nLemma weak_until_latch_eventually :\n  forall (P Q : infseq T -> Prop) ex,\n    weak_until (P /\\_ ~_ Q) (P /\\_ Q) ex ->\n    eventually Q ex ->\n    eventually (P /\\_ Q) ex.\nProof using.\n  intros P Q ex H_w.\n  induction 1;\n    inversion H_w; firstorder using E0, E_next.\nQed.\n\nLemma always_not_eventually_not :\n  forall (P : infseq T -> Prop) (s : infseq T),\n    always P s -> ~ eventually (~_ P) s.\nProof using.\nintros P s alP evP.\ninduction evP.\n- unfold not_tl in H.\n  contradict H.\n  destruct s as [x s].\n  apply always_now in alP.\n  assumption.\n- contradict IHevP.\n  apply always_invar in alP.\n  assumption.\nQed.\n\nLemma continuously_not_inf_often :\n  forall (P : infseq T -> Prop) (s : infseq T),\n  continuously (~_ P) s -> ~ inf_often P s.\nProof using.\nintros P s cnyP.\ninduction cnyP.\n- destruct s as [e s].\n  intros ifP.\n  apply always_now in ifP.\n  induction ifP.\n  * destruct s0 as [e0 s0].\n    apply always_now in H.\n    unfold not_tl in H.\n    contradict H.\n    trivial.\n  * apply always_invar in H.\n    contradict IHifP.\n    trivial.\n- intro ioP.\n  apply always_invar in ioP.\n  contradict IHcnyP.\n  trivial.\nQed.\n\nLemma inf_often_not_continuously :\n  forall (P : infseq T -> Prop) (s : infseq T),\n  inf_often (~_ P) s -> ~ continuously P s.\nProof using.\nintros P s ioP cnyP.\ninduction cnyP.\n- destruct s as [x s].\n  apply always_now in ioP.\n  induction ioP.\n  * destruct s0 as [x' s0].\n    apply always_now in H.\n    unfold not_tl in H0.\n    contradict H0.\n    assumption.\n  * apply always_invar in H.\n    contradict IHioP.\n    assumption.\n- apply inf_often_invar in ioP.\n  contradict IHcnyP.\n  assumption.\nQed.\n\nLemma release_not_until : \n  forall (J P : infseq T -> Prop) (s : infseq T),\n  release J P s -> ~ until (~_ J) (~_ P) s.\nProof using.\nintros J P s rl un.\ninduction un as [s Ps |x s Js IHun IH].\n- destruct s as [x s].\n  unfold not_tl in Ps.\n  apply release_Cons in rl.\n  destruct rl as [Psr rl].\n  contradict Ps.\n  assumption.\n- apply release_Cons in rl.\n  destruct rl as [Ps rl].\n  unfold not_tl in Js.\n  case rl; trivial.\nQed.\n\nLemma until_not_release :\n  forall (J P : infseq T -> Prop) (s : infseq T),\n  until J P s -> ~ release (~_ J) (~_ P) s.\nProof using.\nintros J P s un rl.\ninduction un.\n- destruct s as [x s].\n  apply release_Cons in rl.\n  destruct rl as [Ps rl].\n  unfold not_tl in Ps.\n  contradict Ps.\n  assumption.\n- apply release_Cons in rl.\n  destruct rl as [Ps rl].\n  case rl; trivial.\n  unfold not_tl.\n  intros Js.\n  contradict Js.\n  assumption.\nQed.\n\nLemma weak_until_not_until :\n  forall (J P : infseq T -> Prop) (s : infseq T),\n    weak_until (J /\\_ ~_ P) (~_ J /\\_ ~_ P) s -> ~ until J P s.\nProof using.\nintros J P s wu un.\ninduction un.\n- destruct s as [x s].\n  apply weak_until_Cons in wu.\n  case wu; unfold not_tl, and_tl.\n  * intros [Js Ps].\n    contradict Ps.\n    assumption.\n  * intros [[Js Ps] wun].\n    contradict Ps.\n    assumption.\n- apply weak_until_Cons in wu.\n  case wu.\n  * unfold not_tl, and_tl.\n    intros [Js Ps].\n    contradict Js.\n    assumption.\n  * intros [[Js Ps] wun].\n    contradict IHun.\n    assumption.\nQed.\n\nLemma until_not_weak_until :\n  forall (J P : infseq T -> Prop) (s : infseq T),\n    until (J /\\_ ~_ P) (~_ J /\\_ ~_ P) s -> ~ weak_until J P s.\nProof using.\nintros J P s un wun.\ninduction un as [s JPs | x s JPs IHun IH]; unfold not_tl, and_tl in JPs; destruct JPs as [Js Ps].\n- destruct s as [x s].\n  apply weak_until_Cons in wun.\n  case wun; trivial.\n  intros [JCs wu].\n  contradict Js.\n  assumption.\n- apply weak_until_Cons in wun.\n  case wun.\n  * intros PCs.\n    contradict Ps.\n    assumption.\n  * intros [JCs wu].\n    contradict IH.\n    assumption.\nQed.\n\n(* connector facts *)\n\nLemma and_tl_comm : \n  forall (P Q : infseq T -> Prop) (s : infseq T),\n  (P /\\_ Q) s <-> (Q /\\_ P) s.\nProof using.\nintros; split; unfold and_tl; apply and_comm.\nQed.\n\nLemma and_tl_assoc : \n  forall (P Q R : infseq T -> Prop) (s : infseq T),\n  ((P /\\_ Q) /\\_ R) s <-> (P /\\_ Q /\\_ R) s.\nProof using.\nintros; split; unfold and_tl; apply and_assoc.\nQed.\n\nLemma or_tl_comm :\n  forall (P Q : infseq T -> Prop) (s : infseq T),\n  (P \\/_ Q) s <-> (Q \\/_ P) s.\nProof using.\nintros; split; unfold or_tl; apply or_comm.\nQed.\n\nLemma or_tl_assoc : \n  forall (P Q R : infseq T -> Prop) (s : infseq T),\n  ((P \\/_ Q) \\/_ R) s <-> (P \\/_ Q \\/_ R) s.\nProof using.\nintros; split; unfold or_tl; apply or_assoc.\nQed.\n\nLemma not_tl_or_tl : \n  forall (P Q : infseq T -> Prop) (s : infseq T),\n  (~_ (P \\/_ Q)) s <-> ((~_ P) /\\_ (~_ Q)) s.\nProof using.\nintros P Q s; unfold not_tl, and_tl, or_tl; split; [ intros PQs | intros [Ps Qs] PQs].\n- split; intro Ps; contradict PQs; [left|right]; assumption.\n- case PQs; assumption.\nQed.\n\nLemma not_tl_or_tl_and_tl : \n  forall (P Q : infseq T -> Prop) (s : infseq T),\n    ((~_ P) \\/_ (~_ Q)) s -> (~_ (P /\\_ Q)) s.\nProof using.\nintros P Q s; unfold not_tl, and_tl, or_tl; intros PQs [Ps Qs]; case PQs; intros nPQs; contradict nPQs; assumption.\nQed.\n\nEnd sec_modal_op_lemmas.\n\nArguments always_inv [T inv] _ [s] _.\nArguments always_Cons [T x s P] _.\nArguments always_now [T x s P] _.\nArguments always_invar [T x s P] _.\nArguments always_tl [T s P] _.\nArguments always_not_false {T s}.\nArguments always_true {T s}.\nArguments always_and_tl [T P Q s] _ _.\nArguments always_always1 [T P s] _.\nArguments always1_always [T P s] _.\nArguments always_weak_until [T J P s] _.\nArguments always_release [T J P s] _.\nArguments always_inf_often [T P s] _.\nArguments always_continuously [T P s] _.\n\nArguments weak_until_Cons [T x s J P] _.\nArguments weak_until_always [T J J' P s] _ _.\nArguments until_weak_until [T J P s] _.\nArguments eventually_Cons [T x s P] _.\nArguments eventually_trans [T P Q inv] _ _ [s] _ _.\nArguments not_eventually [T P x s] _ _.\nArguments eventually_next [T s P] _.\nArguments eventually_always_cumul [T s P Q] _ _.\nArguments eventually_weak_until_cumul [T s P J] _ _.\nArguments weak_until_eventually [T P Q J] _ [s] _ _ _.\nArguments until_Cons [T x s J P] _.\nArguments until_eventually [T J P s] _.\nArguments release_Cons [T x s J P] _.\nArguments inf_often_invar [T x s P] _.\nArguments continuously_invar [T x s P] _.\nArguments continuously_and_tl [T P Q s] _ _.\nArguments continuously_inf_often [T P s] _.\n\nArguments now_monotonic [T P Q] _ [s] _.\nArguments next_monotonic [T P Q] _ [s] _.\nArguments consecutive_monotonic [T P Q] _ [s] _.\nArguments always_monotonic [T P Q] _ [s] _.\nArguments weak_until_monotonic [T P Q J K] _ _ [s] _.\nArguments until_monotonic [T P Q J K] _ _ [s] _.\nArguments release_monotonic [T P Q J K] _ _ [s] _.\nArguments eventually_monotonic [T P Q] _ _ _ [s] _ _.\nArguments eventually_monotonic_simple [T P Q] _ [s] _.\nArguments inf_often_monotonic [T P Q] _ [s] _.\nArguments continuously_monotonic [T P Q] _ [s] _.\n\nArguments not_eventually_always_not [T P s] _.\nArguments always_not_eventually [T P s] _ _.\nArguments eventually_not_always [T P s] _ _.\nArguments weak_until_always_not_always [T J P s] _ _.\nArguments always_not_eventually_not [T P s] _ _.\nArguments continuously_not_inf_often [T P s] _ _.\nArguments inf_often_not_continuously [T P s] _ _.\nArguments release_not_until [T J P s] _ _.\nArguments until_not_release [T J P s] _ _.\nArguments weak_until_not_until [T J P s] _ _.\nArguments until_not_weak_until [T J P s] _ _.\n\nArguments and_tl_comm {T P Q s}.\nArguments and_tl_assoc {T P Q R s}.\nArguments or_tl_comm {T P Q s}.\nArguments or_tl_assoc {T P Q R s}.\nArguments not_tl_or_tl {T P Q s}.\nArguments not_tl_or_tl_and_tl [T P Q s] _ _.\n\nLtac monotony := \n  match goal with \n     | [ |- now ?P ?s -> now ?Q ?s ] =>\n       apply now_monotonic\n     | [ |- next ?P ?s -> next ?Q ?s ] =>\n       apply next_monotonic\n     | [ |- consecutive ?P ?s -> consecutive ?Q ?s ] =>\n       apply consecutive_monotonic\n     | [ |- always ?P ?s -> always ?Q ?s ] =>\n       apply always_monotonic\n     | [ |- weak_until ?J ?P ?s -> weak_until ?K ?Q ?s ] =>\n       apply weak_until_monotonic\n     | [ |- until ?J ?P ?s -> until ?K ?Q ?s ] =>\n       apply until_monotonic\n     | [ |- release ?J ?P ?s -> release ?K ?Q ?s ] =>\n       apply release_monotonic\n     | [ |- ?J ?s -> eventually ?P ?s -> eventually ?Q ?s ] =>\n       apply eventually_monotonic\n     | [ |- continuously ?P ?s -> continuously ?Q ?s ] =>\n       apply continuously_monotonic\n     | [ |- inf_often ?P ?s -> inf_often ?Q ?s ] =>\n       apply inf_often_monotonic\n  end.\n",
      "theorem": "Lemma recons : forall s, Cons (hd s) (tl s) = s.",
      "ground_truth": "Proof using.\nintros s. \n(* Trick : simpl doesn't progress, you have to eat s first *)\ncase s.  simpl. reflexivity.\nQed."
    },
    {
      "split": "train-sft",
      "index": 42,
      "prefix": "(************************************************************************)\n(*         *   The Coq Proof Assistant / The Coq Development Team       *)\n(*  v      *   INRIA, CNRS and contributors - Copyright 1999-2018       *)\n(* <O___,, *       (see CREDITS file for the list of authors)           *)\n(*   \\VV/  **************************************************************)\n(*    //   *    This file is distributed under the terms of the         *)\n(*         *     GNU Lesser General Public License Version 2.1          *)\n(*         *     (see LICENSE file for the text of the license)         *)\n(************************************************************************)\n\nRequire Export Rbase.\nComments \"Lemmas used by the tactic Fourier\".\n\nOpen Scope R_scope.\n\nLemma Rfourier_lt : forall x1 y1 a:R, x1 < y1 -> 0 < a -> a * x1 < a * y1.\nintros; apply Rmult_lt_compat_l; assumption.\nQed.\n\nLemma Rfourier_le : forall x1 y1 a:R, x1 <= y1 -> 0 < a -> a * x1 <= a * y1.\nred.\nintros.\ncase H; auto with real.\nQed.\n\nLemma Rfourier_lt_lt :\n forall x1 y1 x2 y2 a:R,\n   x1 < y1 -> x2 < y2 -> 0 < a -> x1 + a * x2 < y1 + a * y2.\nintros x1 y1 x2 y2 a H H0 H1; try assumption.\napply Rplus_lt_compat.\ntry exact H.\napply Rfourier_lt.\ntry exact H0.\ntry exact H1.\nQed.\n\nLemma Rfourier_lt_le :\n forall x1 y1 x2 y2 a:R,\n   x1 < y1 -> x2 <= y2 -> 0 < a -> x1 + a * x2 < y1 + a * y2.\nintros x1 y1 x2 y2 a H H0 H1; try assumption.\ncase H0; intros.\napply Rplus_lt_compat.\ntry exact H.\napply Rfourier_lt; auto with real.\nrewrite H2.\nrewrite (Rplus_comm y1 (a * y2)).\nrewrite (Rplus_comm x1 (a * y2)).\napply Rplus_lt_compat_l.\ntry exact H.\nQed.\n\nLemma Rfourier_le_lt :\n forall x1 y1 x2 y2 a:R,\n   x1 <= y1 -> x2 < y2 -> 0 < a -> x1 + a * x2 < y1 + a * y2.\nintros x1 y1 x2 y2 a H H0 H1; try assumption.\ncase H; intros.\napply Rfourier_lt_le; auto with real.\nrewrite H2.\napply Rplus_lt_compat_l.\napply Rfourier_lt; auto with real.\nQed.\n\nLemma Rfourier_le_le :\n forall x1 y1 x2 y2 a:R,\n   x1 <= y1 -> x2 <= y2 -> 0 < a -> x1 + a * x2 <= y1 + a * y2.",
      "suffix": "\n\nLemma Rlt_zero_pos_plus1 : forall x:R, 0 < x -> 0 < 1 + x.\nintros x H; try assumption.\nrewrite Rplus_comm.\napply Rle_lt_0_plus_1.\nred; auto with real.\nQed.\n\nLemma Rlt_mult_inv_pos : forall x y:R, 0 < x -> 0 < y -> 0 < x * / y.\nintros x y H H0; try assumption.\nreplace 0 with (x * 0).\napply Rmult_lt_compat_l; auto with real.\nring.\nQed.\n\nLemma Rlt_zero_1 : 0 < 1.\nexact Rlt_0_1.\nQed.\n\nLemma Rle_zero_pos_plus1 : forall x:R, 0 <= x -> 0 <= 1 + x.\nintros x H; try assumption.\ncase H; intros.\nred.\nleft; try assumption.\napply Rlt_zero_pos_plus1; auto with real.\nrewrite <- H0.\nreplace (1 + 0) with 1.\nred; left.\nexact Rlt_zero_1.\nring.\nQed.\n\nLemma Rle_mult_inv_pos : forall x y:R, 0 <= x -> 0 < y -> 0 <= x * / y.\nintros x y H H0; try assumption.\ncase H; intros.\nred; left.\napply Rlt_mult_inv_pos; auto with real.\nrewrite <- H1.\nred; right; ring.\nQed.\n\nLemma Rle_zero_1 : 0 <= 1.\nred; left.\nexact Rlt_zero_1.\nQed.\n\nLemma Rle_not_lt : forall n d:R, 0 <= n * / d -> ~ 0 < - n * / d.\nintros n d H; red; intros H0; try exact H0.\ngeneralize (Rgt_not_le 0 (n * / d)).\nintros H1; elim H1; try assumption.\nreplace (n * / d) with (- - (n * / d)).\nreplace 0 with (- -0).\nreplace (- (n * / d)) with (- n * / d).\nreplace (-0) with 0.\nred.\napply Ropp_gt_lt_contravar.\nred.\nexact H0.\nring.\nring.\nring.\nring.\nQed.\n\nLemma Rnot_lt0 : forall x:R, ~ 0 < 0 * x.\nintros x; try assumption.\nreplace (0 * x) with 0.\napply Rlt_irrefl.\nring.\nQed.\n\nLemma Rlt_not_le_frac_opp : forall n d:R, 0 < n * / d -> ~ 0 <= - n * / d.\nintros n d H; try assumption.\napply Rgt_not_le.\nreplace 0 with (-0).\nreplace (- n * / d) with (- (n * / d)).\napply Ropp_lt_gt_contravar.\ntry exact H.\nring.\nring.\nQed.\n\nLemma Rnot_lt_lt : forall x y:R, ~ 0 < y - x -> ~ x < y.\nunfold not; intros.\napply H.\napply Rplus_lt_reg_l with x.\nreplace (x + 0) with x.\nreplace (x + (y - x)) with y.\ntry exact H0.\nring.\nring.\nQed.\n\nLemma Rnot_le_le : forall x y:R, ~ 0 <= y - x -> ~ x <= y.\nunfold not; intros.\napply H.\ncase H0; intros.\nleft.\napply Rplus_lt_reg_l with x.\nreplace (x + 0) with x.\nreplace (x + (y - x)) with y.\ntry exact H1.\nring.\nring.\nright.\nrewrite H1; ring.\nQed.\n\nLemma Rfourier_gt_to_lt : forall x y:R, y > x -> x < y.\nunfold Rgt; intros; assumption.\nQed.\n\nLemma Rfourier_ge_to_le : forall x y:R, y >= x -> x <= y.\nintros x y; exact (Rge_le y x).\nQed.\n\nLemma Rfourier_eqLR_to_le : forall x y:R, x = y -> x <= y.\nexact Req_le.\nQed.\n\nLemma Rfourier_eqRL_to_le : forall x y:R, y = x -> x <= y.\nexact Req_le_sym.\nQed.\n\nLemma Rfourier_not_ge_lt : forall x y:R, (x >= y -> False) -> x < y.\nexact Rnot_ge_lt.\nQed.\n\nLemma Rfourier_not_gt_le : forall x y:R, (x > y -> False) -> x <= y.\nexact Rnot_gt_le.\nQed.\n\nLemma Rfourier_not_le_gt : forall x y:R, (x <= y -> False) -> x > y.\nexact Rnot_le_lt.\nQed.\n\nLemma Rfourier_not_lt_ge : forall x y:R, (x < y -> False) -> x >= y.\nexact Rnot_lt_ge.\nQed.\n",
      "theorem": "Lemma Rfourier_le_le :\n forall x1 y1 x2 y2 a:R,\n   x1 <= y1 -> x2 <= y2 -> 0 < a -> x1 + a * x2 <= y1 + a * y2.",
      "ground_truth": "intros x1 y1 x2 y2 a H H0 H1; try assumption.\ncase H0; intros.\nred.\nleft; try assumption.\napply Rfourier_le_lt; auto with real.\nrewrite H2.\ncase H; intros.\nred.\nleft; try assumption.\nrewrite (Rplus_comm x1 (a * y2)).\nrewrite (Rplus_comm y1 (a * y2)).\napply Rplus_lt_compat_l.\ntry exact H3.\nrewrite H3.\nred.\nright; try assumption.\nauto with real.\nQed."
    },
    {
      "split": "train-sft",
      "index": 43,
      "prefix": "(**\nn\u4e57\u306e\u548c\u306e\u56e0\u6570\u5206\u89e3\u516c\u5f0f\n\n(factorization formula for the sum of powers n)\n===================\n\n@suharahiromichi\n\n2023/07/01\n*)\nFrom mathcomp Require Import all_ssreflect.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\n(**\n# \u306f\u3058\u3081\u306b\n\n\u306a\u3093\u306e\u5f79\u306b\u7acb\u3064\u304b\u308f\u304b\u308a\u307e\u305b\u3093\u304c $ a ^ k + 1 $ \u306e\u56e0\u6570\u5206\u89e3\u3092\u8003\u3048\u3066\u307f\u307e\u3059\u3002\n\n$ a ^ k - b ^ k $ \u306e\u56e0\u6570\u5206\u89e3\u306f\u9ad8\u6821\u3067\u7fd2\u3063\u305f\u901a\u308a\u4ee5\u4e0b\u3067\u3059\u3002\n\n```math\na ^ k - b ^ k = (a - b) \\ \\sum_{i=0}^{k - 1} (a^i \\ b^{k - 1 - i})\n```\n\n\u3053\u308c\u306f\u3001MathComp\u306e\u30c7\u30a3\u30d5\u30a9\u30eb\u30c8\u3067\u3042\u308b\u81ea\u7136\u6570\u306e\u7bc4\u56f2\u3067\u53ef\u80fd\u3067\u3042\u308a\u3001\n``binomial.v`` \u3067\u8a3c\u660e\u3055\u308c\u3066\u3044\u307e\u3059\u3002\n*)\n\nCheck subn_exp : forall a b k : nat,\n    a ^ k - b ^ k = (a - b) * (\\sum_(i < k) a ^ (k.-1 - i) * b ^ i).\n\n(**\n\u3053\u308c\u306e\u5de6\u8fba\u306e``-``\u3092``+``\u306b\u5909\u3048\u305f\u3001$a ^ k + b ^ k$\u306f\u3001\nk\u304c\u5947\u6570\uff08\u5b9f\u969b\u306b\u306f\u5947\u6570\u3067\u5272\u308a\u5207\u308c\u308b\u6570\uff09\u306e\u5834\u5408\u306b\u3060\u3051\u56e0\u6570\u5206\u89e3\u3067\u304d\u307e\u3059\u3002\n\u307e\u305f\u3001a\u304c\u5947\u6570\u4e57\u306e\u9805\u304c``-``\u306b\u306a\u308b\u305f\u3081\u3001\u81ea\u7136\u6570\u306e\u7bc4\u56f2\u3067\u306f\u8a3c\u660e\u3067\u304d\u307e\u305b\u3093\u3002\n\u81ea\u7136\u6570 k \u304c\u5947\u6570\u3067\u3001b \u304c 0 \u306e\u5834\u5408\u306a\u3089\u3070\u3001\u56e0\u6570\u5206\u89e3\u3067\u304d\u308b\u3053\u3068\u3092\u8a3c\u660e\u3067\u304d\u308b\u308f\u3051\u3067\u3059\u3002\n\n```math\nforall k : nat, a ^ k + 1 = (a + 1) \\ \\sum_{i=0}^{k - 1} a^i\n```\n\n\u3053\u306e\u8a18\u4e8b\u306e\u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u306f\u4ee5\u4e0b\u306b\u3042\u308a\u307e\u3059\u3002\n\n``https://github.com/suharahiromichi/coq/blob/master/math/ssr_factor_sum_of_power.v``\n*)\n\n(**\n# \u88dc\u984c\n\n\u03a3\uff08\u7dcf\u548c\uff09\u306e\u5f0f\u3092\u6271\u3046\u3068\u304d\u306b\u3001``\\bigop``\u306e\u88dc\u984c\u3092\u76f4\u63a5\u4f7f\u3063\u3066\u3082\u3088\u3044\u3067\u3059\u304c\u3001\n\u308f\u304b\u308a\u3084\u3059\u3055\u306e\u305f\u3081\u306b\u3001``\\sum`` \u306b\u3064\u3044\u3066\u8a3c\u660e\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n\n## ``a_n``\u9805\u3092\u53d6\u308a\u51fa\u3059\u3002\n\n$$ \\sum_{i=n}^{n}a_i = a_n $$\n\n\u7dcf\u548c\u3092\u3068\u308b\u7bc4\u56f2\u304c\u3072\u3068\u3064\u306e\u9805\u306e\u5834\u5408\uff08n\u4ee5\u4e0an\u4ee5\u4e0b\uff09\u306f\u3001``a n`` \u3068\u306a\u308a\u307e\u3059\u3002\n *)\n  Lemma sum_nat1 n a :\n    \\sum_(n <= i < n.+1)(a i) = a n.\n  Proof. by rewrite big_nat1. Qed.\n\n(**\n## \u6700\u5f8c\u306e\u9805\u3092\u03a3\u306e\u5916\u306b\u51fa\u3059\u3002\n\nn(\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306e\u4e0a\u9650)\u306b\u3064\u3044\u3066\u306e\u5e30\u7d0d\u6cd5\u3068\u7d44\u307f\u5408\u308f\u305b\u3066\u4f7f\u3044\u307e\u3059\u3002\n\n$$ \\sum_{i=m}^{n}a_i = \\sum_{i=m}^{n-1}a_i + a_n $$\n *)\n  Lemma sum_last m n a :\n    m <= n ->\n    \\sum_(m <= i < n.+1)(a i) = \\sum_(m <= i < n)(a i) + a n.\n  Proof.\n    move=> Hmn.\n    by rewrite big_nat_recr.\n  Qed.\n\n(**\n## \u88dc\u984c\n\n\u6b21\u306b\u3001\u5f0f\u306e\u6574\u7406\u306b\u5fc5\u8981\u306a\u88dc\u984c\u3092\u8a3c\u660e\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n*)\nLemma a1_exp a k : 0 < a ->\n                   a ^ k.+2 - a ^ k = a.+1 * (a ^ k.+1 - a ^ k).\nProof.\n  move=> Ha.\n  rewrite -[in RHS]addn1.\n  rewrite mulnDl 2!mulnBr.\n  rewrite -2!expnS 2!mul1n.\n  rewrite addnBA; last rewrite leq_pexp2l //=.\n  rewrite subnK; last rewrite leq_pexp2l //=.\n  done.\nQed.\n\n(**\n# ``k = 2 n + 1`` \u306e\u5834\u5408\u306e\u8a3c\u660e\n\n\u8a3c\u660e\u3057\u305f\u3044\u3082\u306e\u306f\u4ee5\u4e0b\u3067\u3059\u304c\u3001\u8aac\u660e\u3092\u88dc\u8db3\u3059\u308b\u3053\u3068\u3002\n*)\nLemma addn1_exp_2n1 a n : 0 < a ->\n                      (a ^ n.*2.+1).+1 = a.+1 * (\\sum_(0 <= i < n.+1) (a ^ i.*2 - a ^ i.*2.-1)).+1.\nProof.\n  elim: n => [| n IHn] Ha.\n  - rewrite double0 expn1 sum_nat1 double0 expn0.\n    have -> : (1 - 1).+1 = 1 by done.\n    by rewrite muln1.\n  - rewrite sum_last //.\n    rewrite -addSn mulnDr -IHn //.\n    rewrite addSn.\n    congr _.+1.\n    (* a ^ n.+1.*2.+1 = a ^ n.*2.+1 + (a + 1) * (a ^ n.+1.*2 - a ^ n.+1.*2.-1) *)\n    rewrite [in a ^ n.+1.*2]doubleS [in a ^ n.+1.*2.-1]doubleS.\n    rewrite -a1_exp //.\n    rewrite [n.*2.+2.-1]/= doubleS.\n    rewrite subnKC //.\n    rewrite leq_pexp2l //.\n    rewrite -{1}[n.*2]addn0 -addn3.\n    by rewrite ltn_add2l.\nQed.\n\n(**\n# \u5fdc\u7528 1\n\n\u5fdc\u7528\u3068\u3057\u3066\u3001k\u304c\u5947\u6570\u306e\u6642\u3001$a^k + 1$ \u304c $a + 1$ \u3067\u5272\u308a\u5207\u308c\u308b\u3053\u3068\u3092\u8a3c\u660e\u3057\u307e\u3059\u3002\n\n\u307e\u305a\u3001$2 \\ n + 1$ \u3067\u8a3c\u660e\u3057\u305f\u306e\u3061\u3001\u3064\u3044\u3067\u3001$k = 2 \\ n + 1$ \u3067\u8a3c\u660e\u3057\u307e\u3059\u3002\n*)\n\nLemma dvd_exp_2n1 a n :\n  0 < a -> a.+1 %| (a ^ n.*2.+1).+1.\nProof.\n  move=> Ha.\n  rewrite addn1_exp_2n1 //.\n  by apply: dvdn_mulr.\nQed.\n\nLemma dvd_exp_odd a k :\n  0 < a -> odd k -> a.+1 %| (a ^ k).+1.",
      "suffix": "\n\n\n(**\n# \u5fdc\u7528 2\n\n\u3082\u3046\u3072\u3068\u3064\u306e\u5fdc\u7528\u3068\u3057\u3066\u3001\n\n$2 ^ n + 1$ \u304c\u7d20\u6570\u306e\u3068\u304d\u3001$n$\u306f2\u306e\u7d2f\u4e57\u3067\u3042\u308b\u3002\n\n\u3053\u308c\u306e\u5bfe\u5076\u3092\u8a3c\u660e\u3057\u3066\u307f\u307e\u3059\u3002\u3059\u306a\u308f\u3061\u3001\n\n$n$\u304c2\u306e\u7d2f\u4e57\u3067\u306a\u3044\uff08\u5947\u6570\u3092\u56e0\u6570\u306b\u6301\u3064\uff09\u3068\u304d\u3001$2 ^ n + 1$\u306f\u5408\u6210\u6570\uff08\u3075\u305f\u3064\u306e\u81ea\u7136\u6570\u306e\u7a4d\uff09\u3067\u3042\u308b\u3002\n*)\nLemma expS_composite n : forall (a b : nat),\n    0 < a -> n = (2 ^ a) * b.*2.+1 ->\n    (exists p q : nat, 1 < p -> 1 < q -> (2 ^ n).+1 = p * q).\nProof.\n  move=> a b Ha ->.\n  have -> : 2 ^ ((2 ^ a) * b.*2.+1) = (2 ^ (2 ^ a)) ^ b.*2.+1 by rewrite expnM.\n  set x := 2 ^ (2 ^ a).\n  have Ho : odd b.*2.+1 by rewrite oddS odd_double.\n  have Hx : 0 < x  by rewrite expn_gt0 //.\n  exists x.+1.\n  exists (\\sum_(0 <= i < b.+1) (x ^ i.*2 - x ^ i.*2.-1)).+1.\n  by rewrite addn1_exp_2n1.\nQed.\n\n(**\n# \u4f7f\u308f\u306a\u304b\u3063\u305f\u88dc\u984c\n*)\n\nLemma l_odd_doublenS  k : odd k -> k = k./2.*2.+1.\nProof.\n  move=> Hk.\n  by rewrite odd_halfK // (@ltn_predK 0) // odd_gt0.\nQed.\n\nLemma ltnSSn n : n < n.+2.\nProof.\n  by apply: (ltn_trans (_ : n < n.+1)); first rewrite ltnSn //.\nQed.\n\nLemma ltnSSSn n : n < n.+3.\nProof.\n  apply: (ltn_trans (_ : n < n.+1)); first rewrite ltnSn //.\n  by apply: ltnSSn.\nQed.\n\n(* END *)\n",
      "theorem": "Lemma dvd_exp_odd a k :\n  0 < a -> odd k -> a.+1 %| (a ^ k).+1.",
      "ground_truth": "Proof.\n  move=> Ha Hk.\n  rewrite -[k]odd_double_half Hk add1n.  \n  by apply: dvd_exp_2n1.\nQed."
    },
    {
      "split": "train-sft",
      "index": 44,
      "prefix": "(* ***** examples: intuitionistic logic ***** *)\n\n(* The logical connectives for true, false, conjunction,\ndisjunction are defined by means of inductive predicates.\nRoughly the constructors correspond to the introduction\nrules, and the induction principle corresponds to the\nelimination rules. *)\n\nPrint True.\n(* True_ind states that P holds if we can prove True from it *)\nCheck True_ind.\n\nPrint False.\n(* False_ind gives the elimination rule for False:\nany P follows from False *)\nCheck False_ind.\n\nParameters A B C : Prop.\nLemma about_false: False -> A.\n\nProof.\nintro x.\nelim x.\n(* alternative:\nelimtype False.\nassumption.      *)\n(* alternative:\napply False_ind.\nassumption.      *)\nQed.\n\nPrint and.\nCheck and_ind.\n\nLemma about_intro_and : A -> B -> A /\\ B.",
      "suffix": "\n\nLemma about_elim_and : A /\\ B -> C -> A.\n(* elim or apply and_ind *)\n\nProof.\nintros x y.\napply and_ind with A B.\nintros.\nassumption.\nassumption.\nQed.\n\n\n(* ***** examples: even ***** *)\n\n(* an inductive definition of even *)\nInductive even : nat -> Prop :=\n| evenO : even O\n| evenSS : forall n:nat , even n -> even (S (S n)).\n\nCheck evenO.\nCheck (even O).\nCheck (even 1).\nCheck (evenSS O evenO).\nCheck (even 2).\nCheck (evenSS 2 (evenSS O evenO)).\nCheck (even 4).\n\n(* example *)\nTheorem evenzero : (even O).\n\nProof.\napply evenO.\nQed.\n\n(* example *)\nTheorem evenss : forall n:nat , (even n) -> (even (S (S n))).\n\nProof.\nintro n.\nintro H.\napply evenSS.\nexact H.\nQed.\n\n(*\nalternative proof:\nintro n.\nintro H.\napply evenSS.\nexact H.\nQed.\n*)\n\n\n(* ***** examples: le ***** *)\n\nInductive le (n:nat) : nat -> Prop :=\n| le_n : le n n\n| le_S : forall m:nat , le n m -> le n (S m).\n\n\nCheck (le 0).\nCheck (le 0 0). (* a type, which can be regarded as a\n  proposition. We don't know whether the proposition\n  is true or false yet. *)\nCheck (le_n 0). (* a value of the above type, which can\n  be regarded as a proof that the above proposition\n  is true. *)\nCheck (le 5 10).\nCheck (le_n 100).\nCheck (le_S 0 0 (le_n 0)).\nDefinition zero_smaller_than_one := (le_S 0 0 (le_n 0)).\nCheck zero_smaller_than_one.\nCheck (le_n 7).\n\n(* We claim that zero is smaller than two.\n  This is equivalent to giving a declaration of an\n  identifier with the appropriate type.\n\n  The proof of the claim is to give a value that has\n  exactly this type.\n*)\nLemma zero_smaller_than_two : le 0 (S (S 0)).\nProof.\napply le_S.\napply le_S.\napply le_n.\nQed.\n\n(* what did we just do?\nto prove: the type le 0 (S (S 0)) is inhabited\n\n  last step in the proof: this is an axiom\nle_n 0 : le 0 0\n  because we know now that le_n is of type le 0 0, we can give this value as\n  the second argument of the constructor of le_S.\nle_S 0 (le_n 0) : le 0 (S 0)\n  We have just proved that the *value* le_S 0 (le_n 0) is of *type* le 0 (S 0).\n  As the last step, we apply the constructor le_S again.\nle_S (S 0) (le_S 0 (le_n 0) : le 0 (S (S 0))\n*)\n\n\n(* Question: can we give a data-type \"ancestor\"? *)\nInductive ancestor (n:nat) : nat -> Prop :=\n    (* the successor of a number is an ancestor of that number *)\n  | anc_S : ancestor n (S n)\n    (* the ancestor of the sucessor of n is also an ancestor of n*)\n  | anc_anc : forall m:nat , ancestor n m -> ancestor n (S m)\n  .\n\nCheck ancestor 100 0.\nCheck anc_S 0.\n\nCheck ancestor 1 0.\nCheck anc_anc 0 0.\n\n(*\nLemma no_number_is_its_own_ancestor : forall m:nat , not (ancestor m m).\nProof.\nunfold not.\nintro m.\nelim m.\nintro.\n\nQed.\n*)\n\n(* examples: sorted *)\n\n(* an inductive type for finite lists of natural numbers *)\nInductive natlist : Set :=\n| nil : natlist\n| cons : nat -> natlist -> natlist.\n\n(* an inductive predicate sorted *)\nInductive sorted : natlist -> Prop :=\n| sorted0 : sorted nil (* the empty list is sorted *)\n| sorted1 : forall n:nat , sorted (cons n nil) (* the singleton list is sorted *)\n(* if n < h\n  and cons h t is sorted\n then cons n (cons h t) is sorted. *)\n| sorted2 : forall n h:nat , forall t:natlist ,\n            le n h -> sorted (cons h t) -> sorted (cons n (cons h t)).\n\nCheck (sorted1 1).\nDefinition list_one_sorted := (sorted1 1).\nCheck list_one_sorted.\nCheck (sorted2 O 1 nil zero_smaller_than_one list_one_sorted).\nDefinition list_zero_one_sorted := (sorted2 O 1 nil zero_smaller_than_one list_one_sorted).\nCheck list_zero_one_sorted.\n\n\n\n\n(* ***** examples: inversion ***** *)\nParameter P : nat -> Prop.\nParameter Q : nat -> nat -> Prop.\nParameter R : natlist -> Prop.\n\nLemma one : forall n : nat, even n -> P n.\n\nProof.\nintros n H.\napply even_ind.\ninversion H.\nAbort.\n\nLemma two : forall n m : nat, le n m -> Q n m.\n\nintros n m H.\ninversion H.\nAbort.\n\nLemma three : forall l : natlist, sorted l -> R l.\n\nProof.\nintros l H.\ninversion H.\nAbort.\n\n\n\n(* *************** now the exercises start ********** *)\n(* *************** we use definition given above **** *)\n\n(* exercise 1 *)\nTheorem even2 : (even 2 ).\nProof.\napply evenSS.\napply evenO.\nQed.\n\n(* a few checks *)\nCheck evenO.\nCheck evenzero.\nPrint evenzero.\nCheck evenSS.\nCheck even2.\nPrint even2.\n\n(* exercise 2\n   use inversion *)\nTheorem noteven1 : ~(even 1).\nProof.\nintro.\ninversion H.\nQed.\n\n(* exercise 3\n   you may want to use an earlier proved result *)\nTheorem even4 : even 4.\nProof.\napply evenSS.\napply even2.\nQed.\n\n(* exercise 4 *)\nTheorem noteven3 : ~(even 3).\nProof.\nintro.\ninversion H.\napply noteven1.\nassumption.\nQed.\n\n(* an inductive definition of even and odd *)\nInductive ev : nat -> Prop :=\n| evO : ev O\n| evS : forall n:nat , odd n -> ev (S n)\nwith odd : nat -> Prop :=\n| oddS : forall n:nat , ev n -> odd (S n).\n\n(* example *)\nTheorem evzero : ev O.\nProof.\nexact evO.\nQed.\n\n(* example *)\nTheorem odd1 : odd 1.\nProof.\nexact (oddS O evzero).\nQed.\n\n(* exercise 5 *)\nTheorem ev2 : ev 2.\nProof.\napply evS.\napply odd1.\nQed.\n\n(* exercise 6 *)\nTheorem notodd2 : ~ odd 2.\nProof.\nintro.\ninversion H.\ninversion H1.\ninversion H3.\nQed.\n\n(* exercise 7\n   use induction *)\nTheorem evorodd : forall n:nat, ev n \\/ odd n.\nProof.\nintro.\ninduction n.\nleft.\nexact evO.\ninversion IHn.\nright.\napply oddS.\nassumption.\nleft.\napply evS.\nassumption.\nQed.\n\n(* exercise 8 *)\nTheorem zero_and_zero : le O O.\nProof.\nexact (le_n 0).\nQed.\n\n(* exercise 9 *)\nTheorem zero_and_one  : le 0 1.\nProof.\nexact (le_S 0 0 zero_and_zero).\nQed.\n\n(* some checks *)\nPrint zero_and_one.\nCheck zero_and_one.\n\n(* exercise 10 *)\nTheorem one_and_zero : ~ (le 1 0).\nProof.\nintro.\ninversion H.\nQed.\n\n\n(* exercise 11 *)\nTheorem sortednil : sorted nil.\nProof.\nexact sorted0.\nQed.\n\n\n(* exercise 12 *)\nTheorem sortedone : sorted (cons 0 nil).\nProof.\nPrint sorted.\nexact (sorted1 0).\nQed.\n\n(* exercise 13 *)\nTheorem sorted_one_two_three :\n  sorted (cons 1 (cons 2 (cons 3 nil))).\nProof.\nPrint sorted.\napply sorted2.\nLemma le_succ : forall n , le n (S n).\nProof.\nintro.\napply le_S.\napply le_n.\nQed.\napply le_succ.\napply sorted2.\napply le_succ.\napply sorted1.\nQed.\n\n(* exercise 14 *)\nTheorem sorted_tail :\n  forall (n : nat) (l : natlist),\n  sorted (cons n l) ->\n  sorted l.\nProof.\nintros.\ninversion H.\nexact sorted0.\nassumption.\nQed.\n\n(* given for exercise 15\n   without_last n k l holds if\n   n is the last element of k\n   and\n   l is k without the last element *)\nInductive without_last (n:nat) : natlist -> natlist -> Prop :=\n| without_last_one :\n  without_last n (cons n nil) nil\n| without_last_more :\n    forall m:nat, forall l k : natlist,\n    without_last n k l -> without_last n (cons m k) (cons m l).\n\n(* exercise 15 *)\n(* define a predicate palindrome : natlist -> Prop\n   that holds exactly if the input list is equal to its reverse.\n   use three clauses: for the empty list, for a list of one\n   element, for a list of two or more elements *)\n\nInductive palindrome : natlist -> Prop :=\n  | pali_nil : palindrome nil\n  | pali_one : forall n:nat, palindrome (cons n nil)\n  | pali_more : forall n:nat, forall l k:natlist,\n        without_last n k l -> palindrome l -> palindrome (cons n k)\n  .\n\n  (* l ++  [n]   and  l is a palindrome, then    n : k      is a palindrome\n     |-- k --|                                n : l ++ [n]*)\n\n(*\nvim: filetype=coq\n*)\n",
      "theorem": "Lemma about_intro_and : A -> B -> A /\\ B.",
      "ground_truth": "Proof.\nintro x.\nintro y.\nsplit.\nassumption.\nassumption.\n(* alternative:\napply conj.\nassumption.\nassumption.      *)\nQed."
    },
    {
      "split": "train-sft",
      "index": 45,
      "prefix": "(* Notation *)\nNotation \"\u2200 x .. y , P\" := (forall x, .. (forall y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' \u2200 x .. y ']' , '/' P ']'\") : type_scope.\n\nNotation \"\u2203 x .. y , P\" := (exists x, .. (exists y, P) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' \u2203 x .. y ']' , '/' P ']'\") : type_scope.\n\nNotation \"x \u2228 y\" :=\n  (x \\/ y) (at level 85, right associativity) : type_scope.\n\nNotation \"x \u2227 y\" :=\n  (x /\\ y) (at level 80, right associativity) : type_scope.\n\nNotation \"\u00ac x\" := (~x) (at level 75, right associativity) : type_scope.\n\nNotation \"x \u2192 y\" := (x -> y)\n  (at level 99, y at level 200, right associativity): type_scope.\n\nNotation \"x \u2194 y\" :=\n  (x <-> y) (at level 95, no associativity): type_scope.\n\nNotation \"x \u2260 y\" := (x <> y) (at level 70) : type_scope.\n\nNotation \"'\u03bb' x .. y , t\" := (fun x => .. (fun y => t) ..)\n  (at level 200, x binder, y binder, right associativity,\n  format \"'[ ' '[ ' '\u03bb' x .. y ']' , '/' t ']'\").\n\n(* Logic *)\nAxiom classic : \u2200 P : Prop, P \u2228 \u00acP.\n\nProposition NNPP : \u2200 P, (\u00ac (\u00ac P) \u2194 P).\nProof. intros; destruct (classic P); tauto. Qed.\n\nProposition inp : \u2200 P Q : Prop, (P \u2194 Q) \u2192 (\u00ac P \u2192 \u00ac Q).\nProof. intros; intro. elim H0. apply H; auto. Qed.\n\nParameter Class : Type.\n\nParameter In : Class \u2192 Class \u2192 Prop.\nNotation \"a \u2208 A\" := (In a A)(at level 70).\nNotation \"a \u2209 A\" := (\u00ac (a \u2208 A))(at level 70).\n\nParameter Classifier : \u2200 P : Class \u2192 Prop, Class.\nNotation \"\\{ P \\}\" := (Classifier P)(at level 0).\n\n(* Axiom and Ensemble *)\nAxiom ExtAx : \u2200 A B : Class, A = B \u2194 (\u2200 x, x \u2208 A \u2194 x \u2208 B).\nLtac AppE := apply ExtAx; split; intros.\n\nDefinition Ensemble x : Prop := \u2203 y, x \u2208 y.\nLtac Ens := unfold Ensemble; eauto.\n\nAxiom ClaAx : \u2200 x P, x \u2208 \\{ P \\} \u2194 Ensemble x \u2227 (P x).\n\nFact ClaI : \u2200 x (P : Class \u2192 Prop), Ensemble x \u2192 P x \u2192 x \u2208 \\{ P \\}.\nProof. intros * Hx HP. apply ClaAx; auto. Qed.\n\nFact ClaE : \u2200 x (P : Class \u2192 Prop), x \u2208 \\{ P \\} \u2192 Ensemble x \u2227 P x.\nProof. intros * Hx. apply ClaAx; auto. Qed.\n\nDefinition NoEmpty A := \u2203 x, x \u2208 A.\nNotation \"\u29bf A\" := (NoEmpty A) (at level 45).\n\nDefinition Empty := \\{ \u03bb x, x \u2260 x \\}.\nNotation \" \u2205 \" := Empty.\n\nFact EmptyNI : \u2200 x, x \u2209 \u2205.\nProof. intros x H. apply ClaE in H. apply H; auto. Qed.\nLtac exfalso0 := exfalso; eapply EmptyNI; eauto.\n\nFact EmptyEq : \u2200 x, x = \u2205 \u2194 \u00ac (\u29bf x).\nProof.\n  split; intros. subst x. intro. destruct H. exfalso0.\n  AppE. elim H. exists x0; auto. exfalso0.\nQed.\n\nFact EmptyNE : \u2200 x, x \u2260 \u2205 \u2194 \u29bf x.\nProof.\n  intros. pose proof EmptyEq. split; intros.\n  - apply inp with (Q := \u00ac (\u29bf x)) in H0; auto.\n    apply -> NNPP in H0; auto.\n  - intro. apply H in H1; auto.\nQed.\n\nDefinition \u03bc := \\{ \u03bb x, x = x \\}.\n\nFact \u03bc_En : \u2200 x, x \u2208 \u03bc \u2194 Ensemble x.",
      "suffix": "\n\nDefinition Singleton x := \\{ \u03bb z, x \u2208 \u03bc \u2192 z = x \\}.\nNotation \"[ x ]\" := (Singleton x) (at level 0, right associativity).\n\nFact SingI : \u2200 x, Ensemble x \u2192 x \u2208 [x].\nProof. intros. apply ClaI; auto. Qed.\n\nFact SingE : \u2200 x y, Ensemble x \u2192 y \u2208 [x] \u2192 y = x.\nProof.\n  intros. apply ClaE in H0 as []. apply H1. apply \u03bc_En; auto.\nQed.\n\nDefinition Included A B := \u2200 x, x \u2208 A \u2192 x \u2208 B.\nNotation \"A \u2282 B\" := (Included A B)(at level 70).\n\nFact ReSyTrP : \u2200 A B C,\n  (A \u2282 A) \u2227 (A \u2282 B \u2192 B \u2282 A \u2192 A = B) \u2227 (A \u2282 B \u2192 B \u2282 C \u2192 A \u2282 C).\nProof.\n  intros. split. intros x; auto. split; intros.\n  - AppE; auto. - intros x Hx. apply H in Hx. auto.\nQed.\n\nAxiom SubAx : \u2200 x, Ensemble x \u2192\n  \u2203 y, Ensemble y \u2227 (\u2200 z, z \u2282 x \u2192 z \u2208 y).\n\nFact SubAxI : \u2200 x z, Ensemble x \u2192 z \u2282 x \u2192 Ensemble z.\nProof. intros. apply SubAx in H as [y []]. Ens. Qed.\n\nDefinition PowerSet X := \\{ \u03bb A, A \u2282 X \\}.\nNotation \" cP( X )\" := (PowerSet X)(at level 9, right associativity).\n\nFact PowerIE : \u2200 X Y, Ensemble X \u2192 Y \u2208 cP(X) \u2194 Y \u2282 X.\nProof.\n  intros. split; intros. apply ClaE in H0; tauto.\n  apply ClaI; auto. eapply SubAxI; eauto.\nQed.\n\nFact PowerP : \u2200 X, Ensemble X \u2192 Ensemble cP(X) \u2227\n  (\u2200 Y, Y \u2282 X \u2194 Y \u2208 cP(X)).\nProof.\n  intros. split.\n  - pose proof H as H'. apply SubAx in H as [B [Hbe Hb]].\n    assert (cP(X) \u2282 B). { intros z Hz. apply PowerIE in Hz; auto. }\n    clear H'. eapply SubAxI; eauto.\n  - split; intros. apply PowerIE; auto. apply PowerIE in H0; auto.\nQed.\n\nFact SingEn : \u2200 x, Ensemble x \u2192 Ensemble [x].\nProof.\n  intros. assert ([x] \u2282 cP(x)).\n  { intros z Hz. apply SingE in Hz; auto. subst.\n    apply PowerIE; auto. intros z; auto. }\n  apply PowerP in H as []; auto. eapply SubAxI; eauto.\nQed.\n\nDefinition Union A B := \\{ \u03bb x, x \u2208 A \u2228 x \u2208 B \\}.\nNotation \"A \u22c3 B\" := (Union A B)(at level 65, right associativity).\n\nFact UnionIE : \u2200 x A B, x \u2208 A \u2228 x \u2208 B \u2194 x \u2208 (A \u22c3 B).\nProof.\n  intros. split; intros. destruct H as []; apply ClaI; Ens.\n  apply ClaE in H. tauto.\nQed.\n\nFact UnionNE : \u2200 x A B, x \u2209 A \u22c3 B \u2192 x \u2209 A /\\ x \u2209 B.\nProof. intros. split; intro; elim H; apply UnionIE; auto. Qed.\n\nFact Idem : \u2200 A, A \u22c3 A = A.\nProof.\n  intros. AppE. apply UnionIE in H. tauto. apply UnionIE; auto.\nQed.\n\nFact Commu : \u2200 A B, A \u22c3 B = B \u22c3 A.\nProof. intros. AppE; apply UnionIE in H; apply UnionIE; tauto. Qed.\n\nFact EmUnion : \u2200 A, A \u22c3 \u2205 = A.\nProof.\n  intros. AppE. apply UnionIE in H as []; auto.\n  exfalso0. apply UnionIE; Ens.\nQed.\n\nAxiom UnionAx : \u2200 X Y, Ensemble X \u2192 Ensemble Y \u2192 Ensemble (X \u22c3 Y).\n\nDefinition Inter A B := \\{ \u03bb x, x \u2208 A \u2227 x \u2208 B \\}.\nNotation \"A \u2229 B\" := (Inter A B)(at level 60, right associativity).\n\nFact InterIE : \u2200 x A B, x \u2208 A \u2227 x \u2208 B \u2194 x \u2208 (A \u2229 B).\nProof.\n  intros. split; intros. apply ClaI; auto. destruct H; Ens.\n  apply ClaE in H. tauto.\nQed.\n\nFact Idem' : \u2200 A, A \u2229 A = A.\nProof.\n  intros. AppE. apply InterIE in H; tauto. apply InterIE; auto.\nQed.\n\nFact Commu' : \u2200 A B, A \u2229 B = B \u2229 A.\nProof. intros. AppE; apply ClaE in H; apply ClaI; tauto. Qed.\n\nFact EmInter : \u2200 A, A \u2229 \u2205 = \u2205.\nProof. intros. AppE. apply InterIE in H; tauto. exfalso0. Qed.\n\nFact Distribu : \u2200 A B C, (A \u22c3 B) \u2229 C = (A \u2229 C) \u22c3 (B \u2229 C).\nProof.\n  intros. AppE; apply ClaI; Ens.\n  - apply InterIE in H as []. apply UnionIE in H as [H|H].\n    left; apply InterIE; tauto. right; apply InterIE; tauto.\n  - apply UnionIE in H as []; apply InterIE in H as [];\n    split; auto; apply ClaI; auto; Ens.\nQed.\n\nFact DistribuLI : \u2200 A B C, A \u2229 (B \u22c3 C) = A \u2229 B \u22c3 A \u2229 C.\nProof.\n  intros. rewrite Commu', Distribu, Commu', (Commu' A C); auto.\nQed.\n\nFact InterEn : \u2200 X Y, Ensemble X \u2192 Ensemble Y \u2192 Ensemble (X \u2229 Y).\nProof.\n   intros. assert (X \u2229 Y \u2282 X).\n   { intros z Hz. apply ClaE in Hz; tauto. }\n   clear H0. eapply SubAxI; eauto.\nQed.\n\nDefinition Setmin A B := \\{ \u03bb x, x \u2208 A \u2227 x \u2209 B \\}.\nNotation \"A - B\" := (Setmin A B).\n\nFact SetminIE : \u2200 x A B, x \u2208 A \u2227 x \u2209 B \u2194 x \u2208 (A - B).\nProof.\n  intros. split; intros. apply ClaI; auto. destruct H; Ens.\n  apply ClaE in H. tauto.\nQed.\n\nFact SetminId : \u2200 X, X - X = \u2205.\nProof. intro. AppE. apply SetminIE in H; tauto. exfalso0. Qed.\n\nFact SetminEm : \u2200 X, X - \u2205 = X.\nProof.\n  intro. AppE. apply SetminIE in H; tauto.\n  apply SetminIE. split; auto. intro. exfalso0.\nQed.\n\nFact IncludP : \u2200 A B X, A \u2282 X \u2192 A - B \u2282 X.\nProof. intros * Ha z Hz. apply SetminIE in Hz as []; auto. Qed.\n\nFact IncludP1 : \u2200 A B C, A \u2282 B \u2192 A - C \u2282 B - C.\nProof.\n  intros * Hab z Hz. apply SetminIE in Hz as []. apply SetminIE; auto.\nQed.\n\nFact IncludP2 : \u2200 A X, X - A \u2282 X.\nProof. intros * x Hx. apply ClaE in Hx. tauto. Qed.\n\nFact TwSetmin : \u2200 A X, A \u2282 X \u2192 X - (X - A) = A.\nProof.\n  intros. AppE. apply SetminIE in H0 as [Hx H0].\n  destruct (classic (x \u2208 A)); eauto. elim H0. apply SetminIE. tauto.\n  apply SetminIE. split; auto. intro. apply SetminIE in H1 as []; tauto.\nQed.\n\nFact TwDeMorgan : \u2200 A B C, A - (B \u2229 C) = (A - B) \u22c3 (A - C).\nProof.\n  intros. AppE; apply ClaE in H as [_ H].\n  - destruct H, (classic (x \u2208 C)); apply UnionIE.\n    + left; apply SetminIE. split; auto.\n      intro; elim H0. apply InterIE. auto.\n    + right; apply SetminIE. auto.\n  - destruct H; apply SetminIE in H as []; apply SetminIE;\n    split; auto; intro; apply InterIE in H1 as []; tauto.\nQed.\n\nFact InterEqEmI : \u2200 x U A,\n  Ensemble x \u2192 U \u2229 A - [x] = \u2205 \u2192 x \u2209 A \u2192 U \u2229 A = \u2205.\nProof with eauto.\n  intros. rewrite <- H0. AppE; apply InterIE in H2 as [Hu Ha];\n  apply InterIE; split... apply SetminIE. split... intro.\n  apply SingE in H2... subst... apply ClaE in Ha. tauto.\nQed.\n\nDefinition EleU cA := \\{ \u03bb z, \u2203 y, z \u2208 y \u2227 y \u2208 cA \\}.\nNotation \"\u222a cA\" := (EleU cA)(at level 66).\n\nFact EleUIE : \u2200 x cA, (\u2203 A, x \u2208 A \u2227 A \u2208 cA) \u2194 x \u2208 \u222acA.\nProof.\n  split; intros. destruct H as [A []]. apply ClaI; Ens.\n  apply ClaE in H as [Hx [y []]]. eauto.\nQed.\n\nFact EleUSin : \u2200 X, Ensemble X \u2192 \u222a[X] = X.\nProof with eauto.\n  intros * Hxe. AppE. apply EleUIE in H as [y [Hx Hy]].\n  apply SingE in Hy... subst... apply EleUIE.\n  exists X. split... apply SingI...\nQed.\n\nAxiom EleUAx : \u2200 A, Ensemble A \u2192 Ensemble (\u222aA).\n\nDefinition EleI cA := \\{ \u03bb z, \u2200 y, y \u2208 cA \u2192 z \u2208 y \\}.\nNotation \"\u22c2 cA\" := (EleI cA)(at level 66).\n\n(* De Morgan Law *)\nDefinition AAr A cA := \\{\u03bb z, \u2203 Ar, Ar \u2208 cA \u2227 z = A - Ar\\}.\n\nFact AArI : \u2200 A B cA, Ensemble A \u2192\n  (\u2203 Ar, Ar \u2208 cA \u2227 B = A - Ar) \u2192 B \u2208 AAr A cA.\nProof.\n  intros. destruct H0 as [Ar []]. apply ClaI. eapply SubAxI; eauto.\n  subst. apply IncludP2. eauto.\nQed.\n\nFact AArE : \u2200 A B cA, B \u2208 AAr A cA \u2192 (\u2203 Ar, Ar \u2208 cA \u2227 B = A - Ar).\nProof. intros. apply ClaE in H. tauto. Qed.\n\nFact AArP : \u2200 A cA, Ensemble A \u2192 cA \u2260 \u2205 \u2192 AAr A cA \u2260 \u2205.\nProof.\n  intros. apply EmptyNE in H0 as [Ar H0]. apply EmptyNE.\n  exists (A - Ar). apply AArI; eauto.\nQed.\n\nFact DeMorganUI : \u2200 A cA, Ensemble A \u2192 cA \u2260 \u2205 \u2192 (A - \u222acA) = \u22c2(AAr A cA).\nProof with eauto.\n  intros. AppE.\n  - apply SetminIE in H1 as [Hx HcA]. apply ClaI; Ens. intros.\n    apply AArE in H1 as [B [Hb Heq]]. subst. apply SetminIE.\n    split... intro. elim HcA. apply EleUIE...\n  - apply EmptyNE in H0 as [Ar H0]. apply ClaE in H1 as []. apply ClaI...\n    assert (A - Ar \u2208 AAr A cA). apply AArI...\n    apply H2 in H3. apply SetminIE in H3 as [Hx H3]. split...\n    intro. apply EleUIE in H4 as [B [Hb H4]].\n    assert (A - B \u2208 AAr A cA). apply AArI...\n    apply H2 in H5. apply ClaE in H5; tauto.\nQed.\n\nDefinition Unordered x y := [x] \u22c3 [y].\nNotation \"[ x | y ] \" := (Unordered x y) (at level 0).\n\nDefinition Ordered x y := [ [x] | [x | y] ].\nNotation \"[ x , y ]\" := (Ordered x y) (at level 0).\n\nDefinition Relation r := \u2200 z, z \u2208 r \u2192 \u2203 x y, z = [x,y].\n\nDefinition Function f :=\n  Relation f \u2227 \u2200 x y z, [x,y] \u2208 f \u2227 [x,z] \u2208 f \u2192 y = z.\n\nDefinition Value f x := \u22c2 \\{ \u03bb y, [x,y] \u2208 f \\}.\nNotation \"f [ x ]\" := (Value f x)(at level 5).\n\nDefinition Domain f := \\{ \u03bb x, \u2203 y, [x,y] \u2208 f \\}.\nNotation \"dom( f )\" := (Domain f)(at level 5).\n\nDefinition Range f := \\{ \u03bb y, \u2203 x, [x,y] \u2208 f \\}.\nNotation \"ran( f )\" := (Range f)(at level 5).\n\nAxiom RepAx : \u2200 f, Function f \u2192 Ensemble dom( f ) \u2192 Ensemble ran( f ).\n\nAxiom RegAx : \u2200 x, x \u2260 \u2205 -> \u2203 y, y \u2208 x \u2227 x \u2229 y = \u2205.\n\nAxiom InfAx : \u2203 y, Ensemble y \u2227 \u2205 \u2208 y \u2227 (\u2200 x, x \u2208 y \u2192 (x \u22c3 [x]) \u2208 y).\n\nDefinition ChoiceFunction c :=\n  Function c /\\ \u2200 x, x \u2208 dom(c) -> c [x] \u2208 x.\n\nAxiom ChoAx : \u2203 c, ChoiceFunction c /\\ dom(c) = \u03bc - [\u2205].\n\nFact EmptySet : Ensemble \u2205.\nProof. destruct InfAx as [x [_ [He _]]]. Ens. Qed.\nLtac Empt := apply EmptySet.\n\nFact IntSinEm : \u2200 A B C, Ensemble C \u2192\n  A \u2208 [C] \u22c3 [\u2205] \u2192 B \u2208 [C] \u22c3 [\u2205] \u2192 A \u2229 B \u2208 [C] \u22c3 [\u2205].\nProof with eauto.\n  intros * Hc Ha Hb. apply UnionIE in Ha as [];\n  apply UnionIE in Hb as []; apply SingE in H;\n  apply SingE in H0; try Empt; subst...\n  - rewrite Idem'. apply UnionIE. left; apply ClaI...\n  - rewrite EmInter. apply UnionIE. right; apply SingI. Empt.\n  - rewrite Commu', EmInter. apply UnionIE.\n    right; apply SingI. Empt.\n  - rewrite EmInter. apply UnionIE. right. apply SingI. Empt.\nQed.\n\nFact EleUSinEm : \u2200 a cT, Ensemble a \u2192 cT \u2282 [a] \u22c3 [\u2205] \u2192 \u222acT \u2208 [a] \u22c3 [\u2205].\nProof with eauto.\n  intros * Hae Ht. assert (Hte : Ensemble cT).\n  { eapply SubAxI; [| apply Ht]. apply UnionAx; apply SingEn... Empt. }\n  assert (cT \u2208 cP([a] \u22c3 [\u2205])). apply ClaI...\n  assert (\u2200 c d, Ensemble c \u2192 Ensemble d \u2192 cP([c] \u22c3 [d]) =\n    \\{ \u03bb Z, Z = \u2205 \u2228 Z = [c] \u2228 Z = [d] \u2228 Z = [c] \u22c3 [d] \\}).\n  { intros. AppE.\n    - apply ClaI. Ens. apply ClaE in H2 as [_ H2].\n      destruct (classic (c \u2208 x)), (classic (d \u2208 x)).\n      + right; right; right. apply ReSyTrP... intros z Hz.\n        apply UnionIE in Hz as []; apply SingE in H5; auto; subst...\n      + right; left. AppE; [| apply SingE in H5; subst; auto].\n        apply ClaI. Ens. intro. pose proof H5 as H5'.\n        apply H2, UnionIE in H5 as []; apply SingE in H5...\n        subst; tauto.\n      + right; right; left. AppE; [| apply SingE in H5; subst; auto].\n        apply ClaI. Ens. intro. pose proof H5 as H5'.\n        apply H2, UnionIE in H5 as []; apply SingE in H5...\n        subst; tauto.\n      + left. AppE; [|exfalso0]. pose proof H5 as H5'.\n        apply H2, UnionIE in H5 as []; apply SingE in H5; subst; tauto.\n    - apply ClaI. Ens. intros z Hz.\n      apply ClaE in H2 as [_ [| [| [| ]]]];\n      subst... exfalso0. apply ClaI; Ens. apply ClaI; Ens. }\n  rewrite H0 in H; try apply EmptySet... clear H0.\n  apply ClaE in H as [_ [| [| [| ]]]]; subst.\n  + assert (\u222a\u2205 = \u2205).\n    { AppE; [| exfalso0]. apply EleUIE in H as [y [_ Hy]]. exfalso0. }\n    rewrite H. apply UnionIE. right. apply ClaI...\n  + rewrite EleUSin... apply UnionIE. left. apply ClaI...\n  + pose proof EmptySet. rewrite EleUSin...\n    apply UnionIE. right. apply SingI...\n  + assert (\u222a [a] \u22c3 [\u2205] = a).\n    { AppE. apply EleUIE in H as [y [Hx Hy]].\n      apply UnionIE in Hy as []; apply SingE in H; subst... exfalso0.\n      apply EmptySet. apply EleUIE. exists a. split...\n      apply UnionIE. left. apply ClaI... }\n    rewrite H. apply UnionIE. left; apply ClaI...\nQed.\n",
      "theorem": "Fact \u03bc_En : \u2200 x, x \u2208 \u03bc \u2194 Ensemble x.",
      "ground_truth": "Proof. split; intros. Ens. apply ClaI; auto. Qed."
    },
    {
      "split": "train-sft",
      "index": 46,
      "prefix": "From Coq Require Import Utf8 RelationClasses PropExtensionality Classical_Prop\n  List.\n\nImport ListNotations.\n\nSet Default Goal Selector \"!\".\nSet Printing Projections.\nSet Universe Polymorphism.\n\nLtac forward_gen H tac :=\n  match type of H with\n  | ?X \u2192 _ => let H' := fresh in assert (H':X) ; [tac|specialize (H H'); clear H']\n  end.\n\nTactic Notation \"forward\" constr(H) := forward_gen H ltac:(idtac).\nTactic Notation \"forward\" constr(H) \"by\" tactic(tac) := forward_gen H tac.\n\nNotation val x := (let 'exist _ t _ := x in t).\nNotation \"\u27e8 u \u27e9\" := (exist _ u _).\n\nDefinition prf [A P] (p : { x : A | P x }) : P (val p).\nProof.\n  destruct p. assumption.\nQed.\n\nNotation \"'\u2211' x .. y , p\" := (sigT (fun x => .. (sigT (fun y => p%type)) ..))\n  (at level 200, x binder, right associativity,\n   format \"'[' '\u2211'  '/  ' x  ..  y ,  '/  ' p ']'\")\n  : type_scope.\n\nNotation \"( x ; y )\" := (@existT _ _ x y).\nNotation \"( x ; y ; z )\" := (x ; ( y ; z)).\nNotation \"( x ; y ; z ; t )\" := (x ; ( y ; (z ; t))).\nNotation \"( x ; y ; z ; t ; u )\" := (x ; ( y ; (z ; (t ; u)))).\nNotation \"( x ; y ; z ; t ; u ; v )\" := (x ; ( y ; (z ; (t ; (u ; v))))).\nNotation \"x .\u03c01\" := (@projT1 _ _ x) (at level 3, format \"x '.\u03c01'\").\nNotation \"x .\u03c02\" := (@projT2 _ _ x) (at level 3, format \"x '.\u03c02'\").\n\nDefinition coe {A B} (e : A = B) : A \u2192 B :=\n  match e with\n  | eq_refl => \u03bb x, x\n  end.\n\nDefinition heq {A B : Type} (x : A) (y : B) :=\n  \u2211 (e : A = B), coe e x = y.\n\nNotation \"x \u2245 y\" := (heq x y) (at level 80).\n\nLemma sig_ext :\n  \u2200 A (P : A \u2192 Prop) (u v : { x : A | P x }),\n    val u = val v \u2192\n    u = v.",
      "suffix": "\n\nLemma classical_right :\n  \u2200 (P Q : Prop),\n    (\u00ac P \u2192 Q) \u2192\n    P \u2228 Q.\nProof.\n  intros P Q h.\n  classical_right. auto.\nQed.\n\nLemma classical_left :\n  \u2200 (P Q : Prop),\n    (\u00ac Q \u2192 P) \u2192\n    P \u2228 Q.\nProof.\n  intros P Q h.\n  classical_left. auto.\nQed.\n\nLemma not_exists_forall :\n  \u2200 (A : Type) (P : A \u2192 Prop),\n    \u00ac (\u2203 x, P x) \u2192\n    id (\u2200 x, \u00ac P x).\nProof.\n  intros A P h x hx.\n  apply h. exists x. apply hx.\nQed.\n\nLemma not_forall_exists :\n  \u2200 A (P : A \u2192 Prop),\n    \u00ac (\u2200 x, P x) \u2192\n    \u2203 x, \u00ac (P x).\nProof.\n  intros A P h.\n  apply NNPP. intro hn. apply h. clear h.\n  intro x.\n  apply NNPP. intro hx. apply hn.\n  exists x. assumption.\nQed.\n\nInductive seqR [A] (R : A \u2192 A \u2192 Prop) : list A \u2192 Prop :=\n| seqR_nil : seqR R []\n| seqR_one : \u2200 x, seqR R [ x ]\n| seqR_cons : \u2200 x y l, R x y \u2192 seqR R (y :: l) \u2192 seqR R (x :: y :: l).\n\n(* Truncation of a stream like structure *)\nFixpoint strunc [A] (s : nat \u2192 A) (n : nat) : list A :=\n  match n with\n  | 0 => []\n  | S n => s 0 :: strunc (\u03bb n, s (S n)) n\n  end.",
      "theorem": "Lemma sig_ext :\n  \u2200 A (P : A \u2192 Prop) (u v : { x : A | P x }),\n    val u = val v \u2192\n    u = v.",
      "ground_truth": "Proof.\n  intros A P u v e.\n  destruct u, v. subst. f_equal. apply proof_irrelevance.\nQed."
    },
    {
      "split": "train-sft",
      "index": 47,
      "prefix": "Require Export List.\nRequire Export Maps.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\n\n\n(** * join axiom **)\n(* Axiom map_join_emp: *)\n(*   forall x, join x emp x. *)\n\n(* ** ac: Check map_join_emp. *)\n(* ** ac: Check @map_join_emp. *)\n(* ** ac: Check join. *)\n(* ** ac: Check @join. *)\n\nCreate HintDb jdb.\n\nModule general.\n  Ltac jauto := auto with jdb.\n  Ltac jeauto := eauto with jdb.\n  Ltac jeauto2 := eauto 2 with jdb.\nEnd general.\n\nImport general.\n\nHint Resolve @map_join_emp : jdb.\n(** must add @, because type class may find instant automatically,\n      then map_join_emp becomes a specific lemma ....\n **)\n\n(* ** ac: Print HintDb jdb. *)\n(* Axiom map_join_pos: *)\n(*   forall x y, *)\n(*     join x y emp -> *)\n(*     x = emp /\\ y = emp. *)\n\n(* Axiom map_join_comm: *)\n(*   forall x y z, *)\n(*     join x y z -> *)\n(*     join y x z. *)\n\n(* Axiom map_join_assoc: *)\n(*   forall a b mab c mabc, *)\n(*     join a b mab -> *)\n(*     join mab c mabc -> *)\n(*     exists mbc, *)\n(*       join a mbc mabc /\\ *)\n(*       join b c mbc. *)\n\n(* Axiom map_join_cancel: *)\n(*   forall a b b' c, *)\n(*     join a b c -> *)\n(*     join a b' c -> *)\n(*     b = b'. *)\n\n(* Axiom map_join_deter: *)\n(*   forall a b c c', *)\n(*     join a b c -> *)\n(*     join a b c' -> *)\n(*     c = c'. *)\n\nHint Immediate @map_join_comm : jdb.\n\nHint Resolve @map_join_cancel @map_join_deter : jdb.\n\n(* ** ac: Check map_join_assoc. *)\n\nLemma map_join_assoc':\n  forall {A B T:Type} {MC:PermMap A B T} a b mab c mabc,\n    join a b mab ->\n    join mab c mabc ->\n    exists mbc,\n      join a mbc mabc.\nProof.\n  intros.\n  remember (map_join_assoc H H0).\n  destruct e as (mbc & F1 & F2).\n  exists mbc.\n  auto.\nQed.\n\n(* ** ac: Check map_join_assoc'. *)\n(* ** ac: Check @map_join_assoc'. *)\nLemma map_join_assoc'':\n  forall {A B T:Type} {MC:PermMap A B T} a b mab c mabc,\n    join a b mab ->\n    join mab c mabc ->\n    exists mbc,\n      join mbc a mabc.\nProof.\n  intros.\n  remember (map_join_assoc H H0).\n  destruct e as (mbc & F1 & F2).\n  exists mbc.\n  auto with jdb.\nQed.\n\n\nHint Resolve @map_join_assoc' @map_join_assoc'' : jdb.\n\n(* ** ac: Print HintDb jdb. *)\n\nExample test_1:\n  forall {A B T:Type} {MC:PermMap A B T} a b mab c mabc,\n    join a b mab ->\n    join c mab mabc ->\n    exists mbc,\n      join mbc a mabc.\nProof.\n  intros.\n  jeauto.\nQed.\n\nLemma map_join_emp':\n  forall {A B T:Type} {MC:PermMap A B T} x z,\n    join x emp z ->\n    x = z.\n  intros; jeauto.\nQed.\n\nLemma map_join_emp'':\n  forall {A B T:Type} {MC:PermMap A B T} x z,\n    join emp x z ->\n    x = z.\n  intros; jeauto.\nQed.\n\nHint Resolve @map_join_emp' @map_join_emp'' : jdb.\n\nLemma map_join_pos':\n  forall {A B T:Type} {MC:PermMap A B T} x y,\n    join x y emp ->\n    x = emp.\nProof.\n  intros; apply map_join_pos in H; tauto.\nQed.\n\nLemma map_join_pos'':\n  forall {A B T:Type} {MC:PermMap A B T} x y,\n    join x y emp ->\n    y = emp.\nProof.\n  intros; apply map_join_pos in H; tauto.\nQed.\n\nHint Resolve @map_join_pos' @map_join_pos'' : jdb.\n\n(** * Axiom : set , get and sig **)\n\n(** ** get general **)\nHint Resolve @map_get_unique : jdb.\nHint Resolve @map_get_sig @map_get_sig' @map_get_set @map_get_set' : jdb.\n\nHint Resolve @map_dec_a : jdb.\nLemma map_get_sig'_l:\n  forall {A B T:Type} {MC:PermMap A B T} t t' v v',\n    get (sig t v) t' = Some v' ->\n    t = t'.\nProof.\n  intros.\n  generalize (@map_dec_a _ _ _ _ t t'); intro.\n  destruct H0.\n  auto.\n  assert (get (sig t v) t' = None) by jeauto.\n  rewrite H in H0.\n  inversion H0.\nQed.  \n\nLemma map_get_sig'_r:\n  forall {A B T:Type} {MC:PermMap A B T} t t' v v',\n    get (sig t v) t' = Some v' ->\n    v = v'.\nProof.\n  intros.\n  generalize (@map_dec_a _ _ _ _ t t'); intro.\n  destruct H0.\n  subst.\n  assert (get (sig t' v) t' = Some v) by jeauto.\n  rewrite H0 in H.\n  inversion H; subst; auto.\n  assert (get (sig t v) t' = None) by jeauto.\n  rewrite H in H0.\n  inversion H0.\nQed.\n\nHint Resolve @map_get_sig'_l @map_get_sig'_r : jdb.\n\nHint Resolve @map_join_get_some @map_join_get_some @map_join_getp_some : jdb.\nHint Resolve @map_set_emp @map_set_sig @map_join_set_none map_join_set_perm : jdb.\nHint Resolve @map_join_get_sig @map_join_get_sig_perm : jdb.\n\n\n(** * operator: merge **)\n(* Parameter merge: T -> T -> T. *)\n\n(* Axiom map_join_merge: *)\n(*   (** the scope of exists is very large, using parenthesis **) *)\n(*   forall x y, *)\n(*     (exists z, join x y z) -> *)\n(*     join x y (merge x y). *)\n\nHint Resolve @map_join_merge : jdb.\n\nLemma map_join_merge':\n  forall {A B T:Type} {MC:PermMap A B T} x y z,\n    join x y z ->\n    z = merge x y.\nProof.\n  intros.\n  assert (join x y (merge x y)).\n  apply map_join_merge.\n  exists z; auto.\n  eauto 2 with jdb.\nQed.\n\nHint Resolve @map_join_merge' : jdb.\n\n(* Axiom map_merge_comm: *)\n(*   forall x y, *)\n(*     merge x y = merge y x. *)\n\n(******************************* join_list *******************************)\nInductive join_list {A B T:Type} {MC:PermMap A B T}: list T -> T -> Prop :=\n| jl_nil: join_list nil emp\n| jl_cons:\n    forall h ls z' z ,\n      join_list ls z' ->\n      join h z' z ->\n      join_list (h::ls) z.\n\nHint Resolve @jl_nil @jl_cons : jdb.\n\nLemma jl_ref:\n  forall {A B T:Type} {MC:PermMap A B T} x,\n    join_list (x::nil) x.\nProof.\n  intros.\n  eapply jl_cons with (z':=emp); jauto.\nQed.\n\nHint Resolve @jl_ref : jdb.\n\nLemma jl_join_to_jl:\n  forall {A B T:Type} {MC:PermMap A B T} x y z,\n    join x y z ->\n    join_list (x::y::nil) z.\nProof.\n  intros; jeauto.\nQed.\n\nHint Resolve @jl_join_to_jl : jdb.\n\nLemma jl_elim_nil:\n  forall {A B T:Type} {MC:PermMap A B T} x lx',\n    join_list (emp :: lx') x ->\n    join_list lx' x.\nProof.\n  intros.\n  inversion H; subst; clear H.\n  assert (z' = x) by jeauto; subst.\n  auto.\nQed.\n\nHint Resolve @jl_elim_nil : jdb.\n\nLemma jl_emp:\n  forall {A B T:Type} {MC:PermMap A B T},\n    join_list nil emp.\nProof.\n  jauto.\nQed.\n\nHint Resolve @jl_emp : jdb.\n\nLemma jl_emp':\n  forall {A B T:Type} {MC:PermMap A B T} x,\n    join_list nil x -> x = emp.\nProof.\n  intros.\n  inversion H.\n  jauto.\nQed.\n\nHint Resolve @jl_emp' : jdb.\n\n(** * main lemma: jl_sub **)\n(** ** TODO: simpl **)\nLemma jl_sub:\n  forall {A B T:Type} {MC:PermMap A B T} x lx lz',\n    join_list lx x ->\n    forall z,\n      join_list (x::lz') z ->\n      join_list (lx ++ lz') z.\nProof.\n  induction 1.\n  (** trivial start **)\n  intros.\n  simpl.\n  apply jl_elim_nil in H.\n  auto.\n  (** complex induction **)\n  rename ls into lx'.\n  rename z' into x'.\n  rename h into hx.\n  rename H into Hjl_x.\n  rename H0 into Hjop_x.\n  rename z into x.\n  intros z Hjl_z.\n  simpl.\n  (** generate some facts **)\n  inversion Hjl_z.\n  subst.\n  rename H1 into Hjl_z'.\n  rename H3 into Hjop_z.\n  remember (map_join_assoc Hjop_x Hjop_z).\n  clear Heqe.\n  rename e into Hmz.\n  destruct Hmz as (mz & Hjop_mz_new & Hjop_mz).\n  (** deal with goal **)\n  eapply jl_cons.\n  eapply IHjoin_list.\n  eapply jl_cons.\n  eauto.\n  instantiate (1:=mz).\n  eauto.\n  auto.\nQed.\n\n\n(** * main lemma: jl_deter **)\nLemma jl_deter:\n  forall {A B T:Type} {MC:PermMap A B T} l x x',\n    join_list l x ->\n    join_list l x' ->\n    x = x'.",
      "suffix": "\n\nHint Resolve @jl_deter : jdb.\n\n(** * main lemma: jl_split **)\nLemma jl_split:\n  forall {A B T:Type} {MC:PermMap A B T} l1 l2 z,\n    join_list (l1 ++ l2) z ->\n    exists x y,\n      join_list l1 x /\\\n      join_list l2 y /\\\n      join x y z.\nProof.\n  induction l1; jeauto.\n  intros l2 z Hjl_z.\n  simpl in Hjl_z.\n  inversion Hjl_z; subst; clear Hjl_z.\n  apply IHl1 in H1.\n  destruct H1 as (x' & y & Hjl_x' & Hjl_y & Hjop_z').\n  clear IHl1.\n  rename H3 into Hjop_z.\n  apply map_join_comm in Hjop_z'.\n  apply map_join_comm in Hjop_z.\n  remember (map_join_assoc Hjop_z' Hjop_z).\n  clear Heqe.\n  destruct e as (x & Hjop_z1 & Hjop_x).\n  exists x.\n  exists y.\n  split; jeauto.\nQed.\n\nLtac join_assoc_tac H1 H2 :=\n  let f := fresh \"tac_H\" in\n  let f1 := fresh \"tac_Hjop1\" in\n  let f2 := fresh \"tac_Hjop2\" in\n  let mbc := fresh \"mbc\" in\n  first [ remember (map_join_assoc H1 H2) as f\n        | apply map_join_comm in H2;\n          remember (map_join_assoc H1 H2) as f];\n  destruct f as (mbc & f1 & f2).\n\n(** * main lemma: jl_merge_op **)\nLemma jl_merge_op:\n  forall {A B T:Type} {MC:PermMap A B T} l1 l2 x y z,\n    join_list l1 x ->\n    join_list l2 y ->\n    join x y z ->\n    join_list (l1 ++ l2) z.\nProof.\n  induction l1.\n  (** base case **)\n  intros.\n  simpl.\n  assert (x = emp) by jauto.\n  subst.\n  assert (y = z) by jeauto2.\n  subst.\n  auto.\n  (** induction case **)\n  intros.\n  simpl.\n  inversion H.\n  subst.\n  clear H.\n  rename H4 into Hjl_l1.\n  rename H6 into Hjl_a_l1.\n  rename z' into ml1.\n  rename x into ma_l1.\n  join_assoc_tac Hjl_a_l1 H1; jeauto.\nQed.\n\nHint Resolve @jl_merge_op : jdb.\n\nLemma jl_swap:\n  forall {A B T:Type} {MC:PermMap A B T} l1 l2 z,\n    join_list (l1 ++ l2) z ->\n    join_list (l2 ++ l1) z.\nProof.\n  intros.\n  apply jl_split in H.\n  destruct H as (x & y & Hjl_x & Hjl_y & Hjop_z).\n  jeauto.\nQed.\n\n(** * main lemma: jl_lift **)\nLemma jl_lift:\n  forall {A B T:Type} {MC:PermMap A B T} h l1 l2 z,\n    join_list (l1 ++ h :: l2) z ->\n    join_list (h :: l1 ++ l2) z.\nProof.\n  intros.\n  apply jl_swap in H.\n  simpl in H.\n  inversion H.\n  clear H.\n  subst.\n  apply jl_swap in H2.\n  jeauto.\nQed.\n\nLemma jl_ref_eql:\n  forall {A B T:Type} {MC:PermMap A B T} x y,\n    join_list (x :: nil) y ->\n    x = y.\nProof.\n  intros.\n  assert (join_list (x :: nil) x) by jauto.\n  jeauto2.\nQed.\n\nHint Resolve @jl_ref_eql : jdb.\n\nLemma jl_list_to_op:\n  forall {A B T:Type} {MC:PermMap A B T} x y z,\n    join_list (x :: y :: nil) z ->\n    join x y z.\nProof.\n  intros.\n  inversion H.\n  subst.\n  assert (y = z') by jeauto.\n  subst z'.\n  auto.\nQed.\n\nHint Resolve @jl_list_to_op : jdb.\n\nLemma jl_intro_op:\n  forall {A B T:Type} {MC:PermMap A B T} l1 l2 x y z,\n    join_list l1 x ->\n    join_list l2 y ->\n    join_list (l1 ++ l2) z ->\n    join x y z.\nProof.\n  intros.\n  apply jl_split in H1.\n  destruct H1 as (x0 & y0 & H2 & H3 & H4).\n  assert (x = x0) by jeauto2.\n  assert (y = y0) by jeauto2.\n  subst x0 y0.\n  auto.\nQed.\n\nHint Resolve @jl_intro_op : jdb.\n\nLemma jl_intro_ex_jop:\n  forall {A B T:Type} {MC:PermMap A B T} m l1 l2 l' x y,\n    join_list (l1 ++ (l2 ++ l')) m ->\n    join_list l1 x ->\n    join_list l2 y ->\n    (exists z, join x y z).\nProof.\n  intros.\n  rewrite app_assoc in H.\n  apply jl_split in H.\n  destruct H as (x0 & y0 & F1 & F2 & F3).\n  exists x0.\n  jeauto.\nQed.\n\nHint Resolve @jl_intro_ex_jop.\n\nLemma jl_intro_merge:\n  forall {A B T:Type} {MC:PermMap A B T} m l1 l2 l' x y,\n    join_list (l1 ++ (l2 ++ l')) m ->\n    join_list l1 x ->\n    join_list l2 y ->\n    join x y (merge x y).\nProof.\n  intros.\n  apply map_join_merge.\n  jeauto.\nQed.\n\nLemma jl_intro_jl_of_merge:\n  forall {A B T:Type} {MC:PermMap A B T} l1 l2 x y,\n    join_list l1 x ->\n    join_list l2 y ->\n    join x y (merge x y) ->\n    join_list (l1 ++ l2) (merge x y).\nProof.\n  intros.\n  jeauto.\nQed.\n\nFixpoint merge_list {A B T:Type} {MC:PermMap A B T} (l: list T) : T :=\n  match l with\n    | x :: l' =>\n      merge x (merge_list l')\n    | nil => emp\n  end.\n\nLemma jl_merge_list:\n  (** wonderful lemma !!! **)\n  forall {A B T:Type} {MC:PermMap A B T} l m,\n    join_list l m ->\n    join_list l (merge_list l).\nProof.\n  induction 1.\n  jeauto.\n  simpl.\n  eapply jl_cons.\n  exact IHjoin_list.\n  assert (merge_list ls = z') by jeauto.\n  rewrite H1 in *.\n  clear H1.\n  jeauto.\nQed.\n\nHint Resolve @jl_merge_list : jdb.\n\nLemma jl_intro_merge_list_sub:\n  forall {A B T:Type} {MC:PermMap A B T} lx ly m,\n    join_list (lx ++ ly) m ->\n    join_list lx (merge_list lx).\nProof.\n  intros.\n  apply jl_split in H.\n  destruct H as (? & ? & ? & ? & ?).\n  jeauto.\nQed.\n\nLemma jl_merge_list_merge:\n  forall {A B T:Type} {MC:PermMap A B T} l1 l2 x y,\n    join_list l1 x ->\n    join_list l2 y ->\n    join x y (merge x y) ->\n    join_list (l1 ++ l2) (merge_list (l1 ++ l2)).\nProof.\n  intros.\n  assert (join_list (l1 ++ l2) (merge x y)) by jeauto.\n  jeauto.\nQed.\n\nLemma jl_merge_list_subtract:\n  forall {A B T:Type} {MC:PermMap A B T} l1 x,\n    join_list l1 x ->\n    forall l2 z,\n      join_list (l1 ++ l2) z ->\n      join_list l2 (merge_list l2).\nProof.\n  (* ** ac: Check jl_split. *)\n  intros.\n  apply jl_split in H0.\n  destruct H0 as (x0 & y & F1 & F2 & F3).\n  jeauto.\nQed.\n\nLemma jl_merge_emp:\n  forall {A B T:Type} {MC:PermMap A B T} x,\n    merge x emp = x.\nProof.\n  intros.\n  apply eq_sym.\n  apply map_join_merge'.\n  jeauto.\nQed.\n\nLemma jl_merge_emp':\n  forall {A B T:Type} {MC:PermMap A B T} x,\n    merge emp x = x.\nProof.\n  intros.\n  apply eq_sym.\n  apply map_join_merge'.\n  jeauto.\nQed.\n\n(***************************** list tactics *****************************)\nRequire Import NPeano.\n\nLtac slice l n m :=\n  (** l: list ?T (?T can be everything), n m: nat **)\n  (** get slice [n:m] of list l, count from 0\n        for example, slice (1::2::3::4::5::nil) 0 2 = (1::2::nil)\n        so be careful that m is exclusive !!!\n   **)\n  match type of l with\n    | list ?T =>\n      let rec slice' l n m :=\n          match m with\n            | O => constr:(@nil T)\n            | S ?m' =>\n              match l with\n                | nil => constr:(@nil T)\n                | ?h :: ?l' =>\n                  match n with\n                    | O =>\n                      let l1 := slice' l' n m' in\n                      constr:(h :: l1)\n                    | S ?n' =>\n                      let l1 := slice' l' n' m' in\n                      constr:(l1)\n                  end\n              end\n          end in\n      slice' l n m\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z: T) (t:A) (v:B), False.\nintros.\nlet y := slice ((sig t v)::x::y::z::nil) 0 2 in\npose y.\nAbort.\n\nLtac length l :=\n  (** l: list A **)\n  (** return the length of list l **)\n  match l with\n    | nil => constr:(O)\n    | _ :: ?ls =>\n      let n := length ls in\n      constr:(S n)\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z:T), False.\nintros.\nlet y := length (x::y::z::nil) in\npose y.\nAbort.\n\nLtac nth l n :=\n  (** l: list ?T, n: nat **)\n  (** nth element of list l, number from 0\n        for example, nth_general (x::y::nil) 0 = x **)\n  let l' := slice l n (S n) in\n  match l' with\n    | ?h :: nil => h\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z:T), False.\nintros.\nlet y := nth (x::y::z::nil) 1 in\npose y.\nAbort.\n\nLtac map T f ls :=\n  (** T: Type, f: A -> T(but f is a tactic function), ls: list A **)\n  (** classical functional programming function: map **)\n  let rec map' ls :=\n      match ls with\n        | nil => constr:(@nil T)\n        | ?x :: ?ls' =>\n          let x' := f x in\n          let ls'' := map' ls' in\n          constr:(x'::ls'')\n      end in\n  map' ls.\n\n\n(** PS: how to use condition in tactic? see below ~\n    Ltac find l x :=\n      match l with\n        | ?h :: ?ls =>\n          let cond1 := constr:(eq_refl x: x = h) in (** if x = h **)\n            constr:(O)\n        | ?h :: ?ls =>\n          let n := find ls x in (** if x <> h **)\n            constr:(S n)\n      end. **)\n\nLtac find l x :=\n  (** l: list A, x: A **)\n  (** find the subscript of x in l\n        for example l=(m1::m2::nil) x=m2, then (find l x) = 1 **)\n  match l with\n    | x :: ?ls =>\n      constr:(O)\n    | _ :: ?ls =>\n      let n := find ls x in\n      constr:(S n)\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4:T) (t:A) (v:B), False.\nintros.\nlet y := find (x2::(sig t v)::x3::x4::nil) (sig t v) in\npose y.\nlet y := find (x2::x1::(sig t v)::x3::x4::nil) (sig t v) in\npose y.\nAbort.\n\nLtac find_all l lx :=\n  (** l: list A, lx: list A **)\n  (** find all element of lx in l, return a [list nat] **)\n  map nat ltac:(fun x => find l x) lx.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4 x5:T) t v, join (sig t v) x1 x2.\nintros.\nlet ls := find_all (x1::x2::(sig t v)::x4::nil) ((sig t v)::x4::nil) in\npose ls.\nAbort.\n\nLtac lifts_order ln :=\n  (** ln: list nat **)\n  (** if we want transform a list to let the (2th, 3th, 4th) be the first three element, we then perform 4th-to-head, then the 4th of new list to head, then the 4th of new list to head, so the lift number list is (4th, 4th, 4th).\n        this tactic perform this transform **)\n  let rec lifts_order_inc b l :=\n      (** forall x in l, if x < b, then inc x **)\n      match l with\n        | nil => constr:(@nil nat)\n        | ?h :: ?l' =>\n          let l0 := lifts_order_inc b l' in\n          let x := constr:(Nat.ltb h b) in\n          match (eval compute in x) with\n            | true => constr:((S h) :: l0)(** if h < b, then inc h **)\n            | false => constr:(h :: l0)\n          end\n      end in\n  let rec lifts_order' l :=\n      match l with\n        | nil => constr:(@nil nat)\n        | ?h :: ?l' =>\n          let l0 := lifts_order_inc h l' in\n          let l1 := lifts_order' l0 in\n          constr:(h :: l1)\n      end in\n  let l1 := constr:(rev ln) in\n  let l2 := (eval compute in l1) in\n  lifts_order' l2.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x:list nat), x = x.\nintros.\nlet y := lifts_order (2::3::nil) in\nassert (x = y).\n (** test the result of lifts_trans_list **)\nAbort.\n\nLtac slice_tail l n :=\n  (** tail of l from n, inclusive **)\n  let len := length l in\n  slice l n (S len).\n\nLtac lift_nat l n :=\n  (** l: list T, n: nat **)\n  (** return a list, which equal to lift nth element of l to the head **)\n  let l1 := slice l 0 n in\n  let x := nth l n in\n  let l2 := slice_tail l (S n) in\n  let l' := constr:(x :: l1 ++ l2) in\n  let l'' := (eval simpl in l') in\n  constr:(l'').\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z:T), False.\nintros.\nlet n := lift_nat (x::y::z::nil) 2 in\npose n.\nlet n := slice_tail (x::y::z::nil) 1 in\npose n.\nAbort.\n\nLtac lift l x :=\n  (** l: list T, x: T **)\n  let n := find l x in\n  lift_nat l n.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z:T), False.\nintros.\nlet n := lift (x::y::z::nil) z in\npose n.\nAbort.\n\n(* ** ac: Check rev. *)\n(**\n     useing constr:(rev) in TypeClass will cause some problem, see below example.\n     eval compute unfold something in TypeClass **)\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4 x5:T) t v,\n    join (sig t v) x1 x2 ->\n    (sig t v :: nil) ++ (x2 :: nil) = (sig t v :: x2 :: nil) ->\n    (sig t v :: nil) ++ (x1 :: nil) = (sig t v :: x1 :: nil).\nintros.\nsimpl in H0.\nlet l1 := constr:(rev (x1::(sig t v)::nil)) in\nlet l2 := (eval simpl in l1) in\npose l2.\nlet l1 := constr:(rev (x1::(sig t v)::nil)) in\nlet l2 := (eval simpl in l1) in\npose l2.\n (** aaaaaaaaaa!!!!!! simpl will unfold sig to sigx ... How to fix it? **)\n(**\n     \u03b2 (reduction of functional application),\n     \u03b4 (unfolding of transparent constants, see 6.11.2),\n     \u03b9 (reduction of pattern-matching over a constructed term, and unfolding of fix and cofix expressions)\n     \u03b6 (contraction of local definitions)\n     the flag are either beta, delta, iota or zeta\n **)\nlet l1 := constr:(rev (x1::(sig t v)::nil)) in\nlet l2 := (eval compute -[sig] in l1) in\npose l2.\nlet l1 := constr:(rev (x1::(merge x2 x3)::nil)) in\nlet l2 := (eval compute -[sig] in l1) in\npose l2.\n\nlet l1 := constr:(rev (x1::(merge x2 x3)::nil)) in\nlet l2 := (eval compute -[merge] in l1) in\npose l2.\n\nlet l1 := constr:(rev (x1::(merge x2 x3)::(sig t v)::nil)) in\nlet l2 := (eval compute -[sig get set join emp merge] in l1) in\npose l2.\n(* simpl. *)\nsimpl.\nlet l1 := constr:(rev (x1::(merge x2 x3)::(sig t v)::nil)) in\nlet l2 := eval simpl in l1 in\n    pose l2.\nAbort.\n\nLtac lifts l lx :=\n  (** l: list T, lx: list T **)\n  (** lift all the ident in lx, among l **)\n  let rec lifts' l lx :=\n      match lx with\n        | ?x :: ?lx' =>\n          let l' := lift l x in\n          lifts' l' lx'\n        | nil => constr:(l)\n      end in\n  let lx' := constr:(rev lx) in\n  let lx'' := (eval simpl in lx') in\n  lifts' l lx''.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4 x5:T) t v, join (sig t v) x1 x2.\nintros.\nlet l1 := constr:(rev (x1::(sig t v)::nil)) in\nlet n := lifts (x1::x2::x3::(sig t v)::nil) (x2::x1::x3::nil) in\npose n.\nlet n := lifts (x1::x2::(sig t v)::x3::x4::x5::nil) (x2::(sig t v)::x3::nil) in\npose n.\nAbort.\n\nLtac extract l lx :=\n  (** l: list T, lx: list T **)\n  (** perform [lifts l lx], and get the tail part of l out of lx **)\n  let l' := lifts l lx in\n  let n := length lx in\n  let l'' := slice_tail l' n in\n  constr:(l'').\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4 x5:T), False.\nintros.\nlet n := extract (x1::x2::x3::x4::x5::nil) (x3::x1::x2::nil) in\npose n.\nAbort.\n\nLtac truncate l lx :=\n  (** l: list ?T, lx: list ?T **)\n  (** n = length lx, then get (slice_tail l n) **)\n  (** this should be put in list tactics **)\n  let n := length lx in\n  slice_tail l n.\n\n(* ** ac: Check Nat.ltb. *)\nLtac subp_list l1 l2 :=\n  (** l1 l2: list ?T **)\n  (** predicate whether l2 if the sub set of l1, return tactic value **)\n  let l' := extract l1 l2  in\n  (** not fail, means l2 is subset of l1 **)\n  idtac.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4 x5:T), False.\nintros.\nsubp_list (x1::x2::x3::nil) (x1::x3::nil).\nsubp_list (x1::x2::x3::nil) (x1::x3::x2::nil).\nlet n := extract (x1::x2::x3::x4::x5::nil) (x3::x1::x2::nil) in\npose n.\nAbort.\n\nLtac same_list l1 l2 :=\n  (** l1 l2: list ?T **)\n  (** predicate of that l1 and l2 is the same set, return true or false **)\n  (** this should be move to list tactic part **)\n  let n1 := length l1 in\n  let n2 := length l2 in\n  let dummy1 := constr:(eq_refl n1: n1 = n2) in (** n1 = n2 ? **)\n  let l' := extract l1 l2 in (** l' = nil if l1 and l2 are same set **)\n  match l' with\n    | nil => constr:(true)\n    | _ => constr:(false)\n  end.\n\nLtac same_list' l1 l2 :=\n  (** the same as same_list, but return tactic. **)\n  let b := same_list l1 l2 in\n  match b with\n    | true => idtac\n    | false => fail\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z i:T), join_list (x::y::z::nil) i -> False.\nintros.\nlet n := same_list (x::y::z::nil) (y::z::x::nil) in pose n.\nlet n := same_list (@nil T) (@nil T) in pose n.\nAbort.\n\n(** * tactic about Hypothesis and goals **)\n\nLtac liftH_nat H n :=\n  (** H: hypo ident, n: nat **)\n  (** H must has type [join_list ?l ?ml], then transform H to let nth element of l at the head of l **)\n  match type of H with\n    | join_list ?l ?ml =>\n      let l1 := slice l 0 n in\n      let l2 := slice_tail l (S n) in\n      let x := nth l n in\n      let tmp := fresh in\n      assert (tmp: l = (l1 ++ x :: l2)) by auto;\n      rewrite tmp in H;\n      clear tmp;\n      apply jl_lift in H;\n      simpl in H\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z ml:T) t v,\n    join_list (x::y::z::(sig t v)::nil) ml -> False.\nintros.\nliftH_nat H 3.\nAbort.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (a1 a2 x1' x2' x1 x2 x3 x4 x12 x34 x1234:T) (x:A) (v:B),\n    join_list (x1::x2::(sig x v)::nil) x12 ->\n    join_list (a1::a2::nil) x2' ->\n    join_list (x1'::x2'::nil) x3 ->\n    join_list (x12::x3::x4::nil) x1234 -> False.\nintros.\nliftH_nat H2 1.\nAbort.\n\nLtac liftH H x :=\n  (** H: hypo ident, x: T **)\n  (** similar to liftH_nat, except x is the ident, not number **)\n  match type of H with\n    | join_list ?l ?ml =>\n      let n := find l x in\n      liftH_nat H n\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z ml:T) t v,\n    join_list (x::y::z::(sig t v)::nil) ml -> False.\nintros.\nliftH H (sig t v).\nliftH H y.\nAbort.\n\nLtac liftsH H lx :=\n  (** H: hypo ident, lx: list T **)\n  (** lifts all element of lx in H **)\n  let rec liftsH' lx :=\n      match lx with\n        | ?x :: ?lx' =>\n          liftH H x;\n          liftsH' lx'\n        | nil => idtac\n      end in\n  let lx' := constr:(rev lx) in\n  let lx'' := (eval simpl in lx') in\n  liftsH' lx''.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4 x5 ml:T) t v,\n    usePerm = false ->\n    join_list (x1::x2::x3::x4::x5::(sig t v)::nil) ml -> False.\nintros.\nliftsH H0 ((sig t v) :: nil).\nliftsH H0 (x2::x4::x1::nil).\nAbort.\n\nLtac in_hyp l :=\n  (** l : list T **)\n  (** predicate of the existence [H: join_list l _ ], return true/false **)\n  match goal with\n    | H : join_list ?ll ?x |- _ =>\n      same_list l ll\n    | _ => constr:(false)\n  end.\n\nLtac in_hyp' l :=\n  (** the same as in_hyp, but return tactic. **)\n  let b := in_hyp l in\n  match b with\n    | true => idtac\n    | false => fail\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x y z i:T),\n    join_list (x::y::z::nil) i ->\n    join_list (x::y::nil) z ->\n    join_list nil emp -> False.\nintros.\nlet n := in_hyp (x::nil) in pose n.\nlet n := in_hyp (@nil T) in pose n.\nin_hyp' (x::y::nil).\nAbort.\n\nLtac search_x x :=\n  (** x: T **)\n  (** find the hypo [H: join_list ?lx x], return H if find, else fail **)\n  match goal with\n    | H: join_list ?lx x |- _ =>\n      constr:(H)\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4 x5:T) t v,\n    join_list (x1::x2::nil) x3 ->\n    get x1 t = Some v -> False.\nintros.\nlet n:= search_x x3 in pose n.\nAbort.\n\nLtac in_hyp_x x :=\n  (** x: T **)\n  (** whether [join_list lx x] is in hypo, return true/false **)\n  match goal with\n    | H: join_list ?lx x |- _ =>\n      constr:(true)\n    | |- _ => constr:(false)\n  end.\n\nLtac in_hyp_x' x :=\n  (** x: T **)\n  (** whether [join_list lx x] is in hypo, return tactic value **)\n  match goal with\n    | H: join_list ?lx x |- _ => idtac\n  end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 x4 x5:T) t v,\n    join_list (x1::x2::nil) x3 ->\n    join_list nil emp ->\n    get x1 t = Some v -> False.\nintros.\nlet n:= search_x x3 in pose n.\nlet n:= in_hyp_x emp in pose n.\nAbort.\n\nDefinition done (T : Type) (x : T) :=\n  (** I learn this tricky method in CPDT. *)\n  (** While we proof the goal, hypo place can be used to keep accumulated information.\n        This function acts as the sign of such information.\n   **)\n  True.\n(* ** ac: Check done. *)\n(* ** ac: Check done (1 = 1). *)\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 y z : T),\n    False.\nintros.\nassert (done (x1 = x2)) by constructor.\nassert (done x1) by constructor.\nAbort.\n\nLtac place_done T :=\n  (** T: Type **)\n  (** intro [done T] **)\n  assert (done T) by constructor.\n\nLtac check_done T :=\n  (** T: Type **)\n  (** if [done T] is in context, return true, else return false **)\n  match goal with\n    | H: done T |- _ =>\n      constr:(true)\n    | _ => constr:(false)\n  end.\n\nLtac check_done' T :=\n  (** T: Type **)\n  (** if [done T] is in context, succeed, else fail **)\n  let b := check_done T in\n  match b with\n    | true => idtac\n    | false => fail\n  end.\n\nLtac clear_done :=\n  (** clear all form [done _] in context **)\n  repeat match goal with\n           | H: done _ |- _ =>\n             clear H\n         end.\n\nGoal forall {A B T:Type} {MC:PermMap A B T} (x1 x2 x3 y z : T),\n    False.\nintros.\nplace_done (x1 = x2).\nplace_done x1.\nplace_done A.\n(* ** ac: check_done' A. *)\nlet x := check_done (x1=x2) in pose x.\nclear_done.\nAbort.\n\nLemma jl_split_left:\n  forall {A B T:Type} {MC:PermMap A B T} l1 l2 z,\n    join_list (l1 ++ l2) z ->\n    exists x,\n      join_list l1 x.\nProof.\n  intros.\n  apply jl_split in H.\n  destruct H as (x & y & H1 & H2 & H3).\n  eauto.\nQed.\n\n\nLemma map_join_get_none':\n  forall {A B T:Type} {MC:PermMap A B T} x y z t,\n    join x y z ->\n    get y t = None ->\n    get z t = get x t.\nProof.\n  intros.\n  apply map_join_comm in H.\n  eapply map_join_get_none; eauto.\nQed.  \n\nHint Resolve map_join_get_none' : jdb.\n\nLemma map_join_get_no_perm:\n  forall {A B T:Type} {MC:PermMap A B T} x y z t v,\n    usePerm = false ->\n    join x y z ->\n    get x t = Some v ->\n    get y t = None /\\ get z t = Some v.\nProof.\n  intros.\n  destruct (get y t) eqn:F1; destruct (get z t) eqn:F2.\n  assert (Hf: False) by jeauto2; inversion Hf.\n  assert (Hf: False) by jeauto2; inversion Hf.\n  assert (Hf: get z t = get x t) by jeauto2.\n  rewrite H1 in *.\n  rewrite F2 in *.\n  inversion Hf.\n  subst.\n  auto.\n  assert (Hf: get z t = get x t) by jeauto2.\n  rewrite H1 in *.\n  rewrite F2 in *.\n  inversion Hf.\nQed.\n\nLemma map_join_get_no_perm1:\n  forall {A B T:Type} {MC:PermMap A B T} x y z t v,\n    usePerm = false ->\n    join x y z ->\n    get x t = Some v ->\n    get y t = None.\nProof.\n  intros.\n  generalize (@map_join_get_no_perm _ _ _ _ _ _ _ _ _ H H0 H1); intro. \n  destruct H2; auto.\nQed.  \n\nLemma map_join_get_no_perm2:\n  forall {A B T:Type} {MC:PermMap A B T} x y z t v,\n    usePerm = false ->\n    join x y z ->\n    get x t = Some v ->\n    get z t = Some v.\nProof.\n  intros.\n  generalize (@map_join_get_no_perm _ _ _ _ _ _ _ _ _ H H0 H1); intro. \n  destruct H2; auto.\nQed.  \n\nHint Resolve @map_join_get_no_perm1 @map_join_get_no_perm2 : jdb.\n\nLemma jl_intro_set_noPerm:\n  forall {A B T:Type} {MC:PermMap A B T} lx' x t v,\n    usePerm = false ->\n    join_list ((sig t v)::lx') x ->\n    forall v', join_list ((sig t v')::lx') (set x t v').\nProof.\n  intros.\n  inversion H0; clear H0; subst.\n  eapply jl_cons.\n  jeauto.\n  erewrite <- map_set_sig.\n  assert (get z' t = None) by jeauto2.\n  jeauto2.\nQed.\n\nLemma jl_intro_get_noPerm:\n  forall {A B T:Type} {MC:PermMap A B T} lx' x t v,\n    usePerm = false ->\n    join_list ((sig t v)::lx') x ->\n    get x t = Some v.\nProof.\n  intros.\n  inversion H0; clear H0; subst.\n  jeauto2.\nQed.\n\nLtac simpl_map :=\n  match goal with\n    | H : exists _, _ |- _ => destruct H; simpl_map\n    | H : (_ /\\ _) |- _ => destruct H; simpl_map\n    (*\n    | |- _ /\\ _ => split; simpljoin'\n      | H : emposabst _ |- _ =>\n      unfold emposabst in H; subst; mytac_1\n    *) \n    | H :  join emp _ _ |- _ =>\n      apply  map_join_emp' in H; subst;simpl_map\n\n    | H :  join _ emp _ |- _ =>\n      apply  map_join_comm in H; apply map_join_emp' in H; subst;simpl_map\n\n    | |-  join emp _ _ => \n      apply  map_join_comm;apply  map_join_emp;simpl_map\n    | |-  join _ emp _ =>\n       apply  map_join_emp; simpl_map\n\n    | H : join ?a ?b ?ab |- join ?b ?a ?ab =>\n      apply map_join_comm; auto\n\n    | H : (_, _) = (_, _) |- _ => inversion H; clear H; simpl_map\n    | H : ?x = ?x |- _ => clear H; simpl_map\n    | |- ?x = ?x => reflexivity\n\n    | |-  join _ ?a ?a => apply  map_join_comm;simpl_map\n    | |-  join ?a _ ?a => apply  map_join_emp;simpl_map\n\n    | |- emp = _ => reflexivity;simpl_map\n    | |- _ = emp => reflexivity; simpl_map\n(*    | |- emposabst _ => unfold emposabst; reflexivity; mytac_1\n    | |- empabst = _ => reflexivity; mytac_1\n    | |- _ = empabst => reflexivity; mytac_1\n\n    | |- empisr = _ => reflexivity; mytac_1\n    | |- _ = empisr => reflexivity; mytac_1\n *)\n    | H : True |- _ => clear H; simpl_map\n    | |- True => auto\n    | _ => try (progress subst; simpl_map)\n  end.\n\nLtac simpljoin := repeat progress simpl_map.\n\nTactic Notation \"simp\" \"join\" := simpljoin.\n",
      "theorem": "Lemma jl_deter:\n  forall {A B T:Type} {MC:PermMap A B T} l x x',\n    join_list l x ->\n    join_list l x' ->\n    x = x'.",
      "ground_truth": "Proof.\n  induction l.\n  intros.\n  assert (x = emp) by jeauto.\n  assert (x' = emp) by jeauto.\n  subst.\n  auto.\n\n  intros x x' Hjl_x Hjl_x'.\n  inversion Hjl_x.\n  subst.\n  rename z' into nx.\n  inversion Hjl_x'.\n  subst.\n  rename z' into nx'.\n  clear Hjl_x Hjl_x'.\n  rename H1 into Hjl_nx.\n  rename H2 into Hjl_nx'.\n  rename H3 into Hjop_x.\n  rename H5 into Hjop_x'.\n  assert (nx = nx') by jeauto2.\n  subst.\n  jeauto2.\nQed."
    },
    {
      "split": "train-sft",
      "index": 48,
      "prefix": "Require Import Setoid.\nRequire Import Morphisms.\nRequire Import Coq.Program.Basics.\nRequire Import NArith.\n\nUnset Printing Records.\n\nFrom Ordinal Require Import Defs.\nFrom Ordinal Require Import Operators.\n\n(** * Definitions by transfinite primitive recursion.\n  *)\nDefinition foldOrd (z:Ord) (s:Ord -> Ord) : Ord -> Ord :=\n  fix foldOrd (x:Ord) : Ord :=\n    match x with\n    | ord A f => z \u2294 supOrd (fun i => s (foldOrd (f i)))\n    end.\n\nLemma foldOrd_unfold z s x :\n  foldOrd z s x = z \u2294 supOrd (fun i => s (foldOrd z s (x i))).\nProof.\n  destruct x; reflexivity.\nQed.\n\nLemma foldOrd_least z s (q:Ord -> Ord)\n      (Hz : forall x, z \u2264 q x)\n      (Hmono : forall x y, x \u2264 y -> s x \u2264 s y)\n      (Hsq : forall (x:Ord) (i:x), s (q (x i)) \u2264 (q x)) :\n      (forall x, foldOrd z s x \u2264 q x).\nProof.\n  induction x as [A f Hx].\n  simpl.\n  apply lub_least.\n  - apply Hz.\n  - apply sup_least. intros a.\n    transitivity (s (q (f a))); auto.\n    apply (Hsq (ord A f)).\nQed.\n\nLemma foldOrd_unfold_le z s (x:Ord) i :\n  s (foldOrd z s (x i)) \u2264 foldOrd z s x.\nProof.\n  destruct x as [A f]. simpl.\n  etransitivity; [ | apply lub_le2 ].\n  etransitivity; [ | apply (sup_le _ _ i)]. simpl.\n  reflexivity.\nQed.\n\nLemma foldOrd_above_z z s x : z \u2264 foldOrd z s x.\nProof.\n  destruct x as [A f]; simpl; auto with ord.\nQed.\n\nLemma foldOrd_monotone z s : forall x y,\n    (forall a b, a \u2264 b -> s a \u2264 s b) ->\n    x \u2264 y -> foldOrd z s x \u2264 foldOrd z s y.\nProof.\n  induction x as [A f Hx]. simpl; intros.\n  apply lub_least.\n  - apply foldOrd_above_z.\n  - apply sup_least. intros a; simpl.\n    rewrite ord_le_unfold in H0.\n    specialize (H0 a). simpl in H0.\n    rewrite ord_lt_unfold in H0.\n    destruct H0 as [b ?].\n    rewrite <- (foldOrd_unfold_le z s y b).\n    apply H.\n    apply Hx; auto.\nQed.\n\nLemma foldOrd_zero z s : foldOrd z s 0 \u2248 z.\nProof.\n  split.\n  - simpl.\n    apply lub_least.\n    + apply ord_le_refl.\n    + apply sup_least. intros. elim a.\n  - apply foldOrd_above_z.\nQed.\n\nLemma foldOrd_increasing z s : forall x y,\n    (forall a, z \u2264 a -> a < s a) ->\n    (forall a b, a \u2264 b -> s a \u2264 s b) ->\n    x < y -> foldOrd z s x < foldOrd z s y.\nProof.\n  intros x y. revert x.\n  destruct y as [B g]; simpl; intros.\n  rewrite ord_lt_unfold in H1.\n  destruct H1 as [b ?].\n  simpl in *.\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ b).\n  eapply ord_le_lt_trans; [ | apply H; apply foldOrd_above_z ].\n  apply foldOrd_monotone; auto.\nQed.\n\nLemma foldOrd_succ z s x :\n  (forall q, z \u2264 q -> z \u2264 s q) ->\n  foldOrd z s (succOrd x) \u2248 s (foldOrd z s x).\nProof.\n  split.\n  - simpl.\n    apply lub_least.\n    + apply H.\n      destruct x; simpl; auto with ord.\n    + apply sup_least. intro.\n      apply ord_le_refl.\n  - rewrite succ_unfold. simpl foldOrd.\n    rewrite <- lub_le2.\n    rewrite <- (sup_le _ _ tt).\n    reflexivity.\nQed.\n\nLemma foldOrd_limit z s x :\n  limitOrdinal x ->\n  (forall a b, a \u2264 b -> s a \u2264 s b) ->\n  foldOrd z s x \u2248 boundedSup x (foldOrd z s).\nProof.\n  intros.\n  split.\n  - destruct x as [A f]. destruct H. simpl.\n    apply lub_least.\n    + destruct H as [a0].\n      eapply ord_le_trans; [ | apply (sup_le _ _ a0) ]. simpl.\n      destruct (f a0); simpl; auto with ord.\n    + apply sup_least. intro a.\n      destruct (H1 a) as [a' ?].\n      eapply ord_le_trans; [ | apply (sup_le _ _ a') ]. simpl.\n      apply ord_le_trans with (foldOrd z s (succOrd (f a))).\n      simpl.\n      eapply ord_le_trans; [ | apply lub_le2 ].\n      eapply ord_le_trans; [ | apply (sup_le _ _ tt) ]. simpl.\n      apply ord_le_refl.\n      apply foldOrd_monotone; auto.\n      apply succ_least. auto.\n  - apply boundedSup_least. intros a Ha.\n    apply foldOrd_monotone; auto with ord.\nQed.\n\nLemma foldOrd_strongly_continuous z s :\n  strongly_continuous (foldOrd z s).\nProof.\n  red; simpl; intros.\n  apply lub_least.\n  - rewrite <- (sup_le _ _ a0).\n    apply foldOrd_above_z.\n  - apply sup_least.\n    intros [a q]; simpl.\n    rewrite <- (sup_le _ _ a).\n    apply foldOrd_unfold_le.\nQed.\n\nLemma foldOrd_complete z s :\n  complete z ->\n  (forall x, z <= x -> 0 < s x) ->\n  z <= s z ->\n  (forall x y, x <= y -> s x <= s y) ->\n  (forall o, complete o -> complete (s o)) ->\n  forall x, complete x -> complete (foldOrd z s x).\nProof.\n  intros Hz Hs0 Hs1 Hs2 Hs3.\n  induction x as [X f Hx].\n  simpl; intros [Hx1 [Hx2 Hx3]].\n  assert (Hsup : complete (supOrd (fun i : X => s (foldOrd z s (f i))))).\n  { apply sup_complete; auto.\n    - intros x1 x2.\n      destruct (Hx1 x1 x2) as [x' [Hx'1 Hx'2]].\n      exists x'.\n      split; apply Hs2; apply foldOrd_monotone; auto.\n    - destruct Hx2 as [[x]|Hx2].\n      + left. exists x.\n        apply Hs0.\n        apply foldOrd_above_z.\n      + right. intro x; elim Hx2. exact (inhabits x).\n  }\n  destruct Hx2 as [[x]|Hx2].\n  + apply lub_complete2; auto.\n    rewrite <- (sup_le _ _ x).\n    transitivity (s z); auto.\n    apply Hs2. apply foldOrd_above_z.\n  + apply lub_complete1; auto.\n    apply sup_least. intro x.\n    elim Hx2. exact (inhabits x).\nQed.\n\n\n(** * Ordinal addition *)\n\nDefinition addOrd (x y:Ord) := foldOrd x succOrd y.\n\nNotation \"x + y\" := (addOrd x y) : ord_scope.\n\nLemma addOrd_unfold (x y:Ord) : x + y = x \u2294 supOrd (fun i => succOrd (x + y i)).\nProof.\n  destruct y; reflexivity.\nQed.\n\nLemma addOrd_succ (x y:Ord) : x + succOrd y \u2248 succOrd (x + y).\nProof.\n  unfold addOrd. apply foldOrd_succ.\n  intros; auto with ord.\nQed.\n\nLemma addOrd_le1 x y : x \u2264 x + y.\nProof.\n  destruct y as [B g].\n  simpl.\n  apply lub_le1.\nQed.\n\nLemma addOrd_le2 x y : y \u2264 x + y.\nProof.\n  induction y as [B g Hy].\n  destruct x as [A f].\n  simpl.\n  rewrite ord_le_unfold; intro b. simpl.\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ b).\n  apply succ_trans.\n  apply Hy.\nQed.\n\nLemma addOrd_zero_r x : x + 0 \u2248 x.\nProof.\n  split; simpl; auto with ord.\n  apply lub_least; auto with ord.\n  apply sup_least. intros [].\nQed.\n\nLemma addOrd_zero_l x : 0 + x \u2248 x.\nProof.\n  induction x as  [X f Hx].\n  split; simpl.\n  - apply lub_least; auto with ord.\n    apply sup_least; intro i.\n    apply succ_least.\n    rewrite Hx.\n    apply (index_lt (ord X f)).\n  - rewrite ord_le_unfold.\n    simpl; intro x.\n    rewrite <- lub_le2.\n    rewrite <- (sup_le _ _ x).\n    apply succ_trans.\n    apply Hx.\nQed.\n\nLemma addOrd_monotone :\n  forall x y z1 z2, x \u2264 y -> z1 \u2264 z2 -> x + z1 \u2264 y + z2.\nProof.\n  induction z1 as [C h]. destruct z2 as [D i].\n  simpl; intros.\n  apply lub_least.\n  + rewrite <- lub_le1. auto.\n  + rewrite <- lub_le2.\n    apply sup_least; intro c.\n    destruct (ord_le_subord _ _ H1 c) as [d Hd]. simpl in *.\n    rewrite <- (sup_le _ _ d).\n    apply succ_monotone.\n    apply H; auto.\nQed.\n\nLemma addOrd_increasing :\n  forall x y z, x < y -> z + x < z + y.\nProof.\n  intros.\n  unfold addOrd.\n  apply foldOrd_increasing; auto with ord.\nQed.\n\nLemma addOrd_continuous x :\n  strongly_continuous (addOrd x).\nProof.\n  unfold addOrd.\n  apply foldOrd_strongly_continuous.\nQed.\n\nLemma addOrd_complete x y :\n  complete x -> complete y -> complete (x + y).\nProof.\n  intros. unfold addOrd.\n  apply foldOrd_complete; auto with ord.\nQed.\n\nAdd Parametric Morphism : addOrd with signature\n    ord_le ++> ord_le ++> ord_le as addOrd_le_mor.\nProof.\n  intros. apply addOrd_monotone; auto.\nQed.\n\nAdd Parametric Morphism : addOrd with signature\n    ord_le ++> ord_lt ++> ord_lt as addOrd_lt_mor2.\nProof.\n  intros.\n  eapply ord_lt_le_trans.\n  apply addOrd_increasing; eauto.\n  apply addOrd_monotone; auto.\n  reflexivity.\nQed.\n\nAdd Parametric Morphism : addOrd with signature\n   ord_eq ==> ord_eq ==> ord_eq as addOrd_eq_mor.\nProof.\n  intros; split; apply addOrd_le_mor; solve [apply H|apply H0].\nQed.\n\nLemma addOrd_lub a b c :\n  a + (b \u2294 c) \u2248 (a + b) \u2294 (a + c).\nProof.\n  apply (lub_continuous (addOrd a)).\n  - intros. apply addOrd_monotone; auto with ord.\n  - apply foldOrd_strongly_continuous.\nQed.\n\nLemma addOrd_assoc a b c :\n  a + (b + c) \u2248 a + b + c.\nProof.\n  induction c as [C g]; simpl.\n  rewrite addOrd_lub.\n  split.\n  - apply lub_least.\n    + apply lub_le1.\n    + unfold addOrd at 1.\n      rewrite foldOrd_unfold at 1.\n      apply lub_least.\n      rewrite <- lub_le1.\n      apply addOrd_le1.\n      apply sup_least.\n      rewrite sup_unfold. simpl.\n      intros [??]. simpl.\n      apply succ_least.\n      rewrite <- lub_le2.\n      rewrite <- (sup_le _ _ x).\n      apply succ_trans.\n      apply H.\n  - apply lub_least.\n    + apply lub_le1.\n    + apply sup_least; intro c.\n      apply succ_least.\n      rewrite <- H.\n      rewrite <- addOrd_lub.\n      apply addOrd_increasing.\n      rewrite <- lub_le2.\n      rewrite <- (sup_le _ _ c).\n      apply succ_trans.\n      reflexivity.\nQed.\n\nLemma addOrd_cancel_le a b x y :\n  a + x \u2264 b + y -> a \u2265 b -> x \u2264 y.",
      "suffix": "\n\n\nLemma addOrd_cancel a b x y :\n  a + x \u2248 b + y -> a \u2248 b -> x \u2248 y.\nProof.\n  unfold ord_eq; intuition; eapply addOrd_cancel_le; eauto.\nQed.\n\nLemma onePlus_succ x : 1 + x \u2264 succOrd x.\nProof.\n  induction x as [X f Hx].\n  rewrite addOrd_unfold. simpl.\n  apply lub_least. apply succOrd_le_mor. auto with ord.\n  apply sup_least; intro i.\n  apply succOrd_le_mor.\n  rewrite Hx.\n  apply succ_least. apply (index_lt (ord X f) i).\nQed.\n\nLemma limit_onePlus x : limitOrdinal x -> 1 + x \u2264 x.\nProof.\n  destruct x as [X f]; simpl; intros [??].\n  apply lub_least.\n  apply succ_least.\n  destruct H as [x]. rewrite ord_lt_unfold. exists x. auto with ord.\n  apply sup_least; intro x.\n  apply succ_least. simpl.\n  hnf in H0.\n  destruct (H0 x) as [y Hy].\n  apply ord_le_lt_trans with (f y).\n  transitivity (succOrd (f x)).\n  apply onePlus_succ.\n  apply succ_least. auto.\n  apply (index_lt (ord X f) y).\nQed.\n\nLemma natOrdSize_add n m :\n  natOrdSize (n+m)%nat \u2248 natOrdSize m + natOrdSize n.\nProof.\n  induction n; simpl natOrdSize.\n  - symmetry. apply addOrd_zero_r.\n  - rewrite addOrd_succ.\n    rewrite IHn. reflexivity.\nQed.\n\nLemma limitOrdinal_intro : forall x,\n    x > 0 ->\n    (forall i, i < x -> exists j, i < j /\\ j < x) ->\n    limitOrdinal x.\nProof.\n  destruct x as [X f]; intros.\n  simpl; split.\n  - rewrite ord_lt_unfold in H. destruct H as [i _].\n    exact (inhabits i).\n  - hnf. intros.\n    destruct (H0 (f a)) as [b [??]].\n    apply (index_lt (ord X f) a).\n    rewrite ord_lt_unfold in H2.\n    destruct H2 as [k ?].\n    exists k.\n    apply ord_lt_le_trans with b; auto.\nQed.\n\nLemma successor_add x y :\n  successorOrdinal y -> successorOrdinal (x + y).\nProof.\n  rewrite ord_isSucc.\n  intros [o Ho].\n  rewrite ord_isSucc.\n  exists (x + o).\n  rewrite Ho.\n  apply addOrd_succ.\nQed.\n\nLemma limit_add x y :\n  limitOrdinal y -> limitOrdinal (x + y).\nProof.\n  intros.\n  destruct y as [Y f]; simpl in *; intuition.\n  apply limitOrdinal_intro.\n  destruct H0 as [y].\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ y).\n  apply succ_trans. auto with ord.\n  intros.\n  apply lub_lt in H.\n  destruct H.\n  exists x.\n  split; auto.\n  destruct H0 as [y].\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ y).\n  apply succ_trans. apply addOrd_le1.\n  apply sup_lt in H.\n  destruct H as [y H].\n  destruct (H1 y) as [y' H2].\n  exists (x + f y').\n  split.\n  eapply ord_lt_le_trans; [ apply H |].\n  apply succ_least.\n  apply addOrd_increasing.\n  auto.\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ y').\n  apply succ_trans.\n  reflexivity.\nQed.\n\n\nLemma foldOrd_add z s a b :\n  (forall x y, x \u2264 y -> s x \u2264 s y) ->\n  foldOrd z s (a + b) \u2248 foldOrd (foldOrd z s a) s b.\nProof.\n  intros.\n  induction b as [B g]. simpl.\n  rewrite lub_continuous.\n  split.\n  apply lub_least.\n  apply lub_le1.\n  transitivity (foldOrd z s (limOrd (fun i => a + g i))).\n  apply foldOrd_monotone; auto; apply sup_succ_lim.\n  simpl.\n  apply lub_least.\n  rewrite <- lub_le1.\n  apply foldOrd_above_z.\n  apply sup_least; intro i.\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ i).\n  apply H.\n  apply H0.\n  apply lub_least; auto with ord.\n  apply sup_least; intro i.\n  rewrite <- lub_le2.\n  transitivity (foldOrd z s (succOrd (a + g i))).\n  simpl.\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ tt).\n  apply H.\n  apply H0.\n  apply foldOrd_monotone; auto.\n  rewrite <- (sup_le _ _ i); auto with ord.\n  intros; apply foldOrd_monotone; auto.\n  apply foldOrd_strongly_continuous.\nQed.\n\n\n(** * Ordinal multiplication *)\n\nFixpoint mulOrd (x:Ord) (y:Ord) : Ord :=\n    match y with\n    | ord B g => supOrd (fun b:B => mulOrd x (g b) + x)\n    end.\n\nNotation \"x * y\" := (mulOrd x y) : ord_scope.\n\nLemma mulOrd_unfold (x:Ord) (y:Ord) :\n  x * y =\n  supOrd (fun i:y => x * (y i) + x).\nProof.\n  destruct y; auto.\nQed.\n\nLemma mulOrd_monotone1 : forall z x y, x \u2264 y -> x * z \u2264 y * z.\nProof.\n  induction z as [C h Hz].\n  simpl; intros.\n  apply sup_least. intro c. simpl.\n  rewrite <- (sup_le _ _ c).\n  apply addOrd_monotone; auto.\nQed.\n\nLemma mulOrd_monotone2 : forall y x z, y \u2264 z -> x * y \u2264 x * z.\nProof.\n  induction y as [B g Hy].\n  intros.\n  destruct x as [A f]; simpl in *.\n  apply sup_least. intro b.\n  rewrite ord_le_unfold in H.\n  specialize (H b).\n  simpl in H.\n  rewrite ord_lt_unfold in H.\n  destruct H as [q ?].\n  specialize (Hy b).\n  generalize (Hy (ord A f) (z q) H).\n  intros.\n  rewrite (mulOrd_unfold (ord A f) z).\n  rewrite <- (sup_le _ _ q).\n  apply lub_least.\n  - simpl.\n    rewrite <- lub_le1.\n    apply Hy. auto.\n  - simpl.\n    rewrite <- lub_le2.\n    apply sup_ord_le_morphism. intro i.\n    apply succ_monotone.\n    apply addOrd_monotone; auto.\n    reflexivity.\nQed.\n\nLemma mulOrd_increasing2 : forall x y z,\n    0 < x ->\n    y < z ->\n    x * y < x * z.\nProof.\n  intros x y [C h] Hx H.\n  rewrite (mulOrd_unfold x (ord C h)).\n  simpl.\n  rewrite ord_lt_unfold in H.\n  destruct H as [c Hc]. simpl in Hc.\n  rewrite <- (sup_le _ _ c).\n  apply ord_le_lt_trans with (mulOrd x (h c)); [ apply mulOrd_monotone2 ; assumption | ].\n  apply ord_le_lt_trans with (addOrd (mulOrd x (h c)) zeroOrd).\n  - apply addOrd_zero_r.\n  - apply addOrd_increasing. auto.\nQed.\n\nAdd Parametric Morphism : mulOrd with signature\n    ord_le ++> ord_le ++> ord_le as mulOrd_le_mor.\nProof.\n  intros.\n  apply ord_le_trans with (x * y0).\n  apply mulOrd_monotone2; auto.\n  apply mulOrd_monotone1; auto.\nQed.\n\nAdd Parametric Morphism : mulOrd with signature\n    ord_eq ==> ord_eq ==> ord_eq as mulOrd_eq_mor.\nProof.\n  unfold ord_eq; intuition; apply mulOrd_le_mor; auto.\nQed.\n\n\nLemma mulOrd_zero_r : forall x, x * 0 \u2248 0.\nProof.\n  intros; split.\n  - destruct x as [A f]. simpl.\n    apply sup_least. intuition.\n  - apply zero_least.\nQed.\n\nLemma mulOrd_zero_l : forall x, 0 * x \u2248 0.\nProof.\n  induction x as [X f Hx].\n  split; simpl mulOrd.\n  - apply sup_least; intro x.\n    apply lub_least.\n    apply Hx.\n    apply sup_least; intros [].\n  - apply zero_least.\nQed.\n\nLemma mulOrd_succ : forall x y, x * (succOrd y) \u2248 (x * y) + x.\nProof.\n  intros; split; simpl.\n  - apply sup_least; auto with ord.\n  - simpl.\n    rewrite <- (sup_le _ _ tt); auto with ord.\nQed.\n\nLemma mulOrd_one_r : forall x, mulOrd x 1 \u2248 x.\nProof.\n  intro.\n  rewrite mulOrd_succ.\n  rewrite mulOrd_zero_r.\n  apply addOrd_zero_l.\nQed.\n\nLemma mulOrd_continuous x : strongly_continuous (mulOrd x).\nProof.\n  red; simpl; intros.\n  apply sup_least.\n  intros [a q]. simpl.\n  rewrite <- (sup_le _ _ a).\n  rewrite (mulOrd_unfold x (f a)).\n  rewrite <- (sup_le _ _ q).\n  apply ord_le_refl.\nQed.\n\nLemma mulOrd_lub a b c :\n  a * (b \u2294 c) \u2248 (a * b) \u2294 (a * c).\nProof.\n  apply (lub_continuous (mulOrd a)).\n  - intros. apply mulOrd_monotone2; auto with ord.\n  - apply mulOrd_continuous.\nQed.\n\nLemma mulOrd_one_l : forall x, mulOrd 1 x \u2248 x.\nProof.\n  intro.\n  induction x as [X f].\n  rewrite mulOrd_unfold.\n  split.\n  - apply sup_least. intro i.\n    rewrite addOrd_unfold; simpl.\n    apply lub_least.\n    + rewrite H. apply (index_le (ord X f)).\n    + apply sup_least; intro.\n      apply succ_least.\n      rewrite ord_lt_unfold. exists i.\n      apply lub_least.\n      apply H.\n      apply sup_least; intros [].\n  - rewrite ord_le_unfold; intro i.\n    rewrite <- (sup_le _ _ i); simpl.\n    rewrite <- lub_le2.\n    rewrite <- (sup_le _ _ tt).\n    apply succ_trans.\n    rewrite <- lub_le1.\n    apply H.\nQed.\n\nLemma mulOrd_positive : forall x y,\n    0 < x ->\n    0 < y ->\n    0 < x * y.\nProof.\n  intros x y Hx Hy.\n  destruct x as [A f].\n  destruct y as [B g].\n  simpl.\n  rewrite ord_lt_unfold in Hx.\n  rewrite ord_lt_unfold in Hy.\n  destruct Hx as [a _].\n  destruct Hy as [b _].\n  simpl in *.\n  rewrite <- (sup_le _ _ b).\n  rewrite <- lub_le2. simpl.\n  rewrite <- (sup_le _ _ a).\n  auto with ord.\nQed.\n\nLemma mulOrd_limit : forall x y,\n    limitOrdinal y ->\n    x * y \u2248 supOrd (fun b:y => x * (y b)).\nProof.\n  destruct y as [B g]; simpl; intros.\n  split.\n  - apply sup_least. intro b.\n    destruct H as [_ H].\n    destruct (H b) as [b' Hb'].\n    rewrite <- (sup_le _ _ b').\n    apply ord_le_trans with (mulOrd x (succOrd (g b))).\n    apply (mulOrd_succ x (g b)).\n    apply mulOrd_monotone2.\n    apply succ_least; auto.\n  - apply sup_least. intro b.\n    rewrite <- (sup_le _ _ b).\n    apply addOrd_le1.\nQed.\n\nLemma mulOrd_complete x y : complete x -> complete y -> complete (x * y).\nProof.\n  induction y as [Y g Hy]; simpl mulOrd; intros Hx [Hy1 [Hy2 Hy3]].\n  apply sup_complete.\n  - intros. apply addOrd_complete; auto.\n  - intros y1 y2.\n    destruct (Hy1 y1 y2) as [y' [Hy'1 Hy'2]].\n    exists y'. split.\n    + apply addOrd_monotone; auto.\n      apply mulOrd_monotone2; auto.\n      reflexivity.\n    + apply addOrd_monotone; auto.\n      apply mulOrd_monotone2; auto.\n      reflexivity.\n  - destruct (complete_zeroDec x Hx).\n    + right; intro y.\n      rewrite <- (addOrd_zero_l 0).\n      apply addOrd_monotone; auto.\n      rewrite H.\n      rewrite mulOrd_zero_l.\n      reflexivity.\n    + destruct Hy2 as [[y]|Hy2].\n      * left. exists y.\n        apply ord_lt_le_trans with x; auto.\n        rewrite <- (addOrd_zero_l x) at 1.\n        apply addOrd_monotone; auto with ord.\n      * right. intro y. elim Hy2. exact (inhabits y).\nQed.\n\n\nLemma ordDistrib_left a b c :\n  a * (b + c) \u2248 (a * b) + (a * c).\nProof.\n  induction c as [C h].\n  split.\n  - rewrite addOrd_unfold.\n    rewrite mulOrd_lub.\n    apply lub_least.\n    + apply addOrd_le1.\n    + rewrite mulOrd_unfold.\n      apply sup_least.\n      intros [??]. unfold boundedSup.\n      rewrite (H x).\n      rewrite <- addOrd_assoc.\n      apply addOrd_monotone; auto with ord.\n      rewrite (mulOrd_unfold a (ord C h)).\n      rewrite <- (sup_le _ _ x).\n      apply addOrd_monotone; auto with ord.\n  - rewrite addOrd_unfold.\n    apply lub_least.\n    + rewrite addOrd_unfold.\n      rewrite mulOrd_lub.\n      apply lub_le1.\n    + rewrite mulOrd_unfold.\n      simpl.\n      rewrite (sup_unfold C (fun i => a * h i + a)). simpl.\n      apply sup_least; intros [??]. simpl.\n      apply succ_least.\n      apply ord_lt_le_trans with (a * b + (a * h x + a)).\n      apply addOrd_increasing.\n      apply index_lt.\n      rewrite addOrd_assoc.\n      rewrite mulOrd_lub.\n      rewrite <- lub_le2.\n      rewrite (mulOrd_unfold a (supOrd _ )).\n      rewrite (sup_unfold C (fun i => succOrd (b + h i))). simpl.\n      rewrite <- (sup_le _ _ (existT _ x tt)). simpl.\n      rewrite (H x).\n      reflexivity.\nQed.\n\nLemma mulOrd_assoc a b c :\n  a * (b * c) \u2248 a * b * c.\nProof.\n  induction c as [C h]; simpl.\n  split.\n  - apply sup_least. intros [??]. simpl.\n    fold mulOrd.\n    rewrite <- (sup_le _ _ x).\n    rewrite <- (H x).\n    rewrite <- ordDistrib_left.\n    destruct (b * h x + b) as [Q q]; simpl.\n    rewrite <- (sup_le _ _ o).\n    reflexivity.\n  - apply sup_least. simpl; intro x.\n    rewrite <- (H x).\n    rewrite <- ordDistrib_left.\n    rewrite mulOrd_unfold.\n    apply sup_least; intro i.\n    rewrite (mulOrd_unfold a (supOrd _)). simpl.\n    rewrite (sup_unfold C (fun i => b * h i + b)). simpl.\n    rewrite <- (sup_le _ _ (existT _ x i)). simpl.\n    reflexivity.\nQed.\n\nLemma natOrdSize_mul n m :\n  natOrdSize (n*m)%nat \u2248 natOrdSize m * natOrdSize n.\nProof.\n  induction n; simpl natOrdSize.\n  - rewrite mulOrd_zero_r; reflexivity.\n  - rewrite mulOrd_succ.\n    rewrite natOrdSize_add.\n    rewrite IHn.\n    reflexivity.\nQed.\n\n(** * Ordinal exponentiation *)\n\nDefinition expOrd (x y:Ord) : Ord :=\n  foldOrd 1 (fun a => a * x) y.\n\nLemma expOrd_unfold (x:Ord) (y:Ord) :\n  expOrd x y =\n  1 \u2294 supOrd (fun i:y => expOrd x (y i) * x).\nProof.\n  destruct y; auto.\nQed.\n\nLemma expOrd_nonzero x y : 0 < expOrd x y.\nProof.\n  apply ord_lt_le_trans with 1.\n  apply succ_lt.\n  apply foldOrd_above_z.\nQed.\n\nLemma expOrd_zero x : expOrd x 0 \u2248 1.\nProof.\n  apply foldOrd_zero.\nQed.\n\nLemma expOrd_succ x y :\n  0 < x ->\n  expOrd x (succOrd y) \u2248 (expOrd x y) * x.\nProof.\n  intros.\n  apply foldOrd_succ.\n  intros.\n  apply succ_least.\n  apply mulOrd_positive.\n  rewrite ord_le_unfold in H0. apply (H0 tt). auto.\nQed.\n\nLemma expOrd_monotone a : forall x y,\n    x \u2264 y ->\n    expOrd a x \u2264 expOrd a y.\nProof.\n  intros. apply foldOrd_monotone; auto.\n  intros; apply mulOrd_monotone1; auto.\nQed.\n\nLemma expOrd_monotone_base : forall x y a,\n  x \u2264 y ->\n  expOrd x a \u2264 expOrd y a.\nProof.\n  intros.\n  induction a as [A f].\n  do 2 rewrite expOrd_unfold.\n  apply lub_least. { apply lub_le1. }\n  rewrite <- lub_le2.\n  apply sup_least; intro i.\n  rewrite <- (sup_le _ _ i).\n  etransitivity.\n  { apply mulOrd_monotone2. apply H. }\n  apply mulOrd_monotone1.\n  apply H0.\nQed.\n\nAdd Parametric Morphism : expOrd with signature\n    ord_le ++> ord_le ++> ord_le as expOrd_le_mor.\nProof.\n  intros.\n  transitivity (expOrd x y0).\n  apply expOrd_monotone; auto.\n  apply expOrd_monotone_base; auto.\nQed.\n\nAdd Parametric Morphism : expOrd with signature\n    ord_eq ==> ord_eq ==> ord_eq as expOrd_eq_mor.\nProof.\n  unfold ord_eq; intuition; apply expOrd_le_mor; auto.\nQed.\n\nLemma expOrd_increasing a (Ha : 1 < a) :\n  forall x y,\n    x < y ->\n    expOrd a x < expOrd a y.\nProof.\n  intros.\n  apply foldOrd_increasing; auto.\n  - intros.\n    rewrite <- (mulOrd_one_r a0) at 1.\n    apply mulOrd_increasing2; auto.\n    apply ord_lt_le_trans with 1; auto.\n    apply succ_lt.\n  - apply mulOrd_monotone1.\nQed.\n\nLemma expOrd_limit x y (Hx: 1 < x) :\n  limitOrdinal y ->\n  expOrd x y \u2248 boundedSup y (expOrd x).\nProof.\n  intros.\n  apply foldOrd_limit; auto.\n  apply mulOrd_monotone1.\nQed.\n\nLemma expOrd_continuous x :\n  strongly_continuous (expOrd x).\nProof.\n  apply foldOrd_strongly_continuous; auto.\nQed.\n\nLemma expOrd_complete x y :\n  0 < x -> complete x -> complete y -> complete (expOrd x y).\nProof.\n  intros Hx0 Hx Hy. unfold expOrd.\n  apply foldOrd_complete; auto.\n  - apply succ_complete. apply zero_complete.\n  - intros. apply mulOrd_positive; auto.\n    apply ord_lt_le_trans with 1; auto.\n    apply succ_lt.\n  - apply succ_least.\n    apply mulOrd_positive; auto.\n    apply succ_lt.\n  - intros. apply mulOrd_monotone1; auto.\n  - intros; apply mulOrd_complete; auto.\nQed.\n\n\nLemma expOrd_one_base x : expOrd 1 x \u2248 1.\nProof.\n  induction x as [A f].\n  rewrite expOrd_unfold.\n  split.\n  - apply lub_least; auto with ord.\n    apply sup_least; intro i.\n    rewrite mulOrd_one_r.\n    apply (H i).\n  - apply lub_le1.\nQed.\n\nLemma expOrd_one x : expOrd x 1 \u2248 1 \u2294 x.\nProof.\n  rewrite expOrd_unfold.\n  split; apply lub_least.\n  apply lub_le1.\n  apply sup_least; intro i.\n  rewrite expOrd_zero.\n  rewrite mulOrd_one_l.\n  apply lub_le2.\n  apply lub_le1.\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ tt).\n  rewrite expOrd_zero.\n  rewrite mulOrd_one_l.\n  reflexivity.\nQed.\n\nLemma expOrd_one' x : x > 0 -> expOrd x 1 \u2248 x.\nProof.\n  intros.\n  rewrite expOrd_one.\n  split.\n  apply lub_least; auto with ord.\n  apply lub_le2.\nQed.\n\nLemma expOrd_lub a b c :\n  expOrd a (b \u2294 c) \u2248 expOrd a b \u2294 expOrd a c.\nProof.\n  unfold expOrd.\n  apply lub_continuous.\n  intros; apply foldOrd_monotone; auto.\n  intros; apply mulOrd_monotone1; auto.\n  apply foldOrd_strongly_continuous.\nQed.\n\nLemma expOrd_add a b c :\n  expOrd a (b + c) \u2248 expOrd a b * expOrd a c.\nProof.\n  induction c as [C h]; simpl.\n  rewrite expOrd_lub.\n  split.\n  - apply lub_least.\n    + rewrite mulOrd_lub.\n      rewrite <- lub_le1.\n      rewrite mulOrd_one_r.\n      reflexivity.\n    + rewrite expOrd_unfold at 1.\n      apply lub_least.\n      * rewrite mulOrd_lub.\n        rewrite <- lub_le1.\n        rewrite mulOrd_one_r.\n        apply succ_least.\n        apply expOrd_nonzero.\n      * apply sup_least; simpl.\n        intros [??]. simpl.\n        rewrite (H x).\n        rewrite <- mulOrd_assoc.\n        rewrite mulOrd_unfold.\n        apply sup_least. simpl; intro i.\n        rewrite mulOrd_lub.\n        rewrite <- lub_le2.\n        rewrite <- (sup_le _ _ x).\n        rewrite (mulOrd_unfold _ (expOrd a (h x) * a)).\n        rewrite <- (sup_le _ _ i).\n        reflexivity.\n\n  - apply sup_least. intros [|[x i]]; simpl.\n    + rewrite <- lub_le1.\n      transitivity (0 + expOrd a b).\n      apply addOrd_monotone; auto with ord.\n      apply sup_least; intros [].\n      apply addOrd_zero_l.\n    + rewrite <- lub_le2.\n      transitivity (expOrd a (b + h x) * a).\n      rewrite (H x).\n      rewrite <- mulOrd_assoc.\n      rewrite (mulOrd_unfold (expOrd a b) (expOrd a (h x) * a)).\n      rewrite <- (sup_le _ _ i).\n      reflexivity.\n      rewrite ord_le_unfold. intro j.\n      rewrite ord_lt_unfold. simpl.\n      exists (inr _ (existT _ (existT _ x tt) j)). simpl.\n      reflexivity.\nQed.\n\n\nLemma expOrd_mul a b c :\n  expOrd a (b * c) \u2248 expOrd (expOrd a b) c.\nProof.\n  revert a b; induction c as [C h]; intros.\n  rewrite mulOrd_unfold.\n  rewrite (expOrd_unfold (expOrd a b)).\n  split.\n  - rewrite expOrd_unfold.\n    apply lub_least; auto with ord.\n    apply sup_least; intros [i q].\n    rewrite <- lub_le2.\n    etransitivity; [ | apply (sup_le _ _ i) ]. simpl.\n    rewrite <- (H i).\n    rewrite <- expOrd_add.\n\n    unfold expOrd at 2.\n    rewrite foldOrd_unfold.\n    rewrite <- lub_le2.\n    rewrite <- (sup_le  _ _ q).\n    reflexivity.\n  - apply lub_least. { apply succ_least; apply expOrd_nonzero. }\n    apply sup_least. intro i.\n    rewrite <- (H i).\n    transitivity (expOrd a (b * h i + b)).\n    rewrite expOrd_add. reflexivity.\n    apply expOrd_monotone.\n    rewrite <- (sup_le _ _ i).\n    reflexivity.\nQed.\n\n\nDefinition powOmega (x:Ord) : Ord := expOrd \u03c9 x.\n\nLemma powOmega_monotone : forall x y, x \u2264 y -> powOmega x \u2264 powOmega y.\nProof.\n  unfold powOmega. apply expOrd_monotone.\nQed.\n\nLemma powOmega_increasing : forall x y, x < y -> powOmega x < powOmega y.\nProof.\n  intros.\n  apply expOrd_increasing; auto.\n  apply omega_gt1.\nQed.\n\n(** * The Knuth up-arrow functions, adapted to ordinals.\n\n    The up-arrow functions continue the pattern established above:\n    multiplication is defined via transfinite iteration of addition,\n    exponentation is defined via transfinite iteration of multiplication, etc.\n    \n    However, the later functions in the the sequence (@KnuthUp 2@ and above)\n    are rather less interesting. They saturate at @\u03c9@ and fail to be increasing.\n    This limits their applicability for constructing larger ordinals, even though\n    they are a rapidly increasing sequence of functions on finite ordinals AKA\n    the natural numbers.\n*)\n\nFixpoint KnuthUp (n:nat) (a:Ord) : Ord -> Ord :=\n  match n with\n  | O    => fun b => b * a\n  | S n' => foldOrd 1 (KnuthUp n' a)\n  end.\n\nLemma KnuthUp_zero : KnuthUp 0%nat = fun a b => b * a.\nProof. reflexivity. Qed.\n\nLemma KnuthUp_succ n : KnuthUp (S n) = fun a => foldOrd 1 (KnuthUp n a).\nProof. reflexivity. Qed.\n\nLemma KnuthUp_one : KnuthUp 1%nat = expOrd.\nProof. reflexivity. Qed.\n\nLemma KnuthUp_two : KnuthUp 2%nat = fun a => foldOrd 1 (expOrd a).\nProof. reflexivity. Qed.\n\nLemma KnuthUp_monotone n : forall a b c d,\n  a \u2264 b ->\n  c \u2264 d ->\n  KnuthUp n a c \u2264 KnuthUp n b d.\nProof.\n  induction n; simpl; intros.\n  transitivity (c*b).\n  apply mulOrd_monotone2; auto.\n  apply mulOrd_monotone1; auto.\n  transitivity (foldOrd 1 (KnuthUp n b) c).\n  apply foldOrd_least.\n  apply foldOrd_above_z.\n  intros; apply IHn; auto with ord.\n  intros.\n  destruct x as [X f].\n  simpl.\n  rewrite <- lub_le2.\n  rewrite <- (sup_le _ _ i).\n  apply IHn; auto with ord.\n  apply foldOrd_monotone; auto.\n  intros; apply IHn; auto with ord.\nQed.\n\nLemma KnuthUp_continuous n : forall a,\n  (n > 0)%nat ->\n  strongly_continuous (KnuthUp n a).\nProof.\n  intros. inversion H; subst; apply foldOrd_strongly_continuous.\nQed.\n\nLemma KnuthUp_one_eq n : forall a,\n  0 < a ->\n  KnuthUp n a 1 \u2248 a.\nProof.\n  induction n; simpl KnuthUp.\n  - intros. rewrite mulOrd_one_l. reflexivity.\n  - intros. split.\n    apply lub_least.\n    apply succ_least; auto.\n    apply sup_least; intros.\n    destruct n; simpl KnuthUp.\n    transitivity (1 * a).\n    apply mulOrd_monotone1.\n    apply lub_least; auto with ord.\n    apply sup_least. intros [].\n    rewrite mulOrd_one_l. auto with ord.\n    rewrite lub_continuous.\n    apply lub_least.\n    apply IHn. auto.\n    rewrite sup_unfold.\n    simpl.\n    apply lub_least.\n    apply succ_least; auto.\n    apply sup_least; intros [[] _].\n    intros.\n    apply foldOrd_monotone; auto.\n    intros; apply KnuthUp_monotone; auto with ord.\n    apply foldOrd_strongly_continuous.\n    rewrite <- lub_le2.\n    rewrite <- (sup_le _ _ tt).\n    rewrite <- IHn at 1; auto.\n    apply KnuthUp_monotone; auto with ord.\nQed.\n\n\nLemma KnuthUp_omega_fix : forall n a,\n    (n > 0)%nat ->\n    0 < a ->\n    KnuthUp n a (KnuthUp (S n) a \u03c9) \u2248 KnuthUp (S n) a \u03c9.\nProof.\n  split.\n  - intros.\n    rewrite KnuthUp_succ.\n    intros.\n    transitivity (KnuthUp n a (supOrd (fun (i:\u03c9) => foldOrd 1 (KnuthUp n a) i))).\n    apply KnuthUp_monotone; auto with ord.\n    simpl.\n    apply lub_least.\n    rewrite <- (sup_le _ _ 0%nat).\n    apply foldOrd_above_z.\n    apply sup_least; intro i.\n    rewrite <- (sup_le _ _ (S i)).\n    simpl.\n    rewrite <- lub_le2.\n    rewrite <- (sup_le _ _ tt).\n    reflexivity.\n    transitivity (supOrd (fun (i:\u03c9) => KnuthUp n a (foldOrd 1 (KnuthUp n a) (sz i)))).\n    apply KnuthUp_continuous; auto.\n    apply sup_least; intro i.\n    simpl.\n    rewrite <- lub_le2.\n    rewrite <- (sup_le _ _ i).\n    reflexivity.\n  - simpl.\n    apply lub_least.\n    inversion H; simpl; apply foldOrd_above_z.\n    apply sup_least; intro i.\n    apply KnuthUp_monotone; auto with ord.\n    induction i; simpl.\n    apply lub_least; auto with ord.\n    apply sup_least; intros [].\n    apply lub_least; auto with ord.\n    apply sup_least; intros [].\n    rewrite <- lub_le2.\n    rewrite <- (sup_le  _ _ i).\n    apply KnuthUp_monotone; auto with ord.\nQed.\n\nTheorem KnuthUp_saturates : forall n a b,\n    (n > 0)%nat ->\n    0 < a ->\n    KnuthUp (S n) a b \u2264 KnuthUp (S n) a \u03c9.\nProof.\n  intros.\n  induction b as [B g]; intros.\n  rewrite <- KnuthUp_omega_fix; auto.\n  rewrite KnuthUp_succ.\n  simpl foldOrd at 1.\n  apply lub_least.\n  inversion H; simpl; apply foldOrd_above_z.\n  apply sup_least; intro i.\n  apply KnuthUp_monotone; auto with ord.\n  apply H1; auto.\nQed.\n\nTheorem KnuthUp_not_increasing : forall n,\n    (n > 1)%nat ->\n    (forall a b c, b < c -> KnuthUp n a b < KnuthUp n a c) -> False.\nProof.\n  intros.\n  apply (ord_lt_irreflexive (KnuthUp n \u03c9 (succOrd \u03c9))).\n  apply ord_le_lt_trans with (KnuthUp n \u03c9 \u03c9).\n  destruct n. inversion H.\n  apply KnuthUp_saturates; auto.\n  inversion H; auto with arith.\n  apply (index_lt _ 0%nat).\n  apply H0.\n  apply succ_lt.\nQed.\n\nTheorem KnuthUp2_epsilon_number : forall a,\n    a \u2265 \u03c9 ->\n    KnuthUp 2%nat a \u03c9 \u2248 expOrd \u03c9 (KnuthUp 2%nat a \u03c9).\nProof.\n  intros. split.\n  - apply increasing_inflationary; auto.\n    intros; apply expOrd_increasing; auto.\n    apply omega_gt1.\n  - rewrite <- KnuthUp_omega_fix at 2; auto.\n    rewrite KnuthUp_one.\n    apply expOrd_monotone_base; auto.\n    rewrite <- H. apply (index_lt _ 0%nat).\nQed.\n\n\nGlobal Opaque addOrd mulOrd expOrd.\n\n\n(** Misc. facts about the addition of finite ordinals *)\n\nLemma add_cancel_finite (n:\u03c9) x y :\n  x + sz n \u2248 y + sz n -> x \u2248 y.\nProof.\n  induction n; simpl; intro H.\n  do 2 rewrite addOrd_zero_r in H; auto.\n  do 2 rewrite addOrd_succ in H.\n  apply succ_cancel_eq in H.\n  auto.\nQed.\n\nLemma onePlus_finite_succ m :\n  1 + natOrdSize m \u2248 succOrd (natOrdSize m).\nProof.\n  induction m; simpl.\n  rewrite addOrd_zero_r. auto with ord.\n  rewrite addOrd_succ.\n  rewrite IHm.\n  reflexivity.\nQed.\n",
      "theorem": "Lemma addOrd_cancel_le a b x y :\n  a + x \u2264 b + y -> a \u2265 b -> x \u2264 y.",
      "ground_truth": "Proof.\n  revert y.\n  induction x as [X f].\n  intro y.\n  unfold addOrd. rewrite foldOrd_unfold.\n  intros H1 H2.\n  rewrite ord_le_unfold. simpl; intro x.\n  assert (H3 : a + f x < b + y).\n  { eapply ord_lt_le_trans; [ | apply H1 ].\n    rewrite <- lub_le2.\n    rewrite <- (sup_le _ _ x).\n    rewrite ord_lt_unfold. exists tt. simpl.\n    reflexivity. }\n  unfold addOrd at 2 in H3.\n  rewrite foldOrd_unfold in H3.\n  apply lub_lt in H3.\n  destruct H3.\n  - elim (ord_lt_irreflexive b).\n    apply ord_le_lt_trans with (a + f x); auto.\n    rewrite <- H2. apply addOrd_le1.\n  - apply sup_lt in H0.\n    destruct H0 as [i ?].\n    rewrite ord_lt_unfold.\n    exists i.\n    apply H; auto.\n    rewrite ord_lt_unfold in H0.\n    destruct H0; simpl in *.\n    auto.\nQed."
    },
    {
      "split": "train-sft",
      "index": 49,
      "prefix": "(*****************************************************************************)\n(*                                                                           *)\n(*  Vector.v                                                                 *)\n(*                                                                           *)\n(*  This file defines fixed-length vectors of natural numbers.               *)\n(*                                                                           *)\n(*  Some definitions and results about vectors are borrowed from a later     *)\n(*  version of Coq.                                                          *)\n(*                                                                           *)\n(*****************************************************************************)\n\n\nRequire Import Vector.\nRequire Import PeanoNat.\n\nRequire Export Vector.\n\nImport Vector.VectorNotations.\n\n\n\nOpen Scope vector_scope.\n\n(* Notation for 'append' is available in Coq 8.10: *)\n\nInfix \"++\" := append : vector_scope.\n\n\n(* The function 'splitat' is available in Coq 8.10: *)\n\nFixpoint splitat {A} (l : nat) {r : nat} : t A (l + r) -> t A l * t A r :=\n  match l with\n  | 0 => fun v => ([], v)\n  | S l' => fun v =>\n    let (v1, v2) := splitat l' (tl v) in\n    (hd v::v1, v2)\n  end.\n\n\n(* The Lemma 'splitat_append' is available in Coq 8.10: *)\n\nLemma splitat_append {A} (l : nat) {r : nat} (b0 : t A l) (b1 : t A r) :\n  splitat l (b0 ++ b1) = (b0, b1).\nProof with auto.\n  induction b0; simpl...\n  rewrite IHb0...\nQed.\n\n\n(* In the present development, only vectors of natural numbers are needed: *)\n\nDefinition NVect := Vector.t nat.\n\nLemma fst_splitat_append (l : nat) {r : nat} (b0 : NVect l) (b1 : NVect r) :\n  fst (splitat l (b0 ++ b1)) = b0.",
      "suffix": "\n\nLemma snd_splitat_append (l : nat) {r : nat} (b0 : NVect l) (b1 : NVect r) :\n  snd (splitat l (b0 ++ b1)) = b1.\nProof with auto.\n  rewrite splitat_append...\nQed.\n\n\n(* Equality is decidable for 'NVect': *)\n\nDefinition nvect_eq_dec := (@VectorEq.eq_dec nat Nat.eqb Nat.eqb_eq).\n\nClose Scope vector_scope.\n\n",
      "theorem": "Lemma fst_splitat_append (l : nat) {r : nat} (b0 : NVect l) (b1 : NVect r) :\n  fst (splitat l (b0 ++ b1)) = b0.",
      "ground_truth": "Proof with auto.\n  rewrite splitat_append...\nQed."
    }
  ]
}